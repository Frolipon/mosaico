(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Badsender = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/*global window, global*/
var util = require("util")
var assert = require("assert")

var slice = Array.prototype.slice
var console
var times = {}

if (typeof global !== "undefined" && global.console) {
    console = global.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"]
    , [info, "info"]
    , [warn, "warn"]
    , [error, "error"]
    , [time, "time"]
    , [timeEnd, "timeEnd"]
    , [trace, "trace"]
    , [dir, "dir"]
    , [assert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = Date.now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    var duration = Date.now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function assert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"assert":21,"util":40}],2:[function(require,module,exports){
/*
   evol.colorpicker 3.2.2
   (c) 2015 Olivier Giulieri
   http://evoluteur.github.io/colorpicker/
*/
!function(a,b){var c=0,d=window.navigator.userAgent,e=d.indexOf("MSIE ")>0,f=e?"-ie":"",g=e?!1:/mozilla/.test(d.toLowerCase())&&!/webkit/.test(d.toLowerCase()),h=[],i=["ffffff","000000","eeece1","1f497d","4f81bd","c0504d","9bbb59","8064a2","4bacc6","f79646"],j=["f2f2f2","7f7f7f","ddd9c3","c6d9f0","dbe5f1","f2dcdb","ebf1dd","e5e0ec","dbeef3","fdeada","d8d8d8","595959","c4bd97","8db3e2","b8cce4","e5b9b7","d7e3bc","ccc1d9","b7dde8","fbd5b5","bfbfbf","3f3f3f","938953","548dd4","95b3d7","d99694","c3d69b","b2a2c7","92cddc","fac08f","a5a5a5","262626","494429","17365d","366092","953734","76923c","5f497a","31859b","e36c09","7f7f7f","0c0c0c","1d1b10","0f243e","244061","632423","4f6128","3f3151","205867","974806"],k=["c00000","ff0000","ffc000","ffff00","92d050","00b050","00b0f0","0070c0","002060","7030a0"],l=[["003366","336699","3366cc","003399","000099","0000cc","000066"],["006666","006699","0099cc","0066cc","0033cc","0000ff","3333ff","333399"],["669999","009999","33cccc","00ccff","0099ff","0066ff","3366ff","3333cc","666699"],["339966","00cc99","00ffcc","00ffff","33ccff","3399ff","6699ff","6666ff","6600ff","6600cc"],["339933","00cc66","00ff99","66ffcc","66ffff","66ccff","99ccff","9999ff","9966ff","9933ff","9900ff"],["006600","00cc00","00ff00","66ff99","99ffcc","ccffff","ccccff","cc99ff","cc66ff","cc33ff","cc00ff","9900cc"],["003300","009933","33cc33","66ff66","99ff99","ccffcc","ffffff","ffccff","ff99ff","ff66ff","ff00ff","cc00cc","660066"],["333300","009900","66ff33","99ff66","ccff99","ffffcc","ffcccc","ff99cc","ff66cc","ff33cc","cc0099","993399"],["336600","669900","99ff33","ccff66","ffff99","ffcc99","ff9999","ff6699","ff3399","cc3399","990099"],["666633","99cc00","ccff33","ffff66","ffcc66","ff9966","ff6666","ff0066","d60094","993366"],["a58800","cccc00","ffff00","ffcc00","ff9933","ff6600","ff0033","cc0066","660033"],["996633","cc9900","ff9900","cc6600","ff3300","ff0000","cc0000","990033"],["663300","996600","cc3300","993300","990000","800000","993333"]],m="#0000ffff",n=function(a){var b=a.toString(16);return 1==b.length&&(b="0"+b),b},o=function(a){return n(Number(a))},p=function(a){var b=n(a);return b+b+b},q=function(a){if(a.length>10){var b=1+a.indexOf("("),c=a.indexOf(")"),d=a.substring(b,c).split(",");return["#",o(d[0]),o(d[1]),o(d[2])].join("")}return a};a.widget("evol.colorpicker",{version:"3.2.1",options:{color:null,showOn:"both",hideButton:!1,displayIndicator:!0,transparentColor:!1,history:!0,defaultPalette:"theme",strings:"Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet."},_active:!1,_create:function(){var b=this;switch(this._paletteIdx="theme"==this.options.defaultPalette?1:2,this._id="evo-cp"+c++,this._enabled=!0,this.options.showOn=this.options.hideButton?"focus":this.options.showOn,this.element.get(0).tagName){case"INPUT":var d=this.options.color,h=this.element,i=("focus"===this.options.showOn?"":"evo-pointer ")+"evo-colorind"+(g?"-ff":f)+(this.options.hideButton?" evo-hidden-button":""),j="";if(this._isPopup=!0,this._palette=null,null!==d)h.val(d);else{var k=h.val();""!==k&&(d=this.options.color=k)}d===m?i+=" evo-transparent":j=null!==d?"background-color:"+d:"",h.addClass("colorPicker "+this._id).wrap('<div style="width:'+(this.options.hideButton?this.element.width():this.element.width()+32)+"px;"+(e?"margin-bottom:-21px;":"")+(g?"padding:1px 0;":"")+'"></div>').after('<div class="'+i+'" style="'+j+'"></div>').on("keyup onpaste",function(c){var d=a(this).val();d!=b.options.color&&b._setValue(d,!0)});var l=this.options.showOn;("both"===l||"focus"===l)&&h.on("focus",function(){b.showPalette()}),("both"===l||"button"===l)&&h.next().on("click",function(a){return a.stopPropagation(),b.showPalette(),!1});break;default:this._isPopup=!1,this._palette=this.element.html(this._paletteHTML()).attr("aria-haspopup","true"),this._bindColors()}if(this.options.history&&(d&&this._add2History(d),this.options.initialHistory)){var n=this.options.initialHistory;for(var o in n)this._add2History(n[o])}},_paletteHTML:function(){var a=this._paletteIdx=Math.abs(this._paletteIdx),b=this.options,c=b.strings.split(","),d='<div class="evo-pop'+f+' ui-widget ui-widget-content ui-corner-all"'+(this._isPopup?' style="position:absolute"':"")+"><span>"+this["_paletteHTML"+a]()+'</span><div class="evo-more"><a href="javascript:void(0)">'+c[1+a]+"</a>";return b.history&&(d+='<a href="javascript:void(0)" class="evo-hist">'+c[5]+"</a>"),d+="</div>",b.displayIndicator&&(d+=this._colorIndHTML(this.options.color)+this._colorIndHTML("")),d+="</div>"},_colorIndHTML:function(a){var b=e?"evo-colorbox-ie ":"",c="";return a?a===m?b+="evo-transparent":c="background-color:"+a:c="display:none",'<div class="evo-color" style="float:left"><div style="'+c+'" class="'+b+'"></div><span>'+(a?a:"")+"</span></div>"},_paletteHTML1:function(){for(var a=this.options,b=a.strings.split(","),c='<td style="background-color:#',d=e?'"><div style="width:2px;"></div></td>':'"><span/></td>',g='<tr><th colspan="10" class="ui-widget-content">',h='<table class="evo-palette'+f+'">'+g+b[0]+"</th></tr><tr>",l=0;10>l;l++)h+=c+i[l]+d;for(h+="</tr>",e||(h+='<tr><th colspan="10"></th></tr>'),h+='<tr class="top">',l=0;10>l;l++)h+=c+j[l]+d;for(var m=1;4>m;m++)for(h+='</tr><tr class="in">',l=0;10>l;l++)h+=c+j[10*m+l]+d;for(h+='</tr><tr class="bottom">',l=40;50>l;l++)h+=c+j[l]+d;for(h+="</tr>"+g,a.transparentColor&&(h+='<div class="evo-transparent evo-tr-box"></div>'),h+=b[1]+"</th></tr><tr>",l=0;10>l;l++)h+=c+k[l]+d;return h+="</tr></table>"},_paletteHTML2:function(){for(var a,b,c='<td style="background-color:#',d=e?'"><div style="width:5px;"></div></td>':'"><span/></td>',g='<table class="evo-palette2'+f+'"><tr>',h="</tr></table>",i='<div class="evo-palcenter">',j=0,k=l.length;k>j;j++){i+=g;var m=l[j];for(a=0,b=m.length;b>a;a++)i+=c+m[a]+d;i+=h}i+='<div class="evo-sep"/>';var n="";for(i+=g,a=255;a>10;a-=10)i+=c+p(a)+d,a-=10,n+=c+p(a)+d;return i+=h+g+n+h+"</div>"},_switchPalette:function(b){if(this._enabled){var c,d,e,f=this.options.strings.split(",");if(a(b).hasClass("evo-hist")){var g=['<table class="evo-palette"><tr><th class="ui-widget-content">',f[5],"</th></tr></tr></table>",'<div class="evo-cHist">'];if(0===h.length)g.push("<p>&nbsp;",f[6],"</p>");else for(var i=h.length-1;i>-1;i--)9===h[i].length?g.push('<div class="evo-transparent"></div>'):g.push('<div style="background-color:',h[i],'"></div>');g.push("</div>"),c=-this._paletteIdx,d=g.join(""),e=f[4]}else this._paletteIdx<0?(c=-this._paletteIdx,this._palette.find(".evo-hist").show()):c=2==this._paletteIdx?1:2,d=this["_paletteHTML"+c](),e=f[c+1],this._paletteIdx=c;this._paletteIdx=c;var j=this._palette.find(".evo-more").prev().html(d).end().children().eq(0).html(e);0>c&&j.next().hide()}},_downOrUpPositioning:function(){for(var a=this.element,b=0;null!==a&&100>b;){if("visible"!=a.css("overflow")){var c=this._palette.offset().top+this._palette.height(),d=a.offset().top+a.height(),e=this._palette.offset().top-this._palette.height()-this.element.outerHeight(),f=a.offset().top,g=c>d&&e>f;g?this._palette.css({bottom:this.element.outerHeight()+"px"}):this._palette.css({bottom:"auto"});break}if("HTML"==a[0].tagName)break;a=a.offsetParent(),b++}},showPalette:function(){if(this._enabled&&(this._active=!0,a(".colorPicker").not("."+this._id).colorpicker("hidePalette"),null===this._palette)){this._palette=this.element.next().after(this._paletteHTML()).next().on("click",function(a){return a.stopPropagation(),!1}),this._bindColors();var b=this;this._isPopup&&(this._downOrUpPositioning(),a(document.body).on("click."+b._id,function(a){a.target!=b.element.get(0)&&b.hidePalette()}).on("keyup."+b._id,function(a){27===a.keyCode&&b.hidePalette()}))}return this},hidePalette:function(){if(this._isPopup&&this._palette){a(document.body).off("click."+this._id);var b=this;this._palette.off("mouseover click","td,.evo-transparent").fadeOut(function(){b._palette.remove(),b._palette=b._cTxt=null}).find(".evo-more a").off("click")}return this},_bindColors:function(){var b=this,c=this.options,d=this._palette.find("div.evo-color"),e=c.history?"td,.evo-cHist>div":"td";c.transparentColor&&(e+=",.evo-transparent"),this._cTxt1=d.eq(0).children().eq(0),this._cTxt2=d.eq(1).children().eq(0),this._palette.on("click",e,function(c){if(b._enabled){var d=a(this);b._setValue(d.hasClass("evo-transparent")?m:q(d.attr("style").substring(17))),b._active=!1}}).on("mouseover",e,function(c){if(b._enabled){var d=a(this),e=d.hasClass("evo-transparent")?m:q(d.attr("style").substring(17));b.options.displayIndicator&&b._setColorInd(e,2),b._active&&b.element.trigger("mouseover.color",e)}}).find(".evo-more a").on("click",function(){b._switchPalette(this)})},val:function(a){return"undefined"==typeof a?this.options.color:(this._setValue(a),this)},_setValue:function(a,b){a=a.replace(/ /g,""),this.options.color=a,this._isPopup?(b||this.hidePalette(),this._setBoxColor(this.element.val(a).next(),a)):this._setColorInd(a,1),this.options.history&&this._paletteIdx>0&&this._add2History(a),this.element.trigger("change.color",a)},_setColorInd:function(a,b){var c=this["_cTxt"+b];this._setBoxColor(c,a),c.next().html(a)},_setBoxColor:function(a,b){b===m?a.addClass("evo-transparent").removeAttr("style"):a.removeClass("evo-transparent").attr("style","background-color:"+b)},_setOption:function(a,b){"color"==a?this._setValue(b,!0):this.options[a]=b},_add2History:function(a){for(var b=h.length,c=0;b>c;c++)if(a==h[c])return;b>27&&h.shift(),h.push(a)},clear:function(){this.hidePalette().val("")},enable:function(){var a=this.element;return this._isPopup?a.removeAttr("disabled"):a.css({opacity:"1","pointer-events":"auto"}),"focus"!==this.options.showOn&&this.element.next().addClass("evo-pointer"),a.removeAttr("aria-disabled"),this._enabled=!0,this},disable:function(){var a=this.element;return this._isPopup?a.attr("disabled","disabled"):(this.hidePalette(),a.css({opacity:"0.3","pointer-events":"none"})),"focus"!==this.options.showOn&&this.element.next().removeClass("evo-pointer"),a.attr("aria-disabled","true"),this._enabled=!1,this},isDisabled:function(){return!this._enabled},destroy:function(){a(document.body).off("click."+this._id),this._palette&&(this._palette.off("mouseover click","td,.evo-cHist>div,.evo-transparent").find(".evo-more a").off("click"),this._isPopup&&this._palette.remove(),this._palette=this._cTxt=null),this._isPopup&&this.element.next().off("click").remove().end().off("focus").unwrap(),this.element.removeClass("colorPicker "+this.id).empty(),a.Widget.prototype.destroy.call(this)}})}(jQuery);
},{}],3:[function(require,module,exports){
//     JavaScript Expression Parser (JSEP) <%= version %>
//     JSEP may be freely distributed under the MIT License
//     http://jsep.from.so/

/*global module: true, exports: true, console: true */
(function (root) {
	'use strict';
	// Node Types
	// ----------
	
	// This is the full set of types that any JSEP node can be.
	// Store them here to save space when minified
	var COMPOUND = 'Compound',
		IDENTIFIER = 'Identifier',
		MEMBER_EXP = 'MemberExpression',
		LITERAL = 'Literal',
		THIS_EXP = 'ThisExpression',
		CALL_EXP = 'CallExpression',
		UNARY_EXP = 'UnaryExpression',
		BINARY_EXP = 'BinaryExpression',
		LOGICAL_EXP = 'LogicalExpression',
		CONDITIONAL_EXP = 'ConditionalExpression',
		ARRAY_EXP = 'ArrayExpression',

		PERIOD_CODE = 46, // '.'
		COMMA_CODE  = 44, // ','
		SQUOTE_CODE = 39, // single quote
		DQUOTE_CODE = 34, // double quotes
		OPAREN_CODE = 40, // (
		CPAREN_CODE = 41, // )
		OBRACK_CODE = 91, // [
		CBRACK_CODE = 93, // ]
		QUMARK_CODE = 63, // ?
		SEMCOL_CODE = 59, // ;
		COLON_CODE  = 58, // :

		throwError = function(message, index) {
			var error = new Error(message + ' at character ' + index);
			error.index = index;
			error.description = message;
			throw error;
		},

	// Operations
	// ----------
	
	// Set `t` to `true` to save space (when minified, not gzipped)
		t = true,
	// Use a quickly-accessible map to store all of the unary operators
	// Values are set to `true` (it really doesn't matter)
		unary_ops = {'-': t, '!': t, '~': t, '+': t},
	// Also use a map for the binary operations but set their values to their
	// binary precedence for quick reference:
	// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
		binary_ops = {
			'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,
			'==': 6, '!=': 6, '===': 6, '!==': 6,
			'<': 7,  '>': 7,  '<=': 7,  '>=': 7, 
			'<<':8,  '>>': 8, '>>>': 8,
			'+': 9, '-': 9,
			'*': 10, '/': 10, '%': 10
		},
	// Get return the longest key length of any object
		getMaxKeyLen = function(obj) {
			var max_len = 0, len;
			for(var key in obj) {
				if((len = key.length) > max_len && obj.hasOwnProperty(key)) {
					max_len = len;
				}
			}
			return max_len;
		},
		max_unop_len = getMaxKeyLen(unary_ops),
		max_binop_len = getMaxKeyLen(binary_ops),
	// Literals
	// ----------
	// Store the values to return for the various literals we may encounter
		literals = {
			'true': true,
			'false': false,
			'null': null
		},
	// Except for `this`, which is special. This could be changed to something like `'self'` as well
		this_str = 'this',
	// Returns the precedence of a binary operator or `0` if it isn't a binary operator
		binaryPrecedence = function(op_val) {
			return binary_ops[op_val] || 0;
		},
	// Utility function (gets called from multiple places)
	// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
		createBinaryExpression = function (operator, left, right) {
			var type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;
			return {
				type: type,
				operator: operator,
				left: left,
				right: right
			};
		},
		// `ch` is a character code in the next three functions
		isDecimalDigit = function(ch) {
			return (ch >= 48 && ch <= 57); // 0...9
		},
		isIdentifierStart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122); // a...z
		},
		isIdentifierPart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
					(ch >= 48 && ch <= 57); // 0...9
		},

		// Parsing
		// -------
		// `expr` is a string with the passed in expression
		jsep = function(expr) {
			// `index` stores the character number we are currently at while `length` is a constant
			// All of the gobbles below will modify `index` as we move along
			var index = 0,
				charAtFunc = expr.charAt,
				charCodeAtFunc = expr.charCodeAt,
				exprI = function(i) { return charAtFunc.call(expr, i); },
				exprICode = function(i) { return charCodeAtFunc.call(expr, i); },
				length = expr.length,

				// Push `index` up to the next non-space character
				gobbleSpaces = function() {
					var ch = exprICode(index);
					// space or tab
					while(ch === 32 || ch === 9) {
						ch = exprICode(++index);
					}
				},
				
				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function() {
					var test = gobbleBinaryExpression(),
						consequent, alternate;
					gobbleSpaces();
					if(exprICode(index) === QUMARK_CODE) {
						// Ternary expression: test ? consequent : alternate
						index++;
						consequent = gobbleExpression();
						if(!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if(exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if(!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},

				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function() {
					gobbleSpaces();
					var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
					while(tc_len > 0) {
						if(binary_ops.hasOwnProperty(to_check)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},

				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function() {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if(!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop)};

					right = gobbleToken();
					if(!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while((biop = gobbleBinaryOp())) {
						prec = binaryPrecedence(biop);

						if(prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						// Reduce: make a binary expression from the three topmost entries.
						while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if(!node) {
							throwError("Expected expression after " + biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while(i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node); 
						i -= 2;
					}
					return node;
				},

				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function() {
					var ch, to_check, tc_len;
					
					gobbleSpaces();
					ch = exprICode(index);

					if(isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if(isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis
						// `foo`, `bar.baz`
						return gobbleVariable();
					} else if (ch === OBRACK_CODE) {
						return gobbleArray();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while(tc_len > 0) {
							if(unary_ops.hasOwnProperty(to_check)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}
						
						return false;
					}
				},
				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function() {
					var number = '', ch, chCode;
					while(isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker
						number += exprI(index++);

						while(isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}
					
					ch = exprI(index);
					if(ch === 'e' || ch === 'E') { // exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if(ch === '+' || ch === '-') { // exponent sign
							number += exprI(index++);
						}
						while(isDecimalDigit(exprICode(index))) { //exponent itself
							number += exprI(index++);
						}
						if(!isDecimalDigit(exprICode(index-1)) ) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}
					

					chCode = exprICode(index);
					// Check to make sure this isn't a variable name that start with a number (123abc)
					if(isIdentifierStart(chCode)) {
						throwError('Variable names cannot start with a number (' +
									number + exprI(index) + ')', index);
					} else if(chCode === PERIOD_CODE) {
						throwError('Unexpected period', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},

				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function() {
					var str = '', quote = exprI(index++), closed = false, ch;

					while(index < length) {
						ch = exprI(index++);
						if(ch === quote) {
							closed = true;
							break;
						} else if(ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch(ch) {
								case 'n': str += '\n'; break;
								case 'r': str += '\r'; break;
								case 't': str += '\t'; break;
								case 'b': str += '\b'; break;
								case 'f': str += '\f'; break;
								case 'v': str += '\x0B'; break;
							}
						} else {
							str += ch;
						}
					}

					if(!closed) {
						throwError('Unclosed quote after "'+str+'"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},
				
				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function() {
					var ch = exprICode(index), start = index, identifier;

					if(isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while(index < length) {
						ch = exprICode(index);
						if(isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if(literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if(identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},

				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function(termination) {
					var ch_i, args = [], node;
					while(index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if(ch_i === termination) { // done parsing
							index++;
							break;
						} else if (ch_i === COMMA_CODE) { // between expressions
							index++;
						} else {
							node = gobbleExpression();
							if(!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					return args;
				},

				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function() {
					var ch_i, node;
					ch_i = exprICode(index);
						
					if(ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if(ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if(ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if(ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if(ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},

				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function() {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if(exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},

				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function() {
					index++;
					return {
						type: ARRAY_EXP,
						elements: gobbleArguments(CBRACK_CODE)
					};
				},

				nodes = [], ch_i, node;
				
			while(index < length) {
				ch_i = exprICode(index);

				// Expressions can be separated by semicolons, commas, or just inferred without any
				// separators
				if(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
					index++; // ignore separators
				} else {
					// Try to gobble each expression individually
					if((node = gobbleExpression())) {
						nodes.push(node);
					// If we weren't able to find a binary expression and are out of room, then
					// the expression passed in probably has too much
					} else if(index < length) {
						throwError('Unexpected "' + exprI(index) + '"', index);
					}
				}
			}

			// If there's only one expression just try returning the expression
			if(nodes.length === 1) {
				return nodes[0];
			} else {
				return {
					type: COMPOUND,
					body: nodes
				};
			}
		};

	// To be filled in by the template
	jsep.version = '<%= version %>';
	jsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };

	/**
	 * @method jsep.addUnaryOp
	 * @param {string} op_name The name of the unary op to add
	 * @return jsep
	 */
	jsep.addUnaryOp = function(op_name) {
		unary_ops[op_name] = t; return this;
	};

	/**
	 * @method jsep.addBinaryOp
	 * @param {string} op_name The name of the binary op to add
	 * @param {number} precedence The precedence of the binary op (can be a float)
	 * @return jsep
	 */
	jsep.addBinaryOp = function(op_name, precedence) {
		max_binop_len = Math.max(op_name.length, max_binop_len);
		binary_ops[op_name] = precedence;
		return this;
	};

	/**
	 * @method jsep.removeUnaryOp
	 * @param {string} op_name The name of the unary op to remove
	 * @return jsep
	 */
	jsep.removeUnaryOp = function(op_name) {
		delete unary_ops[op_name];
		if(op_name.length === max_unop_len) {
			max_unop_len = getMaxKeyLen(unary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeBinaryOp
	 * @param {string} op_name The name of the binary op to remove
	 * @return jsep
	 */
	jsep.removeBinaryOp = function(op_name) {
		delete binary_ops[op_name];
		if(op_name.length === max_binop_len) {
			max_binop_len = getMaxKeyLen(binary_ops);
		}
		return this;
	};

	// In desktop environments, have a way to restore the old value for `jsep`
	if (typeof exports === 'undefined') {
		var old_jsep = root.jsep;
		// The star of the show! It's a function!
		root.jsep = jsep;
		// And a courteous function willing to move out of the way for other similarly-named objects!
		jsep.noConflict = function() {
			if(root.jsep === jsep) {
				root.jsep = old_jsep;
			}
			return jsep;
		};
	} else {
		// In Node.JS environments
		if (typeof module !== 'undefined' && module.exports) {
			exports = module.exports = jsep;
		} else {
			exports.parse = jsep;
		}
	}
}(this));

},{}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');

module.exports = function makeJuiceClient(juiceClient) {

juiceClient.ignoredPseudos = ['hover', 'active', 'focus', 'visited', 'link'];
juiceClient.widthElements = ['TABLE', 'TD', 'IMG'];
juiceClient.heightElements = ['TABLE', 'TD', 'IMG'];
juiceClient.tableElements = ['TABLE', 'TD', 'TH', 'TR', 'TD', 'CAPTION', 'COLGROUP', 'COL', 'THEAD', 'TBODY', 'TFOOT'];
juiceClient.nonVisualElements = [ 'HEAD', 'TITLE', 'BASE', 'LINK', 'STYLE', 'META', 'SCRIPT', 'NOSCRIPT' ];
juiceClient.styleToAttribute = {
  'background-color': 'bgcolor',
  'background-image': 'background',
  'text-align': 'align',
  'vertical-align': 'valign'
};
juiceClient.excludedProperties = [];

juiceClient.juiceDocument = juiceDocument;
juiceClient.inlineDocument = inlineDocument;

function inlineDocument($, css, options) {

  options = options || {};
  var rules = utils.parseCSS(css);
  var editedElements = [];
  var styleAttributeName = 'style';
  
  if (options.styleAttributeName) {
    styleAttributeName = options.styleAttributeName;
  }

  rules.forEach(handleRule);
  editedElements.forEach(setStyleAttrs);

  if (options.inlinePseudoElements) {
    editedElements.forEach(inlinePseudoElements);
  }

  if (options.applyWidthAttributes) {
    editedElements.forEach(function(el) {
      setDimensionAttrs(el, 'width');
    });
  }

  if (options.applyHeightAttributes) {
    editedElements.forEach(function(el) {
      setDimensionAttrs(el, 'height');
    });
  }

  if (options.applyAttributesTableElements) {
    editedElements.forEach(setAttributesOnTableElements);
  }

  if (options.insertPreservedExtraCss && options.extraCss) {
    var preservedText = utils.getPreservedText(options.extraCss, {
      mediaQueries: options.preserveMediaQueries,
      fontFaces: options.preserveFontFaces
    });
    if (preservedText) {
      var $appendTo = null;
      if (options.insertPreservedExtraCss !== true) {
        $appendTo = $(options.insertPreservedExtraCss);
      } else {
        $appendTo = $('head');
        if (!$appendTo.length) { $appendTo = $('body'); }
        if (!$appendTo.length) { $appendTo = $.root(); }
      }

      $appendTo.first().append('<style>' + preservedText + '</style>');
    }
  }

  function handleRule(rule) {
    var sel = rule[0];
    var style = rule[1];
    var selector = new utils.Selector(sel);
    var parsedSelector = selector.parsed();
    var pseudoElementType = getPseudoElementType(parsedSelector);

    // skip rule if the selector has any pseudos which are ignored
    for (var i = 0; i < parsedSelector.length; ++i) {
      var subSel = parsedSelector[i];
      if (subSel.pseudos) {
        for (var j = 0; j < subSel.pseudos.length; ++j) {
          var subSelPseudo = subSel.pseudos[j];
          if (juiceClient.ignoredPseudos.indexOf(subSelPseudo.name) >= 0) {
            return;
          }
        }
      }
    }

    if (pseudoElementType) {
      var last = parsedSelector[parsedSelector.length - 1];
      var pseudos = last.pseudos;
      last.pseudos = filterElementPseudos(last.pseudos);
      sel = parsedSelector.toString();
      last.pseudos = pseudos;
    }

    var els;
    try {
      els = $(sel);
    } catch (err) {
      // skip invalid selector
      return;
    }

    els.each(function() {
      var el = this;

      if (el.name && juiceClient.nonVisualElements.indexOf(el.name.toUpperCase()) >= 0) {
        return;
      }

      if (pseudoElementType) {
        var pseudoElPropName = 'pseudo' + pseudoElementType;
        var pseudoEl = el[pseudoElPropName];
        if (!pseudoEl) {
          pseudoEl = el[pseudoElPropName] = $('<span />').get(0);
          pseudoEl.pseudoElementType = pseudoElementType;
          pseudoEl.pseudoElementParent = el;
          el[pseudoElPropName] = pseudoEl;
        }
        el = pseudoEl;
      }

      if (!el.styleProps) {
        el.styleProps = {};

        // if the element has inline styles, fake selector with topmost specificity
        if ($(el).attr(styleAttributeName)) {
          var cssText = '* { ' + $(el).attr(styleAttributeName) + ' } ';
          addProps(utils.parseCSS(cssText)[0][1], new utils.Selector('<style>', true));
        }

        // store reference to an element we need to compile style="" attr for
        editedElements.push(el);
      }

      // go through the properties
      function addProps(style, selector) {
        for (var i = 0, l = style.length; i < l; i++) {
          if (style[i].type == 'property') {
            var name = style[i].name;
            var value = style[i].value;
            var important = style[i].value.match(/!important$/) !== null;
            if (important && !options.preserveImportant) value = value.replace(/\s*!important$/, '');
            // adds line number and column number for the properties as "additionalPriority" to the 
            // properties because in CSS the position directly affect the priority.
            var additionalPriority = [style[i].position.start.line, style[i].position.start.col];
            var prop = new utils.Property(name, value, selector, important ? 2 : 0, additionalPriority);
            var existing = el.styleProps[name];

            // if property name is not in the excluded properties array
            if (juiceClient.excludedProperties.indexOf(name) < 0) {
              if (existing && existing.compare(prop) === prop || !existing) {
                // deleting a property let us change the order (move it to the end in the setStyleAttrs loop)
                if (existing && existing.selector !== selector) {
                  delete el.styleProps[name];
                } else if (existing) {
                  // make "prop" a special composed property.
                  prop.nextProp = existing;
                }

                el.styleProps[name] = prop;
              }
            }
          }
        }
      }

      addProps(style, selector);
    });
  }

  function setStyleAttrs(el) {
    var l = Object.keys(el.styleProps).length;
    var props = [];
    // Here we loop each property and make sure to "expand"
    // linked "nextProp" properties happening when the same property
    // is declared multiple times in the same selector.
    Object.keys(el.styleProps).forEach(function(key) {
      var np = el.styleProps[key];
      while (typeof np !== 'undefined') {
        props.push(np);
        np = np.nextProp;
      }
    });
    // sort properties by their originating selector's specificity so that
    // props like "padding" and "padding-bottom" are resolved as expected.
    props.sort(function(a, b) {
      return a.compareFunc(b);
    });
    var string = props
      .filter(function(prop) {
        // Content becomes the innerHTML of pseudo elements, not used as a
        // style property
        return prop.prop !== 'content';
      })
      .map(function(prop) {
        return prop.prop + ': ' + prop.value.replace(/["]/g, '\'') + ';';
      })
      .join(' ');
    if (string) {
      $(el).attr(styleAttributeName, string);
    }
  }

  function inlinePseudoElements(el) {
    if (el.pseudoElementType && el.styleProps.content) {
      $(el).html(parseContent(el.styleProps.content.value));
      var parent = el.pseudoElementParent;
      if (el.pseudoElementType === 'before') {
        $(parent).prepend(el);
      } else {
        $(parent).append(el);
      }
    }
  }

  function setDimensionAttrs(el, dimension) {
    if (!el.name) { return; }
    var elName = el.name.toUpperCase();
    if (juiceClient[dimension + 'Elements'].indexOf(elName) > -1) {
      for (var i in el.styleProps) {
        if (el.styleProps[i].prop === dimension) {
          if (el.styleProps[i].value.match(/px/)) {
            var pxSize = el.styleProps[i].value.replace('px', '');
            $(el).attr(dimension, pxSize);
            return;
          }
          if (juiceClient.tableElements.indexOf(elName) > -1 && el.styleProps[i].value.match(/\%/)) {
            $(el).attr(dimension, el.styleProps[i].value);
            return;
          }
        }
      }
    }
  }

  function setAttributesOnTableElements(el) {
    if (!el.name) { return; }
    var elName = el.name.toUpperCase();
    var styleProps = Object.keys(juiceClient.styleToAttribute);

    if (juiceClient.tableElements.indexOf(elName) > -1) {
      for (var i in el.styleProps) {
        if (styleProps.indexOf(el.styleProps[i].prop) > -1) {
          $(el).attr(juiceClient.styleToAttribute[el.styleProps[i].prop], el.styleProps[i].value);
        }
      }
    }
  }
}

function parseContent(content) {
  if (content === 'none' || content === 'normal') {
    return '';
  }

  // Naive parsing, assume well-formed value
  content = content.slice(1, content.length - 1);
  // Naive unescape, assume no unicode char codes
  content = content.replace(/\\/g, '');
  return content;
}

// Return "before" or "after" if the given selector is a pseudo element (e.g.,
// a::after).
function getPseudoElementType(selector) {
  if (selector.length === 0) {
    return;
  }

  var pseudos = selector[selector.length - 1].pseudos;
  if (!pseudos) {
    return;
  }

  for (var i = 0; i < pseudos.length; i++) {
    if (isPseudoElementName(pseudos[i])) {
      return pseudos[i].name;
    }
  }
}

function isPseudoElementName(pseudo) {
  return pseudo.name === 'before' || pseudo.name === 'after';
}

function filterElementPseudos(pseudos) {
  return pseudos.filter(function(pseudo) {
    return !isPseudoElementName(pseudo);
  });
}

function juiceDocument($, options) {
  options = utils.getDefaultOptions(options);
  var css = extractCssFromDocument($, options);
  css += '\n' + options.extraCss;
  inlineDocument($, css, options);
  return $;
}

function getStylesData($, options) {
  var results = [];
  var stylesList = $('style');
  var styleDataList, styleData, styleElement;
  stylesList.each(function() {
    styleElement = this;
    styleDataList = styleElement.childNodes;
    if (styleDataList.length !== 1) {
      return;
    }
    styleData = styleDataList[0].data;
    if (options.applyStyleTags && $(styleElement).attr('data-embed') === undefined) {
      results.push(styleData);
    }
    if (options.removeStyleTags && $(styleElement).attr('data-embed') === undefined) {
      var preservedText = utils.getPreservedText(styleElement.childNodes[0].nodeValue, {
        mediaQueries: options.preserveMediaQueries,
        fontFaces: options.preserveFontFaces
      });
      if (preservedText) {
        styleElement.childNodes[0].nodeValue = preservedText;
      } else {
        $(styleElement).remove();
      }
    }
    $(styleElement).removeAttr('data-embed');
  });
  return results;
}

function extractCssFromDocument($, options) {
  var results = getStylesData($, options);
  var css = results.join('\n');
  return css;
}

return juiceClient;

};
},{"./utils":7}],5:[function(require,module,exports){
'use strict';

module.exports = exports = Property;

/**
 * Module dependencies.
 */

var utils = require('./utils');

/**
 * CSS property constructor.
 *
 * @param {String} property
 * @param {String} value
 * @param {Selector} selector the property originates from
 * @param {Integer} priority 0 for normal properties, 2 for !important properties.
 * @param {Array} additional array of integers representing more detailed priorities (sorting)
 * @api public
 */

function Property(prop, value, selector, priority, additionalPriority) {
  this.prop = prop;
  this.value = value;
  this.selector = selector;
  this.priority = priority || 0;
  this.additionalPriority = additionalPriority || [];
}

/**
 * Compares with another Property based on Selector#specificity.
 *
 * @api public
 */

Property.prototype.compareFunc = function(property) {
  var a = [];
  a.push.apply(a, this.selector.specificity());
  a.push.apply(a, this.additionalPriority);
  a[0] += this.priority;
  var b = [];
  b.push.apply(b, property.selector.specificity());
  b.push.apply(b, property.additionalPriority);
  b[0] += property.priority;
  return utils.compareFunc(a, b);
};

Property.prototype.compare = function(property) {
  var winner = this.compareFunc(property);
  if (winner === 1) return this;
  return property;
};


/**
 * Returns CSS property
 *
 * @api public
 */

Property.prototype.toString = function() {
  return this.prop + ': ' + this.value.replace(/['"]+/g, '') + ';';
};

},{"./utils":7}],6:[function(require,module,exports){
'use strict';

var parser = require("./../../slick/dist/slick.js").parse;

module.exports = exports = Selector;

/**
 * CSS selector constructor.
 *
 * @param {String} selector text
 * @param {Array} optionally, precalculated specificity
 * @api public
 */

function Selector(text, styleAttribute) {
  this.text = text;
  this.spec = undefined;
  this.styleAttribute = styleAttribute || false;
}

/**
 * Get parsed selector.
 *
 * @api public
 */

Selector.prototype.parsed = function() {
  if (!this.tokens) { this.tokens = parse(this.text); }
  return this.tokens;
};

/**
 * Lazy specificity getter
 *
 * @api public
 */

Selector.prototype.specificity = function() {
  var styleAttribute = this.styleAttribute;
  if (!this.spec) { this.spec = specificity(this.text, this.parsed()); }
  return this.spec;

  function specificity(text, parsed) {
    var expressions = parsed || parse(text);
    var spec = [styleAttribute ? 1 : 0, 0, 0, 0];
    var nots = [];

    for (var i = 0; i < expressions.length; i++) {
      var expression = expressions[i];
      var pseudos = expression.pseudos;

      // id awards a point in the second column
      if (expression.id) { spec[1]++; }

      // classes and attributes award a point each in the third column
      if (expression.attributes) { spec[2] += expression.attributes.length; }
      if (expression.classList) { spec[2] += expression.classList.length; }

      // tag awards a point in the fourth column
      if (expression.tag && expression.tag !== '*') { spec[3]++; }

      // pseudos award a point each in the fourth column
      if (pseudos) {
        spec[3] += pseudos.length;

        for (var p = 0; p < pseudos.length; p++) {
          if (pseudos[p].name === 'not') {
            nots.push(pseudos[p].value);
            spec[3]--;
          }
        }
      }
    }

    for (var ii = nots.length; ii--;) {
      var not = specificity(nots[ii]);
      for (var jj = 4; jj--;) { spec[jj] += not[jj]; }
    }

    return spec;
  }
};

/**
 * Parses a selector and returns the tokens.
 *
 * @param {String} selector
 * @api private.
 */

function parse(text) {
  try {
    return parser(text)[0];
  } catch (e) {
    return [];
  }
}

},{"./../../slick/dist/slick.js":17}],7:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

var mensch = require("./../../mensch/index.js");
var own = {}.hasOwnProperty;
var os = require('os');
var Selector = require('./selector');
var Property = require('./property');

exports.Selector = Selector;
exports.Property = Property;

/**
 * Returns an array of the selectors.
 *
 * @license Sizzle CSS Selector Engine - MIT
 * @param {String} selectorText from mensch
 * @api public
 */

exports.extract = function extract(selectorText) {
  var attr = 0;
  var sels = [];
  var sel = '';

  for (var i = 0, l = selectorText.length; i < l; i++) {
    var c = selectorText.charAt(i);

    if (attr) {
      if (']' === c || ')' === c) { attr--; }
      sel += c;
    } else {
      if (',' === c) {
        sels.push(sel);
        sel = '';
      } else {
        if ('[' === c || '(' === c) { attr++; }
        if (sel.length || (c !== ',' && c !== '\n' && c !== ' ')) { sel += c; }
      }
    }
  }

  if (sel.length) {
    sels.push(sel);
  }

  return sels;
};

/**
 * Returns a parse tree for a CSS source.
 * If it encounters multiple selectors separated by a comma, it splits the
 * tree.
 *
 * @param {String} css source
 * @api public
 */

exports.parseCSS = function(css) {
  var parsed = mensch.parse(css, {position: true, comments: true});
  var rules = typeof parsed.stylesheet != 'undefined' && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
  var ret = [];

  for (var i = 0, l = rules.length; i < l; i++) {
    if (rules[i].type == 'rule') {
      var rule = rules[i];
      var selectors = rule.selectors;

      for (var ii = 0, ll = selectors.length; ii < ll; ii++) {
        ret.push([selectors[ii], rule.declarations]);
      }
    }
  }

  return ret;
};

/**
 * Returns preserved text for a CSS source.
 *
 * @param {String} css source
 * @param {Object} options
 * @api public
 */

exports.getPreservedText = function(css, options) {
  var parsed = mensch.parse(css, {position: true, comments: true});
  var rules = typeof parsed.stylesheet != 'undefined' && parsed.stylesheet.rules ? parsed.stylesheet.rules : [];
  var preserved = [];
  var lastStart = null;

  for (var i = rules.length - 1; i >= 0; i--) {
    if ((options.fontFaces && rules[i].type === 'font-face') ||
        (options.mediaQueries && rules[i].type === 'media')) {
      preserved.push(
        mensch.stringify(
          { stylesheet: { rules: [ rules[i] ] }}, 
          { comments: false, indentation: '  ' }
        )
      );
    }
    lastStart = rules[i].position.start;
  }

  if (preserved.length === 0) return false;
  return os.EOL+preserved.join(os.EOL)+os.EOL;
};

exports.normalizeLineEndings = function(text) {
  return text.replace(/\r\n/g, '\n').replace(/\n/g, '\r\n');
};


/**
 * Compares two specificity vectors, returning the winning one.
 *
 * @param {Array} vector a
 * @param {Array} vector b
 * @return {Array}
 * @api public
 */

exports.compareFunc = function(a, b) {
  var min = Math.min(a.length, b.length);
  for (var i = 0; i < min; i++) {
    if (a[i] === b[i]) { continue; }
    if (a[i] > b[i]) { return 1; }
    return -1;
  }

  return a.length-b.length;
};

exports.compare = function(a, b) {
  return exports.compareFunc(a, b) == 1 ? a : b;
};

exports.extend = function(obj, src) {
  for (var key in src) {
    if (own.call(src, key)) {
      obj[key] = src[key];
    }
  }
  return obj;
};

exports.getDefaultOptions = function(options) {
  var result = exports.extend({
    extraCss: '',
    insertPreservedExtraCss: true,
    applyStyleTags: true,
    removeStyleTags: true,
    preserveMediaQueries: true,
    preserveFontFaces: true,
    applyWidthAttributes: true,
    applyHeightAttributes: true,
    applyAttributesTableElements: true,
    url: ''
  }, options);

  result.webResources = result.webResources || {};

  return result;
};

},{"./../../mensch/index.js":12,"./property":5,"./selector":6,"os":29}],8:[function(require,module,exports){
(function (global){
// knockout-sortable 0.11.0 | (c) 2015 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
!function(a){if("function"==typeof define&&define.amd)define(["knockout","jquery","jquery-ui/sortable","jquery-ui/draggable"],a);else if("function"==typeof require&&"object"==typeof exports&&"object"==typeof module){var b=(typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null),c=(typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);(typeof window !== "undefined" ? window['jQuery']['ui']['sortable'] : typeof global !== "undefined" ? global['jQuery']['ui']['sortable'] : null),(typeof window !== "undefined" ? window['jQuery']['ui']['draggable'] : typeof global !== "undefined" ? global['jQuery']['ui']['draggable'] : null),a(b,c)}else a(window.ko,window.jQuery)}(function(a,b){var c="ko_sortItem",d="ko_sourceIndex",e="ko_sortList",f="ko_parentList",g="ko_dragItem",h=a.utils.unwrapObservable,i=a.utils.domData.get,j=a.utils.domData.set,k=b.ui&&b.ui.version,l=k&&k.indexOf("1.6.")&&k.indexOf("1.7.")&&(k.indexOf("1.8.")||"1.8.24"===k),m=function(b,d){a.utils.arrayForEach(b,function(a){1===a.nodeType&&(j(a,c,d),j(a,f,i(a.parentNode,e)))})},n=function(b,c){var d,e={},f=h(b())||{};return f.data?(e[c]=f.data,e.name=f.template):e[c]=b(),a.utils.arrayForEach(["afterAdd","afterRender","as","beforeRemove","includeDestroyed","templateEngine","templateOptions","nodes"],function(b){f.hasOwnProperty(b)?e[b]=f[b]:a.bindingHandlers.sortable.hasOwnProperty(b)&&(e[b]=a.bindingHandlers.sortable[b])}),"foreach"===c&&(e.afterRender?(d=e.afterRender,e.afterRender=function(a,b){m.call(b,a,b),d.call(b,a,b)}):e.afterRender=m),e},o=function(a,b){var c=h(b);if(c)for(var d=0;a>d;d++)c[d]&&h(c[d]._destroy)&&a++;return a},p=function(c,d){var e,f;d?(f=document.getElementById(d),f&&(e=new a.templateSources.domElement(f),e.text(b.trim(e.text())))):b(c).contents().each(function(){this&&1!==this.nodeType&&c.removeChild(this)})};a.bindingHandlers.sortable={init:function(k,m,q,r,s){var t,u,v=b(k),w=h(m())||{},x=n(m,"foreach"),y={};p(k,x.name),b.extend(!0,y,a.bindingHandlers.sortable),w.options&&y.options&&(a.utils.extend(y.options,w.options),delete w.options),a.utils.extend(y,w),y.connectClass&&(a.isObservable(y.allowDrop)||"function"==typeof y.allowDrop)?a.computed({read:function(){var b=h(y.allowDrop),c="function"==typeof b?b.call(this,x.foreach):b;a.utils.toggleDomNodeCssClass(k,y.connectClass,c)},disposeWhenNodeIsRemoved:k},this):a.utils.toggleDomNodeCssClass(k,y.connectClass,y.allowDrop),a.bindingHandlers.template.init(k,function(){return x},q,r,s),t=y.options.start,u=y.options.update;var z=setTimeout(function(){var m;v.sortable(a.utils.extend(y.options,{start:function(b,c){var e=c.item[0];j(e,d,a.utils.arrayIndexOf(c.item.parent().children(),e)),c.item.find("input:focus").change(),t&&t.apply(this,arguments)},receive:function(a,b){m=i(b.item[0],g),m&&(m.clone&&(m=m.clone()),y.dragged&&(m=y.dragged.call(this,m,a,b)||m))},update:function(g,h){var k,n,p,q,r,s=h.item[0],t=h.item.parent()[0],v=i(s,c)||m;if(m=null,v&&this===t||!l&&b.contains(this,t)){if(k=i(s,f),p=i(s,d),n=i(s.parentNode,e),q=a.utils.arrayIndexOf(h.item.parent().children(),s),x.includeDestroyed||(p=o(p,k),q=o(q,n)),(y.beforeMove||y.afterMove)&&(r={item:v,sourceParent:k,sourceParentNode:k&&h.sender||s.parentNode,sourceIndex:p,targetParent:n,targetIndex:q,cancelDrop:!1},y.beforeMove&&y.beforeMove.call(this,r,g,h)),k?b(k===n?this:h.sender||this).sortable("cancel"):b(s).remove(),r&&r.cancelDrop)return;q>=0&&(k&&(k.splice(p,1),a.processAllDeferredBindingUpdates&&a.processAllDeferredBindingUpdates()),n.splice(q,0,v)),j(s,c,null),a.processAllDeferredBindingUpdates&&a.processAllDeferredBindingUpdates(),y.afterMove&&y.afterMove.call(this,r,g,h)}u&&u.apply(this,arguments)},connectWith:y.connectClass?"."+y.connectClass:!1})),void 0!==y.isEnabled&&a.computed({read:function(){v.sortable(h(y.isEnabled)?"enable":"disable")},disposeWhenNodeIsRemoved:k})},0);return a.utils.domNodeDisposal.addDisposeCallback(k,function(){(v.data("ui-sortable")||v.data("sortable"))&&v.sortable("destroy"),a.utils.toggleDomNodeCssClass(k,y.connectClass,!1),clearTimeout(z)}),{controlsDescendantBindings:!0}},update:function(b,c,d,f,g){var h=n(c,"foreach");j(b,e,h.foreach),a.bindingHandlers.template.update(b,function(){return h},d,f,g)},connectClass:"ko_container",allowDrop:!0,afterMove:null,beforeMove:null,options:{}},a.bindingHandlers.draggable={init:function(c,d,e,f,i){var k=h(d())||{},l=k.options||{},m=a.utils.extend({},a.bindingHandlers.draggable.options),o=n(d,"data"),p=k.connectClass||a.bindingHandlers.draggable.connectClass,q=void 0!==k.isEnabled?k.isEnabled:a.bindingHandlers.draggable.isEnabled;return k="data"in k?k.data:k,j(c,g,k),a.utils.extend(m,l),m.connectToSortable=p?"."+p:!1,b(c).draggable(m),void 0!==q&&a.computed({read:function(){b(c).draggable(h(q)?"enable":"disable")},disposeWhenNodeIsRemoved:c}),a.utils.domNodeDisposal.addDisposeCallback(c,function(){b(c).draggable("destroy")}),a.bindingHandlers.template.init(c,function(){return o},e,f,i)},update:function(b,c,d,e,f){var g=n(c,"data");return a.bindingHandlers.template.update(b,function(){return g},d,e,f)},connectClass:a.bindingHandlers.sortable.connectClass,options:{helper:"clone"}}});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],9:[function(require,module,exports){
(function (global){
// Knockout UndoManager v0.2 | (c) 2015 Stefano Bagnara
// License: MIT (http://www.opensource.org/licenses/mit-license) 
// requires "ko.watch" method from knockout.reactor
(function (factory) {
  // Module systems magic dance.
  if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
    // CommonJS or Node: hard-coded dependency on "knockout"
    module.exports = factory((typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null), require("./../knockoutjs-reactor/src/knockout.reactor.js"));
  } else if (typeof define === "function" && define["amd"]) {
    // AMD anonymous module with hard-coded dependency on "knockout"
    define(["knockout", "knockoutjs-reactor", "exports"], factory);
  } else {
    // <script> tag: use the global `ko` object
    factory(ko, ko.watch);
  }
}(function (ko, reactor) { 

  /// <summary>
  ///     Track last "levels" changes within the chained observable down to any given level and
  ///     supports undoing/redoing the changes.
  /// </summary>
  /// <param name="options" type="object">
  ///     { levels: 2 } -> Remember only last "levels" changes<br/>
  ///     { undoLabel: "Undo it (#COUNT)!" } -> Define a label for the undo command. "#COUNT#" sequence will be replaced with the stack length.<br/>
  ///     { redoLabel: "Redo it (#COUNT)!" } -> Define a label for the redo command. "#COUNT#" sequence will be replaced with the stack length.<br/>
  /// </param>
  var undoManager = function (model, options) {
    var undoStack = ko.observableArray();
    var redoStack = ko.observableArray();
    var lastPushedStack;
    var STATE_DOING = 0;
    var STATE_UNDOING = 1;
    var STATE_REDOING = 2;
    var state = STATE_DOING;

    var MODE_NORMAL = 0; // add to stack every change
    var MODE_IGNORE = 1; // do not add anything to the stack
    var MODE_ONCE = 2; // only one sequential change for each property is added to the stack
    var MODE_MERGE = 3; // merge next change with the last one
    var mode = MODE_NORMAL;

    var defaultOptions = {
      levels: 100,
      undoLabel: "undo (#COUNT#)",
      redoLabel: "redo (#COUNT#)"
    };
    
    if (typeof options == 'object') {
      options = ko.utils.extend(defaultOptions, options);
    } else {
      options = defaultOptions;
    }
  
    var _push = function (action) {
      // durante UNDO/REDO lavoriamo sempre in normale
      if (state == STATE_UNDOING) {
        _pushInt(action, redoStack);
      } else if (state == STATE_REDOING) {
        _pushInt(action, undoStack);
      } else if (state == STATE_DOING) {
        _pushInt(action, undoStack);
        redoStack.removeAll();
      }
    };
    
    var _tryMerge = function (prev, newAction) {
      if (typeof prev.mergedAction !== 'undefined') {
        return prev.mergedAction(newAction);
      } else return null;
    };

    var _pushInt = function (action, myStack) {
      /* gestione del merge di azioni: se l'ultima azione nello stack ha un metodo "mergedAction"
         proviamo ad invocarlo e se ci restituisce una funzione la usiamo al posto di entrambe */
      // console.log("UR", "_pushInt", myStack().length > 0 ? typeof myStack()[myStack().length - 1].mergedAction : "EMPTY");
      if (myStack().length > 0) {
        var merged = _tryMerge(myStack()[myStack().length - 1], action);
        // console.log("UR", "_pushInt.merged", merged, "MV", typeof action.mergeableMove, "MA", typeof action.mergeableAction, "MM", typeof action.mergeMe);
        if (merged !== null) {
          myStack()[myStack().length - 1] = merged;
          return;
        }
      }
      if (myStack().length >= options.levels) myStack.shift();
      lastPushedStack = myStack;
      myStack.push(action);
    };
    
    var _xdoCommand = function(label, workState, stack) {
      return {
        name: ko.computed(function() {
          return ko.utils.unwrapObservable(label).replace(/#COUNT#/, stack().length);
        }),
        enabled: ko.computed(function() {
          return stack().length !== 0;
        }),
        execute: function() {
          var action = stack.pop();
          if (action) {
            var prevState = state;
            state = workState;
            var oldMode = mode;
            mode = MODE_MERGE;
            // console.log("XDO", "before", label);
            action();
            // console.log("XDO", "after", label);
            _removeMergedAction(lastPushedStack);
            mode = oldMode;
            state = prevState;
          }
          return true;
        }
      };
    };

    var _removeMergedAction = function(myStack) {
      if (typeof myStack == 'undefined') throw "Unexpected operation: stack cleaner called with undefined stack";
      
      if (myStack().length > 0 && typeof myStack()[myStack().length - 1].mergedAction !== 'undefined') {
        // console.log("Removing mergedAction from stack");
        delete myStack()[myStack().length - 1].mergedAction;
      }
    };

    var _combinedFunction = function(first, second) {
      var res = (function(f1, f2) {
        f1();
        f2();
      }).bind(undefined, first, second);
      if (typeof first.mergedAction !== 'undefined') {
        res.mergedAction = first.mergedAction;
      }
      return res;
    };

    var executeUndoAction = function(child, value, item) {
      // console.log("executeUndoAction", child, value, item);
      if (typeof value !== 'undefined') {
        child(value);
      } else if (item) {
        if (item.status == 'deleted') {
          child.splice(item.index, 0, item.value);
        } else if (item.status == 'added') {
          child.splice(item.index, 1);
        } else {
          throw "Unsupproted item.status: "+item.status;
        }
      } else {
        throw "Unexpected condition: no item and no child.oldValues!";
      }
    };

    var makeUndoActionDefault = function(undoFunc, parents, child, oldVal, item) {
      return undoFunc.bind(undefined, child, oldVal, item);
    };

    var makeUndoAction = makeUndoActionDefault;

    var changePusher = function(parents, child, item) {
      var oldVal = typeof child.oldValues != 'undefined' ? child.oldValues[0] : undefined;
      var act = makeUndoAction(executeUndoAction, parents, child, oldVal, item);

      if (mode == MODE_IGNORE) return;

      if (mode == MODE_MERGE) {
        // console.log("UR", "mergemode");
        if (typeof act !== 'undefined') {
          act.mergedAction = function(newAction) {
            if (typeof newAction.mergeMe !== 'undefined' && newAction.mergeMe) {
              return _combinedFunction(newAction, this);
            } else return null;
          };
          act.mergeMe = true;
        }
      } else {
        if (typeof act !== 'undefined') {
          if (child.oldValues && mode == MODE_ONCE) {
            act.mergedAction = function(oldChild, oldItem, newAction) {
              if (typeof newAction.mergeableAction == 'object' && oldChild == newAction.mergeableAction.child) {
                // console.log("UR", "ignore update for property in MODE_ONCE");
                return this;
              } else return null;
            }.bind(act, child, item);
            act.mergeableAction = { child: child, item: item };
          }
          // console.log("UR", "item.status", item.status);
          // "item" is valued when an item is added/removed/reteined in an array
          // sometimes KO detect "moves" and add a "moved" property with the index but
          // this doesn't happen for example using knockout-sortable or when moving objects
          // between arrays.
          // So this ends up handling this with "mergeableMove" and "mergedAction": 
          if (item && item.status == 'deleted') {
            // TODO se sono in MODE = MERGE devo metteer una funzione di merge che accetta tutto.
            // altrimenti lascio questa.
            act.mergedAction = function(oldChild, oldItem, newAction) {
              // console.log("UR", "act.mergedAction", typeof newAction.mergeableMove);
              // a deleted action is able to merge with a added action if they apply to the same
              // object.
              if (typeof newAction.mergeableMove == 'object' && oldItem.value == newAction.mergeableMove.item.value) {
                // in this case I simply return a single action running both actions in sequence,
                // this way the "undo" will need to undo only once for a "move" operation.
                return _combinedFunction(newAction, this);
              } else {
                console.log("UR", "not mergeable", typeof newAction.mergeableMove);
              }

              return null;
            }.bind(act, child, item);
          }
          if (item && item.status == 'added') {
            // add a mergeableMove property that will be used by the next action "mergedAction" to see if this action
            // can be merged.
            act.mergeableMove = { child: child, item: item };
          }
        }
      }
      if (typeof act !== 'undefined') _push(act);
    };

    var reactorOptions = { depth: -1, oldValues: 1, mutable: true, /* tagParentsWithName: true */ tagFields: true };

    var context = {};
    var react = typeof reactor == 'function' ? reactor : ko.watch;
    var res = react(model, reactorOptions, changePusher, context);

    return {
      push: _push, 
      undoCommand: _xdoCommand(options.undoLabel, STATE_UNDOING, undoStack),
      redoCommand: _xdoCommand(options.redoLabel, STATE_REDOING, redoStack),
      reset: function() { undoStack.removeAll(); redoStack.removeAll(); },
      // setMode: function(newMode) { mode = newMode; _removeMergedAction(undoStack); },
      setModeOnce: function() { mode = MODE_ONCE; _removeMergedAction(undoStack); },
      setModeMerge: function() { mode = MODE_MERGE; _removeMergedAction(undoStack); },
      setModeNormal: function() { mode = MODE_NORMAL; _removeMergedAction(undoStack); },
      setModeIgnore: function() { mode = MODE_IGNORE; _removeMergedAction(undoStack); },
      setUndoActionMaker: function(maker) { makeUndoAction = maker; },
      dispose: function() { /* ko.unwatch(model, reactorOptions, changePusher); */ res.dispose(); }
    };
  };

  return undoManager;
  
}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../knockoutjs-reactor/src/knockout.reactor.js":11}],10:[function(require,module,exports){
(function (global){
// Knockout Fast Mapping v0.1
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function (factory) {
	// Module systems magic dance.

	if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
		// CommonJS or Node: hard-coded dependency on "knockout"
		factory((typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null), exports);
	} else if (typeof define === "function" && define["amd"]) {
		// AMD anonymous module with hard-coded dependency on "knockout"
		define(["knockout", "exports"], factory);
	} else {
		// <script> tag: use the global `ko` object, attaching a `wrap` property
		factory(ko, ko.wrap = {});
	}
}(function (ko, exports) {
    
    // this function mimics ko.mapping
    exports.fromJS = function(jsObject, computedFunctions, observableObjects)
    {
        reset();
	return wrap(jsObject, computedFunctions, observableObjects);
    }

    // this function unwraps the outer for assigning the result to an observable
    // see https://github.com/SteveSanderson/knockout/issues/517
    exports.updateFromJS = function(observable, jsObject, computedFunctions, observableObjects)
    {
        reset();
	return observable(ko.utils.unwrapObservable(wrap(jsObject, computedFunctions, observableObjects)));
    }

    exports.fromJSON = function (jsonString, computedFunctions, observableObjects) {
	var parsed = ko.utils.parseJson(jsonString);
	arguments[0] = parsed;
	return exports.fromJS.apply(this, computedFunctions, observableObjects);
    };
    
    exports.toJS = function (observable) {
	return unwrap(observable);
    }

    exports.toJSON = function (observable) {
	var plainJavaScriptObject = exports.toJS(observable);
	return ko.utils.stringifyJson(plainJavaScriptObject);
    };

    function typeOf(value) {
	var s = typeof value;
	if (s === 'object') {
            if (value) {
                if (value.constructor == Date)
                    s = 'date';
		else if (Object.prototype.toString.call(value) == '[object Array]')
                    s = 'array';
            } else {
		s = 'null';
            }
	}
	return s;
    }

    // unwrapping
    function unwrapObject(o)
    {
	var t = {};

	for (var k in o)
	{
	    var v = o[k];

	    if (ko.isComputed(v))
		continue;

	    t[k] = unwrap(v);
	}

	return t;
    }

    function unwrapArray(a)
    {
	var r = [];

	if (!a || a.length == 0)
	    return r;
	
	for (var i = 0, l = a.length; i < l; ++i)
	    r.push(unwrap(a[i]));

	return r;
    }

    function unwrap(v)
    {
	var isObservable = ko.isObservable(v);

	if (isObservable)
	{
	    var val = v();

	    return unwrap(val);
	}
	else
	{
	    if (typeOf(v) == "array")
	    {
		return unwrapArray(v);
	    }
	    else if (typeOf(v) == "object")
	    {
		return unwrapObject(v);
	    }
	    else
	    {
		return v;
	    }
	}
    }

    function reset()
    {
        parents = [{obj: null, wrapped: null, lvl: ""}];
    }    
    
    // wrapping

    function wrapObject(o, computedFunctions, observableObjects)
    {
        // check for infinite recursion
        for (var i = 0; i < parents.length; ++i) {
            if (parents[i].obj === o) {
                return parents[i].wrapped;
            }
        }

	var t = {};

	for (var k in o)
	{
	    var v = o[k];

            parents.push({obj: o, wrapped: t, lvl: currentLvl() + "/" + k});

	    t[k] = wrap(v, computedFunctions, observableObjects);

            parents.pop();
	}

	if (computedFunctions && computedFunctions[currentLvl()])
	    t = computedFunctions[currentLvl()](t);

        if (hasES5Plugin())
            ko.track(t);

	if (observableObjects) return ko.observable(t);
	return t;
    }

    function wrapArray(a, computedFunctions, observableObjects)
    {
	var r = ko.observableArray();

	if (!a || a.length == 0)
	    return r;

	for (var i = 0, l = a.length; i < l; ++i)
	    r.push(wrap(a[i], computedFunctions, observableObjects));

	return r;
    }

    // a stack, used for two purposes:
    //  - circular reference checking
    //  - computed functions
    var parents;

    function currentLvl()
    {
	return parents[parents.length-1].lvl;
    }

    function wrap(v, computedFunctions, observableObjects)
    {
	if (typeOf(v) == "array")
	{
	    return wrapArray(v, computedFunctions, observableObjects);
	}
	else if (typeOf(v) == "object")
	{
	    return wrapObject(v, computedFunctions, observableObjects);
	}
	else
	{
            if (!hasES5Plugin() && typeof v !== 'function')
            {
	        var t = ko.observable();
	        t(v);
	        return t;
            } else
                return v;
	}
    }

    function hasES5Plugin()
    {
        return ko.track != null;
    }
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],11:[function(require,module,exports){
// Deep observer plugin for Knockout http://knockoutjs.com/
// (c) Ziad Jeeroburkhan
// License: MIT (http://www.opensource.org/licenses/mit-license.php)
// Version 1.3.6

ko.subscribable.fn['watch'] = function (targetOrCallback, options, evaluatorCallback, context) {
    /// <summary>
    ///     Track and manage changes within the chained observable down to any given level. 
    /// </summary>
    /// <param name="targetOrCallback">
    ///      The subscription callback function or an object containing the subscribables to be watched.
    /// </param>
    /// <param name="options" type="object">
    ///     false -> Disables tracking on the chained observable.
    ///     { depth: 2 } -> Track all nested subscribables down to the 2nd level(default is 1).<br/>
    ///     { depth: -1 } -> Track all nested subscribables.<br/>
    ///     { hide: [...] } -> Property or array of properties to be ignored.<br/>
    ///     { hideArrays: true } -> Ignore all nested arrays.<br/>
    ///     { hideWrappedValues: true } -> Ignore observables wrapped under yet another parent observable.<br/>
    ///     { mutable: true } -> Dynamically adapt to changes made to the target structure through any subscribable.<br/>
    ///     { watchedOnly: true } -> Watch only subscribables tagged with .watch().<br/>
    ///     { beforeWatch: function(parents, child) {...} } -> Function called prior to creating a subscription. Returning false aborts the operation and ignores its children.<br/>
    ///     { wrap: true } -> Wrap all fields into observables. This happens on the fly for new array items(or child objects when mutable is set to true).<br/>
    ///     { beforeWrap: function(parents, field, value) {...} } -> Function called prior to wrapping a value into an observable. Returning false leaves it as it is.<br/>
    ///     { tagFields: true } -> Add the property '_fieldName' under each property for textual identification.<br/>
    ///     { tagFields: 'parentsOnly' } -> Same as above except that it is limited to parent properties only.<br/>
    ///     { oldValues: 3 } -> Keep the last three values for each subscribable under the property 'oldValues'.<br/>
    ///     { seal: true } -> Prevent any subsequent watcher from watching the target again.<br/>
    ///     { unloop: true } -> Avoid circular paths through the use of a breadcrumb property '_watcher' set at each node level.<br/>
    /// </param>
    /// <param name="evaluatorCallback" type="function">
    ///     The  callback function called during changes. Any return value is assigned to the chained observable.
    /// </param>

    var targetType = typeof targetOrCallback;

    if (targetType === 'boolean' || targetType === 'undefined') {
        // Turn on or off the watcher for the specified target along with any of its children.
        ko.watch(this, { enabled: targetOrCallback !== false });
    } else if (targetType === 'function' && !ko.isSubscribable(targetOrCallback)) {
        // Target the chained subscribable itself if no target subscribable or object was passed.
        ko.watch(this, options || {}, targetOrCallback, context || this);
    } else {
        ko.watch(targetOrCallback, options, evaluatorCallback, context || this);
    }

    return this;
};

ko['watch'] = function (target, options, evaluatorCallback, context) {
    /// <summary>
    ///     Track and manage changes within a specific target object down to any given level.
    /// </summary>
    /// <param name="target">
    ///     An object or function containing the targeted subscribable(s).
    /// </param>
    /// <param name="options" type="object">
    ///     { depth: 2 } -> Track all nested subscribables down to the 2nd level(default is 1).<br/>
    ///     { depth: -1 } -> Track all nested subscribables.<br/>
    ///     { hide: [...] } -> Property or array of properties to be ignored.<br/>
    ///     { hideArrays: true } -> Ignore all nested arrays.<br/>
    ///     { hideWrappedValues: true } -> Ignore observables wrapped under yet another parent observable.<br/>
    ///     { mutable: true } -> Dynamically adapt to changes made to the target structure through any subscribable.<br/>
    ///     { watchedOnly: true } -> Watch only subscribables tagged with .watch().<br/>
    ///     { beforeWatch: function(parents, child) {...} } -> Function called prior to creating a subscription. Returning false aborts the operation and ignores its children.<br/>
    ///     { wrap: true } -> Wrap all fields into observables. This happens on the fly for new array items(or child objects when mutable is set to true).<br/>
    ///     { beforeWrap: function(parents, field, value) {...} } -> Function called prior to wrapping a value into an observable. Returning false leaves it as it is.<br/>
    ///     { tagFields: true } -> Add the property '_fieldName' under each property for textual identification.<br/>
    ///     { tagFields: 'parentsOnly' } -> Same as above except that it is limited to parent properties only.<br/>
    ///     { oldValues: 3 } -> Keep the last three values for each subscribable under the property 'oldValues'.<br/>
    ///     { seal: true } -> Prevent any subsequent watcher from watching the target again.<br/>
    ///     { unloop: true } -> Avoid circular paths through the use of a breadcrumb property '_watcher' set at each node level.<br/>
    ///     { getter: function(parents, child, property) {...} } -> Function used to retrieve the property value from the given child. False can be returned to ignore the property.<br/>
    /// </param>
    /// <param name="evaluatorCallback" type="function">
    ///     The callback function called during changes.
    /// </param>

    if (typeof options === 'function') {
        context = context || evaluatorCallback;
        evaluatorCallback = options;
        options = {};
    }

    context = context || this;

    function watchChildren(child, parent, grandParents, unwatch, keepOffParentList, fieldName) {
        if (child && options.depth !== 0 && (options.depth === -1 || grandParents.length < (options.depth || 1))) {

            // Proceed on watched children only when in watched-only mode.
            if (options.watchedOnly && !child.watchable && child != target)
                return;

            // Setting the target as false prevents it from being watched later on.
            if (options.enabled === false || options.enabled === true)
                child.watchable = options.enabled;

            // Ignore watch-disabled objects.
            if (child.watchable === false)
                return;

            // Prevent subsequent watchers from watching the target when sealed.
            if (options.seal === true)
                child.watchable = false;

            var type = typeof child;

            if (type === 'object' || type === 'function') {
                // Bypass circular references.
                if (child._watcher === context)
                    return;

                // Ignore hidden objects. Also applies to any of their children.
                if (options.hide)
                    if (ko.utils.arrayIndexOf(options.hide, child) > -1)
                        return;

                // Merge parents. Using a fresh array so it is not referenced in the next recursion if any.
                var parents = [].concat(grandParents, parent && parent !== target ? parent : []);

                if (type === 'function') {
                    if (typeof child['notifySubscribers'] == 'function') {
                        // Target is a subscribable. Watch it.
                        if (evaluatorCallback) {
                            if (options.enabled === true && child.watchable === false)
                                // Only waking up an existing watcher. Let's not add another.
                                return;

                            if (unwatch || !options.beforeWatch || options.beforeWatch.call(context, parents, child, fieldName) !== false) {
                                var isArray = typeof child.pop === 'function';

                                if (unwatch) {
                                    disposeWatcher(child);
                                } else {
                                    assignWatcher(child, isArray, parents, keepOffParentList);
                                }

                                if (isArray) {
                                    watchChildren(child(), keepOffParentList ? null : child, parents, unwatch, true);
                                    return true;
                                } else {
                                    if (options.hideWrappedValues !== true)
                                        return watchChildren(child(), keepOffParentList ? null : child, parents, unwatch, true);
                                }
                            }
                        }
                    }
                } else {
                    if (Object.prototype.toString.call(child) === '[object Object]') {
                        ko.utils.objectForEach(child, function (property, sub) {
                            sub = options.getter ? options.getter.call(context, parents, child, property) : sub;
                            if (sub) {
                                if (options.wrap) {
                                    // Wrap simple objects and arrays into observables.
                                    var type = Object.prototype.toString.call(sub);
                                    if (type !== '[object Function]' && type !== '[object Object]') {
                                        if (!options.beforeWrap || options.beforeWrap.call(context, parents, child, sub) !== false) {
                                            sub = child[property] = type === '[object Array]'
                                                ? ko.observableArray(sub)
                                                : ko.observable(sub);
                                        }
                                    }
                                }

                                if (options.unloop)
                                    sub._watcher = unwatch ? undefined : context;

                                var hasChildren = watchChildren(sub, keepOffParentList ? null : child, parents, unwatch, null, property);

                                if (options.tagFields && sub._fieldName === undefined)
                                    if (hasChildren
                                        || (options.tagFields !== 'parentsOnly' && typeof sub === 'function' || typeof sub === 'object'))
                                        sub._fieldName = property;
                            }
                        });
                    } else { // '[object Array]'
                        if (options.hideArrays !== true)
                            for (var i = 0; i < child.length; i++)
                                watchChildren(child[i], keepOffParentList ? null : child, parents, unwatch);
                    }

                    return true;
                }
            }
        }
    }

    // Subscriptions are stored under either the _subscriptions field for the debug version
    // or the F, H or M fields when minified depending on the version used.
    var subscriptionsField;
    switch (ko.DEBUG || ko.version) {
        case true: subscriptionsField = '_subscriptions'; break;
        case "3.0.0": subscriptionsField = 'F'; break;
        case "3.1.0": subscriptionsField = 'H'; break;
        case "3.2.0": subscriptionsField = 'M'; break;
        case "3.3.0": subscriptionsField = 'G'; break;
        case "3.4.0": subscriptionsField = 'K'; break;
        default: throw "Unsupported Knockout version. Only v3.0.0 to v3.4.0 are supported when minified. Current version is " + ko.version;
    }

    function disposeWatcher(child) {
        var subsc = child[subscriptionsField];

        if (subsc) {
            if (subsc.change)
                for (var i = subsc.change.length - 1; i >= 0; i--)
                    if (subsc.change[i]._watcher === context)
                        subsc.change[i].dispose();

            if (subsc.beforeChange && (options.mutable || options.oldValues > 0))
                // Also clean up any before-change subscriptions used for tracking old values.
                for (var i = subsc.beforeChange.length - 1; i >= 0; i--)
                    if (subsc.beforeChange[i]._watcher === context)
                        subsc.beforeChange[i].dispose();

            if (subsc.arrayChange)
                for (var i = subsc.arrayChange.length - 1; i >= 0; i--)
                    if (subsc.arrayChange[i]._watcher === context)
                        subsc.arrayChange[i].dispose();
        } else {
            throw "Subscriptions field (." + subscriptionsField + ") not defined for observable child " + (child._fieldName || "");
        }
    }

    function assignWatcher(child, isArray, parents, keepOffParentList) {
        if (isArray) {
            // Child is an observable array. Watch all changes within it.
            child.subscribe(function (changes) {
                ko.utils.arrayForEach(changes, function (item) {
                    var returnValue = evaluatorCallback.call(context, parents, child, item);
                    if (returnValue !== undefined)
                        context(returnValue);

                    if (!item.moved) {
                        // Deleted or brand new item. Unwatch or watch it accordingly.
                        setTimeout(function () {
                            watchChildren(item.value, (keepOffParentList ? null : child), parents, item.status === 'deleted');
                        }, 0);
                    }
                });
            }, undefined, 'arrayChange')._watcher = context;

        } else {
            child.subscribe(function () {
                if (child.watchable !== false) {
                    var returnValue = evaluatorCallback.call(context, parents, child);

                    if (returnValue !== undefined)
                        context(returnValue);

                    if (options.mutable && typeof child() === 'object')
                        // Watch the new comer.
                        watchChildren(child(), (keepOffParentList ? null : child), parents);
                }

            }, null, 'change')._watcher = context;

            if (options.oldValues > 0 || options.mutable) {
                child.subscribe(function (oldValue) {
                    if (options.oldValues > 0) {
                        // Add old value to history list before every update.
                        var values = (child['oldValues']
                            ? child['oldValues']
                            : child['oldValues'] = []);

                        values.unshift(oldValue);

                        while (values.length > options.oldValues)
                            values.pop();
                    }

                    if (options.mutable && typeof oldValue === 'object')
                        // Clean up all subscriptions for the old child object.
                        watchChildren(oldValue, (keepOffParentList ? null : child), parents, false, true);

                }, null, 'beforeChange')._watcher = context;
            }
        }
    }

    // Use a computed when targeting a non-watchable function.
    if (typeof target === 'function' && !ko.isSubscribable(target))
        return ko.computed(target, evaluatorCallback, options);

    watchChildren(target, null, []);

    return {
        dispose: function () {
            watchChildren(target, null, [], true);
        }
    };
};

},{}],12:[function(require,module,exports){
module.exports = {
    lex  : require('./lib/lexer'),
    parse: require('./lib/parser'),
    stringify: require('./lib/stringify')
};

},{"./lib/lexer":14,"./lib/parser":15,"./lib/stringify":16}],13:[function(require,module,exports){
(function (process){
exports = module.exports = debug;

function debug(label) {
  return _debug.bind(null, label);
}

function _debug(label) {
  var args = [].slice.call(arguments, 1);
  args.unshift('[' + label + ']');
  process.stderr.write(args.join(' ') + '\n');
}
}).call(this,require('_process'))

},{"_process":30}],14:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `lex()` and print the results.

var debug = require('./debug')('lex');

exports = module.exports = lex;

/**
 * Convert a CSS string into an array of lexical tokens.
 *
 * @param {String} css CSS
 * @returns {Array} lexical tokens
 */
function lex(css) {
  var start; // Debug timer start.

  var buffer = '';      // Character accumulator
  var ch;               // Current character
  var column = 0;       // Current source column number
  var cursor = -1;      // Current source cursor position
  var depth = 0;        // Current nesting depth
  var line = 1;         // Current source line number
  var state = 'before-selector'; // Current state
  var stack = [state];  // State stack
  var token = {};       // Current token
  var tokens = [];      // Token accumulator

  // Supported @-rules, in roughly descending order of usage probability.
  var atRules = [
    'media',
    'keyframes',
    { name: '-webkit-keyframes', type: 'keyframes', prefix: '-webkit-' },
    { name: '-moz-keyframes', type: 'keyframes', prefix: '-moz-' },
    { name: '-ms-keyframes', type: 'keyframes', prefix: '-ms-' },
    { name: '-o-keyframes', type: 'keyframes', prefix: '-o-' },
    'font-face',
    { name: 'import', state: 'before-at-value' },
    { name: 'charset', state: 'before-at-value' },
    'supports',
    'viewport',
    { name: 'namespace', state: 'before-at-value' },
    'document',
    { name: '-moz-document', type: 'document', prefix: '-moz-' },
    'page'
  ];

  // -- Functions ------------------------------------------------------------

  /**
   * Advance the character cursor and return the next character.
   *
   * @returns {String} The next character.
   */
  function getCh() {
    skip();
    return css[cursor];
  }

  /**
   * Return the state at the given index in the stack.
   * The stack is LIFO so indexing is from the right.
   *
   * @param {Number} [index=0] Index to return.
   * @returns {String} state
   */
  function getState(index) {
    return index ? stack[stack.length - 1 - index] : state;
  }

  /**
   * Look ahead for a string beginning from the next position. The string
   * being looked for must start at the next position.
   *
   * @param {String} str The string to look for.
   * @returns {Boolean} Whether the string was found.
   */
  function isNextString(str) {
    var start = cursor + 1;
    return (str === css.slice(start, start + str.length));
  }

  /**
   * Find the start position of a substring beginning from the next
   * position. The string being looked for may begin anywhere.
   *
   * @param {String} str The substring to look for.
   * @returns {Number|false} The position, or `false` if not found.
   */
  function find(str) {
    var pos = css.slice(cursor).indexOf(str);

    return pos > 0 ? pos : false;
  }

  /**
   * Determine whether a character is next.
   *
   * @param {String} ch Character.
   * @returns {Boolean} Whether the character is next.
   */
  function isNextChar(ch) {
    return ch === peek(1);
  }

  /**
   * Return the character at the given cursor offset. The offset is relative
   * to the cursor, so negative values move backwards.
   *
   * @param {Number} [offset=1] Cursor offset.
   * @returns {String} Character.
   */
  function peek(offset) {
    return css[cursor + (offset || 1)];
  }

  /**
   * Remove the current state from the stack and set the new current state.
   *
   * @returns {String} The removed state.
   */
  function popState() {
    var removed = stack.pop();
    state = stack[stack.length - 1];

    return removed;
  }

  /**
   * Set the current state and add it to the stack.
   *
   * @param {String} newState The new state.
   * @returns {Number} The new stack length.
   */
  function pushState(newState) {
    state = newState;
    stack.push(state);

    return stack.length;
  }

  /**
   * Replace the current state with a new state.
   *
   * @param {String} newState The new state.
   * @returns {String} The replaced state.
   */
  function replaceState(newState) {
    var previousState = state;
    stack[stack.length - 1] = state = newState;

    return previousState;
  }

  /**
   * Move the character cursor. Positive numbers move the cursor forward.
   * Negative numbers are not supported!
   *
   * @param {Number} [n=1] Number of characters to skip.
   */
  function skip(n) {
    if ((n || 1) == 1) {
      if (css[cursor] == '\n') {
        line++;
        column = 1;
      } else {
        column++;
      }
      cursor++;
    } else {
      var skipStr = css.slice(cursor, cursor + n).split('\n');
      if (skipStr.length > 1) {
        line += skipStr.length - 1;
        column = 1;
      }
      column += skipStr[skipStr.length - 1].length;
      cursor = cursor + n;
    }
  }

  /**
   * Add the current token to the pile and reset the buffer.
   */
  function addToken() {
    token.end = {
      line: line,
      col: column
    };

    DEBUG && debug('addToken:', JSON.stringify(token, null, 2));

    tokens.push(token);

    buffer = '';
    token = {};
  }

  /**
   * Set the current token.
   *
   * @param {String} type Token type.
   */
  function initializeToken(type) {
    token = {
      type: type,
      start: {
        line: line,
        col : column
      }
    };
  }

  // -- Main Loop ------------------------------------------------------------

  /*
  The main loop is a state machine that reads in one character at a time,
  and determines what to do based on the current state and character.
  This is implemented as a series of nested `switch` statements and the
  case orders have been mildly optimized based on rough probabilities
  calculated by processing a small sample of real-world CSS.

  Further optimization (such as a dispatch table) shouldn't be necessary
  since the total number of cases is very low.
  */

  TIMER && (start = Date.now());

  while (ch = getCh()) {
    DEBUG && debug(ch, getState());

    // column += 1;

    switch (ch) {
    // Space
    case ' ':
      switch (getState()) {
      case 'selector':
      case 'value':
      case 'value-paren':
      case 'at-group':
      case 'at-value':
      case 'comment':
      case 'double-string':
      case 'single-string':
        buffer += ch;
        break;
      }
      break;

    // Newline or tab
    case '\n':
    case '\t':
    case '\r':
    case '\f':
      switch (getState()) {
      case 'value':
      case 'value-paren':
      case 'at-group':
      case 'comment':
      case 'single-string':
      case 'double-string':
      case 'selector':
        buffer += ch;
        break;

      case 'at-value':
        // Tokenize an @-rule if a semi-colon was omitted.
        if ('\n' === ch) {
          token.value = buffer.trim();
          addToken();
          popState();
        }
        break;
      }

      // if ('\n' === ch) {
      //   column = 0;
      //   line += 1;
      // }
      break;

    case ':':
      switch (getState()) {
      case 'name':
        token.name = buffer.trim();
        buffer = '';

        replaceState('before-value');
        break;

      case 'before-selector':
        buffer += ch;

        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        buffer += ch;
        break;
      }
      break;

    case ';':
      switch (getState()) {
      case 'name':
      case 'before-value':
      case 'value':
        // Tokenize a declaration
        // if value is empty skip the declaration
        if (buffer.trim().length > 0) {
          token.value = buffer.trim(),
          addToken();
        }
        replaceState('before-name');
        break;

      case 'value-paren':
        // Insignificant semi-colon
        buffer += ch;
        break;

      case 'at-value':
        // Tokenize an @-rule
        token.value = buffer.trim();
        addToken();
        popState();
        break;

      case 'before-name':
        // Extraneous semi-colon
        break;

      default:
        buffer += ch;
        break;
      }
      break;

    case '{':
      switch (getState()) {
      case 'selector':
        // If the sequence is `\{` then assume that the brace should be escaped.
        if (peek(-1) === '\\') {
            buffer += ch;
            break;
        }

        // Tokenize a selector
        token.text = buffer.trim();
        addToken();
        replaceState('before-name');
        depth = depth + 1;
        break;

      case 'at-group':
        // Tokenize an @-group
        token.name = buffer.trim();

        // XXX: @-rules are starting to get hairy
        switch (token.type) {
        case 'font-face':
        case 'viewport' :
        case 'page'     :
          pushState('before-name');
          break;

        default:
          pushState('before-selector');
        }

        addToken();
        depth = depth + 1;
        break;

      case 'name':
      case 'at-rule':
        // Tokenize a declaration or an @-rule
        token.name = buffer.trim();
        addToken();
        pushState('before-name');
        depth = depth + 1;
        break;

      case 'comment':
      case 'double-string':
      case 'single-string':
        // Ignore braces in comments and strings
        buffer += ch;
        break;
      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;
      }

      break;

    case '}':
      switch (getState()) {
      case 'before-name':
      case 'name':
      case 'before-value':
      case 'value':
        // If the buffer contains anything, it is a value
        if (buffer) {
          token.value = buffer.trim();
        }

        // If the current token has a name and a value it should be tokenized.
        if (token.name && token.value) {
          addToken();
        }

        // Leave the block
        initializeToken('end');
        addToken();
        popState();

        // We might need to leave again.
        // XXX: What about 3 levels deep?
        if ('at-group' === getState()) {
          initializeToken('at-group-end');
          addToken();
          popState();
        }
        
        if (depth > 0) {
          depth = depth - 1;
        }

        break;

      case 'at-group':
      case 'before-selector':
      case 'selector':
        // If the sequence is `\}` then assume that the brace should be escaped.
        if (peek(-1) === '\\') {
            buffer += ch;
            break;
        }

        if (depth > 0) {
          // Leave block if in an at-group
          if ('at-group' === getState(1)) {
            initializeToken('at-group-end');
            addToken();
          }
        }

        if (depth > 1) {
          popState();
        }

        if (depth > 0) {
          depth = depth - 1;
        }
        break;

      case 'double-string':
      case 'single-string':
      case 'comment':
        // Ignore braces in comments and strings.
        buffer += ch;
        break;
      }

      break;

    // Strings
    case '"':
    case "'":
      switch (getState()) {
      case 'double-string':
        if ('"' === ch && '\\' !== peek(-1)) {
          popState();
        }
        break;

      case 'single-string':
        if ("'" === ch && '\\' !== peek(-1)) {
          popState();
        }
        break;

      case 'before-at-value':
        replaceState('at-value');
        pushState('"' === ch ? 'double-string' : 'single-string');
        break;

      case 'before-value':
        replaceState('value');
        pushState('"' === ch ? 'double-string' : 'single-string');
        break;

      case 'comment':
        // Ignore strings within comments.
        break;

      default:
        if ('\\' !== peek(-1)) {
          pushState('"' === ch ? 'double-string' : 'single-string');
        }
      }

      buffer += ch;
      break;

    // Comments
    case '/':
      switch (getState()) {
      case 'comment':
      case 'double-string':
      case 'single-string':
        // Ignore
        buffer += ch;
        break;

      case 'before-value':
      case 'selector':
      case 'name':
      case 'value':
        if (isNextChar('*')) {
          // Ignore comments in selectors, properties and values. They are
          // difficult to represent in the AST.
          var pos = find('*/');

          if (pos) {
            skip(pos + 1);
          }
        } else {
          if (getState() == 'before-value') replaceState('value');
          buffer += ch;
        }
        break;

      default:
        if (isNextChar('*')) {
          // Create a comment token
          initializeToken('comment');
          pushState('comment');
          skip();
        }
        else {
          buffer += ch;
        }
        break;
      }
      break;

    // Comment end or universal selector
    case '*':
      switch (getState()) {
      case 'comment':
        if (isNextChar('/')) {
          // Tokenize a comment
          token.text = buffer; // Don't trim()!
          skip();
          addToken();
          popState();
        }
        else {
          buffer += ch;
        }
        break;

      case 'before-selector':
        buffer += ch;
        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        buffer += ch;
      }
      break;

    // @-rules
    case '@':
      switch (getState()) {
      case 'comment':
      case 'double-string':
      case 'single-string':
        buffer += ch;
        break;
      case 'before-value':
        replaceState('value');
        buffer += ch;
        break;

      default:
        // Iterate over the supported @-rules and attempt to tokenize one.
        var tokenized = false;
        var name;
        var rule;

        for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {
          rule = atRules[j];
          name = rule.name || rule;

          if (!isNextString(name)) { continue; }

          tokenized = true;

          initializeToken(name);
          pushState(rule.state || 'at-group');
          skip(name.length);

          if (rule.prefix) {
            token.prefix = rule.prefix;
          }

          if (rule.type) {
            token.type = rule.type;
          }
        }

        if (!tokenized) {
          // Keep on truckin' America!
          buffer += ch;
        }
        break;
      }
      break;

    // Parentheses are tracked to disambiguate semi-colons, such as within a
    // data URI.
    case '(':
      switch (getState()) {
      case 'value':
        pushState('value-paren');
        break;
      case 'before-value':
        replaceState('value');
        break;
      }

      buffer += ch;
      break;

    case ')':
      switch (getState()) {
      case 'value-paren':
        popState();
        break;
      case 'before-value':
        replaceState('value');
        break;
      }

      buffer += ch;
      break;

    default:
      switch (getState()) {
      case 'before-selector':
        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-name':
        initializeToken('property');
        replaceState('name');
        break;

      case 'before-value':
        replaceState('value');
        break;

      case 'before-at-value':
        replaceState('at-value');
        break;
      }

      buffer += ch;
      break;
    }
  }

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return tokens;
}

},{"./debug":13}],15:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `parse()` and print the results.

var debug = require('./debug')('parse');
var lex = require('./lexer');

exports = module.exports = parse;

var _comments;   // Whether comments are allowed.
var _depth;      // Current block nesting depth.
var _position;   // Whether to include line/column position.
var _tokens;     // Array of lexical tokens.

/**
 * Convert a CSS string or array of lexical tokens into a `stringify`-able AST.
 *
 * @param {String} css CSS string or array of lexical token
 * @param {Object} [options]
 * @param {Boolean} [options.comments=false] allow comment nodes in the AST
 * @returns {Object} `stringify`-able AST
 */
function parse(css, options) {
  var start; // Debug timer start.

  options || (options = {});
  _comments = !!options.comments;
  _position = !!options.position;

  _depth = 0;

  // Operate on a copy of the given tokens, or the lex()'d CSS string.
  _tokens = Array.isArray(css) ? css.slice() : lex(css);

  var rule;
  var rules = [];
  var token;

  TIMER && (start = Date.now());

  while ((token = next())) {
    rule = parseToken(token);
    rule && rules.push(rule);
  }

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return {
    type: "stylesheet",
    stylesheet: {
      rules: rules
    }
  };
}

// -- Functions --------------------------------------------------------------

/**
 * Build an AST node from a lexical token.
 *
 * @param {Object} token lexical token
 * @param {Object} [override] object hash of properties that override those
 *   already in the token, or that will be added to the token.
 * @returns {Object} AST node
 */
function astNode(token, override) {
  override || (override = {});

  var key;
  var keys = ['type', 'name', 'value'];
  var node = {};

  // Avoiding [].forEach for performance reasons.
  for (var i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (token[key]) {
      node[key] = override[key] || token[key];
    }
  }

  keys = Object.keys(override);

  for (i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (!node[key]) {
      node[key] = override[key];
    }
  }

  if (_position) {
    node.position = {
      start: token.start,
      end: token.end
    };
  }

  DEBUG && debug('astNode:', JSON.stringify(node, null, 2));

  return node;
}

/**
 * Remove a lexical token from the stack and return the removed token.
 *
 * @returns {Object} lexical token
 */
function next() {
  var token = _tokens.shift();
  DEBUG && debug('next:', JSON.stringify(token, null, 2));
  return token;
}

// -- Parse* Functions ---------------------------------------------------------

/**
 * Convert an @-group lexical token to an AST node.
 *
 * @param {Object} token @-group lexical token
 * @returns {Object} @-group AST node
 */
function parseAtGroup(token) {
  _depth = _depth + 1;

  // As the @-group token is assembled, relevant token values are captured here
  // temporarily. They will later be used as `tokenize()` overrides.
  var overrides = {};

  switch (token.type) {
  case 'font-face':
  case 'viewport' :
    overrides.declarations = parseDeclarations();
    break;

  case 'page':
    overrides.prefix = token.prefix;
    overrides.declarations = parseDeclarations();
    break;

  default:
    overrides.prefix = token.prefix;
    overrides.rules = parseRules();
  }

  return astNode(token, overrides);
}

/**
 * Convert an @import lexical token to an AST node.
 *
 * @param {Object} token @import lexical token
 * @returns {Object} @import AST node
 */
function parseAtImport(token) {
  return astNode(token);
}

/**
 * Convert an @charset token to an AST node.
 *
 * @param {Object} token @charset lexical token
 * @returns {Object} @charset node
 */
function parseCharset(token) {
  return astNode(token);
}

/**
 * Convert a comment token to an AST Node.
 *
 * @param {Object} token comment lexical token
 * @returns {Object} comment node
 */
function parseComment(token) {
  return astNode(token, {text: token.text});
}

function parseNamespace(token) {
  return astNode(token);
}

/**
 * Convert a property lexical token to a property AST node.
 *
 * @returns {Object} property node
 */
function parseProperty(token) {
  return astNode(token);
}

/**
 * Convert a selector lexical token to a selector AST node.
 *
 * @param {Object} token selector lexical token
 * @returns {Object} selector node
 */
function parseSelector(token) {
  function trim(str) {
    return str.trim();
  }

  return astNode(token, {
    type: 'rule',
    selectors: token.text.split(',').map(trim),
    declarations: parseDeclarations(token)
  });
}

/**
 * Convert a lexical token to an AST node.
 *
 * @returns {Object|undefined} AST node
 */
function parseToken(token) {
  switch (token.type) {
  // Cases are listed in roughly descending order of probability.
  case 'property': return parseProperty(token);

  case 'selector': return parseSelector(token);

  case 'at-group-end': _depth = _depth - 1; return;

  case 'media'     :
  case 'keyframes' :return parseAtGroup(token);

  case 'comment': if (_comments) { return parseComment(token); } break;

  case 'charset': return parseCharset(token);
  case 'import': return parseAtImport(token);

  case 'namespace': return parseNamespace(token);

  case 'font-face':
  case 'supports' :
  case 'viewport' :
  case 'document' :
  case 'page'     : return parseAtGroup(token);
  }

  DEBUG && debug('parseToken: unexpected token:', JSON.stringify(token));
}

// -- Parse Helper Functions ---------------------------------------------------

/**
 * Iteratively parses lexical tokens from the stack into AST nodes until a
 * conditional function returns `false`, at which point iteration terminates
 * and any AST nodes collected are returned.
 *
 * @param {Function} conditionFn
 *   @param {Object} token the lexical token being parsed
 *   @returns {Boolean} `true` if the token should be parsed, `false` otherwise
 * @return {Array} AST nodes
 */
function parseTokensWhile(conditionFn) {
  var node;
  var nodes = [];
  var token;

  while ((token = next()) && (conditionFn && conditionFn(token))) {
    node = parseToken(token);
    node && nodes.push(node);
  }

  // Place an unused non-`end` lexical token back onto the stack.
  if (token && token.type !== 'end') {
    _tokens.unshift(token);
  }

  return nodes;
}

/**
 * Convert a series of tokens into a sequence of declaration AST nodes.
 *
 * @returns {Array} declaration nodes
 */
function parseDeclarations() {
  return parseTokensWhile(function (token) {
    return (token.type === 'property' || token.type === 'comment');
  });
}

/**
 * Convert a series of tokens into a sequence of rule nodes.
 *
 * @returns {Array} rule nodes
 */
function parseRules() {
  return parseTokensWhile(function () { return _depth; });
}

},{"./debug":13,"./lexer":14}],16:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `stringify()` and print the results.

var debug = require('./debug')('stringify');

var _comments;      // Whether comments are allowed in the stringified CSS.
var _compress;      // Whether the stringified CSS should be compressed.
var _indentation;   // Indentation option value.
var _n;             // Compression-aware newline character.
var _s;             // Compression-aware space character.

exports = module.exports = stringify;

/**
 * Convert a `stringify`-able AST into a CSS string.
 *
 * @param {Object} `stringify`-able AST
 * @param {Object} [options]
 * @param {Boolean} [options.comments=false] allow comments in the CSS
 * @param {Boolean} [options.compress=false] compress whitespace
 * @param {String} [options.indentation=''] indentation sequence
 * @returns {String} CSS
 */
function stringify(ast, options) {
  var start; // Debug timer start.

  options || (options = {});
  _indentation = options.indentation || '';
  _compress = !!options.compress;
  _comments = !!options.comments;

  if (_compress) {
    _n = _s = '';
  } else {
    _n = '\n';
    _s = ' ';
  }

  TIMER && (start = Date.now());

  var css = reduce(ast.stylesheet.rules, stringifyNode).join('\n').trim();

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return css;
}

// -- Functions --------------------------------------------------------------

/**
 * Modify the indentation level, or return a compression-aware sequence of
 * spaces equal to the current indentation level.
 *
 * @param {Number} [level=undefined] indentation level modifier
 * @returns {String} sequence of spaces
 */
function indent(level) {
  this.level || (this.level = 1);

  if (level) {
    this.level += level;
    return;
  }

  if (_compress) { return ''; }

  return Array(this.level).join(_indentation || '');
}

// -- Stringify Functions ------------------------------------------------------

/**
 * Stringify an @-rule AST node.
 *
 * Use `stringifyAtGroup()` when dealing with @-groups that may contain blocks
 * such as @media.
 *
 * @param {String} type @-rule type. E.g., import, charset
 * @returns {String} Stringified @-rule
 */
function stringifyAtRule(node) {
  return '@' + node.type + ' ' + node.value + ';' + _n;
}

/**
 * Stringify an @-group AST node.
 *
 * Use `stringifyAtRule()` when dealing with @-rules that may not contain blocks
 * such as @import.
 *
 * @param {Object} node @-group AST node
 * @returns {String}
 */
function stringifyAtGroup(node) {
  var label = '';
  var prefix = node.prefix || '';

  if (node.name) {
    label = ' ' + node.name;
  }

  // FIXME: @-rule conditional logic is leaking everywhere.
  var chomp = node.type !== 'page';

  return '@' + prefix + node.type + label + _s + stringifyBlock(node, chomp) + _n;
}

/**
 * Stringify a comment AST node.
 *
 * @param {Object} node comment AST node
 * @returns {String}
 */
function stringifyComment(node) {
  if (!_comments) { return ''; }

  return '/*' + (node.text || '') + '*/' + _n;
}

/**
 * Stringify a rule AST node.
 *
 * @param {Object} node rule AST node
 * @returns {String}
 */
function stringifyRule(node) {
  var label;

  if (node.selectors) {
    label = node.selectors.join(',' + _n);
  } else {
    label = '@' + node.type;
    label += node.name ? ' ' + node.name : '';
  }

  return indent() + label + _s + stringifyBlock(node) + _n;
}


// -- Stringify Helper Functions -----------------------------------------------

/**
 * Reduce an array by applying a function to each item and retaining the truthy
 * results.
 *
 * When `item.type` is `'comment'` `stringifyComment` will be applied instead.
 *
 * @param {Array} items array to reduce
 * @param {Function} fn function to call for each item in the array
 *   @returns {Mixed} Truthy values will be retained, falsy values omitted
 * @returns {Array} retained results
 */
function reduce(items, fn) {
  return items.reduce(function (results, item) {
    var result = (item.type === 'comment') ? stringifyComment(item) : fn(item);
    result && results.push(result);
    return results;
  }, []);
}

/**
 * Stringify an AST node with the assumption that it represents a block of
 * declarations or other @-group contents.
 *
 * @param {Object} node AST node
 * @returns {String}
 */
// FIXME: chomp should not be a magic boolean parameter
function stringifyBlock(node, chomp) {
  var children = node.declarations;
  var fn = stringifyDeclaration;

  if (node.rules) {
    children = node.rules;
    fn = stringifyRule;
  }

  children = stringifyChildren(children, fn);
  children && (children = _n + children + (chomp ? '' : _n));

  return '{' + children + indent() + '}';
}

/**
 * Stringify an array of child AST nodes by calling the given stringify function
 * once for each child, and concatenating the results.
 *
 * @param {Array} children `node.rules` or `node.declarations`
 * @param {Function} fn stringify function
 * @returns {String}
 */
function stringifyChildren(children, fn) {
  if (!children) { return ''; }

  indent(1);
  var results = reduce(children, fn);
  indent(-1);

  if (!results.length) { return ''; }

  return results.join(_n);
}

/**
 * Stringify a declaration AST node.
 *
 * @param {Object} node declaration AST node
 * @returns {String}
 */
function stringifyDeclaration(node) {
  if (node.type === 'property') {
    return stringifyProperty(node);
  }

  DEBUG && debug('stringifyDeclaration: unexpected node:', JSON.stringify(node));
}

/**
 * Stringify an AST node.
 *
 * @param {Object} node AST node
 * @returns {String}
 */
function stringifyNode(node) {
  switch (node.type) {
  // Cases are listed in roughly descending order of probability.
  case 'rule': return stringifyRule(node);

  case 'media'    :
  case 'keyframes': return stringifyAtGroup(node);

  case 'comment': return stringifyComment(node);

  case 'import'   :
  case 'charset'  :
  case 'namespace': return stringifyAtRule(node);

  case 'font-face':
  case 'supports' :
  case 'viewport' :
  case 'document' :
  case 'page'     : return stringifyAtGroup(node);
  }

  DEBUG && debug('stringifyNode: unexpected node: ' + JSON.stringify(node));
}

/**
 * Stringify an AST property node.
 *
 * @param {Object} node AST property node
 * @returns {String}
 */
function stringifyProperty(node) {
  var name = node.name ? node.name + ':' + _s : '';

  return indent() + name + node.value + ';';
}

},{"./debug":13}],17:[function(require,module,exports){
/*!
* slick.js
* v1.0.1 - 2013-12-20
* https://github.com/shashankmehta/slick.js
* (c) Shashank Mehta; MIT License
*/
/*global jQuery */
(function ($, root) {
    'use strict';

    $.fn.exists = function () {
        return this.length !== 0;
    };

    var Slick = function (container, config) {
        this.options = {
            source: undefined,
            start: undefined,
            end: undefined,
            keyControl: true,
            content: undefined,
            theme: {
                container: container,
                content: '.slick-content',
                currentNo: '.current-no',
                totalNo: '.total',
                next: '.next',
                prev: '.prev',
            }
        };

        for (var option in this.options) {
            if (this.options.hasOwnProperty(option) && option !== 'theme') {
                this.options[option] = config[option] !== undefined ? config[option] : this.options[option];
            }
        }

        if(config.theme !== undefined){
            for (var val in this.options.theme) {
                if (this.options.theme.hasOwnProperty(val)) {
                    this.options.theme[val] = config.theme[val] !== undefined ? config.theme[val] : this.options.theme[val];
                }
            }
        }

        this.options.content = this.options.theme.container + ' ' + this.options.theme.content;

        this.state = {
            // Stores slide url no that is visible
            current: this.options.start-1,
            
            start: this.options.start,
            end: this.options.end,

            // Stores values that is shown in controls
            slide: {
                current: 0,
                difference: (this.options.start - 1),
                total: (this.options.end - this.options.start + 1),
                maxHit: 0
            }
        };
        
        this.init.apply(this);
    };

    var SlickProto = Slick.prototype;

    SlickProto.hooks = {

        // Main function for handling next/forwarding of slides
        next: function() {
            var slick = this;

            if(slick.state.slide.current < slick.state.slide.total){
                var step = ++slick.state.slide.current + slick.state.slide.difference;
                slick.hooks.setSlide.apply(this, [step]);
            }
        },

        // Main function for handling going backward
        prev: function(){
            var slick = this;

            if(slick.state.slide.current > 1){
                var step = --slick.state.slide.current + slick.state.slide.difference;
                slick.hooks.setSlide.apply(this, [step]);
            }
        },

        setSlide: function(step){
            var slick = this;
            var slideStatus = slick.hooks.slideStatus.apply(slick, [step]);
            slick.state.slide.current = step - slick.state.slide.difference;

            if(slick.state.slide.current === 1){
                $(slick.options.theme.container).animate({'opacity': '1'}, 500);
            }

            if($(slick.options.theme.container + ' .skip' + slick.options.theme.currentNo).is(':input')){
                $(slick.options.theme.container + ' ' + slick.options.theme.currentNo).val(slick.state.slide.current);
            }
            else {
                $(slick.options.theme.container + ' .skip').val(slick.state.slide.current);
                $(slick.options.theme.container + ' ' + slick.options.theme.currentNo).html(slick.state.slide.current);
            }

            
            if(slideStatus === 1){
                $(slick.options.content + ' img.current').removeClass('current').addClass('cached-slide').hide();
                $(slick.options.content + ' img[data-slide=' + step + ']').removeClass('cached-slide').addClass('current').show();
                slick.state.current = step;
                $(slick.options.theme.container + ' .length').width(100 * slick.state.slide.current / slick.state.slide.total + '%');
                slick.hooks.getSlide.apply(slick, [step+1]);
                return;
            }
            else if(slideStatus === 2){
                slick.hooks.slideSwitch.apply(this, [step]);
            }
            else if(slideStatus === 0){
                // Removing on load from all previous still loading images 
                $(slick.options.content + ' img.loading').off('load.slideSwitch').remove();
                slick.hooks.getSlide.apply(slick, [step]);
                slick.hooks.slideSwitch.apply(this, [step]);
            }
        },

        // Gets the slide for the step
        getSlide: function(step){
            var slick = this;
            if(slick.hooks.slideStatus.apply(this, [step]) === 0 && step <= slick.state.end){
                $(slick.options.content).append('<img src="'+ slick.hooks.imagePath.apply(slick, [step]) +'" data-slide=' + step + ' class="loading">');
                $(slick.options.content + ' img.loading').hide();
                $(slick.options.content + ' img.loading').load(function(){
                    $(this).removeClass('loading').addClass('cached-slide');
                });
            }
        },

        slideSwitch: function(step){
            var slick = this;
            $(slick.options.content + ' img[data-slide=' + step + ']').on('load.slideSwitch', function(){
                $(slick.options.content + ' img.current').removeClass('current').addClass('cached-slide').hide();
                $(this).removeClass('cached-slide').addClass('current').show();
                slick.state.current = step;
                $(slick.options.theme.container + ' .length').width(100 * (step + 1) / slick.state.slide.total + '%');
                slick.hooks.getSlide.apply(slick, [step+1]);
            });
        },

        // Returns the status of a slide
        // 0: Not requested yet
        // 1: cached
        // 2: loading
        slideStatus: function(step){
            var slick = this;
            var el = slick.options.content + ' img[data-slide=' + step + ']';
            if($(el).exists()){
                if($(el).hasClass('loading')){
                    return 2;
                }
                else {
                    return 1;
                }
            }
            else {
                return 0;
            }
        },

        // Returns the path with the current no inserted
        imagePath: function(step){
            var parts = this.options.source.split('*');
            return parts[0] + step + parts[1];
        },

        skip: function(val){
            if($.isNumeric(val)){
                var slick = this;

                var step = parseInt(val) + slick.state.slide.difference;
                slick.hooks.getSlide.apply(slick, [step]);
                slick.hooks.setSlide.apply(slick, [step]);
            }
        }

    };

    SlickProto.init = function(){
        var slick = this;

        $(slick.options.theme.container).css('opacity', '0');

        // Sets the first slide
        if(typeof slick.options.source === 'string'){
            slick.hooks.next.apply(slick);
        }

        // Attaches event listeners for next/prev buttons
        $(slick.options.theme.container + ' ' + slick.options.theme.next).click(function(e){
            e.preventDefault();
            slick.hooks.next.apply(slick);
        });
        $(slick.options.theme.container + ' ' + slick.options.theme.prev).click(function(e){
            e.preventDefault();
            slick.hooks.prev.apply(slick);
        });
        $(slick.options.theme.container + ' ' + slick.options.theme.totalNo).html(slick.state.end - slick.state.start + 1);

        // Ataches keyboard control
        if(slick.options.keyControl){
            $(document).keyup(function(e) {
                if ((e.keyCode ===  39) && !$('input:focus').exists()) {
                    slick.hooks.next.apply(slick);
                }
                if ((e.keyCode ===  37) && !$('input:focus').exists()) {
                    slick.hooks.prev.apply(slick);
                }
            });
        }
        
        $(slick.options.theme.container + ' .skip').keypress(function(e){
            if(e.keyCode === 13){
                slick.hooks.skip.apply(slick, [$(this).val()]);
                $(this).blur();
            }
        });
    };

    window.Slick = Slick;

    // Exposing programmatic access
    Slick.next = function(slick){
        if(slick.constructor === Slick){
            slick.hooks.next.apply(slick);
        }
    };

    Slick.prev = function(slick){
        if(slick.constructor === Slick){
            slick.hooks.prev.apply(slick);
        }
    };

    Slick.skip = function(slick, step){
        if(slick.constructor === Slick){
            slick.hooks.skip.apply(slick, [step]);
        }
    };

}(jQuery, window));
},{}],18:[function(require,module,exports){
// TinyColor v1.2.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function() {

var trimLeft = /^[\s,#]+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    math = Math,
    mathRound = math.round,
    mathMin = math.min,
    mathMax = math.max,
    mathRandom = math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function() {
        return rgbaToHex(this._r, this._g, this._b, this._a);
    },
    toHex8String: function() {
        return '#' + this.toHex8();
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = s.toHex8String();
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
            color.s = convertToPercentage(color.s);
            color.v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, color.s, color.v);
            ok = true;
            format = "hsv";
        }
        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
            color.s = convertToPercentage(color.s);
            color.l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, color.s, color.l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b and a are contained in the set [0, 255]
// Returns an 8 character hex
function rgbaToHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (mathRound(hsl.h) + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;
    var w = p * 2 - 1;
    var a = rgb2.a - rgb1.a;

    var w1;

    if (w * a == -1) {
        w1 = w;
    } else {
        w1 = (w + a) / (1 + w * a);
    }

    w1 = (w1 + 1) / 2;

    var w2 = 1 - w1;

    var rgba = {
        r: rgb2.r * w1 + rgb1.r * w2,
        g: rgb2.g * w1 + rgb1.g * w2,
        b: rgb2.b * w1 + rgb1.b * w2,
        a: rgb2.a * p  + rgb1.a * (1 - p)
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            a: convertHexToDecimal(match[1]),
            r: parseIntFromHex(match[2]),
            g: parseIntFromHex(match[3]),
            b: parseIntFromHex(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})();

},{}],19:[function(require,module,exports){
(function (global){
/*
 * Toastr
 * Copyright 2012-2015
 * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * ARIA Support: Greta Krafsig
 *
 * Project: https://github.com/CodeSeven/toastr
 */
/* global define */
; (function (define) {
    define(['jquery'], function ($) {
        return (function () {
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: 'error',
                info: 'info',
                success: 'success',
                warning: 'warning'
            };

            var toastr = {
                clear: clear,
                remove: remove,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {},
                subscribe: subscribe,
                success: success,
                version: '2.1.2',
                warning: warning
            };

            var previousToast;

            return toastr;

            ////////////////

            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function getContainer(options, create) {
                if (!options) { options = getOptions(); }
                $container = $('#' + options.containerId);
                if ($container.length) {
                    return $container;
                }
                if (create) {
                    $container = createContainer(options);
                }
                return $container;
            }

            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function subscribe(callback) {
                listener = callback;
            }

            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function clear($toastElement, clearOptions) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if (!clearToast($toastElement, options, clearOptions)) {
                    clearContainer(options);
                }
            }

            function remove($toastElement) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if ($toastElement && $(':focus', $toastElement).length === 0) {
                    removeToast($toastElement);
                    return;
                }
                if ($container.children().length) {
                    $container.remove();
                }
            }

            // internal functions

            function clearContainer (options) {
                var toastsToClear = $container.children();
                for (var i = toastsToClear.length - 1; i >= 0; i--) {
                    clearToast($(toastsToClear[i]), options);
                }
            }

            function clearToast ($toastElement, options, clearOptions) {
                var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function () { removeToast($toastElement); }
                    });
                    return true;
                }
                return false;
            }

            function createContainer(options) {
                $container = $('<div/>')
                    .attr('id', options.containerId)
                    .addClass(options.positionClass)
                    .attr('aria-live', 'polite')
                    .attr('role', 'alert');

                $container.appendTo($(options.target));
                return $container;
            }

            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: 'toast',
                    containerId: 'toast-container',
                    debug: false,

                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                    showDuration: 300,
                    showEasing: 'swing', //swing and linear are built into jQuery
                    onShown: undefined,
                    hideMethod: 'fadeOut',
                    hideDuration: 1000,
                    hideEasing: 'swing',
                    onHidden: undefined,
                    closeMethod: false,
                    closeDuration: false,
                    closeEasing: false,

                    extendedTimeOut: 1000,
                    iconClasses: {
                        error: 'toast-error',
                        info: 'toast-info',
                        success: 'toast-success',
                        warning: 'toast-warning'
                    },
                    iconClass: 'toast-info',
                    positionClass: 'toast-top-right',
                    timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                    titleClass: 'toast-title',
                    messageClass: 'toast-message',
                    escapeHtml: false,
                    target: 'body',
                    closeHtml: '<button type="button">&times;</button>',
                    newestOnTop: true,
                    preventDuplicates: false,
                    progressBar: false
                };
            }

            function publish(args) {
                if (!listener) { return; }
                listener(args);
            }

            function notify(map) {
                var options = getOptions();
                var iconClass = map.iconClass || options.iconClass;

                if (typeof (map.optionsOverride) !== 'undefined') {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }

                if (shouldExit(options, map)) { return; }

                toastId++;

                $container = getContainer(options, true);

                var intervalId = null;
                var $toastElement = $('<div/>');
                var $titleElement = $('<div/>');
                var $messageElement = $('<div/>');
                var $progressElement = $('<div/>');
                var $closeElement = $(options.closeHtml);
                var progressBar = {
                    intervalId: null,
                    hideEta: null,
                    maxHideTime: null
                };
                var response = {
                    toastId: toastId,
                    state: 'visible',
                    startTime: new Date(),
                    options: options,
                    map: map
                };

                personalizeToast();

                displayToast();

                handleEvents();

                publish(response);

                if (options.debug && console) {
                    console.log(response);
                }

                return $toastElement;

                function escapeHtml(source) {
                    if (source == null)
                        source = "";

                    return new String(source)
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }

                function personalizeToast() {
                    setIcon();
                    setTitle();
                    setMessage();
                    setCloseButton();
                    setProgressBar();
                    setSequence();
                }

                function handleEvents() {
                    $toastElement.hover(stickAround, delayedHideToast);
                    if (!options.onclick && options.tapToDismiss) {
                        $toastElement.click(hideToast);
                    }

                    if (options.closeButton && $closeElement) {
                        $closeElement.click(function (event) {
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                event.cancelBubble = true;
                            }
                            hideToast(true);
                        });
                    }

                    if (options.onclick) {
                        $toastElement.click(function (event) {
                            options.onclick(event);
                            hideToast();
                        });
                    }
                }

                function displayToast() {
                    $toastElement.hide();

                    $toastElement[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                    );

                    if (options.timeOut > 0) {
                        intervalId = setTimeout(hideToast, options.timeOut);
                        progressBar.maxHideTime = parseFloat(options.timeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        if (options.progressBar) {
                            progressBar.intervalId = setInterval(updateProgress, 10);
                        }
                    }
                }

                function setIcon() {
                    if (map.iconClass) {
                        $toastElement.addClass(options.toastClass).addClass(iconClass);
                    }
                }

                function setSequence() {
                    if (options.newestOnTop) {
                        $container.prepend($toastElement);
                    } else {
                        $container.append($toastElement);
                    }
                }

                function setTitle() {
                    if (map.title) {
                        $titleElement.append(!options.escapeHtml ? map.title : escapeHtml(map.title)).addClass(options.titleClass);
                        $toastElement.append($titleElement);
                    }
                }

                function setMessage() {
                    if (map.message) {
                        $messageElement.append(!options.escapeHtml ? map.message : escapeHtml(map.message)).addClass(options.messageClass);
                        $toastElement.append($messageElement);
                    }
                }

                function setCloseButton() {
                    if (options.closeButton) {
                        $closeElement.addClass('toast-close-button').attr('role', 'button');
                        $toastElement.prepend($closeElement);
                    }
                }

                function setProgressBar() {
                    if (options.progressBar) {
                        $progressElement.addClass('toast-progress');
                        $toastElement.prepend($progressElement);
                    }
                }

                function shouldExit(options, map) {
                    if (options.preventDuplicates) {
                        if (map.message === previousToast) {
                            return true;
                        } else {
                            previousToast = map.message;
                        }
                    }
                    return false;
                }

                function hideToast(override) {
                    var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                    var duration = override && options.closeDuration !== false ?
                        options.closeDuration : options.hideDuration;
                    var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                    if ($(':focus', $toastElement).length && !override) {
                        return;
                    }
                    clearTimeout(progressBar.intervalId);
                    return $toastElement[method]({
                        duration: duration,
                        easing: easing,
                        complete: function () {
                            removeToast($toastElement);
                            if (options.onHidden && response.state !== 'hidden') {
                                options.onHidden();
                            }
                            response.state = 'hidden';
                            response.endTime = new Date();
                            publish(response);
                        }
                    });
                }

                function delayedHideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                        progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                    }
                }

                function stickAround() {
                    clearTimeout(intervalId);
                    progressBar.hideEta = 0;
                    $toastElement.stop(true, true)[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing}
                    );
                }

                function updateProgress() {
                    var percentage = ((progressBar.hideEta - (new Date().getTime())) / progressBar.maxHideTime) * 100;
                    $progressElement.width(percentage + '%');
                }
            }

            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }

            function removeToast($toastElement) {
                if (!$container) { $container = getContainer(); }
                if ($toastElement.is(':visible')) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                    previousToast = undefined;
                }
            }

        })();
    });
}(typeof define === 'function' && define.amd ? define : function (deps, factory) {
    if (typeof module !== 'undefined' && module.exports) { //Node
        module.exports = factory((typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null));
    } else {
        window.toastr = factory(window.jQuery);
    }
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
var templateSystem = require('../src/js/bindings/choose-template.js');
document.addEventListener('DOMContentLoaded', function(event) {
  templateSystem.addTemplate("array", "<!-- ko foreach: $data --><!-- ko block: $data --><!-- /ko --><!-- /ko -->");
  templateSystem.addTemplate("block-show", "<!-- ko block: $data, scrollIntoView: $root.selectedBlock() === $data --><!-- /ko -->");
  templateSystem.addTemplate("block-wysiwyg", "<div class=\x22editable block\x22 data-drop-content=\x22Drop here\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here') }, click: function(obj, evt) { $root.selectBlock(obj); return true }, clickBubble: false, css: { selected: $root.selectedBlock() === $data }, scrollIntoView: $root.selectedBlock() === $data\x22>  <div class=\x22mo-blockselectionhelper\x22></div>  <div class=\x22tools\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: typeof $index != 'undefined' -->    <div title=\x22Drag this handle to move the block\x22 data-bind=\x22attr: { title: $root.t('Drag this handle to move the block') }\x22 class=\x22tool handle\x22><i class=\x22fa fa-fw fa-sort\x22></i></div>    <!-- ko if: $index() > 0 -->    <div title=\x22Move this block upside\x22 data-bind=\x22attr: { title: $root.t('Move this block upside') }\x22 class=\x22tool moveup\x22><i class=\x22fa fa-fw fa-sort-asc\x22 data-bind='click: $root.moveBlock.bind($element, $index, $parent, true)'></i></div>    <!-- /ko -->    <!-- ko if: $index() < $parent.blocks().length -1 -->    <div title=\x22Move this block downside\x22 data-bind=\x22attr: { title: $root.t('Move this block downside') }\x22 class=\x22tool movedown\x22><i class=\x22fa fa-fw fa-sort-desc\x22 data-bind='click: $root.moveBlock.bind($element, $index, $parent, false)'></i></div>    <!-- /ko -->    <div title=\x22Delete block\x22 class=\x22tool delete\x22 data-bind=\x22attr: { title: $root.t('Delete block') }, click: $root.removeBlock.bind($element, $rawData, $parent)\x22><i class=\x22fa fa-fw fa-trash-o\x22></i></div>    <div title=\x22Duplicate block\x22 class=\x22tool clone\x22 data-bind=\x22attr: { title: $root.t('Duplicate block') }, click: $root.duplicateBlock.bind($element, $index, $parent)\x22><i class=\x22fa fa-fw fa-files-o\x22></i></div>    <!-- /ko -->    <!-- ko if: typeof $data._nextVariant != 'undefined' --><div title=\x22Switch block variant\x22 class=\x22tool variant\x22 data-bind=\x22attr: { title: $root.t('Switch block variant') }, click: $data._nextVariant\x22><i class=\x22fa fa-fw fa-magic\x22></i></div><!-- /ko -->  </div>  <!-- ko block: $data --><!-- /ko --></div>");
  templateSystem.addTemplate("blocks-show", "<!-- ko template: { name: 'block-show', foreach: blocks } --><!-- /ko -->");
  templateSystem.addTemplate("blocks-wysiwyg", "<div class=\x22sortable-blocks-edit\x22 data-drop-content=\x22Drop here\x22 data-empty-content=\x22Drop here blocks from the Blocks tab\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here'), 'data-empty-content': $root.t('Drop here blocks from the &quot;Blocks&quot; tab') }, css: { 'empty': ko.utils.unwrapObservable(blocks).length == 0 }, extsortable: { connectClass: 'sortable-blocks-edit', template: 'block-wysiwyg', data: blocks, dragging: $root.dragging, beforeMove: $root.startMultiple, afterMove: $root.stopMultiple, options: { handle: '.handle', placeholder: $root.placeholderHelper } }\x22></div>");
  templateSystem.addTemplate("customstyle", "<div class=\x22customStyleHelp\x22 data-bind=\x22html: $root.t('Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class=&quot;customStyled&quot;><span>&quot;small cube&quot; </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul>')\x22>Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class=\x22customStyled\x22><span>\x22small cube\x22 </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul></div>");
  templateSystem.addTemplate("empty", "");
  templateSystem.addTemplate("error", "[<div style=\x22background-color: #fff0f0\x22 data-bind=\x22text: ko.toJS($data)\x22></div>]");
  templateSystem.addTemplate("gallery-images", "<div data-bind=\x22foreach: items.currentPageData\x22>  <div class=\x22draggable-item\x22 data-bind=\x22if: typeof thumbnailUrl != 'undefined'\x22>    <div class=\x22draggable image\x22 data-bind=\x22click: $root.addImage, extdraggable: { data: $data, dropContainer: '#main-wysiwyg-area', dragging: $root.draggingImage, 'options': { 'appendTo': '#page' } }, style: { backgroundImage: 'url(\\'' + thumbnailUrl + '\\')' }\x22>      <img title=\x22Drag this image and drop it on any template image placeholder\x22 style=\x22display: block;\x22 data-bind=\x22tooltips: {}, attr: { src: thumbnailUrl, 'title': $root.t('Drag this image and drop it on any template image placeholder') }\x22/>    </div>  </div></div><!-- ko if: items.pageCount() > 1 --><div class=\x22galleryPager\x22 data-bind=\x22buttonset: {}\x22>  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: items.moveFirst, button: { disabled: items.currentPage() == 1, icons: { primary: 'fa fa-fast-backward' }, text: false }\x22>First</a>  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: items.movePrevious, button: { disabled: items.currentPage() == 1, icons: { primary: 'fa fa-backward' }, text: false }\x22>Previous</a>  <span data-bind=\x22button: { disabled: true, text: true, label: ' '+items.currentPage()+' di '+items.pageCount()+' ' }\x22> X di Y </span>  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: items.moveNext, button: { disabled: items.currentPage() == items.pageCount(), icons: { primary: 'fa fa-forward' }, text: false }\x22>Next</a>  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: items.moveLast, button: { disabled: items.currentPage() == items.pageCount(), icons: { primary: 'fa fa-fast-forward' }, text: false }\x22>Last</a></div><!-- /ko -->");
  templateSystem.addTemplate("img-wysiwyg", "<table tabfocus=\x220\x22 cellspacing=\x220\x22 cellpadding=\x220\x22 data-drop-content=\x22Drop here\x22 data-bind=\x22style: _stylebind, click: function(obj, evt) { $root.selectItem(_item, _data); return true; }, clickBubble: false, fudroppable: { activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }, droppable: { options: { accept: '.image', activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }, data: _src, dragged: $root.fileToImage }, css: { selecteditem: $root.isSelectedItem(_item) }, scrollIntoView: $root.isSelectedItem(_item), attr: { 'data-drop-content': $root.t('Drop here'), width: _width, height: _height, align: _align }\x22  class=\x22img-wysiwyg selectable-img\x22 style=\x22display: table;\x22><tr><td class=\x22uploadzone\x22>  <div class=\x22mo-imgselectionhelper\x22></div>  <div class=\x22mo-uploadzone\x22></div>  <div class=\x22img-size\x22 data-bind=\x22text: _size\x22>size</div>  <div class=\x22midtools\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: _src() != '' -->    <div title=\x22Remove image\x22 class=\x22tool delete\x22 data-bind=\x22attr: { title: $root.t('Remove image') }, click: _src.bind(_src, ''), clickBubble: false\x22><i class=\x22fa fa-fw fa-trash-o\x22></i></div>    <!-- ko if: typeof $root.editImage !== 'undefined' -->    <div title=\x22Open the image editing tool\x22 class=\x22tool edit\x22 data-bind=\x22attr: { title: $root.t('Open the image editing tool') }, click: $root.editImage.bind($element, _src), clickBubble: false\x22><i class=\x22fa fa-fw fa-pencil\x22></i></div>    <!-- /ko -->    <!-- /ko -->    <!-- ko if: _src() == '' -->    <div title=\x22Upload a new image\x22 data-bind=\x22attr: { title: $root.t('Upload a new image') }\x22 class=\x22tool upload\x22 style=\x22position: relative; overflow: hidden;\x22><i class=\x22fa fa-fw fa-upload\x22></i>      <input class=\x22fileupload nofile\x22 type=\x22file\x22 name=\x22files[]\x22 data-bind=\x22fileupload: { data: _src, onerror: $root.notifier.error, onfile: $root.loadImage, canvasPreview: true }\x22 style=\x22z-index: 20; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-size: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block\x22>    </div>    <!-- /ko -->  </div>  <!-- ko template: _template --><!-- /ko -->  <!-- ko if: _src() == '' -->    <!--    <img style=\x22display: block;\x22 class=\x22imgplaceholder\x22 width=\x22200\x22 src=\x22\x22 alt=\x22Insert an image here\x22 data-bind=\x22wysiwygSrc: { src: _src.preloaded, placeholder: _placeholdersrc, width: _width, height: _height, method: _method }\x22 />    -->    <span class=\x22fileuploadtext\x22 style=\x22text-align: center; display: -ms-flexbox; display: flex; align-items: center; flex-align: center; justify-content: center; padding: 1em; position: absolute; top: 0; left: 0; right: 0; bottom: 0;\x22><span class=\x22textMiddle\x22 style=\x22 text-shadow: 1px 1px 0 #FFFFFF, 0 0 10px #FFFFFF; font-weight: bold;\x22 data-bind=\x22text: $root.t('Drop an image here')\x22>Drop an image here</span></span>  <!-- /ko -->  <!-- ko if: _src() != '' -->  <!--    <img style=\x22display: block;\x22 width=\x22200\x22 src=\x22\x22 data-bind=\x22preloader: _src, wysiwygSrc: { src: _src.preloaded, placeholder: _placeholdersrc, width: _width, height: _height, method: _method }\x22 />    -->  <!-- /ko -->  <!-- pulsante per la cancellazione -->  <div title=\x22Drop an image here or click the upload button\x22 data-bind=\x22attr: { title: $root.t('Drop an image here or click the upload button') }, tooltips: {}\x22 class=\x22workzone\x22 style=\x22position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden;\x22>    <!-- ko if: _src.preloaded && _src() != _src.preloaded() -->PRELOADING....<!-- /ko -->    <!-- ko if: _src() != '' -->      <input class=\x22fileupload withfile\x22 type=\x22file\x22 name=\x22files[]\x22 data-bind=\x22fileupload: { data: _src, onerror: $root.notifier.error, onfile: $root.galleryRecent.unshift.bind($root.galleryRecent), canvasPreview: true }\x22 style=\x22z-index: -20; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-zie: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block\x22>    <!-- /ko -->    <div class=\x22progress\x22 style=\x22opacity: .5; width: 80%; margin-left: 10%; position: absolute; bottom: 30%; height: 20px; border: 2px solid black;\x22>      <div class=\x22progress-bar progress-bar-success\x22 style=\x22height: 20px; background-color: black; \x22></div>    </div>  </div></table>");
  templateSystem.addTemplate("main", "<div id=\x22page\x22 style=\x22display: none;\x22 data-bind=\x22visible: true, css: { withToolbox: $root.showToolbox, withPreviewFrame: showPreviewFrame }\x22>  <div id=\x22main-edit-area\x22 data-bind=\x22click: function(obj, evt) { $root.selectBlock(null); return true; }, clickBubble: false\x22>    <!-- ko withProperties: { templateMode: 'wysiwyg', templateModeFallback: 'show' } -->    <div id=\x22main-wysiwyg-area\x22 data-bind=\x22wysiwygScrollfix: true, scrollable: true, fudroppable: { active: draggingImage }, css: { isdragging: dragging, isdraggingimg: draggingImage }, block: content\x22></div>    <!-- /ko -->  </div>  <div id=\x22toolbar\x22 class=\x22mo\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: typeof $root.undo != 'undefined' -->    <span data-bind=\x22buttonset: { }\x22 class=\x22leftButtons\x22>    <a title=\x22Undo last operation\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Undo last operation') }, click: $root.undo.execute, clickBubble: false, button: { disabled: !$root.undo.enabled(), icons: { primary: 'fa fa-reply' }, label: $root.undo.name, text: true }\x22>UNDO</a>    <a title=\x22Redo last operation\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Redo last operation') }, click: $root.redo.execute, clickBubble: false, button: { disabled: !$root.redo.enabled(), icons: { primary: 'fa fa-share' }, label: $root.redo.name, text: true }\x22>REDO</a>    </span>    <!-- ko if: $root.debug -->    <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.undoReset, clickBubble: false, button: { disabled: !$root.undo.enabled() && !$root.redo.enabled(), label: 'reset', text: true }\x22>RESET</a>    <!-- /ko -->    <!-- /ko -->    <span>    <input id=\x22showGallery\x22 type=\x22checkbox\x22 data-bind=\x22checked: $root.showGallery, button: { refreshOn: $root.showGallery,     icons: { primary: 'fa fa-fw fa-picture-o', secondary: null }, text: true, label: $root.t('Gallery') }\x22><label title=\x22Show image gallery\x22 for=\x22showGallery\x22 data-bind=\x22attr: { title: $root.t('Show image gallery') }\x22>show gallery</label></input>    </span>    <!-- CREATION NAME -->    <!-- ko if: $root.titleMode() == 'edit' || $root.titleMode() == 'saving' -->    <form class=\x22creation-name\x22 data-bind=\x22submit: saveEditCreationName, submitBubble: false\x22>      <input type=\x22text\x22 data-bind=\x22value: $root.metadata.name, disable: $root.titleMode() == 'saving', hasFocus: $root.titleMode() == 'edit'\x22/>      <button type=\x22button\x22 data-bind=\x22click: cancelEditCreationName, clickBubble: false, disable: $root.titleMode() == 'saving',      button: { refreshOn: $root.showPreviewFrame, icons: { primary: 'fa fa-fw fa-times', secondary: null }, text: false, label: $root.t('edit-title-cancel') }\x22>cancel</button>      <button type=\x22submit\x22 data-bind=\x22disable: $root.titleMode() == 'saving',        button: { refreshOn: $root.showPreviewFrame, icons: { primary: 'fa fa-fw fa-check-circle', secondary: null }, text: false, label: $root.t('edit-title-save') }\x22>save</button>    </form>    <!-- /ko -->    <!-- ko if: $root.titleMode() == 'show' -->    <div class=\x22creation-name\x22>      <p class=\x22ui-button\x22 data-bind=\x22event: { dblclick: enableEditCreationName }, dblclickBubble: false,        attr: { title: $root.t('edit-title-double-click') }\x22>        <span class=\x22ui-button-text\x22 data-bind=\x22text: $root.creationName\x22></span>      </p>    </div>    <!-- /ko -->    <input id=\x22previewFrameToggle\x22 type=\x22checkbox\x22 data-bind=\x22checked: $root.showPreviewFrame, button: { refreshOn: $root.showPreviewFrame, icons: { primary: 'fa fa-fw fa-tablet', secondary: null }, text: false, label: $root.t('Preview') }\x22><label title=\x22Show live preview\x22 for=\x22previewFrameToggle\x22 data-bind=\x22attr: { title: $root.t('Show live preview') }\x22>PREVIEW</label></input>    <!-- ko if: $root.debug -->    <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.export, clickBubble: false, button: { label: 'export', text: true }\x22>EXPORT</a>    <input type=\x22checkbox\x22 data-bind=\x22checked: $root.debug\x22 /> debug    <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.loadDefaultBlocks, clickBubble: false, button: { icons: { primary: 'fa fa-fw fa-upload' }, label: 'Default', text: true }\x22>LOAD BLOCKS</a>    [<a id=\x22subscriptionsCount\x22 href=\x22javascript:viewModel.loopSubscriptionsCount()\x22>subs</a>]    <!-- /ko -->    <span data-bind=\x22visible: false\x22>    <input type=\x22checkbox\x22 data-bind=\x22checked: $root.showToolbox\x22 /> toolbox    </span>    <div class=\x22rightButtons\x22>    <!-- ko if: typeof $root.save !== 'undefined' -->    <a title=\x22Save template\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Save template') }, click: $root.save.execute, clickBubble: false, button: { disabled: !$root.save.enabled(), icons: { primary: 'fa fa-fw fa-cloud-upload' }, label: $root.t($root.save.name), text: true }\x22>SALVA</a>    <!-- /ko -->    <!-- ko if: typeof $root.test !== 'undefined' -->    <a title=\x22Show preview and send test\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Show preview and send test') }, click: $root.test.execute, clickBubble: false, button: { disabled: !$root.test.enabled(), icons: { primary: 'fa fa-fw fa-paper-plane' }, label: $root.t($root.test.name), text: true }\x22>TEST</a>    <!-- /ko -->    <!-- ko if: typeof $root.download !== 'undefined' -->    <form id=\x22downloadForm\x22 action=\x22#\x22 method=\x22POST\x22>    <input type=\x22hidden\x22 name=\x22action\x22 value=\x22download\x22 />    <input type=\x22hidden\x22 name=\x22filename\x22 value=\x22email.html\x22 id=\x22downloadHtmlFilename\x22 />    <input type=\x22hidden\x22 name=\x22html\x22 id=\x22downloadHtmlTextarea\x22 />    <a title=\x22Download template\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Download template') }, click: $root.download.execute, clickBubble: false, button: { disabled: !$root.download.enabled(), icons: { primary: 'fa fa-fw fa-download' }, label: $root.t($root.download.name), text: true }\x22>DOWNLOAD</a>    </form>    <!-- /ko -->    </div>  </div>  <!-- ko if: $root.showToolbox -->  <div id=\x22main-toolbox\x22 class=\x22mo\x22 data-bind=\x22scrollable: true, withProperties: { templateMode: 'edit' }\x22>    <div data-bind=\x22template: { name: 'toolbox' }\x22></div>  </div>  <!-- /ko -->    <div id=\x22main-preview\x22 class=\x22mo\x22 data-bind=\x22scrollable: true, if: $root.showPreviewFrame\x22>    <div id=\x22preview-toolbar\x22>      <div data-bind=\x22visible: $root.showPreviewFrame, buttonset: { }\x22 style=\x22display: inline-block\x22>        <input id=\x22previewLarge\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22large\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'large', icons: { primary: 'fa fa-fw fa-desktop' } }\x22 />        <label for=\x22previewLarge\x22 title=\x22Large screen\x22 data-bind=\x22attr: { title: $root.t('Large screen') }\x22>Large screen</label>        <input id=\x22previewDesktop\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22desktop\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'desktop', icons: { primary: 'fa fa-fw fa-tablet' } }\x22 />        <label for=\x22previewDesktop\x22 title=\x22Tablet\x22 data-bind=\x22attr: { title: $root.t('Tablet') }\x22>Tablet</label>        <input id=\x22previewMobile\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22mobile\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'mobile', icons: { primary: 'fa fa-fw fa-mobile' } }\x22 />        <label for=\x22previewMobile\x22 title=\x22Smartphone\x22 data-bind=\x22attr: { title: $root.t('Smartphone') }\x22>Smartphone</label>      </div>    </div>    <div id=\x22frame-container\x22 data-bind=\x22css: { desktop: $root.previewMode() == 'desktop', mobile: $root.previewMode() == 'mobile', large: $root.previewMode() == 'large' }\x22>      <iframe data-bind=\x22bindIframe: $data\x22></iframe>    </div>  </div>  <div class=\x22mo\x22 id=\x22mo-body\x22></div>  <!-- TODO REMOVE ME  <div id=\x22incompatible-browser\x22 title=\x22Unsupported browser\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Usupported browser') }, html: '<p>Your browser is not supported.</p><p>Use a different browser or try updaring your browser.</p><p>Supported browsers: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>'\x22>    Unsupported browser  </div>  -->  <div id=\x22incompatible-template\x22 title=\x22Saved model is obsolete\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Saved model is obsolete') }, html: $root.t('<p>The saved model has been created with a previous, non completely compatible version, of the template</p><p>Some content or style in the model <b>COULD BE LOST</b> if you will <b>save</b></p><p>Contact us for more informations!</p>')\x22>    Incompatible template  </div>  <div id=\x22fake-image-editor\x22 title=\x22Fake image editor\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Fake image editor') }, html: $root.t('<p>Fake image editor</p>')\x22>    <p>Fake image editor</p>  </div></div><!-- ko if: $root.logoPath --><div id=\x22loading\x22 class=\x22loading\x22 style=\x22display: block; width: 300px; text-align: center; height: 32px; position: absolute; top:0; bottom: 0; left: 0; right: 0;  margin: auto;\x22 data-bind=\x22attr: { style: 'position: absolute; top: 5px; left: 6px; z-index: 150;'}, css: { loading: false }\x22>  <a href=\x22/\x22 data-bind=\x22attr: { href: $root.logoUrl, alt: $root.logoAlt }\x22><img data-bind=\x22attr: { src: $root.logoPath }\x22 width=\x2232\x22 height=\x2232\x22 alt=\x22mosaico\x22 border=\x220\x22 /></a>  <div style=\x22opacity: 0\x22 data-bind=\x22visible: false\x22>Oppps... !!</div></div><!-- /ko -->");
  templateSystem.addTemplate("toolbox", "<div id=\x22tooltabs\x22 class=\x22tabs_horizontal button_color\x22 data-bind=\x22tabs: { active: $root.selectedTool }\x22>  <ul>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Blocks ready to be added to the template\x22 data-local=\x22true\x22 href=\x22#toolblocks\x22 data-bind=\x22attr: { title: $root.t('Blocks ready to be added to the template') }\x22><i class=\x22fa fa-fw fa-cubes\x22></i> <span data-bind=\x22html: $root.t('Blocks')\x22>Blocks</span></a></li>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Edit content options\x22 href=\x22#toolcontents\x22 data-local=\x22true\x22 data-bind=\x22attr: { title: $root.t('Edit content options') }\x22><i class=\x22fa fa-fw fa-pencil\x22></i> <span data-bind=\x22html: $root.t('Content')\x22>Content</span></a></li>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Edit style options\x22 href=\x22#toolstyles\x22 data-local=\x22true\x22 data-bind=\x22attr: { title: $root.t('Edit style options') }\x22><i class=\x22fa fa-fw fa-paint-brush\x22></i> <span data-bind=\x22html: $root.t('Style')\x22>Style</span></a></li>  </ul>  <div id=\x22toolblocks\x22 data-bind=\x22scrollable: true\x22>    <div class=\x22block-list\x22 data-bind=\x22foreach: blockDefs\x22 style=\x22text-align: center\x22>      <div class=\x22draggable-item\x22 data-bind=\x22withProperties: { templateMode: 'show' }\x22>        <div class=\x22block\x22 data-bind=\x22extdraggable: { connectClass: 'sortable-blocks-edit', data: $data, dropContainer: '#main-wysiwyg-area', dragging: $root.dragging, 'options': { handle: '.handle', distance: 10, 'appendTo': '#page' } }, click: $root.addBlock\x22 style=\x22position: relative;\x22>          <div title=\x22Click or drag to add this block to the template\x22 class=\x22handle\x22 data-bind=\x22attr: { title: $root.t('Click or drag to add this block to the template') }, tooltips: {}\x22></div>          <img data-bind=\x22attr: { alt: $root.t('Block __name__', { name: ko.utils.unwrapObservable(type) }), src: $root.templatePath('edres/'+ko.utils.unwrapObservable(type)+'.png') }\x22 alt=\x22Block __name__\x22 />        </div>        <a href=\x22javascript:void(0)\x22 class=\x22addblockbutton\x22 data-bind=\x22click: $root.addBlock, button: { label: $root.t('Add') }\x22>Add</a>      </div>    </div>  </div>  <div id=\x22toolcontents\x22 data-bind=\x22scrollable: true\x22>    <!-- ko if: $root.selectedBlock() !== null -->    <div data-bind=\x22block: $root.selectedBlock\x22></div>    <!-- /ko -->    <!-- ko if: $root.selectedBlock() == null -->    <div class=\x22noSelectedBlock\x22 data-bind=\x22text: $root.t('By clicking on message parts you will select a block and content options, if any, will show here')\x22>By clicking on message parts you will select a block and content options, if any, will show here</div>    <!-- /ko -->    <!-- ko block: content --><!-- /ko -->  </div>    <div id=\x22toolstyles\x22 data-bind=\x22scrollable: true, withProperties: { templateMode: 'styler' }\x22>    <!-- ko if: typeof $root.content().theme === 'undefined' || typeof $root.content().theme().scheme === 'undefined' || $root.content().theme().scheme() === 'custom' -->      <!-- ko if: $root.selectedBlock() !== null -->      <div data-bind=\x22block: $root.selectedBlock, css: { workLocal: $root.selectedBlock().customStyle, workGlobal: typeof $root.selectedBlock().customStyle === 'undefined' || !$root.selectedBlock().customStyle() }\x22></div>      <!-- /ko -->      <!-- ko if: $root.selectedBlock() == null -->      <div class=\x22noSelectedBlock\x22 data-bind=\x22text: $root.t('By clicking on message parts you will select a block and style options, if available, will show here')\x22>By clicking on message parts you will select a block and style options, if available, will show here</div>      <!-- /ko -->      <div class=\x22workGlobalContent\x22>      <!-- ko block: content --><!-- /ko -->      </div>    <!-- /ko -->  </div></div>        <div id=\x22toolimages\x22 class=\x22slidebar\x22 data-bind=\x22scrollable: true, css: { hidden: $root.showGallery() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.showGallery.bind($element, false);\x22>X</div>  <span class=\x22pane-title\x22 data-bind=\x22text: $root.t('Gallery:')\x22>Gallery:</span>  <div data-drop-content=\x22Drop here\x22 class=\x22img-dropzone pane uploadzone\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here') }, fudroppable: { activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }\x22>  <div class=\x22mo-uploadzone\x22 style=\x22position: relative; padding: 2em; border: 2px dotted #808080\x22>     <input class=\x22fileupload\x22 type=\x22file\x22 multiple name=\x22files[]\x22 data-bind=\x22fileupload: { onerror: $root.notifier.error, onfile: $root.loadImage }\x22 style=\x22z-index: 10; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-zie: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block\x22>     <span data-bind=\x22text: $root.t('Click or drag files here')\x22>Click or drag files here</span>     <div class=\x22workzone\x22 style=\x22position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden;\x22>       <div class=\x22progress\x22 style=\x22opacity: .5; width: 80%; margin-left: 10%; position: absolute; bottom: 30%; height: 20px; border: 2px solid black;\x22>         <div class=\x22progress-bar progress-bar-success\x22 style=\x22height: 20px; background-color: black; \x22></div>       </div>     </div>  </div>  </div>  <!-- ko if: $root.showGallery() -->  <div id=\x22toolimagestab\x22 class=\x22tabs_horizontal\x22 data-bind=\x22tabs: { active: $root.selectedImageTab }\x22>    <ul>      <li data-bind=\x22tooltips: {}\x22><a title=\x22Session images\x22 data-local=\x22true\x22 href=\x22#toolimagesrecent\x22 data-bind=\x22attr: { title: $root.t('Session images') }, text: $root.t('Recents')\x22>Recents</a></li>      <li data-bind=\x22tooltips: {}\x22><a title=\x22Remote gallery\x22 data-local=\x22true\x22 href=\x22#toolimagesgallery\x22 data-bind=\x22attr: { title: $root.t('Remote gallery') }, text: $root.t('Gallery')\x22>Gallery</a></li>    </ul>    <div id=\x22toolimagesrecent\x22>      <!-- ko if: galleryRecent().length == 0 --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('No images uploaded, yet')\x22>No images uploaded, yet</div><!-- /ko -->      <!-- ko template: {name: 'gallery-images', data: { items: galleryRecent } } --># recent gallery #<!-- /ko -->    </div>    <div id=\x22toolimagesgallery\x22 style=\x22text-align: center\x22>    <!-- ko if: $root.galleryLoaded() === false --><a class=\x22loadbutton\x22 title=\x22Show images from the gallery\x22 href=\x22javascript:void(0)\x22 data-bind=\x22attr: { title: $root.t('Show images from the gallery') }, click: $root.loadGallery, button: { disabled: $root.galleryLoaded, icons: { primary: 'fa fa-fw fa-picture-o' }, label: $root.galleryLoaded() == 'loading' ? $root.t('Loading...') : $root.t('Load gallery'), text: true }\x22># load gally #</a><!-- /ko -->    <!-- ko if: $root.galleryLoaded() === 'loading' --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('Loading gallery...')\x22>Loading gallery...</div><!-- /ko -->    <!-- ko if: $root.galleryLoaded() === 0 --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('The gallery is empty')\x22>The gallery is empty</div><!-- /ko -->    <!-- ko template: {name: 'gallery-images', data: { items: galleryRemote } } --># remote gallery #<!-- /ko -->    </div>  </div>  <!-- /ko --></div><div id=\x22tooldebug\x22 class=\x22slidebar\x22 data-bind=\x22css: { hidden: $root.debug() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.debug.bind($element, false);\x22>X</div>    <!-- ko if: $root.debug -->  Content:  <pre data-bind='text: ko.toJSON(content, null, 2)' style=\x22overflow: auto; height: 20%\x22></pre>  BlockDefs:  <pre data-bind='text: ko.toJSON(blockDefs, null, 2)' style=\x22overflow: auto; height: 20%\x22></pre>  <!-- /ko -->  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.exportHTMLtoTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Generate' }\x22>Output</a>  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.exportJSONtoTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Export' }\x22>Export</a>  <a href=\x22javascript:void(0)\x22 data-bind=\x22click: $root.importJSONfromTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Import' }\x22>Import</a>  <textarea id=\x22outputhtml\x22 rows=\x2210\x22 style=\x22width: 100%;\x22></textarea></div><div id=\x22tooltheme\x22 class=\x22ui-widget slidebar\x22 data-bind=\x22css: { hidden: $root.showTheme() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.showTheme.bind($element, false);\x22>X</div>    <!-- ko withProperties: { templateMode: 'styler' } -->    <!-- ko if: $root.showTheme -->      <!-- ko block: $root.content().theme --><!-- /ko -->    <!-- /ko -->  <!-- /ko --></div>");
});

},{"../src/js/bindings/choose-template.js":50}],21:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":40}],22:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],23:[function(require,module,exports){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var root = require('lodash._root');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  return !!array.length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.unary` without support for storing wrapper metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 0 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (!isObject(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseDifference;

},{"lodash._root":25}],24:[function(require,module,exports){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a
 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
 * Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value)) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length,
 *  else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = baseFlatten;

},{}],25:[function(require,module,exports){
(function (global){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(objectTypes[typeof self] && self);

/** Detect free variable `window`. */
var freeWindow = checkGlobal(objectTypes[typeof window] && window);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal ||
  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
    freeSelf || thisGlobal || Function('return this')();

/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

module.exports = root;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],26:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    stringTag = '[object String]';

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(objectTypes[typeof self] && self);

/** Detect free variable `window`. */
var freeWindow = checkGlobal(objectTypes[typeof window] && window);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal ||
  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
    freeSelf || thisGlobal || Function('return this')();

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Reflect = root.Reflect,
    enumerate = Reflect ? Reflect.enumerate : undefined,
    propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * The base implementation of `_.keysIn` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  object = object == null ? object : Object(object);

  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}

// Fallback for IE < 9 with es6-shim.
if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
  baseKeysIn = function(object) {
    return iteratorToArray(enumerate(object));
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a
 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
 * Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Creates an array of index keys for `object` values of arrays,
 * `arguments` objects, and strings, otherwise `null` is returned.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array|null} Returns index keys, else `null`.
 */
function indexKeys(object) {
  var length = object ? object.length : undefined;
  if (isLength(length) &&
      (isArray(object) || isString(object) || isArguments(object))) {
    return baseTimes(length, String);
  }
  return null;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value)) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length,
 *  else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  var index = -1,
      isProto = isPrototype(object),
      props = baseKeysIn(object),
      propsLength = props.length,
      indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  while (++index < propsLength) {
    var key = props[index];
    if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var baseDifference = require('lodash._basedifference'),
    baseFlatten = require('lodash._baseflatten'),
    keysIn = require('lodash.keysin'),
    rest = require('lodash.rest');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetPrototype = Object.getPrototypeOf;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return arrayReduce(props, function(result, key) {
    if (key in object) {
      result[key] = object[key];
    }
    return result;
  }, {});
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/**
 * Gets the `[[Prototype]]` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {null|Object} Returns the `[[Prototype]]`.
 */
function getPrototype(value) {
  return nativeGetPrototype(Object(value));
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
function getSymbols(object) {
  // Coerce `object` to an object to avoid non-object errors in V8.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
  return getOwnPropertySymbols(Object(object));
}

// Fallback for IE < 11.
if (!getOwnPropertySymbols) {
  getSymbols = function() {
    return [];
  };
}

/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !getOwnPropertySymbols ? getSymbols : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = rest(function(object, props) {
  if (object == null) {
    return {};
  }
  props = arrayMap(baseFlatten(props, 1), toKey);
  return basePick(object, baseDifference(getAllKeysIn(object), props));
});

module.exports = omit;

},{"lodash._basedifference":23,"lodash._baseflatten":24,"lodash.keysin":26,"lodash.rest":28}],28:[function(require,module,exports){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, array);
      case 1: return func.call(this, args[0], array);
      case 2: return func.call(this, args[0], args[1], array);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This function is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = rest;

},{}],29:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],30:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it don't break things.
var cachedSetTimeout = setTimeout;
var cachedClearTimeout = clearTimeout;

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],31:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],32:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],33:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],34:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":32,"./encode":33}],35:[function(require,module,exports){
module.exports = require('./lib/speakingurl');

},{"./lib/speakingurl":36}],36:[function(require,module,exports){
(function (root, undefined) {
    'use strict';

    /**
     * getSlug
     * @param  {string} input input string
     * @param  {object|string} opts config object or separator string/char
     * @api    public
     * @return {string}  sluggified string
     */
    var getSlug = function getSlug(input, opts) {

        var separator = '-';
        var uricChars = [';', '?', ':', '@', '&', '=', '+', '$', ',', '/'];
        var uricNoSlashChars = [';', '?', ':', '@', '&', '=', '+', '$', ','];
        var markChars = ['.', '!', '~', '*', '\'', '(', ')'];
        var result = '';
        var diatricString = '';
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i;
        var ch;
        var l;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars;

        /**
         * charMap
         * @type {Object}
         */
        var charMap = {

            // latin
            'À': 'A',
            'Á': 'A',
            'Â': 'A',
            'Ã': 'A',
            'Ä': 'Ae',
            'Å': 'A',
            'Æ': 'AE',
            'Ç': 'C',
            'È': 'E',
            'É': 'E',
            'Ê': 'E',
            'Ë': 'E',
            'Ì': 'I',
            'Í': 'I',
            'Î': 'I',
            'Ï': 'I',
            'Ð': 'D',
            'Ñ': 'N',
            'Ò': 'O',
            'Ó': 'O',
            'Ô': 'O',
            'Õ': 'O',
            'Ö': 'Oe',
            'Ő': 'O',
            'Ø': 'O',
            'Ù': 'U',
            'Ú': 'U',
            'Û': 'U',
            'Ü': 'Ue',
            'Ű': 'U',
            'Ý': 'Y',
            'Þ': 'TH',
            'ß': 'ss',
            'à': 'a',
            'á': 'a',
            'â': 'a',
            'ã': 'a',
            'ä': 'ae',
            'å': 'a',
            'æ': 'ae',
            'ç': 'c',
            'è': 'e',
            'é': 'e',
            'ê': 'e',
            'ë': 'e',
            'ì': 'i',
            'í': 'i',
            'î': 'i',
            'ï': 'i',
            'ð': 'd',
            'ñ': 'n',
            'ò': 'o',
            'ó': 'o',
            'ô': 'o',
            'õ': 'o',
            'ö': 'oe',
            'ő': 'o',
            'ø': 'o',
            'ù': 'u',
            'ú': 'u',
            'û': 'u',
            'ü': 'ue',
            'ű': 'u',
            'ý': 'y',
            'þ': 'th',
            'ÿ': 'y',
            'ẞ': 'SS',

            // language specific

            // Arabic
            'ا': 'a',
            'أ': 'a',
            'إ': 'i',
            'آ': 'aa',
            'ؤ': 'u',
            'ئ': 'e',
            'ء': 'a',
            'ب': 'b',
            'ت': 't',
            'ث': 'th',
            'ج': 'j',
            'ح': 'h',
            'خ': 'kh',
            'د': 'd',
            'ذ': 'th',
            'ر': 'r',
            'ز': 'z',
            'س': 's',
            'ش': 'sh',
            'ص': 's',
            'ض': 'dh',
            'ط': 't',
            'ظ': 'z',
            'ع': 'a',
            'غ': 'gh',
            'ف': 'f',
            'ق': 'q',
            'ك': 'k',
            'ل': 'l',
            'م': 'm',
            'ن': 'n',
            'ه': 'h',
            'و': 'w',
            'ي': 'y',
            'ى': 'a',
            'ة': 'h',
            'ﻻ': 'la',
            'ﻷ': 'laa',
            'ﻹ': 'lai',
            'ﻵ': 'laa',

            // Arabic diactrics
            'َ': 'a',
            'ً': 'an',
            'ِ': 'e',
            'ٍ': 'en',
            'ُ': 'u',
            'ٌ': 'on',
            'ْ': '',

            // Arabic numbers
            '٠': '0',
            '١': '1',
            '٢': '2',
            '٣': '3',
            '٤': '4',
            '٥': '5',
            '٦': '6',
            '٧': '7',
            '٨': '8',
            '٩': '9',

            // Burmese consonants
            'က': 'k',
            'ခ': 'kh',
            'ဂ': 'g',
            'ဃ': 'ga',
            'င': 'ng',
            'စ': 's',
            'ဆ': 'sa',
            'ဇ': 'z',
            'စျ': 'za',
            'ည': 'ny',
            'ဋ': 't',
            'ဌ': 'ta',
            'ဍ': 'd',
            'ဎ': 'da',
            'ဏ': 'na',
            'တ': 't',
            'ထ': 'ta',
            'ဒ': 'd',
            'ဓ': 'da',
            'န': 'n',
            'ပ': 'p',
            'ဖ': 'pa',
            'ဗ': 'b',
            'ဘ': 'ba',
            'မ': 'm',
            'ယ': 'y',
            'ရ': 'ya',
            'လ': 'l',
            'ဝ': 'w',
            'သ': 'th',
            'ဟ': 'h',
            'ဠ': 'la',
            'အ': 'a',
            // consonant character combos
            'ြ': 'y',
            'ျ': 'ya',
            'ွ': 'w',
            'ြွ': 'yw',
            'ျွ': 'ywa',
            'ှ': 'h',
            // independent vowels
            'ဧ': 'e',
            '၏': '-e',
            'ဣ': 'i',
            'ဤ': '-i',
            'ဉ': 'u',
            'ဦ': '-u',
            'ဩ': 'aw',
            'သြော': 'aw',
            'ဪ': 'aw',
            // numbers
            '၀': '0',
            '၁': '1',
            '၂': '2',
            '၃': '3',
            '၄': '4',
            '၅': '5',
            '၆': '6',
            '၇': '7',
            '၈': '8',
            '၉': '9',
            // virama and tone marks which are silent in transliteration
            '္': '',
            '့': '',
            'း': '',

            // Czech
            'č': 'c',
            'ď': 'd',
            'ě': 'e',
            'ň': 'n',
            'ř': 'r',
            'š': 's',
            'ť': 't',
            'ů': 'u',
            'ž': 'z',
            'Č': 'C',
            'Ď': 'D',
            'Ě': 'E',
            'Ň': 'N',
            'Ř': 'R',
            'Š': 'S',
            'Ť': 'T',
            'Ů': 'U',
            'Ž': 'Z',

            // Dhivehi
            'ހ': 'h',
            'ށ': 'sh',
            'ނ': 'n',
            'ރ': 'r',
            'ބ': 'b',
            'ޅ': 'lh',
            'ކ': 'k',
            'އ': 'a',
            'ވ': 'v',
            'މ': 'm',
            'ފ': 'f',
            'ދ': 'dh',
            'ތ': 'th',
            'ލ': 'l',
            'ގ': 'g',
            'ޏ': 'gn',
            'ސ': 's',
            'ޑ': 'd',
            'ޒ': 'z',
            'ޓ': 't',
            'ޔ': 'y',
            'ޕ': 'p',
            'ޖ': 'j',
            'ޗ': 'ch',
            'ޘ': 'tt',
            'ޙ': 'hh',
            'ޚ': 'kh',
            'ޛ': 'th',
            'ޜ': 'z',
            'ޝ': 'sh',
            'ޞ': 's',
            'ޟ': 'd',
            'ޠ': 't',
            'ޡ': 'z',
            'ޢ': 'a',
            'ޣ': 'gh',
            'ޤ': 'q',
            'ޥ': 'w',
            'ަ': 'a',
            'ާ': 'aa',
            'ި': 'i',
            'ީ': 'ee',
            'ު': 'u',
            'ޫ': 'oo',
            'ެ': 'e',
            'ޭ': 'ey',
            'ޮ': 'o',
            'ޯ': 'oa',
            'ް': '',

            // Greek
            'α': 'a',
            'β': 'v',
            'γ': 'g',
            'δ': 'd',
            'ε': 'e',
            'ζ': 'z',
            'η': 'i',
            'θ': 'th',
            'ι': 'i',
            'κ': 'k',
            'λ': 'l',
            'μ': 'm',
            'ν': 'n',
            'ξ': 'ks',
            'ο': 'o',
            'π': 'p',
            'ρ': 'r',
            'σ': 's',
            'τ': 't',
            'υ': 'y',
            'φ': 'f',
            'χ': 'x',
            'ψ': 'ps',
            'ω': 'o',
            'ά': 'a',
            'έ': 'e',
            'ί': 'i',
            'ό': 'o',
            'ύ': 'y',
            'ή': 'i',
            'ώ': 'o',
            'ς': 's',
            'ϊ': 'i',
            'ΰ': 'y',
            'ϋ': 'y',
            'ΐ': 'i',
            'Α': 'A',
            'Β': 'B',
            'Γ': 'G',
            'Δ': 'D',
            'Ε': 'E',
            'Ζ': 'Z',
            'Η': 'I',
            'Θ': 'TH',
            'Ι': 'I',
            'Κ': 'K',
            'Λ': 'L',
            'Μ': 'M',
            'Ν': 'N',
            'Ξ': 'KS',
            'Ο': 'O',
            'Π': 'P',
            'Ρ': 'R',
            'Σ': 'S',
            'Τ': 'T',
            'Υ': 'Y',
            'Φ': 'F',
            'Χ': 'X',
            'Ψ': 'PS',
            'Ω': 'W',
            'Ά': 'A',
            'Έ': 'E',
            'Ί': 'I',
            'Ό': 'O',
            'Ύ': 'Y',
            'Ή': 'I',
            'Ώ': 'O',
            'Ϊ': 'I',
            'Ϋ': 'Y',

            // Latvian
            'ā': 'a',
            // 'č': 'c', // duplicate
            'ē': 'e',
            'ģ': 'g',
            'ī': 'i',
            'ķ': 'k',
            'ļ': 'l',
            'ņ': 'n',
            // 'š': 's', // duplicate
            'ū': 'u',
            // 'ž': 'z', // duplicate
            'Ā': 'A',
            // 'Č': 'C', // duplicate
            'Ē': 'E',
            'Ģ': 'G',
            'Ī': 'I',
            'Ķ': 'k',
            'Ļ': 'L',
            'Ņ': 'N',
            // 'Š': 'S', // duplicate
            'Ū': 'U',
            // 'Ž': 'Z', // duplicate

            // Macedonian
            'Ќ': 'Kj',
            'ќ': 'kj',
            'Љ': 'Lj',
            'љ': 'lj',
            'Њ': 'Nj',
            'њ': 'nj',
            'Тс': 'Ts',
            'тс': 'ts',

            // Polish
            'ą': 'a',
            'ć': 'c',
            'ę': 'e',
            'ł': 'l',
            'ń': 'n',
            // 'ó': 'o', // duplicate
            'ś': 's',
            'ź': 'z',
            'ż': 'z',
            'Ą': 'A',
            'Ć': 'C',
            'Ę': 'E',
            'Ł': 'L',
            'Ń': 'N',
            'Ś': 'S',
            'Ź': 'Z',
            'Ż': 'Z',

            // Ukranian
            'Є': 'Ye',
            'І': 'I',
            'Ї': 'Yi',
            'Ґ': 'G',
            'є': 'ye',
            'і': 'i',
            'ї': 'yi',
            'ґ': 'g',

            // Romanian
            'ă': 'a',
            'Ă': 'A',
            'ș': 's',
            'Ș': 'S',
            // 'ş': 's', // duplicate
            // 'Ş': 'S', // duplicate
            'ț': 't',
            'Ț': 'T',
            'ţ': 't',
            'Ţ': 'T',

            // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
            // ICAO

            'а': 'a',
            'б': 'b',
            'в': 'v',
            'г': 'g',
            'д': 'd',
            'е': 'e',
            'ё': 'yo',
            'ж': 'zh',
            'з': 'z',
            'и': 'i',
            'й': 'i',
            'к': 'k',
            'л': 'l',
            'м': 'm',
            'н': 'n',
            'о': 'o',
            'п': 'p',
            'р': 'r',
            'с': 's',
            'т': 't',
            'у': 'u',
            'ф': 'f',
            'х': 'kh',
            'ц': 'c',
            'ч': 'ch',
            'ш': 'sh',
            'щ': 'sh',
            'ъ': '',
            'ы': 'y',
            'ь': '',
            'э': 'e',
            'ю': 'yu',
            'я': 'ya',
            'А': 'A',
            'Б': 'B',
            'В': 'V',
            'Г': 'G',
            'Д': 'D',
            'Е': 'E',
            'Ё': 'Yo',
            'Ж': 'Zh',
            'З': 'Z',
            'И': 'I',
            'Й': 'I',
            'К': 'K',
            'Л': 'L',
            'М': 'M',
            'Н': 'N',
            'О': 'O',
            'П': 'P',
            'Р': 'R',
            'С': 'S',
            'Т': 'T',
            'У': 'U',
            'Ф': 'F',
            'Х': 'Kh',
            'Ц': 'C',
            'Ч': 'Ch',
            'Ш': 'Sh',
            'Щ': 'Sh',
            'Ъ': '',
            'Ы': 'Y',
            'Ь': '',
            'Э': 'E',
            'Ю': 'Yu',
            'Я': 'Ya',

            // Serbian
            'ђ': 'dj',
            'ј': 'j',
            // 'љ': 'lj',  // duplicate
            // 'њ': 'nj', // duplicate
            'ћ': 'c',
            'џ': 'dz',
            'Ђ': 'Dj',
            'Ј': 'j',
            // 'Љ': 'Lj', // duplicate
            // 'Њ': 'Nj', // duplicate
            'Ћ': 'C',
            'Џ': 'Dz',

            // Slovak
            'ľ': 'l',
            'ĺ': 'l',
            'ŕ': 'r',
            'Ľ': 'L',
            'Ĺ': 'L',
            'Ŕ': 'R',

            // Turkish
            'ş': 's',
            'Ş': 'S',
            'ı': 'i',
            'İ': 'I',
            // 'ç': 'c', // duplicate
            // 'Ç': 'C', // duplicate
            // 'ü': 'u', // duplicate, see langCharMap
            // 'Ü': 'U', // duplicate, see langCharMap
            // 'ö': 'o', // duplicate, see langCharMap
            // 'Ö': 'O', // duplicate, see langCharMap
            'ğ': 'g',
            'Ğ': 'G',

            // Vietnamese
            'ả': 'a',
            'Ả': 'A',
            'ẳ': 'a',
            'Ẳ': 'A',
            'ẩ': 'a',
            'Ẩ': 'A',
            'đ': 'd',
            'Đ': 'D',
            'ẹ': 'e',
            'Ẹ': 'E',
            'ẽ': 'e',
            'Ẽ': 'E',
            'ẻ': 'e',
            'Ẻ': 'E',
            'ế': 'e',
            'Ế': 'E',
            'ề': 'e',
            'Ề': 'E',
            'ệ': 'e',
            'Ệ': 'E',
            'ễ': 'e',
            'Ễ': 'E',
            'ể': 'e',
            'Ể': 'E',
            'ọ': 'o',
            'Ọ': 'o',
            'ố': 'o',
            'Ố': 'O',
            'ồ': 'o',
            'Ồ': 'O',
            'ổ': 'o',
            'Ổ': 'O',
            'ộ': 'o',
            'Ộ': 'O',
            'ỗ': 'o',
            'Ỗ': 'O',
            'ơ': 'o',
            'Ơ': 'O',
            'ớ': 'o',
            'Ớ': 'O',
            'ờ': 'o',
            'Ờ': 'O',
            'ợ': 'o',
            'Ợ': 'O',
            'ỡ': 'o',
            'Ỡ': 'O',
            'Ở': 'o',
            'ở': 'o',
            'ị': 'i',
            'Ị': 'I',
            'ĩ': 'i',
            'Ĩ': 'I',
            'ỉ': 'i',
            'Ỉ': 'i',
            'ủ': 'u',
            'Ủ': 'U',
            'ụ': 'u',
            'Ụ': 'U',
            'ũ': 'u',
            'Ũ': 'U',
            'ư': 'u',
            'Ư': 'U',
            'ứ': 'u',
            'Ứ': 'U',
            'ừ': 'u',
            'Ừ': 'U',
            'ự': 'u',
            'Ự': 'U',
            'ữ': 'u',
            'Ữ': 'U',
            'ử': 'u',
            'Ử': 'ư',
            'ỷ': 'y',
            'Ỷ': 'y',
            'ỳ': 'y',
            'Ỳ': 'Y',
            'ỵ': 'y',
            'Ỵ': 'Y',
            'ỹ': 'y',
            'Ỹ': 'Y',
            'ạ': 'a',
            'Ạ': 'A',
            'ấ': 'a',
            'Ấ': 'A',
            'ầ': 'a',
            'Ầ': 'A',
            'ậ': 'a',
            'Ậ': 'A',
            'ẫ': 'a',
            'Ẫ': 'A',
            // 'ă': 'a', // duplicate
            // 'Ă': 'A', // duplicate
            'ắ': 'a',
            'Ắ': 'A',
            'ằ': 'a',
            'Ằ': 'A',
            'ặ': 'a',
            'Ặ': 'A',
            'ẵ': 'a',
            'Ẵ': 'A',

            // symbols
            '“': '"',
            '”': '"',
            '‘': '\'',
            '’': '\'',
            '∂': 'd',
            'ƒ': 'f',
            '™': '(TM)',
            '©': '(C)',
            'œ': 'oe',
            'Œ': 'OE',
            '®': '(R)',
            '†': '+',
            '℠': '(SM)',
            '…': '...',
            '˚': 'o',
            'º': 'o',
            'ª': 'a',
            '•': '*',
            '၊': ',',
            '။': '.',

            // currency
            '$': 'USD',
            '€': 'EUR',
            '₢': 'BRN',
            '₣': 'FRF',
            '£': 'GBP',
            '₤': 'ITL',
            '₦': 'NGN',
            '₧': 'ESP',
            '₩': 'KRW',
            '₪': 'ILS',
            '₫': 'VND',
            '₭': 'LAK',
            '₮': 'MNT',
            '₯': 'GRD',
            '₱': 'ARS',
            '₲': 'PYG',
            '₳': 'ARA',
            '₴': 'UAH',
            '₵': 'GHS',
            '¢': 'cent',
            '¥': 'CNY',
            '元': 'CNY',
            '円': 'YEN',
            '﷼': 'IRR',
            '₠': 'EWE',
            '฿': 'THB',
            '₨': 'INR',
            '₹': 'INR',
            '₰': 'PF'

        };

        /**
         * special look ahead character array
         * These characters form with consonants to become 'single'/consonant combo
         * @type [Array]
         */
        var lookAheadCharArray = [
            // burmese
            '်',

            // Dhivehi
            'ް'
        ];

        /**
         * diatricMap for languages where transliteration changes entirely as more diatrics are added
         * @type {Object}
         */
        var diatricMap = {
            // Burmese
            // dependent vowels
            'ာ': 'a',
            'ါ': 'a',
            'ေ': 'e',
            'ဲ': 'e',
            'ိ': 'i',
            'ီ': 'i',
            'ို': 'o',
            'ု': 'u',
            'ူ': 'u',
            'ေါင်': 'aung',
            'ော': 'aw',
            'ော်': 'aw',
            'ေါ': 'aw',
            'ေါ်': 'aw',
            '်': '်', // this is special case but the character will be converted to latin in the code
            'က်': 'et',
            'ိုက်': 'aik',
            'ောက်': 'auk',
            'င်': 'in',
            'ိုင်': 'aing',
            'ောင်': 'aung',
            'စ်': 'it',
            'ည်': 'i',
            'တ်': 'at',
            'ိတ်': 'eik',
            'ုတ်': 'ok',
            'ွတ်': 'ut',
            'ေတ်': 'it',
            'ဒ်': 'd',
            'ိုဒ်': 'ok',
            'ုဒ်': 'ait',
            'န်': 'an',
            'ာန်': 'an',
            'ိန်': 'ein',
            'ုန်': 'on',
            'ွန်': 'un',
            'ပ်': 'at',
            'ိပ်': 'eik',
            'ုပ်': 'ok',
            'ွပ်': 'ut',
            'န်ုပ်': 'nub',
            'မ်': 'an',
            'ိမ်': 'ein',
            'ုမ်': 'on',
            'ွမ်': 'un',
            'ယ်': 'e',
            'ိုလ်': 'ol',
            'ဉ်': 'in',
            'ံ': 'an',
            'ိံ': 'ein',
            'ုံ': 'on',

            // Dhivehi
            'ައް': 'ah',
            'ަށް': 'ah',
        };

        /**
         * langCharMap language specific characters translations
         * @type   {Object}
         */
        var langCharMap = {

            'en': {}, // default language

            'az': { // Azerbaijani
                'ç': 'c',
                'ə': 'e',
                'ğ': 'g',
                'ı': 'i',
                'ö': 'o',
                'ş': 's',
                'ü': 'u',
                'Ç': 'C',
                'Ə': 'E',
                'Ğ': 'G',
                'İ': 'I',
                'Ö': 'O',
                'Ş': 'S',
                'Ü': 'U'
            },

            'cs': { // Czech
                'č': 'c',
                'ď': 'd',
                'ě': 'e',
                'ň': 'n',
                'ř': 'r',
                'š': 's',
                'ť': 't',
                'ů': 'u',
                'ž': 'z',
                'Č': 'C',
                'Ď': 'D',
                'Ě': 'E',
                'Ň': 'N',
                'Ř': 'R',
                'Š': 'S',
                'Ť': 'T',
                'Ů': 'U',
                'Ž': 'Z'
            },

            'fi': { // Finnish
                // 'å': 'a', duplicate see charMap/latin
                // 'Å': 'A', duplicate see charMap/latin
                'ä': 'a', // ok
                'Ä': 'A', // ok
                'ö': 'o', // ok
                'Ö': 'O' // ok
            },

            'hu': { // Hungarian
                'ä': 'a', // ok
                'Ä': 'A', // ok
                // 'á': 'a', duplicate see charMap/latin
                // 'Á': 'A', duplicate see charMap/latin
                'ö': 'o', // ok
                'Ö': 'O', // ok
                // 'ő': 'o', duplicate see charMap/latin
                // 'Ő': 'O', duplicate see charMap/latin
                'ü': 'u',
                'Ü': 'U',
                'ű': 'u',
                'Ű': 'U'
            },

            'lt': { // Lithuanian
                'ą': 'a',
                'č': 'c',
                'ę': 'e',
                'ė': 'e',
                'į': 'i',
                'š': 's',
                'ų': 'u',
                'ū': 'u',
                'ž': 'z',
                'Ą': 'A',
                'Č': 'C',
                'Ę': 'E',
                'Ė': 'E',
                'Į': 'I',
                'Š': 'S',
                'Ų': 'U',
                'Ū': 'U'
            },

            'lv': { // Latvian
                'ā': 'a',
                'č': 'c',
                'ē': 'e',
                'ģ': 'g',
                'ī': 'i',
                'ķ': 'k',
                'ļ': 'l',
                'ņ': 'n',
                'š': 's',
                'ū': 'u',
                'ž': 'z',
                'Ā': 'A',
                'Č': 'C',
                'Ē': 'E',
                'Ģ': 'G',
                'Ī': 'i',
                'Ķ': 'k',
                'Ļ': 'L',
                'Ņ': 'N',
                'Š': 'S',
                'Ū': 'u',
                'Ž': 'Z'
            },

            'pl': { // Polish
                'ą': 'a',
                'ć': 'c',
                'ę': 'e',
                'ł': 'l',
                'ń': 'n',
                'ó': 'o',
                'ś': 's',
                'ź': 'z',
                'ż': 'z',
                'Ą': 'A',
                'Ć': 'C',
                'Ę': 'e',
                'Ł': 'L',
                'Ń': 'N',
                'Ó': 'O',
                'Ś': 'S',
                'Ź': 'Z',
                'Ż': 'Z'
            },

            'sk': { // Slovak
                'ä': 'a',
                'Ä': 'A'
            },

            'sr': { // Serbian
                'љ': 'lj',
                'њ': 'nj',
                'Љ': 'Lj',
                'Њ': 'Nj',
                'đ': 'dj',
                'Đ': 'Dj'
            },

            'tr': { // Turkish
                'Ü': 'U',
                'Ö': 'O',
                'ü': 'u',
                'ö': 'o'
            }
        };

        /**
         * symbolMap language specific symbol translations
         * translations must be transliterated already
         * @type   {Object}
         */
        var symbolMap = {

            'ar': {
                '∆': 'delta',
                '∞': 'la-nihaya',
                '♥': 'hob',
                '&': 'wa',
                '|': 'aw',
                '<': 'aqal-men',
                '>': 'akbar-men',
                '∑': 'majmou',
                '¤': 'omla'
            },

            'az': {},

            'ca': {
                '∆': 'delta',
                '∞': 'infinit',
                '♥': 'amor',
                '&': 'i',
                '|': 'o',
                '<': 'menys que',
                '>': 'mes que',
                '∑': 'suma dels',
                '¤': 'moneda'
            },

            'cz': {
                '∆': 'delta',
                '∞': 'nekonecno',
                '♥': 'laska',
                '&': 'a',
                '|': 'nebo',
                '<': 'mene jako',
                '>': 'vice jako',
                '∑': 'soucet',
                '¤': 'mena'
            },

            'de': {
                '∆': 'delta',
                '∞': 'unendlich',
                '♥': 'Liebe',
                '&': 'und',
                '|': 'oder',
                '<': 'kleiner als',
                '>': 'groesser als',
                '∑': 'Summe von',
                '¤': 'Waehrung'
            },

            'dv': {
                '∆': 'delta',
                '∞': 'kolunulaa',
                '♥': 'loabi',
                '&': 'aai',
                '|': 'noonee',
                '<': 'ah vure kuda',
                '>': 'ah vure bodu',
                '∑': 'jumula',
                '¤': 'faisaa'
            },

            'en': {
                '∆': 'delta',
                '∞': 'infinity',
                '♥': 'love',
                '&': 'and',
                '|': 'or',
                '<': 'less than',
                '>': 'greater than',
                '∑': 'sum',
                '¤': 'currency'
            },

            'es': {
                '∆': 'delta',
                '∞': 'infinito',
                '♥': 'amor',
                '&': 'y',
                '|': 'u',
                '<': 'menos que',
                '>': 'mas que',
                '∑': 'suma de los',
                '¤': 'moneda'
            },

            'fr': {
                '∆': 'delta',
                '∞': 'infiniment',
                '♥': 'Amour',
                '&': 'et',
                '|': 'ou',
                '<': 'moins que',
                '>': 'superieure a',
                '∑': 'somme des',
                '¤': 'monnaie'
            },

            'gr': {},

            'hu': {
                '∆': 'delta',
                '∞': 'vegtelen',
                '♥': 'szerelem',
                '&': 'es',
                '|': 'vagy',
                '<': 'kisebb mint',
                '>': 'nagyobb mint',
                '∑': 'szumma',
                '¤': 'penznem'
            },

            'it': {
                '∆': 'delta',
                '∞': 'infinito',
                '♥': 'amore',
                '&': 'e',
                '|': 'o',
                '<': 'minore di',
                '>': 'maggiore di',
                '∑': 'somma',
                '¤': 'moneta'
            },

            'lt': {},

            'lv': {
                '∆': 'delta',
                '∞': 'bezgaliba',
                '♥': 'milestiba',
                '&': 'un',
                '|': 'vai',
                '<': 'mazak neka',
                '>': 'lielaks neka',
                '∑': 'summa',
                '¤': 'valuta'
            },

            'my': {
                '∆': 'kwahkhyaet',
                '∞': 'asaonasme',
                '♥': 'akhyait',
                '&': 'nhin',
                '|': 'tho',
                '<': 'ngethaw',
                '>': 'kyithaw',
                '∑': 'paungld',
                '¤': 'ngwekye'
            },

            'mk': {},

            'nl': {
                '∆': 'delta',
                '∞': 'oneindig',
                '♥': 'liefde',
                '&': 'en',
                '|': 'of',
                '<': 'kleiner dan',
                '>': 'groter dan',
                '∑': 'som',
                '¤': 'valuta'
            },

            'pl': {
                '∆': 'delta',
                '∞': 'nieskonczonosc',
                '♥': 'milosc',
                '&': 'i',
                '|': 'lub',
                '<': 'mniejsze niz',
                '>': 'wieksze niz',
                '∑': 'suma',
                '¤': 'waluta'
            },

            'pt': {
                '∆': 'delta',
                '∞': 'infinito',
                '♥': 'amor',
                '&': 'e',
                '|': 'ou',
                '<': 'menor que',
                '>': 'maior que',
                '∑': 'soma',
                '¤': 'moeda'
            },

            'ro': {
                '∆': 'delta',
                '∞': 'infinit',
                '♥': 'dragoste',
                '&': 'si',
                '|': 'sau',
                '<': 'mai mic ca',
                '>': 'mai mare ca',
                '∑': 'suma',
                '¤': 'valuta'
            },

            'ru': {
                '∆': 'delta',
                '∞': 'beskonechno',
                '♥': 'lubov',
                '&': 'i',
                '|': 'ili',
                '<': 'menshe',
                '>': 'bolshe',
                '∑': 'summa',
                '¤': 'valjuta'
            },

            'sk': {
                '∆': 'delta',
                '∞': 'nekonecno',
                '♥': 'laska',
                '&': 'a',
                '|': 'alebo',
                '<': 'menej ako',
                '>': 'viac ako',
                '∑': 'sucet',
                '¤': 'mena'
            },

            'sr': {},

            'tr': {
                '∆': 'delta',
                '∞': 'sonsuzluk',
                '♥': 'ask',
                '&': 've',
                '|': 'veya',
                '<': 'kucuktur',
                '>': 'buyuktur',
                '∑': 'toplam',
                '¤': 'para birimi'
            },

            'uk': {
                '∆': 'delta',
                '∞': 'bezkinechnist',
                '♥': 'lubov',
                '&': 'i',
                '|': 'abo',
                '<': 'menshe',
                '>': 'bilshe',
                '∑': 'suma',
                '¤': 'valjuta'
            },

            'vn': {
                '∆': 'delta',
                '∞': 'vo cuc',
                '♥': 'yeu',
                '&': 'va',
                '|': 'hoac',
                '<': 'nho hon',
                '>': 'lon hon',
                '∑': 'tong',
                '¤': 'tien te'
            }
        };

        if (typeof input !== 'string') {
            return '';
        }

        if (typeof opts === 'string') {
            separator = opts;
        }

        symbol = symbolMap.en;
        langChar = langCharMap.en;

        if (typeof opts === 'object') {

            maintainCase = opts.maintainCase || false;
            customReplacements = (opts.custom && typeof opts.custom === 'object') ? opts.custom : customReplacements;
            truncate = (+opts.truncate > 1 && opts.truncate) || false;
            uricFlag = opts.uric || false;
            uricNoSlashFlag = opts.uricNoSlash || false;
            markFlag = opts.mark || false;
            convertSymbols = (opts.symbols === false || opts.lang === false) ? false : true;
            separator = opts.separator || separator;

            if (uricFlag) {
                allowedChars += uricChars.join('');
            }

            if (uricNoSlashFlag) {
                allowedChars += uricNoSlashChars.join('');
            }

            if (markFlag) {
                allowedChars += markChars.join('');
            }

            symbol = (opts.lang && symbolMap[opts.lang] && convertSymbols) ?
                symbolMap[opts.lang] : (convertSymbols ? symbolMap.en : {});

            langChar = (opts.lang && langCharMap[opts.lang]) ?
                langCharMap[opts.lang] :
                opts.lang === false || opts.lang === true ? {} : langCharMap.en;

            // if titleCase config is an Array, rewrite to object format
            if (opts.titleCase && typeof opts.titleCase.length === "number" && Array.prototype.toString.call(opts.titleCase)) {

                opts.titleCase.forEach(function (v) {
                    customReplacements[v + ""] = v + "";
                });

                titleCase = true;
            } else {
                titleCase = !!opts.titleCase;
            }

            // if custom config is an Array, rewrite to object format
            if (opts.custom && typeof opts.custom.length === "number" && Array.prototype.toString.call(opts.custom)) {

                opts.custom.forEach(function (v) {
                    customReplacements[v + ""] = v + "";
                });
            }

            // custom replacements
            Object.keys(customReplacements).forEach(function (v) {

                var r;

                if (v.length > 1) {
                    r = new RegExp('\\b' + escapeChars(v) + '\\b', 'gi');
                } else {
                    r = new RegExp(escapeChars(v), 'gi');
                }

                input = input.replace(r, customReplacements[v]);
            });

            // add all custom replacement to allowed charlist
            for (ch in customReplacements) {
                allowedChars += ch;
            }

        }

        allowedChars += separator;

        // escape all necessary chars
        allowedChars = escapeChars(allowedChars);

        // trim whitespaces
        input = input.replace(/(^\s+|\s+$)/g, '');

        lastCharWasSymbol = false;
        lastCharWasDiatric = false;

        for (i = 0, l = input.length; i < l; i++) {

            ch = input[i];

            if (isReplacedCustomChar(ch, customReplacements)) {
                // don't convert a already converted char
                lastCharWasSymbol = false;
            } else if (langChar[ch]) {
                // process language specific diactrics chars conversion
                ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? ' ' + langChar[ch] : langChar[ch];

                lastCharWasSymbol = false;
            } else if (ch in charMap) {
                // the transliteration changes entirely when some special characters are added
                if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
                    diatricString += ch;
                    ch = '';
                } else if (lastCharWasDiatric === true) {
                    ch = diatricMap[diatricString] + charMap[ch];
                    diatricString = '';
                } else {
                    // process diactrics chars
                    ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? ' ' + charMap[ch] : charMap[ch];
                }

                lastCharWasSymbol = false;
                lastCharWasDiatric = false;
            } else
            if (ch in diatricMap) {
                diatricString += ch;
                ch = '';
                // end of string, put the whole meaningful word
                if (i === l - 1) {
                    ch = diatricMap[diatricString];
                }
                lastCharWasDiatric = true;
            } else if (
                // process symbol chars
                symbol[ch] && !(uricFlag && uricChars.join('')
                    .indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars.join('')
                    //.indexOf(ch) !== -1) && !(markFlag && markChars.join('')
                    .indexOf(ch) !== -1)) {

                ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
                ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : '';

                lastCharWasSymbol = true;
            } else {
                if (lastCharWasDiatric === true) {
                    ch = diatricMap[diatricString] + ch;
                    diatricString = '';
                    lastCharWasDiatric = false;
                } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
                    // process latin chars
                    ch = ' ' + ch;
                }
                lastCharWasSymbol = false;
            }

            // add allowed chars
            result += ch.replace(new RegExp('[^\\w\\s' + allowedChars + '_-]', 'g'), separator);
        }

        if (titleCase) {
            result = result.replace(/(\w)(\S*)/g, function (_, i, r) {
                var j = i.toUpperCase() + (r !== null ? r : "");
                return (Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0) ? j : j.toLowerCase();
            });
        }

        // eliminate duplicate separators
        // add separator
        // trim separators from start and end
        result = result.replace(/\s+/g, separator)
            .replace(new RegExp('\\' + separator + '+', 'g'), separator)
            .replace(new RegExp('(^\\' + separator + '+|\\' + separator + '+$)', 'g'), '');

        if (truncate && result.length > truncate) {

            lucky = result.charAt(truncate) === separator;
            result = result.slice(0, truncate);

            if (!lucky) {
                result = result.slice(0, result.lastIndexOf(separator));
            }
        }

        if (!maintainCase && !titleCase) {
            result = result.toLowerCase();
        }

        return result;
    };

    /**
     * createSlug curried(opts)(input)
     * @param   {object|string} opts config object or input string
     * @return  {Function} function getSlugWithConfig()
     **/
    var createSlug = function createSlug(opts) {

        /**
         * getSlugWithConfig
         * @param   {string} input string
         * @return  {string} slug string
         */
        return function getSlugWithConfig(input) {
            return getSlug(input, opts);
        };
    };

    /**
     * escape Chars
     * @param   {string} input string
     */
    var escapeChars = function escapeChars(input) {

        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, '\\$&');
    };

    /**
     * check if the char is an already converted char from custom list
     * @param   {char} ch character to check
     * @param   {object} customReplacements custom translation map
     */
    var isReplacedCustomChar = function (ch, customReplacements) {

        for (var c in customReplacements) {
            if (customReplacements[c] === ch) {
                return true;
            }
        }
    };

    if (typeof module !== 'undefined' && module.exports) {

        // export functions for use in Node
        module.exports = getSlug;
        module.exports.createSlug = createSlug;

    } else if (typeof define !== 'undefined' && define.amd) {

        // export function for use in AMD
        define([], function () {
            return getSlug;
        });

    } else {

        // don't overwrite global if exists
        try {
            if (root.getSlug || root.createSlug) {
                throw 'speakingurl: globals exists /(getSlug|createSlug)/';
            } else {
                root.getSlug = getSlug;
                root.createSlug = createSlug;
            }
        } catch (e) {}

    }
})(this);

},{}],37:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":38,"punycode":31,"querystring":34}],38:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],39:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],40:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":39,"_process":30,"inherits":22}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.default = isByteLength;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable prefer-rest-params */
function isByteLength(str, options) {
  (0, _assertString2.default)(str);
  var min = void 0;
  var max = void 0;
  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isByteLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }
  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
}
module.exports = exports['default'];
},{"./util/assertString":44}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isEmail;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

var _merge = require('./util/merge');

var _merge2 = _interopRequireDefault(_merge);

var _isByteLength = require('./isByteLength');

var _isByteLength2 = _interopRequireDefault(_isByteLength);

var _isFQDN = require('./isFQDN');

var _isFQDN2 = _interopRequireDefault(_isFQDN);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_email_options = {
  allow_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true
};

/* eslint-disable max-len */
/* eslint-disable no-control-regex */
var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
/* eslint-enable max-len */
/* eslint-enable no-control-regex */

function isEmail(str, options) {
  (0, _assertString2.default)(str);
  options = (0, _merge2.default)(options, default_email_options);

  if (options.allow_display_name) {
    var display_email = str.match(displayName);
    if (display_email) {
      str = display_email[1];
    }
  }

  var parts = str.split('@');
  var domain = parts.pop();
  var user = parts.join('@');

  var lower_domain = domain.toLowerCase();
  if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
    user = user.replace(/\./g, '').toLowerCase();
  }

  if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 256 })) {
    return false;
  }

  if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
    return false;
  }

  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }

  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;

  var user_parts = user.split('.');
  for (var i = 0; i < user_parts.length; i++) {
    if (!pattern.test(user_parts[i])) {
      return false;
    }
  }

  return true;
}
module.exports = exports['default'];
},{"./isByteLength":41,"./isFQDN":43,"./util/assertString":44,"./util/merge":45}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isFDQN;

var _assertString = require('./util/assertString');

var _assertString2 = _interopRequireDefault(_assertString);

var _merge = require('./util/merge');

var _merge2 = _interopRequireDefault(_merge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false
};

function isFDQN(str, options) {
  (0, _assertString2.default)(str);
  options = (0, _merge2.default)(options, default_fqdn_options);

  /* Remove the optional trailing dot before checking validity */
  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }
  var parts = str.split('.');
  if (options.require_tld) {
    var tld = parts.pop();
    if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    }
  }
  for (var part, i = 0; i < parts.length; i++) {
    part = parts[i];
    if (options.allow_underscores) {
      part = part.replace(/_/g, '');
    }
    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    }
    if (/[\uff01-\uff5e]/.test(part)) {
      // disallow full-width chars
      return false;
    }
    if (part[0] === '-' || part[part.length - 1] === '-') {
      return false;
    }
  }
  return true;
}
module.exports = exports['default'];
},{"./util/assertString":44,"./util/merge":45}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertString;
function assertString(input) {
  if (typeof input !== 'string') {
    throw new TypeError('This library (validator.js) validates strings only');
  }
}
module.exports = exports['default'];
},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;
function merge() {
  var obj = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var defaults = arguments[1];

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }
  return obj;
}
module.exports = exports['default'];
},{}],46:[function(require,module,exports){
'use strict'

var getSlug = require('speakingurl')

// take care of slugging everything BUT the file extension
// keeping this file as minimal as possible -> used in front-end…
function slugFilename(name) {
  var fileName  = name
  var ext       = /\.[0-9a-z]+$/.exec(name)[0]
  fileName      = fileName.replace(ext, '')
  fileName      = getSlug(fileName) + ext
  return fileName
}

module.exports = slugFilename

},{"speakingurl":35}],47:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */
/* global XMLHttpRequest: false */

var url     = require('url');
var console = require("./../../bower_components/console-browserify/index.js");
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);

var templateLoader = require('./template-loader.js');

require("./ko-bindings.js");
var performanceAwareCaller = require("./timed-call.js").timedCall;

var addUndoStackExtensionMaker = require("./undomanager/undomain.js");
var colorPlugin = require("./ext/color.js");
var inlinerPlugin = require("./ext/inliner.js");

var localStorageLoader = require("./ext/localstorage.js");

if (typeof ko == 'undefined') throw "Cannot find knockout.js library!";
if (typeof $ == 'undefined') throw "Cannot find jquery library!";

if (false) {

function _canonicalize(url) {
  var div = global.document.createElement('div');
  div.innerHTML = "<a></a>";
  div.firstChild.href = url; // Ensures that the href is properly escaped
  div.innerHTML = div.innerHTML; // Run the current innerHTML back through the parser
  return div.firstChild.href;
}

var applyBindingOptions = function(options, ko) {
  // push "convertedUrl" method to the wysiwygSrc binding
  ko.bindingHandlers.wysiwygSrc.convertedUrl = function(src, method, width, height) {
    var imgProcessorBackend = options.imgProcessorBackend ? options.imgProcessorBackend : './upload';
    var backEndMatch = imgProcessorBackend.match(/^(https?:\/\/[^\/]*\/).*$/);
    var srcMatch = src.match(/^(https?:\/\/[^\/]*\/).*$/);
    if (backEndMatch === null || (srcMatch !== null && backEndMatch[1] == srcMatch[1])) {
      return imgProcessorBackend + "?src=" + encodeURIComponent(src) + "&method=" + encodeURIComponent(method) + "&params=" + encodeURIComponent(width + "," + height);
    } else {
      console.log("Cannot apply backend image resizing to non-local resources ", src, method, width, height, backEndMatch, srcMatch);
      return src + "?method=" + method + "&width=" + width + (height !== null ? "&height=" + height : '');
    }
  };

  ko.bindingHandlers.wysiwygSrc.placeholderUrl = function(width, height, text) {
    return options.imgProcessorBackend + "?method=" + 'placeholder' + "&params=" + width + encodeURIComponent(",") + height;
  };

  // pushes custom tinymce configurations from options to the binding
  if (options && options.tinymceConfig)
    ko.bindingHandlers.wysiwyg.standardOptions = options.tinymceConfig;
  if (options && options.tinymceConfigFull)
    ko.bindingHandlers.wysiwyg.fullOptions = options.tinymceConfigFull;
};

}

var start = function(options, templateFile, templateMetadata, jsorjson, customExtensions) {

  templateLoader.fixPageEvents();

  var fileUploadMessagesExtension = function(vm) {
    var fileuploadConfig = {
      messages: {
        unknownError: vm.t('Unknown error'),
        uploadedBytes: vm.t('Uploaded bytes exceed file size'),
        maxNumberOfFiles: vm.t('Maximum number of files exceeded'),
        acceptFileTypes: vm.t('File type not allowed'),
        maxFileSize: vm.t('File is too large'),
        minFileSize: vm.t('File is too small'),
        post_max_size: vm.t('The uploaded file exceeds the post_max_size directive in php.ini'),
        max_file_size: vm.t('File is too big'),
        min_file_size: vm.t('File is too small'),
        accept_file_types: vm.t('Filetype not allowed'),
        max_number_of_files: vm.t('Maximum number of files exceeded'),
        max_width: vm.t('Image exceeds maximum width'),
        min_width: vm.t('Image requires a minimum width'),
        max_height: vm.t('Image exceeds maximum height'),
        min_height: vm.t('Image requires a minimum height'),
        abort: vm.t('File upload aborted'),
        image_resize: vm.t('Failed to resize image'),
        generic: vm.t('Unexpected upload error')
      }
    };
    // fileUpload options.
    if (options && options.fileuploadConfig)
      fileuploadConfig = $.extend(true, fileuploadConfig, options.fileuploadConfig);

    ko.bindingHandlers['fileupload'].extendOptions = fileuploadConfig;

  };

  var simpleTranslationPlugin = function(vm) {
    if (options && options.strings) {
      vm.t = function(key, objParam) {
        var res = options.strings[key];
        if (typeof res == 'undefined') {
          console.warn("Missing translation string for",key,": using default string");
          res = key;
        }
        return vm.tt(res, objParam);
      };
    }
  };

  // simpleTranslationPlugin must be before the undoStack to translate undo/redo labels
  var extensions = [simpleTranslationPlugin, addUndoStackExtensionMaker(performanceAwareCaller), colorPlugin, inlinerPlugin];
  if (typeof customExtensions !== 'undefined')
    for (var k = 0; k < customExtensions.length; k++) extensions.push(customExtensions[k]);
  extensions.push(fileUploadMessagesExtension);

  var galleryUrl = options.fileuploadConfig ? options.fileuploadConfig.url : '/upload/';
  applyBindingOptions(options, ko);

  // TODO what about appending to another element?
  $("<!-- ko template: 'main' --><!-- /ko -->").appendTo(global.document.body);

  // templateFile may override the template path in templateMetadata
  if (typeof templateFile == 'undefined' && typeof templateMetadata != 'undefined') {
    templateFile = templateMetadata.template;
  }
  // TODO canonicalize templateFile to absolute or relative depending on "relativeUrlsException" plugin

  templateLoader.load(performanceAwareCaller, templateFile, templateMetadata, jsorjson, extensions, galleryUrl);

};

if (false) {

var initFromLocalStorage = function(options, hash_key, customExtensions) {
  try {
    var lsData = localStorageLoader(hash_key, options.emailProcessorBackend);
    var extensions = typeof customExtensions !== 'undefined' ? customExtensions : [];
    extensions.push(lsData.extension);
    var template = _canonicalize(lsData.metadata.template);
    start(options, template, lsData.metadata, lsData.model, extensions);
  } catch (e) {
    console.error("TODO not found ", hash_key, e);
  }
};

var init = function(options, customExtensions) {

  var hash = global.location.hash ? global.location.href.split("#")[1] : undefined;

  // Loading from configured template or configured metadata
  if (options && (options.template || options.data)) {
    if (options.data) {
      var data = JSON.parse(options.data);
      start(options, undefined, data.metadata, data.content, customExtensions);
    } else {
      start(options, options.template, undefined, undefined, customExtensions);
    }
    // Loading from LocalStorage (if url hash has a 7chars key)
  } else if (hash && hash.length == 7) {
    initFromLocalStorage(options, hash, customExtensions);
    // Loading from template url as hash (if hash is not a valid localstorage key)
  } else if (hash) {
    start(options, _canonicalize(hash), undefined, undefined, customExtensions);
  } else {
    return false;
  }
  return true;
};

}

if (true) {

//////
// BADSENDER SPECIFIC
//////

// don't replace mosaico code for better merging

// Keep an empty function for not breaking start function
// Event is applyBindingOptions can be surcharged,
// it's better to remove this not necessary piece of code
var applyBindingOptions = $.noop

// FLOW:
// => init
// => start
// in ./template-loader.js
// => templateLoader: Ajax datas
// => templateCompiler:
//    -> Initialize viewmodel (./viewmodel.js)
//    -> Add server datas
//    -> apply plugins (server-storage, setEditorIcon + mosaico defined)

var badsenderExt = require('./ext/badsender-extensions')

var init = function(opts, customExtensions) {
  console.info('BADSENDER – init')
  console.log(opts)
  var hasDatas = opts && opts.metadata && opts.data
  // editor.jade script need a return value
  if (!hasDatas) return false;

  badsenderExt.extendViewModel(opts, customExtensions)
  badsenderExt.extendKnockout(opts)

  start(opts, void(0), opts.metadata, opts.data, customExtensions)

  return true;
}

}

module.exports = {
  isCompatible: templateLoader.isCompatible,
  init: init,
  start: start
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./ext/badsender-extensions":80,"./ext/color.js":82,"./ext/inliner.js":83,"./ext/localstorage.js":84,"./ko-bindings.js":85,"./template-loader.js":86,"./timed-call.js":87,"./undomanager/undomain.js":88,"url":37}],48:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// @see also script-template.js pushTemplate
var addScriptTemplate = function(doc, templateName, templateMarkup) {
  var scriptTag = doc.createElement('script');
  scriptTag.setAttribute('type', 'text/html');
  scriptTag.setAttribute('id', templateName);
  scriptTag.text = templateMarkup;
  doc.body.appendChild(scriptTag);
  return scriptTag;
  // $('<script type="text/html"></sc' + 'ript>').text(templateMarkup).attr('id', templateName).appendTo($('body'));
};

// used for live preview in iframe.
ko.bindingHandlers.bindIframe = {
  // tpl will be overriden with the structure parsed by the input template.
  tpl: "<!DOCTYPE html>\r\n<html>\r\n<head>\r\n</head>\r\n<body><div data-bind=\"block: content\"></div></body>\r\n</html>\r\n",
  init: function(element, valueAccessor) {
    function bindIframe(local) {
      try {
        var iframe = element.contentDocument;
        iframe.open();
        iframe.write(ko.bindingHandlers.bindIframe.tpl);
        iframe.close();

        try {
          var iframedoc = iframe.body;
          if (iframedoc) {
            // scripts have to be duplicated (maybe this is not needed anymore since using string-templates)
            var templates = element.contentWindow.parent.document.getElementsByTagName('script');
            for (var i = 0; i < templates.length; i++) {
              if (templates[i].getAttribute('type') == 'text/html' && templates[i].getAttribute('id')) {
                addScriptTemplate(iframe, templates[i].getAttribute('id'), templates[i].innerHTML);
              }
            }

            var html = iframe.getElementsByTagName("HTML");

            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
              ko.cleanNode(html[0] || iframedoc);
            });

            ko.applyBindings(valueAccessor(), html[0] || iframedoc);
          } else {
            console.log("no iframedoc", local);
          }
        } catch (e) {
          console.log("error reading iframe.body", e, local);
          throw e;
        }
      } catch (e) {
        console.log("error reading iframe contentDocument", e, local);
        throw e;
        // ignored
      }
    }
    bindIframe("first call");
    // older browsers needed this
    // ko.utils.registerEventHandler(element, 'load', bindIframe);
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],49:[function(require,module,exports){
(function (global){
"use strict";
/* globals global:false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");


ko.bindingHandlers['withProperties'] = {
  init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // Make a modified binding context, with a extra properties, and apply it to descendant elements
    var childBindingContext = bindingContext.createChildContext(
      bindingContext.$rawData,
      null, // Optionally, pass a string here as an alias for the data item in descendant contexts
      function(context) {
        ko.utils.extend(context, valueAccessor());
      }
    );
    ko.applyBindingsToDescendants(childBindingContext, element);

    // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice
    return {
      controlsDescendantBindings: true
    };
  }
};
ko.virtualElements.allowedBindings['withProperties'] = true;

ko.bindingHandlers['log'] = {
  init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    console.log("log", valueAccessor());
  }
};


ko.bindingHandlers['block'] = {

  templateExists: function(id) {
    var el = global.document.getElementById(id);
    if (el) return true;
    else return false;
  },

  _chooseTemplate: function(isArray, prefix, action, fallback) {
    var id = prefix + '-' + action;
    if (ko.bindingHandlers['block'].templateExists(id)) return id;
    if (typeof fallback != 'undefined' && fallback !== null) return ko.bindingHandlers['block']._chooseTemplate(isArray, prefix, fallback);
    else {
      var fallBackId = isArray ? 'array' : 'object-' + action;
      if (ko.bindingHandlers['block'].templateExists(fallBackId)) return fallBackId;
      else throw "cannot find template for " + id + "/" + fallBackId;
    }
  },

  // compute displayMode depending on templateMode set using "withProperties" binding.
  _displayMode: function(unwrapped, bindingContext) {
    var prefix = typeof unwrapped.type != 'undefined' ? ko.utils.unwrapObservable(unwrapped.type) : 'notablock-' + typeof(unwrapped);
    var isArray = typeof unwrapped.splice !== 'undefined';
    var templateMode = bindingContext.templateMode ? bindingContext.templateMode : 'show';
    return ko.bindingHandlers['block']._chooseTemplate(isArray, prefix, templateMode, bindingContext.templateModeFallback);
  },

  _makeTemplateValueAccessor: function(valueAccessor, bindingContext) {
    return function() {
      var value = valueAccessor(),
        unwrappedValue = ko.utils.peekObservable(value); // Unwrap without setting a dependency here

      // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
      var modelValue;
      var template;

      if ((!unwrappedValue) || (typeof unwrappedValue.data != 'object' && typeof unwrappedValue.data != 'function')) {
        modelValue = value;
      } else {
        modelValue = unwrappedValue.data;
        if (typeof unwrappedValue.template != 'undefined') {
          var templateParam = ko.utils.unwrapObservable(unwrappedValue.template);
          var templateMode = bindingContext.templateMode ? bindingContext.templateMode : 'show';
          template = ko.bindingHandlers['block']._chooseTemplate(false, templateParam, templateMode, bindingContext.templateModeFallback);
        }
      }

      var unwrappedModelValue = ko.utils.unwrapObservable(modelValue);
      if (ko.isObservable(unwrappedModelValue)) console.log("doubleObservable", unwrappedModelValue);

      if (typeof template == 'undefined') {
        // NOTE IE8 used to break here, but we don't support it anymore, so maybe this is not needed.
        if (modelValue === undefined) {
          template = 'empty';
        } else {
          try {
            template = ko.bindingHandlers['block']._displayMode(unwrappedModelValue, bindingContext);
          } catch (e) {
            console.log(e, unwrappedModelValue, bindingContext['$data'], bindingContext.templateMode);
            throw e;
          }
        }
      }

      return {
        'name': template,
        'data': modelValue,
        'templateEngine': ko.nativeTemplateEngine.instance
      };
    };
  },

  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    if (typeof valueAccessor() === 'undefined') console.log("found a null block: check ending commas in arrays defs in IE");
    var newValueAccessor = ko.bindingHandlers['block']._makeTemplateValueAccessor(valueAccessor, bindingContext);
    return ko.bindingHandlers['template']['init'](element, newValueAccessor);
  },
  'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var newValueAccessor = ko.bindingHandlers['block']._makeTemplateValueAccessor(valueAccessor, bindingContext);
    return ko.bindingHandlers['template']['update'](element, newValueAccessor, allBindings, viewModel, bindingContext);
  }
};
ko.expressionRewriting.bindingRewriteValidators['block'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['block'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],50:[function(require,module,exports){
"use strict";

// script template is the one provided by KO and deals with tempaltes defined as <script type=text/html.
// string template defines them in memory and avoids polluting the HTML: seems to work better in Mosaico.

module.exports = require('./string-template.js');
// module.exports = require('./script-template.js');

},{"./string-template.js":64}],51:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

require("./../../../bower_components/evol-colorpicker/js/evol.colorpicker.min.js");

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null);


var ColorPicker = function() {
  kojqui.BindingHandler.call(this, 'colorpicker');
};
ColorPicker.prototype = kojqui.utils.createObject(kojqui.BindingHandler.prototype);
ColorPicker.prototype.constructor = ColorPicker;

ColorPicker.prototype.init = function(element, valueAccessor, allBindings) {
  var va = valueAccessor();
  var value = va.color;

  // In order to have a correct dependency tracking in "ifSubs" we have to ensure we use a single computer for each editable
  // property. Given this binding needs 2 of them, we create a computed so to "proxy" the dependencies.
  var newDO = ko.computed({
    read: value,
    write: value,
    disposeWhenNodeIsRemoved: element
  });
  var newVA = function() {
    return newDO;
  };

  ko.bindingHandlers.value.init(element, newVA, allBindings);

  var changePropagator = function(event, color) {
    if (typeof color !== 'undefined') newDO(color);
  };
  $(element).on('change.color', changePropagator);

  ko.computed({
    read: function() {
      var opt = {
        color: ko.utils.unwrapObservable(newDO),
        showOn: 'button'
      };
      for (var prop in va)
        if (prop !== 'color' && va.hasOwnProperty(prop)) opt[prop] = ko.utils.unwrapObservable(va[prop]);
      $(element).colorpicker(opt);
    },
    disposeWhenNodeIsRemoved: element
  });

  ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
    $(element).off('change.color', changePropagator);
    $(element).colorpicker('destroy');
  });

};
kojqui.utils.register(ColorPicker);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/evol-colorpicker/js/evol.colorpicker.min.js":2}],52:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

/* https://github.com/knockout/knockout/issues/1171 */
ko.bindingHandlers.cssText = {
  'update': function(node, valueAccessor, allBindings) {
    var text = ko.utils.unwrapObservable(valueAccessor());
    try {
      node.innerText = text;
    } catch (e) {
      if (!node.styleSheet) node.innerHTML = "a{}";
      node.styleSheet.cssText = text;
    }
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],53:[function(require,module,exports){
(function (global){
"use strict";

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

/* knockout droppable, with simplified UMD */
;(function(factory) {
  factory(ko, $);
})(function(ko, $) {
  var ITEMKEY = "ko_sortItem",
    INDEXKEY = "ko_sourceIndex",
    LISTKEY = "ko_sortList",
    PARENTKEY = "ko_parentList",
    DRAGKEY = "ko_dragItem",
    unwrap = ko.utils.unwrapObservable,
    dataGet = ko.utils.domData.get,
    dataSet = ko.utils.domData.set;

  ko.bindingHandlers.droppable = {
    init: function(element, valueAccessor, allBindingsAccessor, data, context) {
      var $element = $(element),
        value = ko.utils.unwrapObservable(valueAccessor()) || {},
        droppable = {},
        dropActual;

      $.extend(true, droppable, ko.bindingHandlers.droppable);
      if (value.data) {
        if (value.options && droppable.options) {
          ko.utils.extend(droppable.options, value.options);
          delete value.options;
        }
        ko.utils.extend(droppable, value);
      } else {
        droppable.data = value;
      }

      dropActual = droppable.options.drop;

      $element.droppable(ko.utils.extend(droppable.options, {
        drop: function(event, ui) {

          var el = ui.draggable[0],
            item = dataGet(el, ITEMKEY) || dataGet(el, DRAGKEY);

          if (item) {

            if (item.clone) {
              item = item.clone();
            }

            if (droppable.dragged) {
              item = droppable.dragged.call(this, item, event, ui) || item;
            }

            if (droppable.data) {
              droppable.data(item);
            }

          }

          if (dropActual) {
            dropActual.apply(this, arguments);
          }

        }
      }));

      //handle enabling/disabling
      if (droppable.isEnabled !== undefined) {
        ko.computed({
          read: function() {
            $element.droppable(ko.utils.unwrapObservable(droppable.isEnabled) ? "enable" : "disable");
          },
          disposeWhenNodeIsRemoved: element
        });
      }

    },
    update: function(element, valueAccessor, allBindingsAccessor, data, context) {

    },
    targetIndex: null,
    afterMove: null,
    beforeMove: null,
    options: {}
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],54:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

/* utility for togetherjs */
ko.bindingHandlers.focusable = {
  'focus': function() {},
  'blur': function() {},
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("focusin", ko.bindingHandlers.focusable.focus);
      $(element).off("focusout", ko.bindingHandlers.focusable.blur);
    });

    $(element).on("focusin", ko.bindingHandlers.focusable.focus);
    $(element).on("focusout", ko.bindingHandlers.focusable.blur);

  }
};

ko.bindingHandlers.scrollable = {
  'scroll': function() {},
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("scroll", ko.bindingHandlers.scrollable.scroll);
    });

    $(element).on("scroll", ko.bindingHandlers.scrollable.scroll);

  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],55:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

ko.extenders.paging = function(target, pageSize) {
  var _pageSize = ko.observable(pageSize || 10),
    // default pageSize to 10
    _currentPage = ko.observable(1); // default current page to 1
  target.pageSize = ko.computed({
    read: _pageSize,
    write: function(newValue) {
      if (newValue > 0) {
        _pageSize(newValue);
      } else {
        _pageSize(10);
      }
    }
  });

  target.currentPage = ko.computed({
    read: _currentPage,
    write: function(newValue) {
      if (newValue > target.pageCount()) {
        _currentPage(target.pageCount());
      } else if (newValue <= 0) {
        _currentPage(1);
      } else {
        _currentPage(newValue);
      }
    }
  });

  target.pageCount = ko.computed(function() {
    return Math.ceil(target().length / target.pageSize()) || 1;
  });

  target.currentPageData = ko.computed(function() {
    var pageSize = _pageSize(),
      pageIndex = _currentPage(),
      startIndex = pageSize * (pageIndex - 1),
      endIndex = pageSize * pageIndex;

    return target().slice(startIndex, endIndex);
  });

  target.moveFirst = function() {
    target.currentPage(1);
  };
  target.movePrevious = function() {
    target.currentPage(target.currentPage() - 1);
  };
  target.moveNext = function() {
    target.currentPage(target.currentPage() + 1);
  };
  target.moveLast = function() {
    target.currentPage(target.pageCount());
  };

  return target;
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],56:[function(require,module,exports){
(function (global){
"use strict";
/* globals global: true */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var sortable = (typeof window !== "undefined" ? window['jQuery']['ui']['sortable'] : typeof global !== "undefined" ? global['jQuery']['ui']['sortable'] : null);
var draggable = (typeof window !== "undefined" ? window['jQuery']['ui']['draggable'] : typeof global !== "undefined" ? global['jQuery']['ui']['draggable'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
require("./../../../bower_components/knockout-sortable/build/knockout-sortable.min.js");

if (typeof sortable == 'undefined') throw "Cannot find jquery-ui sortable widget dependency!";
if (typeof draggable == 'undefined') throw "Cannot find jquery-ui sortable widget dependency!";

var isDraggingHelper = function(writable, e) {
  if (writable()) {
    if (e.type == writable() + 'stop') writable(false);
  } else {
    if (e.type == 'dragstart' || e.type == 'sortstart') writable(e.type.substring(0, 4));
  }
};

var makeExtendedValueAccessor = function(valueAccessor) {
  return function() {
    var modelValue = valueAccessor(),
      unwrappedValue = ko.utils.peekObservable(modelValue); // Unwrap without setting a dependency here

    ko.utils.unwrapObservable(modelValue);

    if (modelValue.options == 'undefined') {
      modelValue.options = {};
    }

    var origStart = modelValue.options.start;
    modelValue.options.start = function(e, ui) {
      if (typeof modelValue.dragging != 'undefined' && ko.isWritableObservable(modelValue.dragging)) isDraggingHelper(modelValue.dragging, e);
      if (typeof modelValue.dropContainer != 'undefined') {
        modelValue.scrollInterval = global.setInterval(function() {
          var foo = $(modelValue.dropContainer).scrollTop();
          $(modelValue.dropContainer).scrollTop(foo + modelValue.adding);
        }, 20);
      }
      if (typeof origStart != 'undefined') return origStart(e, ui);
    };
    var origStop = modelValue.options.stop;
    modelValue.options.stop = function(e, ui) {
      if (typeof modelValue.dragging != 'undefined' && ko.isWritableObservable(modelValue.dragging)) isDraggingHelper(modelValue.dragging, e);
      if (typeof modelValue.dropContainer != 'undefined') {
        global.clearInterval(modelValue.scrollInterval);
      }
      if (typeof origStop != 'undefined') return origStop(e, ui);
    };
    var origDrag = modelValue.options.drag;
    modelValue.options.drag = function(e, ui) {
      if (typeof modelValue.dropContainer != 'undefined') {
        var top = e.pageY - $(modelValue.dropContainer).offset().top;
        var bottom = top - $(modelValue.dropContainer).height();
        // Handle scrolling speed depending on distance from border.
        if (top < -20) {
          modelValue.adding = -20;
          // console.log("<<<");
        } else if (top < 0) {
          modelValue.adding = -10;
          // console.log("<<");
        } else if (top < 10) {
          modelValue.adding = -5;
          // console.log("<");
        } else if (bottom > 20) {
          modelValue.adding = 20;
          // console.log(">>>");
        } else if (bottom > 0) {
          modelValue.adding = 10;
          // console.log(">>");
        } else if (bottom > -10) {
          modelValue.adding = 5;
          // console.log(">");
        } else {
          modelValue.adding = 0;
        }
      }
      if (typeof origDrag != 'undefined') return origDrag(e, ui);
    };

    return modelValue;
  };
};

ko.bindingHandlers.extsortable = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.sortable.init(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.sortable.update(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  }
};

ko.bindingHandlers.extdraggable = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.draggable.init(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.draggable.update(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/knockout-sortable/build/knockout-sortable.min.js":8}],57:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false, Image: false */

// This module depends on those files, but it doesn't have a direct dependency, so we don't require them here.

//require("blueimp-canvas-to-blob");
//require("jquery-file-upload/js/jquery.iframe-transport.js");
//require("jquery-file-upload/js/jquery.fileupload.js");
//require("jquery-file-upload/js/jquery.fileupload-process.js");
//require("jquery-file-upload/js/jquery.fileupload-image.js");
//require("jquery-file-upload/js/jquery.fileupload-validate.js");

var $       = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko      = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// experimental image preloading.
ko.bindingHandlers['preloader'] = {
  init: function(element, valueAccessor) {
    var value = valueAccessor();
    if (typeof value.preloaded == 'undefined') {
      value.preloaded = ko.observable("");

      var preloader = function(newValue) {
        if (newValue != value.preloaded()) {
          if (newValue !== '') {
            var img = new Image();
            img.onload = function() {
              value.preloaded(newValue);
            };
            img.onerror = function() {
              value.preloaded(newValue);
            };
            img.src = newValue;
          } else {
            value.preloaded(newValue);
          }
        }
      };

      value.subscribe(preloader);
      preloader(value());
    }
  }
};

// TODO we don't use advattr and advstyle, maybe we should simply remove this code.
ko.bindingHandlers['advattr'] = {
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(attrName, attrValueAccessor) {
      var attrValue = element.getAttribute(attrName);

      if (ko.isWriteableObservable(attrValueAccessor)) {
        var oldValue = attrValueAccessor();
        if (oldValue != attrValue) {
          attrValueAccessor(attrValue);
          if (oldValue !== null) {
            console.log("AdvAttr found a value different from the default", attrName, oldValue, attrValue);
          }
        }
      }
    });
  },
  'update': function(element, valueAccessor, allBindings) {
    var value = ko.utils.unwrapObservable(valueAccessor()) || {};
    ko.utils.objectForEach(value, function(attrName, attrValue) {
      attrValue = ko.utils.unwrapObservable(attrValue);
      // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
      // when someProp is a "no value"-like value (strictly null, false, or undefined)
      // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
      var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
      if (toRemove) element.removeAttribute(attrName);
      else element.setAttribute(attrName, attrValue.toString());
    });
  }
};
ko.bindingHandlers['advstyle'] = {
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(styleName, styleValueAccessor) {
      var styleValue;
      if (styleName.match(/Px$/)) {
        styleName = styleName.substr(0, styleName.length - 2);
        styleValue = element.style[styleName];
        if (styleValue.match(/px$/)) {
          styleValue = styleValue.replace(/px$/, '');
        } else {
          console.log("AdvStyle binding found an unexpected default value", styleName, styleValue, element);
        }
      } else {
        styleValue = element.style[styleName];
      }

      if (ko.isWriteableObservable(styleValueAccessor)) {
        var oldValue = styleValueAccessor();
        if (oldValue != styleValue) {
          styleValueAccessor(styleValue);
          if (oldValue !== null) {
            console.log("AdvStyle found a value different from the default", styleName, oldValue, styleValue);
          }
        }
      }
    });
  },
  'update': function(element, valueAccessor) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(styleName, styleValue) {
      styleValue = ko.utils.unwrapObservable(styleValue);

      if (styleValue === null || typeof styleValue === 'undefined' || styleValue === false) {
        styleValue = "";
      }

      if (styleName.match(/Px$/)) {
        styleName = styleName.substr(0, styleName.length - 2);
        styleValue = styleValue + "px";
      }

      element.style[styleName] = styleValue;
    });
  }
};

// Utility to log inizialization and disposal of DOM elements.
ko.bindingHandlers['domlog'] = {
  init: function(element, valueAccessor) {
    console.log("initialized", element);
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      console.log("disposed", element);
    });
  }
};

ko.bindingHandlers['fudroppable'] = {
  init: function(element, valueAccessor) {
    var opt = valueAccessor() || {};
    var timeoutsObj = {};

    var over = function(timeouts, dropZoneTimeout, element, className, observable, event) {

      if (!timeouts[dropZoneTimeout]) {
        if (typeof className !== 'undefined') {
          element.classList.add(className);
        }
        if (ko.isWriteableObservable(observable) && !observable()) {
          observable(true);
        }
      } else {
        global.clearTimeout(timeouts[dropZoneTimeout]);
      }

      var stop = function() {
        timeouts[dropZoneTimeout] = null;
        if (typeof className !== 'undefined') {
          element.classList.remove(className);
        }
        if (ko.isWriteableObservable(observable) && observable()) {
          observable(false);
        }
      };

      if (event.type == 'dragleave') stop();
      else {
        // Using 100 it doens't work fine on Linux (chome/firefox), using 200 still shows issues on slow Linux boxes
        timeouts[dropZoneTimeout] = global.setTimeout(stop, 500);
      }

    };

    if (opt.active || opt.activeClass) {
      ko.utils.registerEventHandler(global, 'dragover', over.bind(undefined, timeoutsObj, 'activeTimeout', element, opt.activeClass, opt.active));
    }
    if (opt.hoverClass) {
      // dragenter and dragleave are not required but they speedup feedback when used.
      ko.utils.registerEventHandler(element, 'dragover dragenter dragleave', over.bind(undefined, timeoutsObj, 'hoverTimeout', element, opt.hoverClass, undefined));
    }
  }
};

ko.bindingHandlers['fileupload'] = {
  extendOptions: {},
  // remoteFilePreprocessor method has been set in app.js
  init: function(element, valueAccessor) {
    // TODO domnodedisposal doesn't work when the upload is done by "clicking"
    // Probably jquery-fileupload moves the DOM somewhere else so that KO doesn't
    // detect the removal anymore.
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).fileupload('destroy');
    });

    // if we leave the title the native control will show us a tooltip we don't want.
    // In WebKit the right way to remove it is leaving a "whitespace".
    // In Gecko we have to set it empty.
    if (global.webkitURL)
      $(element).attr('title', ' ');
    else
      $(element).attr('title', '');
  },

  update: function(element, valueAccessor) {
    var options = valueAccessor() || {};

    var $fu = $(element);
    var $parent = $fu.parents('.uploadzone');

    var dataValue = options.data;
    options.data = undefined;

    var canvasPreview = options.canvasPreview;

    // TODO remove hardcoded url
    ko.utils.extend(options, {
      url: '/upload/',
      dataType: 'json',
      dropZone: $parent.find('.mo-uploadzone')[0],
      autoUpload: true,
      acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
      maxFileSize: 1024 * 1024,
      // Enable image resizing, except for Android and Opera,
      // which actually support image resizing, but fail to
      // send Blob objects via XHR requests:
      disableImageResize: /Android(?!.*Chrome)|Opera/.test(global.navigator.userAgent),
      previewMaxWidth: 200,
      previewMaxHeight: 200,
      previewCrop: false,
      replaceFileInput: false, // replaceFileInput true breaks after uploading using "input" (using mouse clic instead of dropping)

      messages: {
        // client side
        unknownError: 'Unknown error',
        uploadedBytes: 'Uploaded bytes exceed file size',
        maxNumberOfFiles: 'Maximum number of files exceeded',
        acceptFileTypes: 'File type not allowed',
        maxFileSize: 'File is too large',
        minFileSize: 'File is too small',
        // server side
        post_max_size: 'The uploaded file exceeds the post_max_size directive in php.ini',
        max_file_size: 'File is too big',
        min_file_size: 'File is too small',
        accept_file_types: 'Filetype not allowed',
        max_number_of_files: 'Maximum number of files exceeded',
        max_width: 'Image exceeds maximum width',
        min_width: 'Image requires a minimum width',
        max_height: 'Image exceeds maximum height',
        min_height: 'Image requires a minimum height',
        abort: 'File upload aborted',
        image_resize: 'Failed to resize image',
        generic: 'Unexpected upload error'
      }
    });

    ko.utils.extend(options, ko.bindingHandlers['fileupload'].extendOptions);

    var working = 0;
    var firstWorked = '';

    var cleanup = function() {
      if (--working === 0) {
        if (dataValue) {
          dataValue(firstWorked);
        }
        firstWorked = '';
        if (canvasPreview) {
          $parent.find('img').show();
          $parent.find('canvas').remove();
        }
        $parent.removeClass("uploading");
        $parent.find('.progress-bar').css('width', 0);
      }
    };

    var translatedMessage = function(text) {
      if (typeof options.messages == 'object' && options.messages !== null) {
        var match = text.match(/^([^ ]+)(.*)$/);
        if (match) {
          if (typeof options.messages[match[1]] !== 'undefined') {
            return options.messages[match[1]] + match[2];
          }
        }
      }
      return text;
    };

    $fu.fileupload(options);

    var events = ['fileuploadadd', 'fileuploadprocessalways', 'fileuploadprogressall', 'fileuploaddone', 'fileuploadfail'];
    var eventHandler = function(e, data) {
      if (e.type == 'fileuploadadd') {
        working++;
      }
      if (e.type == 'fileuploadfail') {
        console.log("fileuploadfail", e, data);
        if (options.onerror) {
          if (data.errorThrown === '' && data.textStatus == 'error') {
            options.onerror(translatedMessage('generic'));
          } else {
            options.onerror(translatedMessage('generic (' + data.errorThrown + ')'));
          }
        }
        cleanup();
      }
      if (e.type == 'fileuploaddone') {
        if (typeof data.result.files[0].url !== 'undefined') {
          if (options.onfile) {
            for (var i = 0; i < data.result.files.length; i++) {
              data.result.files[i] = ko.bindingHandlers['fileupload'].remoteFilePreprocessor(data.result.files[i]);
              options.onfile(data.result.files[i]);
            }
          }

          if (firstWorked === '') firstWorked = data.result.files[0].url;

          if (canvasPreview) {
            var img = new Image();
            img.onload = cleanup;
            img.onerror = cleanup;
            img.src = data.result.files[0].url;
          } else {
            cleanup();
          }
        } else if (typeof data.result.files[0].error !== 'undefined') {
          console.log("remote error", e, data);
          if (options.onerror) {
            options.onerror(translatedMessage(data.result.files[0].error));
          }
          cleanup();
        } else {
          console.log("unexpected error", e, data);
          if (options.onerror) {
            options.onerror(translatedMessage('generic (Unexpected Error retrieving uploaded file)'));
          }
          cleanup();
        }
      }
      if (e.type == 'fileuploadprocessalways') {
        var index = data.index,
          file = data.files[index];
        if (file.preview && index === 0) {
          // if we have a canvas we had multiple uploaded files
          if ($parent.find('canvas').length === 0) {
            if (canvasPreview) {
              var el = $(file.preview).css('width', '100%'); // .css('position', 'absolute').css('left', '0');
              $parent.find('img').hide();
              $parent.prepend(el);
            }
            $parent.addClass("uploading");
            $parent.find('.progress-bar').css('width', 0);
          }
        }
        if (file.error) {
          // File type not allowed
          // File is too large
          if (options.onerror) {
            options.onerror(translatedMessage(file.error));
          }
          cleanup();
        }
      }
      if (e.type == 'fileuploadprogressall') {
        var progress = parseInt(data.loaded / data.total * 100, 10);
        $parent.find('.progress-bar').css('width', progress + '%');
      }
    };
    for (var i = events.length - 1; i >= 0; i--) {
      var eventName = events[i];
      $fu.on(eventName, eventHandler);
    }
    if (!$.support.fileInput) {
      $fu.prop('disabled', true).parent().addClass('disabled');
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],58:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

ko.bindingHandlers['ifSubs'] = {
  // cloneNodes from ko.utils.cloneNodes (missing in minimized KO)
  cloneNodes: function(nodesArray, shouldCleanNodes) {
    for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
      var clonedNode = nodesArray[i].cloneNode(true);
      newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
    }
    return newNodesArray;
  },
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var didDisplayOnLastUpdate,
      savedNodes,
      valueAcc = valueAccessor();
    if (typeof valueAcc.data.subsCount === 'undefined') {
      ko.extenders['subscriptionsCount'](valueAcc.data);
      // NOTE I can't simply listen on "thresholds" because multiple bindings to the same observable could use different thresholds.
    }
    ko.computed(function() {
      var dataValue = ko.utils.unwrapObservable(valueAccessor().data.subsCount),
        isFirstRender = !savedNodes,
        shouldDisplay, needsRefresh, gutter;

      gutter = -(typeof valueAccessor().gutter !== 'undefined' ? valueAccessor().gutter : 1);
      shouldDisplay = dataValue + (didDisplayOnLastUpdate ? gutter : 0) >= ko.utils.unwrapObservable(valueAcc.threshold);
      if (typeof valueAccessor().not !== 'undefined' && valueAccessor().not) {
        shouldDisplay = !shouldDisplay;
      }
      needsRefresh = isFirstRender || (shouldDisplay !== didDisplayOnLastUpdate);

      if (needsRefresh) {
        // Save a copy of the inner nodes on the initial update, but only if we have dependencies.
        if (isFirstRender && ko.computedContext.getDependenciesCount()) {
          savedNodes = ko.bindingHandlers['ifSubs'].cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */ );
        }

        if (shouldDisplay) {
          if (!isFirstRender) {
            ko.virtualElements.setDomNodeChildren(element, ko.bindingHandlers['ifSubs'].cloneNodes(savedNodes));
          }
          ko.applyBindingsToDescendants(bindingContext, element);
        } else {
          ko.virtualElements.emptyNode(element);
        }

        didDisplayOnLastUpdate = shouldDisplay;
      }
    }, null, {
      disposeWhenNodeIsRemoved: element
    });
    return {
      'controlsDescendantBindings': true
    };
  }
};
ko.virtualElements.allowedBindings['ifSubs'] = true;

// ko.isWritableObservable (without "e") has been introduced in 3.2.0, that is also our min requirement.
// minimized knockout "obfuscate" the beforeSubscriptionAdd and afterSubscriptionRemove methods that we hack here.
// so we have to explicitly know that.
var beforeSubscriptionProp;
var afterSubscriptionProp;
if (typeof ko.DEBUG !== 'undefined' && typeof ko.isWritableObservable !== 'undefined') {
  beforeSubscriptionProp = 'beforeSubscriptionAdd';
  afterSubscriptionProp = 'afterSubscriptionRemove';
} else if (ko.version == "3.2.0") {
  beforeSubscriptionProp = 'va';
  afterSubscriptionProp = 'nb';
} else if (ko.version == "3.3.0") {
  beforeSubscriptionProp = 'ja';
  afterSubscriptionProp = 'ua';
} else if (ko.version == "3.4.0") {
  beforeSubscriptionProp = 'sa';
  afterSubscriptionProp = 'Ia';
}
else throw "Unsupported minimized Knockout version " + ko.version + " (supported DEBUG or minimized 3.2.0 ... 3.4.0)";

// internally used by ifsubs binding.
// WARNING this break when used with pureComputed or deferredEvaluated
ko.extenders['subscriptionsCount'] = function(target, l1, l2) {
  if (typeof target.subsCount === 'undefined') {
    target.subsCount = ko.observable(target.getSubscriptionsCount()).extend({
      notify: 'always'
    });
    var underlyingBeforeSubscriptionAddFunction = target[beforeSubscriptionProp];
    var underlyingAfterSubscriptionRemoveFunction = target[afterSubscriptionProp];
    target[beforeSubscriptionProp] = function(event) {
      if (underlyingBeforeSubscriptionAddFunction) underlyingBeforeSubscriptionAddFunction.call(target, event);
      var c = target.getSubscriptionsCount() + 1;
      if (typeof l1 === 'undefined' || c == l1 || typeof l2 === 'undefined' || c == l2) target.subsCount(c);
    };
    target[afterSubscriptionProp] = function(event) {
      if (underlyingAfterSubscriptionRemoveFunction) underlyingAfterSubscriptionRemoveFunction.call(target, event);
      var c = target.getSubscriptionsCount();
      if (typeof l1 === 'undefined' || c == l1 || typeof l2 === 'undefined' || c == l2) target.subsCount(c);
    };
  } else {
    console.log("already applied subscriptionCount to observable");
  }
  return null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],59:[function(require,module,exports){
(function (global){
"use strict";

// Overrides native jQuery spinner to avoid validation of the "step".
// We wants to use the step but also wants to leave the user the ability to select specific values.

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var spinner = (typeof window !== "undefined" ? window['jQuery']['ui']['spinner'] : typeof global !== "undefined" ? global['jQuery']['ui']['spinner'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

if (typeof spinner == 'undefined') throw "Cannot find jquery-ui spinner widget dependency!";

$.widget("ui.spinner", spinner, {
  _adjustValue: function(value) {
    var adj = this._super(value);

    var options = this.options;

    // fix precision from bad JS floating point math
    value = parseFloat(value.toFixed(this._precision()));

    // clamp the value
    if (options.max !== null && value > options.max) {
      return options.max;
    }
    if (options.min !== null && value < options.min) {
      return options.min;
    }

    return value;
  }
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],60:[function(require,module,exports){
(function (global){
"use strict";

// Overrides native jQuery tabs to make tabs working also when using a base tag
// in order to avoid conflicts you have to add a data-local="true" attribute to your tab links.

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
var tabs = (typeof window !== "undefined" ? window['jQuery']['ui']['tabs'] : typeof global !== "undefined" ? global['jQuery']['ui']['tabs'] : null);

if (typeof tabs == 'undefined') throw "Cannot find jquery-ui tabs widget dependency!";

$.widget("ui.tabs", tabs, {
  _isLocal: function( anchor ) {
    if (anchor.getAttribute('data-local') == "true") return true;
    else return this._superApply( arguments );
  }
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],61:[function(require,module,exports){
(function (global){
"use strict";
/* globals global: false */

function pushTemplate(templateName, templateText) {
  var scriptTag = global.document.createElement('script');
  scriptTag.setAttribute('type', 'text/html');
  scriptTag.setAttribute('id', templateName);
  scriptTag.text = templateText;
  global.document.body.appendChild(scriptTag);
}

function removeTemplate(templateName) {
  var el = global.document.getElementById(templateName);
  if (el) el.parentNode.removeChild(el);
}

function init() {}

function getTemplateContent(id) {
  var el = global.document.getElementById(id);
  if (el) return el.innerHTML;
  else return undefined;
}

module.exports = {
  init: init,
  addTemplate: pushTemplate,
  removeTemplate: removeTemplate,
  getTemplateContent: getTemplateContent
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],62:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
var tinymce = (typeof window !== "undefined" ? window['tinymce'] : typeof global !== "undefined" ? global['tinymce'] : null);

var timeout;

var render = function() {

  timeout = undefined;

  if (typeof tinymce.activeEditor !== 'undefined' && typeof tinymce.activeEditor.theme !== 'undefined' && typeof tinymce.activeEditor.theme.panel !== 'undefined' && typeof tinymce.activeEditor.theme.panel.visible !== 'undefined') {
    // @see FloatPanel.js function repositionPanel(panel)
    // First condition group is for Tinymce 4.0/4.1
    // Second condition group is for Tinymce 4.2/4.3 where "._property" are now available as ".state.get('property')".
    if ((typeof tinymce.activeEditor.theme.panel._visible !== 'undefined' && tinymce.activeEditor.theme.panel._visible && tinymce.activeEditor.theme.panel._fixed) || 
        (typeof tinymce.activeEditor.theme.panel.state !== 'undefined' && tinymce.activeEditor.theme.panel.state.get('visible') && tinymce.activeEditor.theme.panel.state.get('fixed'))) {
      tinymce.activeEditor.theme.panel.fixed(false);
    }

    tinymce.activeEditor.nodeChanged();
    // Don't force tinymce to be visible on scrolls
    // If setteed, This will show the tinymce controls event when non are selected
    // https://github.com/goodenough/mosaico/issues/7#issuecomment-236853305
    // tinymce.activeEditor.theme.panel.visible(true);
    if (tinymce.activeEditor.theme.panel.layoutRect().y <= 40)
      tinymce.activeEditor.theme.panel.moveBy(0, 40 - tinymce.activeEditor.theme.panel.layoutRect().y);

  }
};

ko.bindingHandlers.wysiwygScrollfix = {
  'scroll': function(event) {
    if (timeout) global.clearTimeout(timeout);
    timeout = global.setTimeout(render, 50);
  },
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("scroll", ko.bindingHandlers.wysiwygScrollfix.scroll);
    });

    $(element).on("scroll", ko.bindingHandlers.wysiwygScrollfix.scroll);

  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],63:[function(require,module,exports){
(function (global){
"use strict";

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

var _scrollIntoView = function($element, alignTop, scrollParent, moveBy) {
  var currentScrollTop = scrollParent.scrollTop();
  var newScrollTop = currentScrollTop - moveBy - (alignTop ? 20 : -20);
  // iframe scrolls the window and animation is not supported
  var animate = typeof scrollParent[0].nodeType !== 'undefined';
  if (animate) {
    var action = {
      'scrollTop': "" + Math.round(newScrollTop) + "px"
    };
    var time = Math.round(Math.abs(newScrollTop - currentScrollTop));
    scrollParent.stop().animate(action, time);
  } else {
    scrollParent.scrollTop(newScrollTop);
  }
  // native scrollIntoView is not well supported and doesn't work fine.
  // element.scrollIntoView(alignTop);
};

ko.bindingHandlers.scrollIntoView = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var selected = ko.utils.unwrapObservable(valueAccessor());
    if (!selected) return;
    try {

      while (element.nodeType === 8) {
        // element is a comment, move to the next sibling...
        element = element.nextSibling;
      }
      if (element.nodeType !== 8) {
        var scrollParent = $(element).scrollParent();

        var parentTop;
        var relativeOffset = false;
        if (scrollParent[0].nodeType == 9) {
          // scrollparent is document, replacing with body...
          scrollParent = $(scrollParent[0].defaultView);
          parentTop = 0;
          relativeOffset = true;
        } else {
          parentTop = scrollParent.offset().top;
        }

        var parentHeight = scrollParent.height();
        var parentScroll = scrollParent.scrollTop();
        var parentBottom = parentTop + parentHeight;

        // scrollParent is the document.
        var $element = $(element);
        var elTop = $element.offset().top;
        // when we are in "iframe" with scrollbar everythijng changes.
        if (relativeOffset) elTop = elTop - parentScroll;
        var elHeight = $element.height();
        var elBottom = elTop + elHeight;
        if (elTop > parentTop && elTop + elHeight < parentBottom) {
          // both borders are visible => don't do anything.
        } else if (elHeight < parentHeight) {
          // if the block is smaller than the viewPort
          if (elTop < parentTop) _scrollIntoView(element, true, scrollParent, parentTop - elTop);
          // -> if the upper border is higher than the top, then I move it to the top.
          if (elBottom > parentBottom) _scrollIntoView(element, false, scrollParent, parentBottom - elBottom);
          // -> if the bottom border is lower than the bottom then I move it to the bottom.
        } else {
          // if the block is larger than the viewPort we do the opposite!
          // -> if the upper border is higher than the top and the lower is higher than the bottom I move the lower it to the bottom.
          if (elTop < parentTop && elBottom < parentBottom) _scrollIntoView(element, false, scrollParent, parentBottom - elBottom);
          // -> if the bottom border il lower than bottom and the upper is lower than the top I move the upper border to the viewport top
          if (elTop > parentTop && elBottom > parentBottom) _scrollIntoView(element, true, scrollParent, parentTop - elTop);
        }

        // element.scrollIntoView(true);
      }
    } catch (e) {
      console.log("TODO exception scrolling into view", e);
    }
  }
};
ko.virtualElements.allowedBindings['scrollIntoView'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],64:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var origTemplateSystem = require("./script-template.js");

var templates = {};

//define a template source that simply treats the template name as its content
ko.templateSources.stringTemplate = function(templateName, template) {
  this.templateName = templateName;
  this.template = template;
  this._data = {};
};

ko.utils.extend(ko.templateSources.stringTemplate.prototype, {
  data: function(key, value) {
    // console.log("data", key, value, this.templateName);
    if (arguments.length === 1) {
      return this._data[key];
    }

    this._data[key] = value;
  },
  text: function(value) {
    // console.log("text", value, this.templateName)
    if (arguments.length === 0) {
      return this.template;
    }
    this.template = value;
  }
});


//modify an existing templateEngine to work with string templates
function createStringTemplateEngine(templateEngine) {
  var orig = templateEngine.makeTemplateSource;
  templateEngine.makeTemplateSource = function(templateName) {
    if (typeof templates[templateName] !== 'undefined') {
      return new ko.templateSources.stringTemplate(templateName, templates[templateName]);
    } else {
      return orig(templateName);
    }
  };
  return templateEngine;
}

function pushTemplate(templateName, templateText) {
  templates[templateName] = templateText;
}

function removeTemplate(templateName) {
  if (typeof templates[templateName] !== 'undefined') {
    templates[templateName] = undefined;
  } else {
    origTemplateSystem.removeTemplate(templateName);
  }
}

function init() {
  ko.setTemplateEngine(createStringTemplateEngine(new ko.nativeTemplateEngine()));
}

function getTemplateContent(id) {
  if (typeof templates[id] !== 'undefined') {
    return templates[id];
  } else {
    return origTemplateSystem.getTemplateContent(id);
  }
}

module.exports = {
  init: init,
  addTemplate: pushTemplate,
  removeTemplate: removeTemplate,
  getTemplateContent: getTemplateContent
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./script-template.js":61}],65:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

var extendValueAccessor = function(valueAccessor, obj) {
  return function() {
    ko.utils.extend(obj, valueAccessor());
    return obj;
  };
};

var options = {
  show: {
    delay: 500
  },
  track: true,
  items: '[title][title!=""][title!=" "]'
};

ko.bindingHandlers.tooltips = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    if (typeof $.fn.tooltip !== 'undefined' && typeof ko.bindingHandlers.tooltip !== 'undefined') {
      // position: { my: "left+15 top+15", at: "center+30 center+30" }
      // NOTE title with "" and " " is needed to avoid default tooltips in native file upload controls
      return ko.bindingHandlers.tooltip.init(element, extendValueAccessor(valueAccessor, options), allBindingsAccessor, data, context);
    }
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    if (typeof $.fn.tooltip !== 'undefined' && typeof ko.bindingHandlers.tooltip !== 'undefined') {
      return ko.bindingHandlers.tooltip.update(element, extendValueAccessor(valueAccessor, options), allBindingsAccessor, data, context);
    }
  },
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],66:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// equals to "value" binding but apply "invalid" class if "pattern" attribute is defined and value matches the rule
ko.bindingHandlers['validatedValue'] = {
	init: function(element, valueAccessor, allBindings) {
		var newValueAccessor = valueAccessor;
		if (typeof element.pattern !== 'undefined') {
			var re = new RegExp('^(?:' + element.pattern + ')$');
			var computed = ko.computed({
				read: function() {
					var res = ko.utils.unwrapObservable(valueAccessor());
					// TODO support for element.required ?
					var valid = res === null || res === '' || re.test(res);
					// IE11 doesn't support classList.toggle('invalid', state)
					if (valid) {
						element.classList.remove('invalid');
					} else {
						element.classList.add('invalid');
					}
					return res;
				},
				write: ko.isWriteableObservable(valueAccessor()) && function(value) {
					// @see https://github.com/voidlabs/mosaico/issues/103
					ko.selectExtensions.writeValue(element, value);
					var updValue = ko.selectExtensions.readValue(element);
					valueAccessor()(updValue);
				},
				disposeWhenNodeIsRemoved: element
			});
			newValueAccessor = function() {
				return computed;
			};
		}
		ko.bindingHandlers['value'].init(element, newValueAccessor, allBindings);
	}
};
ko.expressionRewriting._twoWayBindings['validatedValue'] = true;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],67:[function(require,module,exports){
(function (global){
"use strict";
/* globals global:false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

ko.bindingHandlers['uniqueId'] = {
  currentIndex: 0,
  'init': function(element, valueAccessor) {
    var data = ko.utils.unwrapObservable(valueAccessor()) || {};
    if (data.id() === '') {
      var id, el, prefix;
      // TODO we need a better prefix
      prefix = 'ko_' + (typeof data.type !== 'undefined' ? ko.utils.unwrapObservable(data.type) : 'block');
      // when loading an exising model, IDs could be already assigned.
      do {
        id = prefix + '_' + (++ko.bindingHandlers['uniqueId'].currentIndex);
        el = global.document.getElementById(id);
        if (el) {
          // when loading an existing model my "currentIndex" is empty.
          // but we have existing blocks, so I must be sure I don't reuse their IDs.
          // We use different prefixes (per block type) so that a hidden block 
          // (for which we have no id in the page, e.g: preheader in versafix-1)
          // will break everthing once we reuse its name.
        }
      } while (el);
      data.id(id);
    }
  }
};
ko.virtualElements.allowedBindings['uniqueId'] = true;

ko.bindingHandlers['virtualAttr'] = {
  update: function(element, valueAccessor) {
    if (element.nodeType !== 8) {
      ko.bindingHandlers['attr'].update(element, valueAccessor);
    }
  }
};
ko.virtualElements.allowedBindings['virtualAttr'] = true;

ko.bindingHandlers['virtualAttrStyle'] = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      // In "preview" we also set "replacedstyle" so to have an attribute to be used by IE (IE breaks the STYLE) to do the export.
      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      var attrs = ["style"];
      if (isNotWysiwygMode) attrs.push("replacedstyle");
      var attrValue = ko.utils.unwrapObservable(valueAccessor());
      for (var i = 0; i < attrs.length; i++) {
        var attrName = attrs[i];
        var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
        if (toRemove)
          element.removeAttribute(attrName);
        else
          element.setAttribute(attrName, attrValue.toString());
      }
    }
  }
};
ko.virtualElements.allowedBindings['virtualAttrStyle'] = true;

ko.bindingHandlers['virtualStyle'] = {
  update: function(element, valueAccessor) {
    if (element.nodeType !== 8) {
      ko.bindingHandlers['style'].update(element, valueAccessor);
    }
  }
};
ko.virtualElements.allowedBindings['virtualStyle'] = true;


ko.bindingHandlers['virtualHtml'] = {
  init: ko.bindingHandlers['html'].init,
  update: function(element, valueAccessor) {
    if (element.nodeType === 8) {
      var html = ko.utils.unwrapObservable(valueAccessor());

      ko.virtualElements.emptyNode(element);
      if ((html !== null) && (html !== undefined)) {
        if (typeof html !== 'string') {
          html = html.toString();
        }

        var parsedNodes = ko.utils.parseHtmlFragment(html);
        if (parsedNodes) {
          var endCommentNode = element.nextSibling;
          for (var i = 0, j = parsedNodes.length; i < j; i++)
            endCommentNode.parentNode.insertBefore(parsedNodes[i], endCommentNode);
        }
      }
    } else { // plain node
      ko.bindingHandlers['html'].update(element, valueAccessor);
    }

    // Content for virtualHTML must not be parsed by KO, it is simple content.
    return {
      controlsDescendantBindings: true
    };
  }
};
ko.virtualElements.allowedBindings['virtualHtml'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],68:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var tinymce = (typeof window !== "undefined" ? window['tinymce'] : typeof global !== "undefined" ? global['tinymce'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
require("./eventable.js");

ko.bindingHandlers.wysiwygOrHtml = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');

    if (isNotWysiwygMode)
      return ko.bindingHandlers['virtualHtml'].init();
    else
      return ko.bindingHandlers.wysiwyg.init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (isNotWysiwygMode)
      return ko.bindingHandlers['virtualHtml'].update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
    //else 
    //  return ko.bindingHandlers.wysiwyg.update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygOrHtml'] = true;

ko.bindingHandlers.wysiwygHref = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      var v = valueAccessor();

      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      // console.log("XXX", bindingContext.templateMode, isNotWysiwygMode, element.getAttribute("href"));
      if (isNotWysiwygMode) {
        element.setAttribute('target', '_new');
      } else {
        /*jshint scripturl:true*/
        // 20150226: removed href to work around FF issues with <a href=""><div contenteditable="true">..</div></a>
        // element.setAttribute('href', 'javascript:void(0)');
        // 20150309: on IE, an editable <a href="" data-editable=""> prevent tinymce toolbar to be shown.
        //           so I change behaviour based on the use of "wysiwygOrHtml"
        // @see: http://www.tinymce.com/develop/bugtracker_view.php?id=7432
        var allbindings = allBindingsAccessor();
        if (typeof allbindings.wysiwygOrHtml !== 'undefined') {
          element.setAttribute('href', 'javascript:void(0)');
        } else {
          element.removeAttribute('href');
          element.setAttribute('disabledhref', '#');
        }
      }
    }
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      // NOTE this unwrap is needed also in "wysiwyg" mode, otherwise dependency tracking dies.
      var attrValue = ko.utils.unwrapObservable(valueAccessor());
      if (isNotWysiwygMode) {
        if ((attrValue === false) || (attrValue === null) || (attrValue === undefined))
          element.removeAttribute('href');
        else
          element.setAttribute('href', attrValue.toString());
      }
    }
  }
};
ko.virtualElements.allowedBindings['wysiwygHref'] = true;

ko.bindingHandlers.wysiwygSrc = {
  convertedUrl: function(src, method, width, height) {
    var res = src + "?method=" + method + "&width=" + width + (height !== null ? "&height=" + height : '');
    console.log("basic converterUrl", res);
    return res;
  },
  placeholderUrl: function(plwidth, plheight, pltext) {
    var placeholdersrc = "'http://lorempixel.com/g/'+" + plwidth + "+'/'+" + plheight + "+'/abstract/'+encodeURIComponent(" + pltext + ")";
    // http://placehold.it/200x150.png/cccccc/333333&text=placehold.it#sthash.nA3r26vR.dpuf
    // placeholdersrc = "'http://placehold.it/'+"+width+"+'x'+"+height+"+'.png/cccccc/333333&text='+"+size;
    // placeholdersrc = "'"+converterUtils.addSlashes(defaultValue)+"'";
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor());
    var attrValue = ko.utils.unwrapObservable(value.src);
    var placeholderValue = ko.utils.unwrapObservable(value.placeholder);
    var width = ko.utils.unwrapObservable(value.width);
    var height = ko.utils.unwrapObservable(value.height);
    if ((attrValue === false) || (attrValue === null) || (attrValue === undefined) || (attrValue === '')) {
      if (typeof placeholderValue == 'object' && placeholderValue !== null) element.setAttribute('src', ko.bindingHandlers.wysiwygSrc.placeholderUrl(placeholderValue.width, placeholderValue.height, placeholderValue.text));
      else element.removeAttribute('src');
    } else {
      var method = ko.utils.unwrapObservable(value.method);
      if (!method) method = width > 0 && height > 0 ? 'cover' : 'resize';
      var src = ko.bindingHandlers.wysiwygSrc.convertedUrl(attrValue.toString(), method, width, height);
      element.setAttribute('src', src);
    }
    if (typeof width !== 'undefined' && width !== null) element.setAttribute("width", width);
    else element.removeAttribute("width");
    if (typeof height !== 'undefined' && height !== null) element.setAttribute("height", height);
    else element.removeAttribute("height");
  }
};

ko.bindingHandlers.wysiwygId = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      element.setAttribute('id', ko.utils.unwrapObservable(valueAccessor()));
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      element.setAttribute('id', ko.utils.unwrapObservable(valueAccessor()));
  }
};
ko.virtualElements.allowedBindings['wysiwygId'] = true;

// used on editable "item" so to bind clicks only in wysiwyg mode.
ko.bindingHandlers.wysiwygClick = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      ko.bindingHandlers.click.init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygClick'] = true;

// used on editable "item" so to bind css only in wysiwyg mode.
ko.bindingHandlers.wysiwygCss = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      ko.bindingHandlers.css.update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygCss'] = true;

ko.bindingHandlers.wysiwygImg = {
  makeTemplateValueAccessor: function(valueAccessor, bindingContext) {
    return function() {
      var isWysiwygMode = (typeof bindingContext.templateMode != 'undefined' && bindingContext.templateMode == 'wysiwyg');

      var modelValue = valueAccessor(),
        unwrappedValue = ko.utils.peekObservable(modelValue); // Unwrap without setting a dependency here

      // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
      ko.utils.unwrapObservable(modelValue);

      return {
        'name': isWysiwygMode ? unwrappedValue['_editTemplate'] : unwrappedValue['_template'],
        'templateEngine': ko.nativeTemplateEngine.instance
      };
    };
  },
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['wysiwygImg'].makeTemplateValueAccessor(valueAccessor, bindingContext));
  },
  'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    bindingContext = bindingContext['extend'](valueAccessor());
    return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['wysiwygImg'].makeTemplateValueAccessor(valueAccessor, bindingContext), allBindings, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygImg'] = true;

// NOTE: there are issues with the "raw" format and trash left around by tinymce workarounds for contenteditable issues.
// setting "forced_root_block: false" disable the default behaviour of adding a wrapper <p> when needed and this seems to fix many issues in IE.
// also, maybe we should use the "raw" only for the "before SetContent" and instead read the "non-raw" content (the raw content sometimes have data- attributes and too many ending <br> in the code)
ko.bindingHandlers.wysiwyg = {
  currentIndex: 0,
  standardOptions: {},
  fullOptions: {
    toolbar1: 'bold italic forecolor backcolor hr styleselect removeformat | link unlink | pastetext code',
    //toolbar1: "bold italic | forecolor backcolor | link unlink | hr | pastetext code", // | newsletter_profile newsletter_optlink newsletter_unsubscribe newsletter_showlink";
    //toolbar2: "formatselect fontselect fontsizeselect | alignleft aligncenter alignright alignjustify | bullist numlist",
    plugins: ["link hr paste lists textcolor code"],
    // valid_elements: 'strong/b,em/i,*[*]',
    // extended_valid_elements: 'strong/b,em/i,*[*]',
    // Removed: image fullscreen contextmenu 
    // download custom:
    // jquery version con legacyoutput, anchor, code, importcss, link, paste, textcolor, hr, lists
  },
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    // TODO ugly, but works...
    ko.bindingHandlers.focusable.init(element);

    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      tinymce.remove('#' + element.getAttribute('id'));
    });

    var value = valueAccessor();

    if (!ko.isObservable(value)) throw "Wysiwyg binding called with non observable";
    if (element.nodeType === 8) throw "Wysiwyg binding called on virtual node, ignoring...." + element.innerHTML;

    var selectorId = element.getAttribute('id');
    if (!selectorId) {
      selectorId = 'wysiwyg_' + (++ko.bindingHandlers['wysiwyg'].currentIndex);
      element.setAttribute('id', selectorId);
    }

    var fullEditor = element.tagName == 'DIV' || element.tagName == 'TD';
    var isSubscriberChange = false;
    var thisEditor;
    var isEditorChange = false;

    var options = {
      selector: '#' + selectorId,
      inline: true,
      // maybe not needed, but won't hurt.
      hidden_input: false,
      plugins: ["paste"],
      toolbar1: "bold italic",
      toolbar2: "",
      // we have to disable preview_styles otherwise tinymce push inline every style he things will be applied and this makes the style menu to inherit color/font-family and more.
      preview_styles: false,
      paste_as_text: true,
      language: 'en',
      schema: "html5",
      extended_valid_elements: 'strong/b,em/i,*[*]',
      menubar: false,
      skin: 'gray-flat',
      setup: function(editor) {
        // TODO change sometimes doesn't trigger (we have to document when)
        // listening on keyup would increase correctness but we would need a rateLimit to avoid flooding.
        editor.on('change redo undo', function() {
          if (!isSubscriberChange) {
            isEditorChange = true;
            // we failed with other ways to do this:
            // value($(element).html());
            // value(element.innerHTML);
            value(editor.getContent({
              format: 'raw'
            }));
            isEditorChange = false;
          }
        });
        // Clicking on the element on focus change allow the "clic" code to be triggered and propagate the selection.
        // Not elegant, maybe we have better options.
        editor.on('focus', function() {
          // Used by scrollfix.js (maybe this is not needed by new scrollfix.js)
          editor.nodeChanged();
          editor.getElement().click();
        });

        // NOTE: this fixes issue with "leading spaces" in default content that were lost during initialization.
        editor.on('BeforeSetContent', function(args) {
          if (args.initial) args.format = 'raw';
        });

        /* NOTE: disabling "ENTER" in tiny editor, not a good thing but may be needed to work around contenteditable issues
        if (!fullEditor) {
          // se non abbiamo il "full Editor", disabilitiamo l'invio. (vari bug)
          editor.on('keydown', function(e) {
            if (e.keyCode == 13) { e.preventDefault(); }
          });
        }
        */

        thisEditor = editor;

      }
    };

    ko.utils.extend(options, ko.bindingHandlers.wysiwyg.standardOptions);
    if (fullEditor) ko.utils.extend(options, ko.bindingHandlers.wysiwyg.fullOptions);

    // we have to put initialization in a settimeout, otherwise switching from "1" to "2" columns blocks
    // will start the new editors before disposing the old ones and IDs get temporarily duplicated.
    // using setTimeout the dispose/create order is correct on every browser tested.
    global.setTimeout(function() {
      tinymce.init(options);
    });

    ko.computed(function() {
      var content = ko.utils.unwrapObservable(valueAccessor());
      if (!isEditorChange) {
        try {
          isSubscriberChange = true;
          // we failed setting contents in other ways...
          // $(element).html(content);
          if (typeof thisEditor !== 'undefined') {
            thisEditor.setContent(content, {
              format: 'raw'
            });
          } else {
            ko.utils.setHtml(element, content);
          }
        } catch (e) {
          console.log("TODO exception setting content to editable element", typeof thisEditor, e);
        }
        isSubscriberChange = false;
      }
    }, null, {
      disposeWhenNodeIsRemoved: element
    });

    // do not parse html content for KO bindings!!
    return {
      controlsDescendantBindings: true
    };

  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./eventable.js":54}],69:[function(require,module,exports){
"use strict";
var console = require("./../../../bower_components/console-browserify/index.js");

// returns 0 if equal (0.0.x release), 1 with backward compatible additions (0.x.0 release), 2 on lost data or incompatible data (x.0.0 release)
var checkModel = function(reference, blockDefs, model, origPrefix, reverse) {
  var blockDefsObj, i, prefix;
  var valid = 0;
  if (typeof reverse == 'undefined') reverse = false;
  if (typeof blockDefs !== 'undefined' && typeof blockDefs.splice == 'function') {
    blockDefsObj = {};
    for (i = 0; i < blockDefs.length; i++) blockDefsObj[blockDefs[i].type] = blockDefs[i];
  } else {
    blockDefsObj = blockDefs;
  }
  for (var prop in reference)
    if (reference.hasOwnProperty(prop)) {
      prefix = typeof origPrefix !== 'undefined' ? origPrefix + "." + prop : prop;
      if (!model.hasOwnProperty(prop)) {
        if (reverse) {
          console.warn("WARN Property ", prefix, "found in model is not defined by template: removing it!");
          valid = Math.max(valid, 2);
          delete reference[prop];
        } else {
          console.log("INFO Property ", prefix, "missing in model, cloning from reference!");
          valid = Math.max(valid, 1);
          model[prop] = reference[prop];
        }
      } else if (typeof model[prop] != typeof reference[prop]) {
        // se sono di tipo diverso allora provo a vedere se l'altro, convertito di tipo mantiene un valore equivalente.
        if (model[prop] !== null && reference[prop] !== null) {
          if (typeof model[prop] == 'string') {
            if (String(reference[prop]) != reference[prop]) {
              console.log("TODO Different type 1 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
              valid = Math.max(valid, 2);
            }
          } else if (typeof model[prop] == 'number') {
            if (Number(reference[prop]) != reference[prop]) {
              console.log("TODO Different type 2 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
              valid = Math.max(valid, 2);
            }
          } else {
            console.log("TODO Different type 3 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
            valid = Math.max(valid, 2);
          }
        }
      } else if (typeof reference[prop] == 'object') {
        if (reference[prop] !== null) {
          if (typeof reference[prop].splice !== 'undefined') {
            if (reference[prop].length > 0) {
              if (model[prop].length > 0) {
                // TODO needs sorting?
                var j = 0;
                for (i = 0; i < model[prop].length; i++) {
                  if (typeof model[prop][i].type == 'string') {
                    while (j < reference[prop].length && reference[prop][j].type !== model[prop][i].type) {
                      console.log("ignoring ", prefix, reference[prop][j].type, " block type in reference not found in model");
                      j++;
                    }
                    if (j >= reference[prop].length) {
                      console.log("WARN cannot find ", prefix, model[prop][i].type, " block in reference");
                      valid = Math.max(valid, 2);
                      break;
                    }
                    // reverse condition so to skip "deep traversing" on error
                    valid = Math.max(valid, checkModel(reference[prop][j], undefined, model[prop][i], prefix + "[" + i + "." + model[prop][i].type + "]"));
                  }
                }
              } else {
                // in the case of different array we check blockDefs
                for (i = 0; i < reference[prop].length; i++) {
                  if (typeof reference[prop][i].type !== 'string') {
                    console.log("TODO found an object with no type", prefix, reference[prop][i]);
                    valid = Math.max(valid, 2);
                  } else if (!blockDefsObj.hasOwnProperty(reference[prop][i].type)) {
                    console.warn("TODO the model uses a block type not defined by the template. REMOVING IT!!", prefix, reference[prop][i]);
                    reference[prop].splice(i, 1);
                    i--;
                    valid = Math.max(valid, 2);
                  } else {
                    valid = Math.max(valid, checkModel(blockDefsObj[reference[prop][i].type], blockDefsObj, reference[prop][i], prefix + "[" + i + "." + reference[prop][i].type + "]"));
                  }
                }
              }
            }
          } else {
            if (model[prop] === null) {
              if (reverse) {
                console.log("WARN Null object in model ", prefix, "instead of", reference[prop], "deleting it");
                valid = Math.max(valid, 2);
                delete reference[prop];
              } else {
                console.log("INFO Null object in model ", prefix, "instead of", reference[prop], "cloning it from the reference");
                valid = Math.max(valid, 1);
                model[prop] = reference[prop];
              }
            } else {
              valid = Math.max(valid, checkModel(reference[prop], blockDefsObj, model[prop], prefix, reverse));
            }
          }
        } else if (model[prop] !== null) {
          console.log("TODO Null in reference but not null in model", prefix, model[prop]);
          valid = Math.max(valid, 2);
        }
      } else if (typeof reference[prop] !== 'string' && typeof reference[prop] !== 'boolean' && typeof reference[prop] !== 'number') {
        console.log("TODO unsupported type", prefix, typeof reference[prop]);
        valid = Math.max(valid, 2);
      }

    }
  if (!reverse) valid = Math.max(valid, checkModel(model, blockDefs, reference, typeof origPrefix !== 'undefined' ? origPrefix + "!R" : "!R", true));
  return valid;
};

module.exports = checkModel;
},{"./../../../bower_components/console-browserify/index.js":1}],70:[function(require,module,exports){
"use strict";

// Parses CSS declarations and supports the property language (-ko-*) found between them.
// Create KO bindings but doesn't depend on KO.
// Needs a bindingProvider.

var converterUtils = require("./utils.js");
var cssParse = require("./../../../bower_components/mensch/lib/parser.js");
var console = require("./../../../bower_components/console-browserify/index.js");
var domutils = require("./domutils.js");

var _declarationValueLookup = function(declarations, propertyname, templateUrlConverter) {
  for (var i = declarations.length - 1; i >= 0; i--) {
    if (declarations[i].type == 'property' && declarations[i].name == propertyname) {
      return _declarationValueUrlPrefixer(declarations[i].value, templateUrlConverter);
    }
  }
  return null;
};

var _propToCamelCase = function(propName) {
  return propName.replace(/-([a-z])/g, function(match, contents, offset, s) {
    return contents.toUpperCase();
  });
};

var _declarationValueUrlPrefixer = function(value, templateUrlConverter) {
  if (value.match(/url\(.*\)/)) {
    var replaced = value.replace(/(url\()([^\)]*)(\))/g, function(matched, prefix, url, postfix) {
      var trimmed = url.trim();
      var apice = url.trim().charAt(0);
      if (apice == '\'' || apice == '"') {
        trimmed = trimmed.substr(1, trimmed.length - 2);
      } else {
        apice = '';
      }
      var newUrl = templateUrlConverter(trimmed);
      if (newUrl !== null) {
        return prefix + apice + newUrl + apice + postfix;
      } else {
        return matched;
      }
    });
    return replaced;
  } else {
    return value;
  }
};

var elaborateDeclarations = function(style, declarations, templateUrlConverter, bindingProvider, element, basicBindings, removeDisplayNone) {
  var newBindings = typeof basicBindings == 'object' && basicBindings !== null ? basicBindings : {};
  var newStyle = null;
  var skipLines = 0;
  if (typeof declarations == 'undefined') {
    var styleSheet = cssParse("#{\n" + style + "}", {
      comments: true,
      position: true
    });
    declarations = styleSheet.stylesheet.rules[0].declarations;
    skipLines = 1;
  }
  for (var i = declarations.length - 1; i >= 0; i--)
    if (declarations[i].type == 'property') {
      if (removeDisplayNone === true && declarations[i].name == 'display' && declarations[i].value == 'none') {
        if (newStyle === null) newStyle = style;
        newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, '');
      } else {
        var decl = declarations[i].name.match(/^-ko-(bind-|attr-)?([a-z0-9-]*?)(-if|-ifnot)?$/);
        if (decl !== null) {
          // rimozione dello stile -ko- dall'attributo style.
          if (newStyle === null && typeof style != 'undefined') newStyle = style;

          var isAttr = decl[1] == 'attr-';
          var isBind = decl[1] == 'bind-';
          var propName = decl[2];

          var isIf = decl[3] == '-if' || decl[3] == '-ifnot';
          var condDecl;
          var bindValue;
          var propDefaultValue;

          if (isIf) {
            condDecl = declarations[i].name.substr(0, declarations[i].name.length - decl[3].length);
            var conditionedDeclaration = _declarationValueLookup(declarations, condDecl, templateUrlConverter);
            if (conditionedDeclaration === null) throw "Unable to find declaration " + condDecl + " for " + declarations[i].name;
          } else {

            if ((isAttr || isBind) && (typeof element == 'undefined' && typeof style != 'undefined')) throw "Attributes and bind declarations are only allowed in inline styles!";

            var needDefaultValue = true;
            var bindType;
            if (isAttr) {
              propDefaultValue = domutils.getAttribute(element, propName);
              needDefaultValue = false;
              bindType = 'virtualAttr';
            } else if (!isBind) {
              needDefaultValue = typeof style !== 'undefined';
              if (needDefaultValue) propDefaultValue = _declarationValueLookup(declarations, propName, templateUrlConverter);
              bindType = 'virtualStyle';
            } else {
              bindType = null;
              if (propName == 'text') {
                if (typeof element !== 'undefined') {
                  propDefaultValue = domutils.getInnerText(element);
                } else {
                  needDefaultValue = false;
                }
              } else if (propName == 'html') {
                if (typeof element !== 'undefined') {
                  propDefaultValue = domutils.getInnerHtml(element);
                } else {
                  needDefaultValue = false;
                }
              } else {
                needDefaultValue = false;
              }
            }

            if (needDefaultValue && propDefaultValue === null) {
              console.error("Cannot find default value for", declarations[i].name, declarations);
              throw "Cannot find default value for " + declarations[i].name + ": " + declarations[i].value + " in " + element + " (" + typeof style + "/" + propName + ")";
            }
            var bindDefaultValue = propDefaultValue;

            var bindName = _propToCamelCase(propName);

            try {
              bindValue = converterUtils.expressionBinding(declarations[i].value, bindingProvider, bindDefaultValue);
            } catch (e) {
              console.error("Model ensure path failed", e.stack, "name", declarations[i].name, "value", declarations[i].value, "default", propDefaultValue, "element", element);
              throw e;
            }

            if (bindType !== null && typeof newBindings[bindType] == 'undefined') newBindings[bindType] = {};


            // Special handling for HREFs
            if (bindType == 'virtualAttr' && bindName == 'href') {
              bindType = null;
              bindName = 'wysiwygHref';
              // We have to remove it, otherwise we ends up with 2 rules writing it.
              if (typeof element != 'undefined' && element !== null) {
                domutils.removeAttribute(element, "href");
              }
            }

            // TODO evaluate the use of "-then" (and -else) postfixes to complete the -if instead of relaying
            // on the same basic sintax (or maybe it is better to support ternary operator COND ? THEN : ELSE).
            var declarationCondition = _declarationValueLookup(declarations, declarations[i].name + '-if', templateUrlConverter);
            var not = false;
            if (declarationCondition === null) {
              declarationCondition = _declarationValueLookup(declarations, declarations[i].name + '-ifnot', templateUrlConverter);
              not = true;
            } else {
              if (_declarationValueLookup(declarations, declarations[i].name + '-ifnot', templateUrlConverter) !== null) {
                throw "Unexpected error: cannot use both -if and -ifnot property conditions";
              }
            }
            if (declarationCondition !== null) {
              try {
                var bindingCond = converterUtils.conditionBinding(declarationCondition, bindingProvider);
                bindValue = (not ? '!' : '') + "(" + bindingCond + ") ? " + bindValue + " : null";
              } catch (e) {
                console.error("Unable to deal with -ko style binding condition", declarationCondition, declarations[i].name);
                throw e;
              }
            }

            if (bindType !== null) newBindings[bindType][bindName] = bindValue;
            else newBindings[bindName] = bindValue;
          }

          // parsing @supports :preview
          if (newStyle !== null) {

            try {
              // if "element" is defined then we are parsing an "inline" style and we want to remove it.
              if (typeof element != 'undefined' && element !== null) {
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, '');
              } else {
                // otherwise we are parsing a full stylesheet.. let's rewrite the full "prop: value" without caring about the original syntax.
                var replacedWith = '';
                // if it is an "if" we simply have to remove it, otherwise we replace the input code with "prop: value" generating expression.
                if (!isIf) replacedWith = propName + ': <!-- ko text: ' + bindValue + ' -->' + propDefaultValue + '<!-- /ko -->';
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, replacedWith);
              }
            } catch (e) {
              console.warn("Remove style failed", e, "name", declarations[i]);
              throw e;
            }

          }

        } else {
          // prefixing urls
          var replacedValue = _declarationValueUrlPrefixer(declarations[i].value, templateUrlConverter);
          if (replacedValue != declarations[i].value) {
            if (newStyle === null && typeof style !== 'undefined') newStyle = style;
            if (newStyle !== null) {
              try {
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, declarations[i].name + ": " + replacedValue);
              } catch (e) {
                console.log("Remove style failed replacing url", e, "name", declarations[i]);
                throw e;
              }
            }
          }

          // Style handling by concatenated "style attribute" (worse performance but more stable than direct style handling)
          var bindName2 = _propToCamelCase(declarations[i].name);
          var bind = 'virtualAttrStyle';
          var bindVal2 = typeof newBindings['virtualStyle'] !== 'undefined' ? newBindings['virtualStyle'][bindName2] : undefined;

          var dist = ' ';
          if (typeof newBindings[bind] == 'undefined') {
            newBindings[bind] = "''";
            dist = '';
          }

          if (typeof bindVal2 !== 'undefined') {
            newBindings[bind] = "'" + declarations[i].name + ": '+(" + bindVal2 + ")+';" + dist + "'+" + newBindings[bind];
            delete newBindings['virtualStyle'][bindName2];
          } else {
            newBindings[bind] = "'" + declarations[i].name + ": " + converterUtils.addSlashes(replacedValue) + ";" + dist + "'+" + newBindings[bind];
          }

        }
      }
    }

  if (typeof element != 'undefined' && element !== null) {
    for (var prop in newBindings['virtualStyle'])
      if (newBindings['virtualStyle'].hasOwnProperty(prop)) {
        console.log("Unexpected virtualStyle binding after conversion to virtualAttr.style", prop, newBindings['virtualStyle'][prop], style);
        throw "Unexpected virtualStyle binding after conversion to virtualAttr.style for " + prop;
      }
    delete newBindings['virtualStyle'];

    var currentBindings = domutils.getAttribute(element, 'data-bind');
    var dataBind = (currentBindings !== null ? currentBindings + ", " : "") + _bindingSerializer(newBindings);
    domutils.setAttribute(element, 'data-bind', dataBind);
  }

  // TODO a function whose return type depends on the input parameters is very ugly.. please FIX ME.
  if (typeof style == 'undefined') {
    // clean virtualStyle if empty
    var hasVirtualStyle = false;
    for (var prop1 in newBindings['virtualStyle'])
      if (newBindings['virtualStyle'].hasOwnProperty(prop1)) {
        hasVirtualStyle = true;
        break;
      }
    if (!hasVirtualStyle) delete newBindings['virtualStyle'];
    else {
      // remove and add back virtualAttrStyle so it gets appended BEFORE virtualAttrStyle (_bindingSerializer reverse them...)
      if (typeof newBindings['virtualAttrStyle'] !== 'undefined') {
        var vs = newBindings['virtualAttrStyle'];
        delete newBindings['virtualAttrStyle'];
        newBindings['virtualAttrStyle'] = vs;
      }
    }
    // returns new serialized bindings
    return _bindingSerializer(newBindings);
  }

  return newStyle;
};

var _bindingSerializer = function(val) {
  var res = [];
  for (var prop in val)
    if (val.hasOwnProperty(prop)) {
      if (typeof val[prop] == 'object') res.push(prop + ": " + "{ " + _bindingSerializer(val[prop]) + " }");
      else res.push(prop + ": " + val[prop]);
    }
  return res.reverse().join(', ');
};

module.exports = elaborateDeclarations;
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/mensch/lib/parser.js":15,"./domutils.js":71,"./utils.js":77}],71:[function(require,module,exports){
(function (global){
"use strict";

// This deals with Cheerio/jQuery issues.
// Most of this could be done without jQuery, too, but jQuery is easier to be mocked with Cheerio
// Otherwise we would need jsDom to run the compiler in the server (without a real browser)

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);

function _extend(target, source) {
  if (source) {
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}

var objExtend = function(obj, extender) {
  if (typeof $.extend == 'function') {
    return $.extend(true, obj, extender);
  } else {
    return _extend(obj, JSON.parse(JSON.stringify(extender)));
  }
};

var getAttribute = function(element, attribute) {
  var res = $(element).attr(attribute);
  if (typeof res == 'undefined') res = null;
  return res;
  // return element.getAttribute(attribute);
};

var setAttribute = function(element, attribute, value) {
  $(element).attr(attribute, value);
  // element.setAttribute(attribute, value);
};

var removeAttribute = function(element, attribute) {
  $(element).removeAttr(attribute);
  // element.removeAttribute(attribute);
};

var getInnerText = function(element) {
  return $(element).text();
  // if (typeof element.innerText != 'undefined') return element.innerText;
  // else return element.textContent;
};

var getInnerHtml = function(element) {
  return $(element).html();
  // return element.innerHTML;
};

var getLowerTagName = function(element) {
  // sometimes cheerio doesn't have tagName but "name".
  // Browsers have "name" with empty string
  // Sometimes cheerio has tagName but no prop function.
  if (element.tagName === '' && typeof element.name == 'string') return element.name.toLowerCase();
  if (element.tagName !== '') return element.tagName.toLowerCase();
  return $(element).prop("tagName").toLowerCase();
  // return element.tagName.toLowerCase();
};

var setContent = function(element, content) {
  $(element).html(content);
  // element.innerHTML = content;
};

var replaceHtml = function(element, html) {
  $(element).replaceWith(html);
  // element.outerHTML = html;
};

var removeElements = function($elements, tryDetach) {
  if (tryDetach && typeof $elements.detach !== 'undefined') $elements.detach();
  // NOTE: we don't need an else, as detach is simply an optimization
  $elements.remove();
};

module.exports = {
  getAttribute: getAttribute,
  setAttribute: setAttribute,
  removeAttribute: removeAttribute,
  getInnerText: getInnerText,
  getInnerHtml: getInnerHtml,
  getLowerTagName: getLowerTagName,
  setContent: setContent,
  replaceHtml: replaceHtml,
  removeElements: removeElements,
  objExtend: objExtend
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],72:[function(require,module,exports){
"use strict";

var console = require("./../../../bower_components/console-browserify/index.js");
var elaborateDeclarations = require("./declarations.js");
var utils = require('./utils.js');
var modelDef = require('./model.js');

var _getOptionsObject = function(options) {
  var optionsCouples = options.split('|');
  var opts = {};
  for (var i = 0; i < optionsCouples.length; i++) {
    var opt = optionsCouples[i].split('=');
    opts[opt[0]] = opt.length > 1 ? opt[1] : opt[0];
  }
  return opts;
};

// TODO this should not have hardcoded rules (we now have a way to declare them in the template definition)
// Category "style" is used by editType "styler"
// Cateogry "content" is used by editType "edit"
// TODO maybe we should use a common string here, and rely only on the original category.
var _filterProps = function(model, editType, level) {
  var res = [];
  for (var prop in model)
    if (!prop.match(/^customStyle$/) && !prop.match(/^_/) && model.hasOwnProperty(prop)) {
      var isStyleProp = model[prop] !== null && typeof model[prop]._category != 'undefined' && model[prop]._category == 'style';
      if (prop == 'id' || prop == 'type' || prop.match(/Blocks$/)) {} else if (editType == 'styler') {
        if (isStyleProp || level > 0) res.push(prop);
      } else if (editType == 'edit') {
        // Editing for properties in the "content" category but not defined in the context of a block
        var isContentProp = model[prop] !== null && typeof model[prop]._category != 'undefined' && model[prop]._category == 'content' &&
          (typeof model[prop]._context == 'undefined' || model[prop]._context != 'block');
        if (isContentProp) res.push(prop);
      } else if (typeof editType == 'undefined') {
        res.push(prop);
      }
    }
  return res;
};

var _propInput = function(model, prop, propAccessor, editType, widgets) {
  var html = "";
  var widget;
  if (model !== null && typeof model._widget != 'undefined') widget = model._widget;

  if (typeof widget == 'undefined') {
    throw "Unknown data type for " + prop;
  }

  // For content editors we deal with focusing (clicking is handled by the container DIV).
  var onfocusbinding = 'focusable: true';
  if (editType == 'edit') {
    onfocusbinding += ', event: { focus: function(ui, event) { $($element).click(); } } ';
  }

  html += '<label class="data-' + widget + '"' + (widget == 'boolean' ? ' data-bind="event: { mousedown: function(ui, evt) { if (evt.button == 0) { var input = $($element).find(\'input\'); var ch = input.prop(\'checked\'); setTimeout(function() { input.click(); input.prop(\'checked\', !ch); input.trigger(\'change\'); }, 0); } } }, click: function(ui, evt) { evt.preventDefault(); }, clickBubble: false"' : '') + '>';

  if (typeof widgets !== 'undefined' && typeof widgets[widget] !== 'undefined') {
    var w = widgets[widget];
    var parameters = {};
    if (typeof w.parameters !== 'undefined')
      for (var p in w.parameters)
        if (w.parameters.hasOwnProperty(p) && typeof model['_'+p] !== 'undefined')
          parameters[p] = model['_'+p];
    html += w.html(propAccessor, onfocusbinding, parameters);
  } else if (widget == 'boolean') {
    html += '<input type="checkbox" value="nothing" data-bind="checked: ' + propAccessor + ', ' + onfocusbinding + '" />';
    html += '<span class="checkbox-replacer" ></span>'; /* data-bind="css: { checked: '+propAccessor+' }" */
  } else if (widget == 'color') {
    html += '<input size="7" type="text" data-bind="colorpicker: { color: ' + propAccessor + ', strings: $root.t(\'Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet.\') }, ' + ', ' + onfocusbinding + '" />';
  } else if (widget == 'select') {
    if (typeof model._options != 'undefined') {
      var opts = _getOptionsObject(model._options);
      // var opts = model._options;
      html += '<select data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '">';
      for (var opt in opts)
        if (opts.hasOwnProperty(opt)) {
          html += '<option value="' + opt + '" data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(opts[opt]) + '\')">' + opts[opt] + '</option>';
        }
      html += '</select>';
    }
  } else if (widget == 'font') {
    html += '<select type="text" data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '">';
    html += '<optgroup label="Sans-Serif Fonts">';
    html += '<option value="Arial,Helvetica,sans-serif">Arial</option>';
    html += '<option value="\'Comic Sans MS\',cursive,sans-serif">Comic Sans MS</option>';
    html += '<option value="Impact,Charcoal,sans-serif">Impact</option>';
    html += '<option value="\'Trebuchet MS\',Helvetica,sans-serif">Trebuchet MS</option>';
    html += '<option value="Verdana,Geneva,sans-serif">Verdana</option>';
    html += '</optgroup>';
    html += '<optgroup label="Serif Fonts">';
    html += '<option value="Georgia,serif">Georgia</option>';
    html += '<option value="\'Times New Roman\',Times,serif">Times New Roman</option>';
    html += '</optgroup>';
    html += '<optgroup label="Monospace Fonts">';
    html += '<option value="\'Courier New\',Courier,monospace">Courier New</option>';
    html += '</optgroup>';
    html += '</select>';
  } else if (widget == 'url') {
    html += '<div class="ui-textbutton">';
    // <a class="ui-spinner-button ui-spinner-down ui-corner-br ui-button ui-widget ui-state-default ui-button-text-only" tabindex="-1" role="button"><span class="ui-button-text"><span class="ui-icon fa fa-fw caret-down">▼</span></span></a>
    html += '<input class="ui-textbutton-input" size="7" type="url" pattern="(mailto:.+@.+|https?://.+\\..+|\\[.*\\].*)" value="nothing" data-bind="css: { withButton: typeof $root.linkDialog !== \'undefined\' }, validatedValue: ' + propAccessor + ', ' + onfocusbinding + '" />';
    html += '<a class="ui-textbutton-button" data-bind="visible: typeof $root.linkDialog !== \'undefined\', click: typeof $root.linkDialog !== \'undefined\' ? $root.linkDialog.bind($element.previousSibling) : false, button: { icons: { primary: \'fa fa-fw fa-ellipsis-h\' }, label: \'Opzioni\', text: false }">Opzioni</a>';
    html += '</div>';
  } else if (widget == 'integer') {
    // at this time the "step" depends on max being greater than 100.
    // maybe we should expose "step" as a configuration, too
    var min = 0;
    var max = 1000;
    if (model !== null && typeof model._max !== 'undefined') max = model._max;
    if (model !== null && typeof model._min !== 'undefined') min = model._min;
    var step = (max - min) >= 100 ? 10 : 1;
    var page = step * 5;
    html += '<input class="number-spinner" size="7" step="' + step + '" type="number" value="-1" data-bind="spinner: { min: ' + min + ', max: ' + max + ', page: ' + page + ', value: ' + propAccessor + ' }, valueUpdate: [\'change\', \'spin\']' + ', ' + onfocusbinding + '" />';
  } else {
    html += '<input size="7" type="text" value="nothing" data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '" />';
  }

  html += '</label>';

  return html;
};

var _getGlobalStyleProp = function(globalStyles, model, prop, path) {
  var globalStyleProp;
  if (typeof model !== 'object' || model === null || typeof model._widget !== 'undefined') {
    if (typeof prop !== 'undefined' && typeof path !== 'undefined' && path.length > 0 && typeof globalStyles == 'object' && typeof globalStyles[path] != 'undefined') {
      globalStyleProp = globalStyles[path];
    }
  }
  return globalStyleProp;
};

var _propEditor = function(withBindingProvider, widgets, templateUrlConverter, model, themeModel, path, prop, editType, level, baseThreshold, globalStyles, globalStyleProp, trackUsage, rootPreviewBinding, previewBackground) {
  if (typeof level == 'undefined') level = 0;

  if (typeof prop !== 'undefined' && typeof model == 'object' && model !== null && typeof model._usecount === 'undefined') {
    console.log("TODO EDITOR ignoring", path, "property because it is not used by the template", "prop:", prop, "type:", editType, "level:", level, withBindingProvider._templateName);
    return "";
  }

  var propAccessor = typeof globalStyleProp != 'undefined' ? prop + '._defaultComputed' : prop;

  var html = "";
  var title;
  var ifSubsProp = propAccessor;
  var ifSubsGutter = 1;
  // typeof globalStyleProp != 'undefined' ? 1 : 2;
  var ifSubsThreshold = 1;

  // The visibility handling is a PITA
  // 
  // Here are some "edge cases" to test whenever we change something here:
  // LM social footer: removing shareVisibile must be reflected in the booleans sub-checks
  // FLUID social block: multiple clicks on the "wand" should not make the editor invisible
  // BIS heroMenu - By changing the menu visibility it should be reflected in style editors for the menu links
  // FLUID almost every block with a color variant sometimes keeps showing style editor for the hidden variant.
  if (typeof model == 'object' && model !== null && typeof model._widget == 'undefined') {
    // Do nothing here
  } else {
    if (typeof globalStyleProp == 'undefined') {
      ifSubsGutter += 1;
    }
  }

  // NOTE baseThreshold is added only when globalStyle is not defined because when we have globalStyle
  // we're going to bind the computed values and not the original and this way we don't add ourserf to the dependency 
  // tracking (subscriptionCount)
  // NOTE baseThreshold is an "expression" and not a fixed number, so this is a concatenation
  if (typeof globalStyleProp == 'undefined' && typeof baseThreshold !== 'undefined') ifSubsThreshold += baseThreshold;

  if (typeof prop != 'undefined' && !!trackUsage) {
    html += '<!-- ko ifSubs: { data: ' + ifSubsProp + ', threshold: ' + ifSubsThreshold + ', gutter: ' + ifSubsGutter + ' } -->';
  }

  if (typeof prop != 'undefined' && (model === null || typeof model._name == 'undefined')) {
    // TODO throw exception?
    console.log("TODO WARN Missing label for property ", prop);
  }
  if (typeof prop == 'undefined' && model !== null && typeof model._name == 'undefined') {
    console.log("TODO WARN Missing label for object ", model.type /*, model */ );
  }

  if (typeof model == 'object' && model !== null && typeof model._widget == 'undefined') {
    var props = _filterProps(model, editType, level);

    var hasCustomStyle = editType == 'styler' && model !== null && typeof model.customStyle !== 'undefined' && typeof globalStyleProp !== 'undefined';
    var selectedItemBinding = '';
    var additionalClasses = '';
    if (typeof prop !== 'undefined' && editType == 'edit') {
      selectedItemBinding = ', click: function(obj, evt) { $root.selectItem(' + prop + ', $data); return false }, clickBubble: false, css: { selecteditem: $root.isSelectedItem(' + prop + ') }, scrollIntoView: $root.isSelectedItem(' + prop + '), ';
      additionalClasses += ' selectable';
    }
    if (hasCustomStyle) {
      additionalClasses += ' supportsCustomStyles';
    }
    html += '<div class="objEdit level' + level + additionalClasses + '" data-bind="tooltips: {}' + selectedItemBinding + '">';
    var modelName = (model !== null && typeof model._name != 'undefined' ? model._name : (typeof prop !== 'undefined' ? '[' + prop + ']' : ''));
    if (hasCustomStyle) {
      var themeSectionName = 'Stile';
      if (typeof themeModel !== 'undefined' && themeModel !== null && typeof themeModel._name !== 'undefined') {
        themeSectionName = themeModel._name;
      } else {
        console.log("TODO missing label for theme section ", prop, model !== null ? model.type : '-');
      }

      modelName = '<span class="blockSelectionMethod" data-bind="text: customStyle() ? $root.ut(\'template\', \'' + utils.addSlashes(modelName) + '\') : $root.ut(\'template\', \'' + utils.addSlashes(themeSectionName) + '\')">Block</span>';
    } else {
      modelName = '<span data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(modelName) + '\')">' + modelName + '</span>';
    }
    title = model !== null && typeof model._help !== 'undefined' ? ' title="' + utils.addSlashes(model._help) + '" data-bind="attr: { title: $root.ut(\'template\', \'' + utils.addSlashes(model._help) + '\') }"' : '';
    html += '<span' + title + ' class="objLabel level' + level + '">' + modelName + '</span>';

    if (editType == 'edit' && typeof model._blockDescription !== 'undefined') {
      html += '<div class="blockDescription" data-bind="html: $root.ut(\'template\', \'' + utils.addSlashes(model._blockDescription) + '\')">' + model._blockDescription + '</div>';
    }

    /* CUSTOM STYLE */
    if (hasCustomStyle) {
      html += '<label class="data-boolean blockCheck" data-bind="tooltips: { }">';
      html += '<input type="checkbox" value="nothing" data-bind="focusable: true, checked: customStyle" />';
      html += '<span title="Switch between global and block level styles editing" data-bind="attr: { title: $root.t(\'Switch between global and block level styles editing\') }" class="checkbox-replacer checkbox-replacer-onoff"></span>'; //  data-bind="tooltip: { content: \'personalizza tutti\' }"
      html += '</label>';
      html += '<!-- ko template: { name: \'customstyle\', if: customStyle } --><!-- /ko -->';
    }

    if (typeof prop != 'undefined') {
      html += '<!-- ko with: ' + prop + ' -->';

      /* PREVIEW */
      if (level == 1 && typeof prop != 'undefined') {
        if (typeof model._previewBindings != 'undefined' && typeof withBindingProvider != 'undefined') {
          if (typeof rootPreviewBinding != 'undefined') html += '<!-- ko with: $root.content() --><div class="objPreview" data-bind="' + rootPreviewBinding + '"></div><!-- /ko -->';
          if (typeof previewBackground != 'undefined') html += '<!-- ko with: $parent --><div class="objPreview" data-bind="' + previewBackground + '"></div><!-- /ko -->';
          var previewBindings = elaborateDeclarations(undefined, model._previewBindings, templateUrlConverter, withBindingProvider.bind(this, path + '.'));
          html += '<div class="objPreview"><div class="objPreviewInner" data-bind="' + previewBindings + '"></div></div>';
        }
      }
    }

    /* PREVIEW */
    var previewBG;
    if (level === 0) {
      if (typeof model._previewBindings != 'undefined') {
        previewBG = elaborateDeclarations(undefined, model._previewBindings, templateUrlConverter, withBindingProvider.bind(this, path.length > 0 ? path + '.' : ''));
      }
    }

    var i, newPath;

    var before = html.length;

    var newThemeModel;
    var newGlobalStyleProp;

    for (i = 0; i < props.length; i++) {
      newPath = path.length > 0 ? path + "." + props[i] : props[i];
      if (typeof model[props[i]] != 'object' || model[props[i]] === null || typeof model[props[i]]._widget != 'undefined') {
        newGlobalStyleProp = undefined;
        if (level === 0 && props[i] == 'theme')
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, 0, baseThreshold, undefined, undefined, trackUsage, rootPreviewBinding);
        else {
          newGlobalStyleProp = _getGlobalStyleProp(globalStyles, model[props[i]], props[i], newPath);
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, level + 1, baseThreshold, globalStyles, newGlobalStyleProp, trackUsage, rootPreviewBinding, previewBG);
        }
      }
    }
    for (i = 0; i < props.length; i++) {
      newPath = path.length > 0 ? path + "." + props[i] : props[i];
      if (!(typeof model[props[i]] != 'object' || model[props[i]] === null || typeof model[props[i]]._widget != 'undefined')) {
        newGlobalStyleProp = undefined;
        if (level === 0 && props[i] == 'theme')
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, 0, baseThreshold, undefined, undefined, trackUsage, rootPreviewBinding);
        else {
          newGlobalStyleProp = _getGlobalStyleProp(globalStyles, model[props[i]], props[i], newPath);
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, level + 1, baseThreshold, globalStyles, newGlobalStyleProp, trackUsage, rootPreviewBinding, previewBG);
        }
      }
    }

    var added = html.length - before;
    if (added === 0) {
      // No editable content: if this is in context "template" we leave it empty, otherwise we show an help.
      if (typeof model == 'object' && model !== null && model._context == 'template') {
        return '';
      } else {
        // TODO move me to a tmpl?
        html += '<div class="objEmpty" data-bind="html: $root.t(\'Selected element has no editable properties\')">Selected element has no editable properties</div>';
      }
    }

    if (typeof prop != 'undefined') {
      html += '<!-- /ko -->';
    }
    html += '</div>';

  } else {
    var checkboxes = true;

    if (typeof globalStyles == 'undefined') checkboxes = false;

    if (model === null || typeof model != 'object' || typeof model._widget != 'undefined') {
      var bindings = [];

      if (typeof globalStyleProp != 'undefined') bindings.push('css: { notnull: ' + prop + '() !== null }');
      title = model !== null && typeof model._help !== 'undefined' ? ' title="' + utils.addSlashes(model._help) + '" data-bind="attr: { title: $root.ut(\'template\', \'' + utils.addSlashes(model._help) + '\') }"' : '';
      if (title.length > 0) bindings.push('tooltips: {}');
      var bind = bindings.length > 0 ? 'data-bind="' + utils.addSlashes(bindings.join()) + '"' : '';
      html += '<div class="propEditor ' + (checkboxes ? 'checkboxes' : '') + '"' + bind + '>';

      var modelName2 = (model !== null && typeof model._name != 'undefined' ? model._name : (typeof prop !== 'undefined' ? '[' + prop + ']' : ''));
      modelName2 = '<span data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(modelName2) + '\')">' + modelName2 + '</span>';
      html += '<span' + title + ' class="propLabel">' + modelName2 + '</span>';
      html += '<div class="propInput ' + (typeof globalStyles != 'undefined' ? 'local' : '') + '" data-bind="css: { default: ' + prop + '() === null }">';
      html += _propInput(model, prop, propAccessor, editType, widgets);
      html += '</div>';
      if (typeof globalStyleProp != 'undefined') {
        html += '<div class="propInput global" data-bind="css: { overridden: ' + prop + '() !== null }">';
        html += _propInput(model, prop, globalStyleProp, editType, widgets);
        html += '</div>';

        if (checkboxes) {
          html += '<div class="propCheck"><label data-bind="tooltips: {}"><input type="checkbox" data-bind="focusable: true, click: function(evt, obj) { $root.localGlobalSwitch(' + prop + ', ' + globalStyleProp + '); return true; }, checked: ' + prop + '() !== null">';
          html += '<span class="checkbox-replacer" data-bind="css: { checked: ' + prop + '() !== null }, attr: { title: $root.t(\'This style is specific for this block: click here to remove the custom style and revert to the theme value\') }"></span>';
          html += '</label></div>';
        }
      }
      html += '</div>';
    } else if (model === null || typeof model != 'object') {
      // TODO remove debug output
      html += '<div class="propEditor unknown">[A|' + prop + "|" + typeof model + ']</div>';
    } else {
      // TODO remove debug output
      html += '<div class="propEditor unknown">[B|' + prop + "|" + typeof model + ']</div>';
    }


  }

  if (typeof prop != 'undefined' && !!trackUsage) {
    html += '<!-- /ko -->';
    html += '<!-- ko ifSubs: { not: true, data: ' + ifSubsProp + ', threshold: ' + ifSubsThreshold + ', gutter: 0 } -->';
    html += '<span class="label notused">(' + prop + ')</span>';
    html += '<!-- /ko -->';
  }

  return html;
};


var createBlockEditor = function(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, editType, templateCreator, baseThreshold, trackGlobalStyles, trackUsage, fromLevel) {
  if (typeof trackUsage == 'undefined') trackUsage = true;
  var model = modelDef.getDef(defs, templateName);

  var rootModel = modelDef.getDef(defs, rootModelName);
  var rootPreviewBindings;
  if (typeof rootModel._previewBindings != 'undefined' && templateName != 'thaeme' && editType == 'styler') {
    rootPreviewBindings = elaborateDeclarations(undefined, rootModel._previewBindings, templateUrlConverter, modelDef.getBindValue.bind(undefined, defs, themeUpdater, rootModelName, rootModelName, ''));
  }

  var globalStyles = typeof trackGlobalStyles != 'undefined' && trackGlobalStyles ? defs[templateName]._globalStyles : undefined;
  var globalStyleProp = typeof trackGlobalStyles != 'undefined' && trackGlobalStyles ? defs[templateName]._globalStyle : undefined;


  var themeModel;
  if (typeof globalStyleProp !== 'undefined') {
    var mm = modelDef.getDef(defs, 'theme');
    // TODO remove deprecated $theme
    themeModel = mm[globalStyleProp.replace(/^(\$theme|_theme_)\./, '')];
  }


  var withBindingProvider = modelDef.getBindValue.bind(undefined, defs, themeUpdater, rootModelName, templateName);
  withBindingProvider._templateName = templateName;

  var html = '<div class="editor">';
  html += "<div class=\"blockType" + (typeof globalStyles != 'undefined' ? " withdefaults" : "") + "\">" + model.type + "</div>";

  var editorContent = _propEditor(withBindingProvider, widgets, templateUrlConverter, model, themeModel, "", undefined, editType, fromLevel, baseThreshold, globalStyles, globalStyleProp, trackUsage, rootPreviewBindings);
  if (editorContent.length > 0) {
    html += editorContent;
  }

  html += '</div>';

  templateCreator(html, templateName, editType);
};

var createBlockEditors = function(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, templateCreator, baseThreshold) {
  createBlockEditor(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, 'edit', templateCreator, baseThreshold);
  createBlockEditor(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, 'styler', templateCreator, baseThreshold, true);
};

var generateEditors = function(templateDef, widgets, templateUrlConverter, templateCreator, baseThreshold) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;
  var blocks = templateDef._blocks;
  var idx;
  var blockDefs = [];
  for (idx = 0; idx < blocks.length; idx++) {
    if (typeof blocks[idx].container !== 'undefined') {
      blockDefs.push(modelDef.generateModel(defs, blocks[idx].block));
    }
    createBlockEditors(defs, widgets, undefined, templateUrlConverter, blocks[idx].root, blocks[idx].block, templateCreator, baseThreshold);
  }

  if (typeof defs['theme'] != 'undefined') createBlockEditor(defs, widgets, undefined, templateUrlConverter, templateName, 'theme', 'styler', templateCreator, undefined, false, false, -1);
  return blockDefs;
};

module.exports = generateEditors;

},{"./../../../bower_components/console-browserify/index.js":1,"./declarations.js":70,"./model.js":74,"./utils.js":77}],73:[function(require,module,exports){
"use strict";
/* global global: false */

var modelDef = require("./model.js");

var wrappedResultModel = function(templateDef) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;
  var finalModelContentDef = modelDef.getDef(defs, templateName);

  var finalModelContent = modelDef.generateResultModel(templateDef);

  var wrapper = require("./wrapper.js");
  var res = wrapper(finalModelContent, finalModelContentDef, defs);

  return res;
};

// requires only when imported
var translateTemplate = function() {
  var tt = require('./parser.js');
  return tt.apply(tt, arguments);
};

// requires only when imported
var generateEditors = function() {
  var ge = require('./editor.js');
  return ge.apply(ge, arguments);
};

var checkModel = function() {
  var cm = require('./checkmodel.js');
  return cm.apply(cm, arguments);
};

module.exports = {
  translateTemplate: translateTemplate,
  wrappedResultModel: wrappedResultModel,
  generateResultModel: modelDef.generateResultModel,
  generateEditors: generateEditors,
  checkModel: checkModel
};
},{"./checkmodel.js":69,"./editor.js":72,"./model.js":74,"./parser.js":75,"./wrapper.js":78}],74:[function(require,module,exports){
"use strict";

var objExtend = require("./domutils.js").objExtend;
var console = require("./../../../bower_components/console-browserify/index.js");

var _valueSet = function(defs, model, prop, value) {
  var dotPos = prop.indexOf('.');
  if (dotPos == -1) {
    if (typeof model[prop] == 'undefined') {
      console.log("Undefined prop " + prop + " while setting value " + value + " in model._valueSet");
    } else if (model[prop] === null) {
      if (typeof value == 'object' && value !== null && typeof value.push == 'undefined') console.log("nullpropobjectvalue", prop, value);
      model[prop] = value;
    } else if (typeof model[prop] == 'object' && typeof model[prop].push == 'function') {
      var values;
      if (typeof value === 'string') {
        var valuesString = value.match(/^\[(.*)\]$/);
        if (valuesString !== null) {
          values = valuesString[1].split(',');
        } else {
          throw "Unexpected default value for array property " + prop + ": " + value;
        }
      } else if (typeof value === 'object' && typeof value.push !== 'undefined') {
        values = value;
      } else {
        throw "Unexpected default value for array property " + prop + ": " + value + " typeof " + (typeof value);
      }
      var res = [];
      for (var i = 0; i < values.length; i++) {
        if (values[i].substr(0, 1) == '@') {
          // TODO remove this legacy support (@), so we can remove "defs" from this function, too.
          res.push(_generateModel(defs, values[i].substr(1)));
        } else if (values[i].length > 0) {
          res.push(values[i]);
        }
      }
      model[prop] = res;
    } else if (typeof model[prop] == 'string' || typeof model[prop] == 'boolean') {
      // TODO does this still happen? Debug/test me.
      model[prop] = value;
    } else if (typeof model[prop] == 'object' && model[prop] !== null && typeof model[prop]._widget != 'undefined') {
      if (typeof value == 'object' && value !== null) console.log("objectvalue", prop, model[prop]._widget, value);
      // _data is defined for primitive types
      model[prop] = value;
    } else {
      console.log("setting", typeof model[prop], model[prop], prop, value);
    }
  } else {
    var propName = prop.substr(0, dotPos);
    _valueSet(defs, model[propName], prop.substr(dotPos + 1), value);
  }
};

var _modelCreateOrUpdateBlockDef = function(defs, templateName, properties, namedProperties) {
  if (typeof defs[templateName] !== 'undefined' && defs[templateName]._initialized && !defs[templateName]._writeable) {
    console.log("_modelCreateOrUpdateBlockDef", defs, templateName, properties, namedProperties);
    throw "Trying to alter non writeable model: " + templateName + " / " + properties;
  }

  if (typeof defs[templateName] == 'undefined') {
    defs[templateName] = {
      _writeable: true
    };
    // Fallback computation of "category" depending on the property name
    // TODO remove me: this should be always defined in the template definition, no need to hardcode this stuff.
    if (typeof namedProperties == 'undefined') namedProperties = {};
    if (typeof namedProperties.category == 'undefined' && typeof defs[templateName]._category == 'undefined') {
      if (templateName.match(/(^t|.T)heme$/) || templateName.match(/(^s|.S)tyle$/) || templateName.match(/(^c|.C)olor$/) || templateName.match(/(^r|.R)adius$/)) {
        namedProperties.category = 'style';
      } else {
        namedProperties.category = 'content';
      }
    }
  }


  if (typeof namedProperties !== 'undefined') {
    // TODO check if this is needed before the ending namedProperty "loop" or not.
    if (typeof namedProperties.name != 'undefined') defs[templateName]._name = namedProperties.name;

    if (typeof namedProperties.themeOverride != 'undefined') {
      defs[templateName]._themeOverride = namedProperties.themeOverride;
    }
    if (typeof namedProperties.globalStyle != 'undefined') {
      defs[templateName]._globalStyle = namedProperties.globalStyle;
      // TODO remove deprecated $theme
      var globalStyleSub = namedProperties.globalStyle.replace(/^(\$theme|_theme_)\./, '');
      var p = globalStyleSub.indexOf('.');
      var gs = p != -1 ? globalStyleSub.substr(0, p) : globalStyleSub;
      _modelCreateOrUpdateBlockDef(defs, 'theme', gs);

      if (typeof defs[templateName]._themeOverride === 'undefined' || !!defs[templateName]._themeOverride) {
        _modelCreateOrUpdateBlockDef(defs, templateName, "customStyle=false");
      }
    }
    if (typeof namedProperties.contextName !== 'undefined') {
      defs[templateName]._context = namedProperties.contextName;
      // TODO is it correct to fallback to "bodyTheme" for blocks not declaring a default theme?
      // Maybe it would be better to simply declare it as mandatory but leave the default configutation
      // to the template definition.
      if (namedProperties.contextName == 'block' && typeof defs[templateName]._globalStyle == 'undefined') {
        defs[templateName]._globalStyle = '_theme_.bodyTheme';
        _modelCreateOrUpdateBlockDef(defs, 'theme', 'bodyTheme');

        if (typeof defs[templateName]._themeOverride == 'undefined' || defs[templateName]._themeOverride) {
          _modelCreateOrUpdateBlockDef(defs, templateName, "customStyle=false");
        }
      }
    }
    if (typeof namedProperties.extend != 'undefined') defs[templateName].type = namedProperties.extend;
  }

  for (var np in namedProperties) if (namedProperties.hasOwnProperty(np) && typeof namedProperties[np] !== 'undefined' && ['name', 'extend', 'contextName', 'globalStyle','themeOverride'].indexOf(np) == -1) {
    defs[templateName]['_'+np] = namedProperties[np];
  }

  if (typeof properties != 'undefined' && properties.length > 0) {
    defs[templateName]._props = typeof defs[templateName]._props != 'undefined' && defs[templateName]._props.length > 0 ? defs[templateName]._props + " " + properties : properties;
  }
};

// remove the first "sequence" in a camelcased word (e.g: myCamelCase => camelCase).
var _removePrefix = function(str) {
  var res = str.match(/^[^A-Z]+([A-Z])(.*)$/);
  return res !== null ? res[1].toLowerCase() + res[2] : null;
};

// TODO defs is needed only because _valueSet needs it.. we should remove it downstream.
var _generateModelFromDef = function(modelDef, defs) {
  var res = {};

  for (var prop in modelDef)
    if (!prop.match(/^_.*/) && modelDef.hasOwnProperty(prop)) {
      var value = modelDef[prop];
      if (typeof value == 'object' && value !== null && typeof value._complex != 'undefined' && value._complex) {
        res[prop] = _generateModelFromDef(value, defs);
      } else if (prop == 'type') {
        res[prop] = value;
      } else if (typeof value == 'object') {
        // most times this will be overwritten by _valueSet
        res[prop] = null;
        // for customStyle this is set to null.
      } else {
        console.error("Unexpected model def", prop, value, modelDef);
        throw "Unexpected model def [" + prop + "]=" + value;
      }
    }

  if (typeof modelDef._defaultValues != 'undefined') {
    var defaults = modelDef._defaultValues;
    for (var prop2 in defaults)
      if (defaults.hasOwnProperty(prop2)) {
        _valueSet(defs, res, prop2, defaults[prop2]);
      }
  }

  return res;
};

var _generateModel = function(defs, name) {
  var modelDef = _getModelDef(defs, name, false, true);
  return _generateModelFromDef(modelDef, defs);
};

var _getDef = function(defs, name) {
  return _getModelDef(defs, name, false, true);
};

var _getModelDef = function(defs, name, returnClone, readonly) {
  // lookup "name" in the template definition
  if (typeof defs[name] == 'undefined') {
    // if the name has a space then returns.
    if (name.indexOf(' ') != -1) return null;
    // otherwise try looking up using a deprefixed name.
    var res = _removePrefix(name);
    if (res !== null) {
      // TODO the deprefixing is powerful, but maybe not really needed.
      return _getModelDef(defs, res, returnClone, readonly);
    }
    // not a prefixed name
    // TODO should we raise an error?
    return null;
  } else {
    // when the name is already defined...
    var defObj = defs[name];
    if (typeof defObj != 'object') throw "Block definition must be an object: found " + defObj + " for " + name;

    if (typeof defObj._initialized == 'undefined') {
      // Populate "type" depending on name
      if (typeof defObj.type == 'undefined') {
        if (name.indexOf(' ') == -1) {
          defObj.type = name;
        } else {
          defObj.type = name.substr(name.indexOf(' ') + 1);
        }
      }

      // If it is not a "data" type then let's deal with inheritance
      if (defObj.type != name && typeof defObj._widget == 'undefined') {
        var typeDef = _getModelDef(defs, defObj.type, true);
        var extended = objExtend(typeDef, defObj);
        defObj = extended;
        defs[name] = defObj;
      } else if (typeof defObj._widget == 'undefined' && typeof defObj._props == 'undefined' && typeof defObj._complex == 'undefined') {
        // TODO here I tried to deal with inheritance for every object without a "type" by using a simple deprefix.
        // but this break on theme containing "pageTheme" that would inherit from is parent. (creating a loop)
        /*
        var superType = _removePrefix(defObj.type);
        if (superType !== null) {
          console.log("Extending", typeDef, name, superType, defObj.type);
          var typeDef = _getModelDef(defs, superType, true);
          
          var extended = jQuery.extend(true, typeDef, defObj);
          defObj = extended;
          defs[name] = defObj;
        }
        */
      }
      defObj._writeable = true;
      defObj._initialized = true;
    }

    if (typeof defObj._props != 'undefined') {
      var def = defObj._props;
      def = def.split(" ");

      if (def.length > 0 && typeof defObj._writeable == 'undefined') {
        console.error("Altering a non writable object ", name, def, defObj);
        throw "Altering a non writable object: " + name + " def: " + def;
      }

      if (typeof defObj._processedDefs == 'undefined') {
        defObj._processedDefs = {};
      }

      if (typeof defObj._globalStyles == 'undefined') {
        defObj._globalStyles = {};
      }

      if (typeof defObj._defaultValues == 'undefined') {
        defObj._defaultValues = {};
      }

      for (var i = 0; i < def.length; i++) {
        var prop = def[i];
        if (prop.length === 0) continue;
        var origProp = prop;
        var defValue = null;
        // parses  "prop" "prop=value" and "prop[]" declarations
        var propDef = prop.match(/^([^=\[\]]+)(\[\])?(=?)(.*)$/);
        if (propDef !== null) {
          prop = propDef[1];
          // TODO array definition should be done differently
          if (propDef[2] == '[]') {
            // TODO type should not be defined in this function
            if (typeof defObj[prop] == 'undefined') defObj[prop] = [];
            defValue = [];
          }
          if (propDef[3] == '=') {
            // TODO remove hardcoded "visible" matching (this should be defined in the template definition)
            if (prop.match(/(^v|V)isible$/)) defValue = String(propDef[4]).toLowerCase() == 'true';
            else if (prop.match(/^customStyle$/)) {
              defValue = String(propDef[4]).toLowerCase() == 'true';
            } else defValue = propDef[4];
          }
        }
        // default values found in "properties" are not being processed by "modelEnsureValue" and by consequence do not call "themeUpdater".
        // TODO document why this is needed, or remove.
        if (defValue !== null) {
          if (typeof defObj._defaultValues[prop] == 'undefined') {
            // if (prop.match(/^_/)) console.log("defValue for", prop, "in", name);
            defObj._defaultValues[prop] = defValue;
          }
        }

        if (typeof defObj[prop] == 'undefined') {
          var val = _getModelDef(defs, name + ' ' + prop, true);
          if (val === null) {
            val = _getModelDef(defs, prop, true);
          }
          defObj[prop] = val;
        }

        defObj._processedDefs[prop] = origProp;
        defObj._complex = true;
      }

      delete defObj._props;
    }

    if (returnClone) {
      defObj._writeable = false;
      var cloned = objExtend({}, defObj);
      return cloned;
    } else if (readonly) {
      defObj._writeable = false;
      return defObj;
    } else {
      if (typeof defObj._writeable == 'undefined' || defObj._writeable === false) throw "Retrieving non writeable object definition: " + name;
      return defObj;
    }
  }
};

var _increaseUseCount = function(readonly, model) {
  if (!readonly) {
    if (typeof model._usecount == 'undefined') model._usecount = 0;
    model._usecount++;
  } else if (typeof model._usecount == 'undefined') {
    console.error("ERROR trying to bind an unused property while readonly", model);
    throw "ERROR trying to bind an unused property";
  }
};

var ensureGlobalStyle = function(defs, readonly, gsBindingProvider, modelName, path, gsFullPath, defaultValue, overrideDefault) {

  var globalStyleBindingBindValue = gsBindingProvider(gsFullPath, defaultValue, overrideDefault);

  if (typeof defs[modelName]._globalStyles[path] == 'undefined') {
    if (readonly) throw "Cannot find _globalStyle for " + path + " in " + modelName + "!";
    if (path.indexOf('.') != -1 || (typeof defs[modelName][path] == 'object' && typeof defs[modelName][path]._widget !== 'undefined')) {
      defs[modelName]._globalStyles[path] = globalStyleBindingBindValue;
    }
  } else if (defs[modelName]._globalStyles[path] != globalStyleBindingBindValue) throw "Unexpected conflicting globalStyle [2] for " + modelName + "/" + path + ": old=" + defs[modelName]._globalStyles[path] + " new=" + globalStyleBindingBindValue;
};

// themeUpdater, defaultValue, overrideDefault, setcategory are only used in !readonly mode
var modelEnsurePathAndGetBindValue = function(readonly, defs, themeUpdater, rootModelName, templateName, within, fullPath, defaultValue, overrideDefault, setcategory) {
  var modelName;
  var res;
  var path;
  // TODO remove '$' and '#' handing
  if (fullPath.substr(0, 1) == '$') {
    console.warn("DEPRECATED $ in bindingProvider: ", fullPath, templateName);
    var p = fullPath.indexOf('.');
    if (p == -1) {
      throw "Unexpected fullPath: " + fullPath + "/" + within + "/" + templateName + "/" + defaultValue + "/" + overrideDefault;
    } else {
      modelName = fullPath.substr(1, p - 1);
      path = fullPath.substr(p + 1);
      // TODO refactor me please
      if (modelName == 'theme') {
        var p2 = path.indexOf('.');
        modelName = path.substr(0, p2);
        path = path.substr(p2 + 1);
      } else {
        throw "Unexpected $ sequence: " + modelName + " in " + fullPath;
      }
      res = "$root.content().theme()." + modelName + "()." + path.replace(new RegExp('\\.', 'g'), '().');
    }
  } else if (fullPath.substr(0, 1) == '#') {
    console.warn("DEPRECATED # in bindingProvider: ", fullPath, templateName);
    modelName = rootModelName;
    path = fullPath.substr(1);
    res = "$root.content()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else if (fullPath.substr(0, 8) == '_theme_.') {
    var p3 = fullPath.indexOf('.', 8);
    modelName = fullPath.substr(8, p3 - 8);
    path = fullPath.substr(p3 + 1);
    res = "$root.content().theme()." + modelName + "()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else if (fullPath.substr(0, 7) == '_root_.') {
    modelName = rootModelName;
    path = fullPath.substr(7);
    res = "$root.content()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else {
    modelName = templateName;
    path = within + fullPath;
    res = fullPath.replace(new RegExp('\\.', 'g'), '().');
  }

  if (typeof defs[modelName] === 'undefined') throw "Cannot find model def for [" + modelName + "]";

  var propPos = path.indexOf('.');
  var propName = propPos == -1 ? path : path.substr(0, propPos);

  if (modelName.indexOf('-') != -1) {
    console.error("ERROR cannot use - for block names", modelName);
    throw "ERROR unexpected char in block name: " + modelName;
  }
  if (propName.indexOf('-') != -1) {
    console.error("ERROR cannot use - for property names", propName);
    throw "ERROR unexpected char in property name: " + modelName;
  }

  // Fastpath
  if (readonly) {
    if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] !== 'undefined' && defs[modelName][propName]._category == 'style') {
      res += '._defaultComputed';
    }
    return res;
  }

  // gets the writable model when "!readonly" or the readonly model otherwise
  var model;
  if (readonly) {
    if (typeof defaultValue !== 'undefined') throw "Cannot use defaultValue in readonly mode!";
    if (overrideDefault) throw "Cannot use overrideDefault in readonly mode for " + modelName + "/" + path + "/" + overrideDefault + "!";
    if (typeof setcategory !== 'undefined') throw "Cannot set category for " + modelName + "/" + path + "/" + setcategory + " in readonly mode!";
    model = _getModelDef(defs, modelName, false, true);
  } else {
    if (defs[modelName]._writeable === false) console.log("TODO debug use cases for this condition", modelName, path);
    model = _getModelDef(defs, modelName, defs[modelName]._writeable === false);
  }

  if (model === null) throw "Unexpected model for [" + modelName + "]";

  // if the property does not exists we have to create it.
  if (typeof model[propName] == 'undefined') {
    // when in readonly mode this cannot be done!
    if (readonly) throw "Cannot find path " + propName + " for " + modelName + "!";
    _modelCreateOrUpdateBlockDef(defs, modelName, propName);
    model = _getModelDef(defs, modelName, false);
  }

  // Needs to do this again, because "_modelCreateOrUpdateBlockDef" could have been just created the property (e.g: backgroundColor buttonBlock not getting defaultComputed in template-lm)
  if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] !== 'undefined' && defs[modelName][propName] !== null && defs[modelName][propName]._category == 'style') {
    res += '._defaultComputed';
  }

  var childModel = model;
  try {
    _increaseUseCount(readonly, childModel);
    if (propPos != -1) {
      var mypath = path;
      do {
        var prop = mypath.substr(0, propPos);
        if (typeof childModel[prop] == 'undefined') {
          throw "Found an unexpected prop " + prop + " for model " + modelName + " for " + path;
        }

        childModel = childModel[prop];
        _increaseUseCount(readonly, childModel);
        mypath = mypath.substr(propPos + 1);
        propPos = mypath.indexOf('.');
      } while (propPos != -1);

      if (typeof childModel[mypath] == 'undefined' || childModel[mypath] === null) {
        throw "Found an unexpected path termination " + mypath + " for model " + modelName + " for " + path;
      }
      childModel = childModel[mypath];
    } else {
      childModel = childModel[path];
    }

    if (typeof childModel === 'undefined' || childModel === null) throw "Unexpected null model for " + modelName + "/" + within + "/" + fullPath;

    if (typeof setcategory !== 'undefined') {
      childModel._category = setcategory;
    }

    _increaseUseCount(readonly, childModel);
  } catch (e) {
    console.error("TODO ERROR Property lookup exception", e, modelName, path, templateName, fullPath, defs);
    throw e;
  }

  if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] == 'object' && defs[modelName][propName] !== null && typeof defs[modelName][propName]._category != 'undefined' && defs[modelName][propName]._category == 'style') {
    // TODO can I restrict this code to !readonly mode?
    var gsBindingProvider = modelEnsurePathAndGetBindValue.bind(undefined, readonly, defs, themeUpdater, rootModelName, templateName, '');

    var subPath = path.indexOf('.') != -1 ? path.substr(path.indexOf('.')) : '';

    // The next code supports only properties with one dot (object.property).
    if (subPath.indexOf('.', 1) != -1) throw "TODO unsupported object nesting! " + path;

    var gsPath = defs[modelName]._globalStyle + '.' + propName;
    if (typeof defs[modelName][propName] == 'object' && defs[modelName][propName] !== null && typeof defs[modelName][propName]._globalStyle != 'undefined') {
      gsPath = defs[modelName][propName]._globalStyle;
    }

    ensureGlobalStyle(defs, readonly, gsBindingProvider, modelName, propName, gsPath, undefined, false);

    var gsFullPath = gsPath + subPath;

    if (typeof defaultValue == 'undefined' && defs[modelName]._defaultValues[path] !== null) defaultValue = defs[modelName]._defaultValues[path];

    ensureGlobalStyle(defs, readonly, gsBindingProvider, modelName, path, gsFullPath, defaultValue, overrideDefault);

    if (typeof defaultValue !== 'undefined') {
      if (readonly) {
        console.error("Cannot set a new theme default value", gsFullPath.substr(7), defaultValue, "while in readonly mode");
        throw "Cannot set a new theme default value (" + defaultValue + ") for " + gsFullPath.substr(7) + " while in readonly mode!";
      }
      themeUpdater('default', gsFullPath.substr(7), defaultValue);
    }

    // TODO complex stuff. If the theme uses inheritance we enforce it using with the same value, but this is a limit.
    defaultValue = null;

  }

  if (typeof defaultValue != 'undefined') {
    if (typeof defs[modelName]._defaultValues[path] == 'undefined' || (typeof overrideDefault != 'undefined' && overrideDefault)) {
      if (readonly) throw "Cannot set new _defaultValues [1] for " + path + " in " + modelName + "!";
      defs[modelName]._defaultValues[path] = defaultValue;
    } else {
      if (defaultValue === null) {
        if (readonly && defs[modelName]._defaultValues[path] !== null) {
          throw "Cannot set new _defaultValues [2] for " + path + " in " + modelName + "!";
        }
        // This remove default value. Ugly. (Needs this for defaults in template-lm socialLinksIcon)
        defs[modelName]._defaultValues[path] = null;
      } else if (defs[modelName]._defaultValues[path] != defaultValue) {
        console.error("TODO error!!! Trying to set a new default value for " + modelName + " " + path + " while it already exists (current: " + defs[modelName]._defaultValues[path] + ", new: " + defaultValue + ")");
        throw "Trying to set a new default value for " + modelName + " " + path + " while it already exists (current: " + defs[modelName].defaultValues[path] + ", new: " + defaultValue + ")";
      }
    }
  }

  return res;
};

var generateResultModel = function(templateDef) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;

  var finalModelContent = _generateModel(defs, templateName);

  // TODO ugly to add this manually
  if (typeof defs['theme'] !== 'undefined') {
    finalModelContent.theme = _generateModel(defs, 'theme');
  }

  return finalModelContent;
};

module.exports = {
  // used to compile the template
  ensurePathAndGetBindValue: modelEnsurePathAndGetBindValue.bind(undefined, false),
  // used in runtime the template
  getBindValue: modelEnsurePathAndGetBindValue.bind(undefined, true),
  generateModel: _generateModel,
  generateResultModel: generateResultModel,
  getDef: _getDef,
  createOrUpdateBlockDef: _modelCreateOrUpdateBlockDef
};
},{"./../../../bower_components/console-browserify/index.js":1,"./domutils.js":71}],75:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
var converterUtils = require("./utils.js");
var elaborateDeclarations = require("./declarations.js");
var processStylesheetRules = require("./stylesheet.js");
var modelDef = require("./model.js");
var domutils = require("./domutils.js");

var wrapElementWithCondition = function(attribute, element, bindingProvider) {
  var cond = domutils.getAttribute(element, attribute);

  try {
    var binding = converterUtils.conditionBinding(cond, bindingProvider);
    $(element).before('<!-- ko if: ' + binding + ' -->');
    $(element).after('<!-- /ko -->');
    domutils.removeAttribute(element, attribute);
  } catch (e) {
    console.warn("Model ensure path failed in if/variant", element, cond, attribute);
    throw e;
  }

};

var replacedAttributes = function(element, attributeName) {
  domutils.setAttribute(element, attributeName, domutils.getAttribute(element, "replaced" + attributeName));
};

var processStyle = function(element, templateUrlConverter, bindingProvider, addUniqueId) {
  var style = domutils.getAttribute(element, 'replacedstyle');
  var newStyle = null;
  var newBindings;
  if (addUniqueId) newBindings = {
    uniqueId: '$data',
    attr: {
      id: 'id'
    }
  };

  var removeDisplayNone = domutils.getAttribute(element, 'data-ko-display') !== null;

  newStyle = elaborateDeclarations(style, undefined, templateUrlConverter, bindingProvider, element, newBindings, removeDisplayNone);

  // only when using "replaced"
  if (newStyle === null) {
    newStyle = style;
  } else {
    // in case there are no bindings we keep replacedstyle to be used by IE during output
    // otherwise I remove it because it will be overwritten by virtualAttrStyle binding.
    // TODO maybe we better use different names for "replaced" used during template conversion
    // and the ones used to create the output.
    domutils.removeAttribute(element, 'replacedstyle');
  }

  if (newStyle !== null) {
    if (newStyle.trim().length > 0) {
      domutils.setAttribute(element, 'style', newStyle);
    } else domutils.removeAttribute(element, 'style');
  }
};


// TODO fixing URLs is also needed where styles uses path (e.g: background-image, @import)
var _fixRelativePath = function(attribute, templateUrlConverter, index, element) {
  var url = domutils.getAttribute(element, attribute);
  var newUrl = templateUrlConverter(url);
  if (newUrl !== null) {
    domutils.setAttribute(element, attribute, newUrl);
  }
};


var processBlock = function(element, defs, themeUpdater, blockPusher, templateUrlConverter, contextName, rootModelName, containerName, generateUniqueId, templateCreator) {

  try {

  var templateName;
  var variantName = '',
    variantDef = '';
  if (contextName == 'block') {
    templateName = domutils.getAttribute(element, 'data-ko-block');
    domutils.removeAttribute(element, 'data-ko-block');
  } else if (contextName == 'template') {
    templateName = rootModelName;
  } else {
    throw "Unexpected context name while processing block: " + contextName;
  }

  // console.log("processBlock", contextName, rootModelName, containerName, templateName);

  // Remove element
  $('[data-ko-remove]', element).remove();

  var fixedBlocks = $('[data-ko-block]', element).replaceWith('<replacedblock>');

  // Urls in these attributes needs "relativization"
  var urlattrs = ['href', 'src', 'data-ko-placeholder-src', 'background'];
  for (var i = 0; i < urlattrs.length; i++) {
    // faccio il bind per non definire funzioni in un loop (jshint)
    var func = _fixRelativePath.bind(undefined, urlattrs[i], templateUrlConverter);
    $('[' + urlattrs[i] + ']', element).each(func);
  }

  var dataDefs = domutils.getAttribute(element, 'data-ko-properties');
  if (dataDefs === null) dataDefs = "";
  $("[data-ko-properties]", element).each(function(index, element) {
    if (dataDefs.length > 0) dataDefs = dataDefs + " ";
    dataDefs = dataDefs + domutils.getAttribute(element, 'data-ko-properties');
    domutils.removeAttribute(element, 'data-ko-properties');
  });

  modelDef.createOrUpdateBlockDef(defs, templateName, dataDefs, { contextName: contextName });

  var bindingProvider = modelDef.ensurePathAndGetBindValue.bind(undefined, defs, themeUpdater, rootModelName, templateName, '');
  if (contextName == 'block') bindingProvider('id', '');

  $('style', element).each(function(index, element) {
    var style = domutils.getInnerHtml(element);

    var blockDefsUpdater = modelDef.createOrUpdateBlockDef.bind(undefined, defs);
    var localWithBindingProvider = modelDef.ensurePathAndGetBindValue.bind(undefined, defs, themeUpdater, rootModelName);
    var newStyle = processStylesheetRules(style, undefined, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName);

    if (newStyle != style) {
      if (newStyle.trim() !== '') {
        var tmpName = templateCreator(newStyle);
        domutils.setAttribute(element, 'data-bind', 'template: { name: \'' + tmpName + '\' }');
        // ho creato il template quindi posso svuotare il sorgente.
        domutils.setContent(element, '');
      } else {
        // remove empty styles blocks
        domutils.removeElements($(element));
      }
    }
  });

  processStyle(element, templateUrlConverter, bindingProvider, generateUniqueId);

  // TODO href should be supported. data-ko-display and data-ko-wrap should never happen in here.
  var notsupported = ['data-ko-display', 'data-ko-editable', 'data-ko-wrap', 'href'];
  for (var j = 0; j < notsupported.length; j++) {
    var attr = domutils.getAttribute(element, notsupported[j]);
    if (attr) {
      console.warn("ERROR: Unsupported " + notsupported[j] + " used together with data-ko-block", element);
      throw "ERROR: Unsupported " + notsupported[j] + " used together with data-ko-block";
    }
  }

  // simply preprocessed as data-ko-wrap + -ko-attr-href
  $("[data-ko-link]", element).each(function(index, element) {
    var urlVar = domutils.getAttribute(element, 'data-ko-link');
    var repStyle = domutils.getAttribute(element, 'replacedstyle');
    if (typeof repStyle == 'undefined' || repStyle === null) repStyle = '';
    if (repStyle !== '') repStyle = '-ko-attr-href: @' + urlVar + "; " + repStyle;
    else repStyle = '-ko-attr-href: @' + urlVar;
    domutils.setAttribute(element, 'replacedstyle', repStyle);
    domutils.setAttribute(element, 'data-ko-wrap', urlVar);
    domutils.removeAttribute(element, 'data-ko-link');
  });

  $("[replacedstyle]", element).each(function(index, element) {
    processStyle(element, templateUrlConverter, bindingProvider, false);
  });

  $("[replacedhttp-equiv]", element).each(function(index, element) {
    replacedAttributes(element, "http-equiv");
  });

  $("[data-ko-display]", element).each(function(index, element) {
    wrapElementWithCondition('data-ko-display', element, bindingProvider);
  });

  $("[data-ko-editable]", element).each(function(index, element) {
    var newBinding, defaultValue, model, currentBindings, dataBind;


    var dataEditable = domutils.getAttribute(element, "data-ko-editable");

    // TODO add validation of the editable

    var itemBindValue;
    var selectBinding;
    if (dataEditable.lastIndexOf('.') > 0) {
      var subs = dataEditable.substr(0, dataEditable.lastIndexOf('.'));
      itemBindValue = bindingProvider(subs);
    } else {
      itemBindValue = bindingProvider(dataEditable);
    }
    selectBinding = "wysiwygClick: function(obj, evt) { $root.selectItem(" + itemBindValue + ", $data); return false }, clickBubble: false, wysiwygCss: { selecteditem: $root.isSelectedItem(" + itemBindValue + ") }, scrollIntoView: $root.isSelectedItem(" + itemBindValue + ")";

    if (domutils.getLowerTagName(element) != 'img') {


      defaultValue = domutils.getInnerHtml(element);
      var modelBindValue = bindingProvider(dataEditable, defaultValue, true, 'wysiwyg');
      newBinding = "";

      if (!domutils.getAttribute(element, "id")) {
        newBinding += "wysiwygId: id()+'_" + dataEditable.replace('.', '_') + "', ";
      }

      if (typeof selectBinding !== 'undefined') {
        newBinding += selectBinding + ", ";
      }

      newBinding += "wysiwygOrHtml: " + modelBindValue;

      if (domutils.getLowerTagName(element) == 'td') {
        var wrappingDiv = $('<div data-ko-wrap="false" style="width: 100%; height: 100%"></div>')[0];
        domutils.setAttribute(wrappingDiv, 'data-bind', newBinding);
        var newContent = domutils.getInnerHtml($('<div></div>').append(wrappingDiv));
        domutils.setContent(element, newContent);
      } else {
        currentBindings = domutils.getAttribute(element, 'data-bind');
        dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
        domutils.setAttribute(element, 'data-bind', dataBind);
        domutils.setContent(element, '');
      }
      domutils.removeAttribute(element, 'data-ko-editable');
    } else {
      var width = domutils.getAttribute(element, 'width');
      if (width === '') width = null;
      if (width === null) {
        console.error("ERROR: data-ko-editable images must declare a WIDTH attribute!", element);
        throw "ERROR: data-ko-editable images must declare a WIDTH attribute!";
      }
      var height = domutils.getAttribute(element, 'height');
      if (height === '') height = null;

      var align = domutils.getAttribute(element, 'align');

      currentBindings = domutils.getAttribute(element, 'data-bind');

      // TODO this is ugly... maybe a better strategy is to pass this around using "data-" attributes
      var dynHeight = currentBindings && currentBindings.match(/virtualAttr: {[^}]* height: ([^,}]*)[,}]/);
      if (dynHeight) height = dynHeight[1];
      var dynWidth = currentBindings && currentBindings.match(/virtualAttr: {[^}]* width: ([^,}]*)[,}]/);
      if (dynWidth) width = dynWidth[1];

      var method;

      defaultValue = domutils.getAttribute(element, 'data-ko-placeholder-src');
      // TODO make sure this default value is the same as the one checked by img-wysiwyg template.
      var value = '';
      if (defaultValue) {
        value = domutils.getAttribute(element, 'src');
      } else {
        defaultValue = domutils.getAttribute(element, 'src');
      }

      var size;
      if (width && height) {
        size = width + "+'x'+" + height;
      } else if (!height) {
        size = "'w'+" + width + "+''";
      } else if (!width) {
        size = "'h'+" + height + "+''";
      }
      var placeholdersrc;
      var plheight = height || domutils.getAttribute(element, 'data-ko-placeholder-height');
      var plwidth = width || domutils.getAttribute(element, 'data-ko-placeholder-width');

      domutils.removeAttribute(element, 'src');
      domutils.removeAttribute(element, 'data-ko-editable');
      domutils.removeAttribute(element, 'data-ko-placeholder-height');
      domutils.removeAttribute(element, 'data-ko-placeholder-width');
      domutils.removeAttribute(element, 'data-ko-placeholder-src');

      if (defaultValue) {
        placeholdersrc = "{ width: " + plwidth + ", height: " + plheight + ", text: " + size + "}";
      }

      if (!plwidth || !plheight) {
        // TODO raise an exception?
        console.error("IMG data-ko-editable must declare width and height attributes, or their placeholder counterparts data-ko-placeholder-width/data-ko-placeholder-height", element);
        throw "ERROR: IMG data-ko-editable MUST declare width and height attributes, or their placeholder counterparts data-ko-placeholder-width/data-ko-placeholder-height";
      }

      var bindingValue = bindingProvider(dataEditable, value, false, 'wysiwyg');
      newBinding = "wysiwygSrc: { width: " + width + ", height: " + height + ", src: " + bindingValue + ", placeholder: " + placeholdersrc + " }";
      dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
      domutils.setAttribute(element, 'data-bind', dataBind);

      var tmplName = templateCreator(element);

      var containerBind = '{ width: ' + width;
      if (align == 'left') containerBind += ', float: \'left\'';
      else if (align == 'right') containerBind += ', float: \'right\'';
      else if (align == 'center') console.log('non so cosa fa align=center su una img e quindi non so come simularne l\'editing');
      else if (align == 'top') containerBind += ', verticalAlign: \'top\'';
      else if (align == 'middle') containerBind += ', verticalAlign: \'middle\'';
      else if (align == 'bottom') containerBind += ', verticalAlign: \'bottom\'';
      containerBind += '}';

      $(element).before('<!-- ko wysiwygImg: { _data: $data, _item: ' + itemBindValue + ', _template: \'' + tmplName + '\', _editTemplate: \'img-wysiwyg\', _src: ' + bindingValue + ', _width: ' + width + ', _height: ' + height + ', _align: ' + (align === null ? undefined : '\'' + align + '\'') + ', _size: ' + size + ', _method: ' + method + ', _placeholdersrc: ' + placeholdersrc + ', _stylebind: ' + containerBind + ' } -->');
      $(element).after('<!-- /ko -->');
    }

  });

  // Applied after the data-editable so to avoid processing hrefs for editable content
  $("[href]", element).each(function(index, element) {
    var attrValue = domutils.getAttribute(element, 'href');
    var newBinding = 'wysiwygHref: \'' + converterUtils.addSlashes(attrValue) + '\'';
    var currentBindings = domutils.getAttribute(element, 'data-bind');
    var dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
    domutils.setAttribute(element, 'data-bind', dataBind);
  });

  $("replacedblock", element).each(function(index, element) {
    var blockElement = fixedBlocks[index];

    var blockName = processBlock(blockElement, defs, themeUpdater, blockPusher, templateUrlConverter, 'block', templateName, containerName, true, templateCreator);
    // replaced blocks are defined in the model root
    var modelBindValue = modelDef.ensurePathAndGetBindValue(defs, themeUpdater, rootModelName, templateName, '', blockName);

    // this way we call block-wysiwyg or block-show and not directly the right block
    $(element).before('<!-- ko block: { data: ' + converterUtils.addSlashes(modelBindValue) + ', template: \'block\' } -->');
    $(element).after('<!-- /ko -->');
    $(element).remove();
  });

  // TODO do we really need to loop in reverse order?
  // data-ko-wrap have to be processed at the end, expecially after "replaceblocks"
  // otherwise a data-ko-wrap wrapping a data-ko-block would break everything.
  $($("[data-ko-wrap]", element).get().reverse(), element).each(function(index, element) {
    var cond = domutils.getAttribute(element, 'data-ko-wrap');
    if (typeof cond === 'undefined' || cond === '' || cond === 'true') {
      throw "Unsupported empty value for data-ko-wrap: use false value if you want to always remove the tag";
    }

    var condBinding = converterUtils.conditionBinding(cond, bindingProvider);

    /*
          var condBinding = false;
          if (typeof cond === 'undefined' || cond === '') {
            throw "Unsupported empty value for data-ko-wrap: use false value if you want to always remove the tag";
          } else if (cond === 'false') {
            condBinding = false;
          } else if (cond === 'true') {
            throw "Unsupported true value for data-ko-wrap. This makes no sense: use false or a variable";
          } else {
            condBinding = bindingProvider(cond)+'()';
          }
    */

    var dataBind = domutils.getAttribute(element, 'data-bind');

    var innerTmplName, outerTmplName;
    // TODO ugly hardcoded handling: at the very least this should be invoked by the data-container caller.
    if (dataBind !== '' && dataBind !== null && dataBind.match(/(block|wysiwygOrHtml):/)) {
      // we can't put the content in a template because it will be overwritten by the binding
      var innerTmplContent = '<!-- ko ' + dataBind + ' -->' + domutils.getInnerHtml(element) + '<!-- /ko -->';
      innerTmplName = templateCreator(innerTmplContent);
      domutils.removeAttribute(element, 'data-ko-wrap');
      outerTmplName = templateCreator(element);
      domutils.replaceHtml(element, '<!-- ko template: /* special */ (typeof templateMode != \'undefined\' && templateMode == \'wysiwyg\') || ' + condBinding + ' ? \'' + outerTmplName + '\' : \'' + innerTmplName + '\' --><!-- /ko -->');
    } else {
      // we put the content in a template and the frame in another template including this one.
      innerTmplName = templateCreator(domutils.getInnerHtml(element));
      domutils.removeAttribute(element, 'data-ko-wrap');
      domutils.setContent(element, '<!-- ko template: \'' + innerTmplName + '\' --><!-- /ko -->');
      outerTmplName = templateCreator(element);
      domutils.replaceHtml(element, '<!-- ko template: (typeof templateMode != \'undefined\' && templateMode == \'wysiwyg\') || ' + condBinding + ' ? \'' + outerTmplName + '\' : \'' + innerTmplName + '\' --><!-- /ko -->');
    }

  });

  templateCreator(element, templateName, 'show');

  blockPusher(rootModelName, templateName, contextName, containerName);

  return templateName;

  } catch (e) {
    console.error("Exception while parsing the template", e, element);
    throw e;
  }

};

function conditional_replace(html) {
  return html.replace(/<!--\[if ([^\]]*)\]>((?:(?!--)[\s\S])*?)<!\[endif\]-->/g, function(match, condition, body) {
    var dd = '<!-- cc:start -->';
    dd += body.replace(/<([A-Za-z:]+)/g, '<!-- cc:bo:$1 --><cc') // before open tag
           .replace(/<\/([A-Za-z:]+)>/g,'<!-- cc:bc:$1 --></cc><!-- cc:ac:$1 -->') // before/after close tag
           .replace(/\/>/g,'/><!-- cc:sc -->'); // self-close tag
    dd += '<!-- cc:end -->';
    var output = '<replacedcc condition="'+condition+'" style="display: none">';
    output += $('<div>').append($(dd)).html()
      .replace(/^<!-- cc:start -->/, '')
      .replace(/<!-- cc:end -->$/, '');
    output += '</replacedcc>';
    return output;
  });
}


var translateTemplate = function(templateName, html, templateUrlConverter, templateCreator) {
  var defs = {};
  var replacedHtml = conditional_replace(html.replace(/(<[^>]+\s)(style|http-equiv)(="[^"]*"[^>]*>)/gi, function(match, p1, p2, p3) {
    return p1 + 'replaced' + p2 + p3;
  }));
  var content = $(replacedHtml);
  var element = content[0];

  var blocks = []; // {rootName, blockName, containerName}
  var _blockPusher = function(rootName, blockName, contextName, containerName) {
    blocks.push({
      root: rootName,
      block: blockName,
      context: contextName,
      container: containerName
    });
  };

  // TODO have to accept nulls as undefineds (because of model.js behaviour)
  var themeUpdater = function(name, key, val) {
    if (typeof defs['themes'] === 'undefined') defs['themes'] = {};
    if (typeof defs['themes'][name] === 'undefined') defs['themes'][name] = {};
    if (typeof defs['themes'][name][key] === 'undefined' || defs['themes'][name][key] === null) defs['themes'][name][key] = val;
    else if (typeof val !== 'undefined' && val !== null) {
      var precVal = defs['themes'][name][key];
      if (precVal != val) console.log("Error setting a new default for property " + key + " in theme " + name + ". old:" + precVal + " new:" + val + "!");
    }
  };

  var containers = $("[data-ko-container]", content);
  var containersDom = {};
  containers.each(function(index, element) {
    var containerName = domutils.getAttribute(element, 'data-ko-container') + "Blocks";

    domutils.removeAttribute(element, 'data-ko-container');
    domutils.setAttribute(element, 'data-bind', 'block: ' + containerName);

    var containerBlocks = $("> [data-ko-block]", element);
    domutils.removeElements(containerBlocks, true);

    containersDom[containerName] = containerBlocks;
  });

  // TODO remove hardcoded properties: we need them because without these loading a basic template fails.
  // Needed in order to use data-ko-block
  modelDef.createOrUpdateBlockDef(defs, 'id');
  // Needed always as it is the default theme section.
  modelDef.createOrUpdateBlockDef(defs, 'bodyTheme');
  // Needed for data-ko-container
  modelDef.createOrUpdateBlockDef(defs, 'blocks', 'blocks[]');

  // Needed if you want to use a text variable? TODO this should not be needed!
  modelDef.createOrUpdateBlockDef(defs, 'text');

  processBlock(element, defs, themeUpdater, _blockPusher, templateUrlConverter, 'template', templateName, undefined, false, templateCreator);

  var blockProcess = function(containerName, index, element) {
    processBlock(element, defs, themeUpdater, _blockPusher, templateUrlConverter, 'block', templateName, containerName, true, templateCreator);
  };

  for (var prop in containersDom)
    if (containersDom.hasOwnProperty(prop)) {
      var containerBlocks = containersDom[prop];
      var containerName = prop;

      modelDef.ensurePathAndGetBindValue(defs, themeUpdater, templateName, templateName, '', containerName + ".blocks", "[]");

      containerBlocks.each(blockProcess.bind(undefined, containerName));
    }

  var templateDef = {
    _defs: defs,
    templateName: templateName,
    _blocks: blocks
  };

  if (typeof defs[templateName]._version !== 'undefined') {
    templateDef.version = defs[templateName]._version;
  }

  return templateDef;
};


module.exports = translateTemplate;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./declarations.js":70,"./domutils.js":71,"./model.js":74,"./stylesheet.js":76,"./utils.js":77}],76:[function(require,module,exports){
"use strict";

// Parses CSS/stylesheets declarations -ko-blockdefs/-ko-themes
// It returns KO bindings but doesn't depend on KO
// Needs a bindingProvider
// Also uses a blockDefsUpdater to update definitions while parsing the stylesheet.

var cssParse = require("./../../../bower_components/mensch/lib/parser.js");
var console = require("./../../../bower_components/console-browserify/index.js");
var converterUtils = require("./utils.js");
var elaborateDeclarations = require("./declarations.js");

/* Temporary experimental code not used
var _processStyleSheetRules_processThemes = function (bindingProvider, themeUpdater, rules) {
  var sels, decls, i, j, k;
  for( i = 0; i < rules.length; i++) {
    if (rules[i].type == 'rule') {
      sels = rules[i].selectors;
      decls = rules[i].declarations;
      for (j = 0; j < sels.length; j++) {
        for (k = 0; k < decls.length; k++) if (decls[k].type == 'property') {
          try {
            var bindVal = bindingProvider('$'+decls[k].name);
            themeUpdater(sels[j], decls[k].name, decls[k].value, bindVal);
          } catch (e) {
            console.log("Exception setting theme for", decls[k].name, decls[k].value, e);
          }
        }
      }
    }
  }
};
*/

var _processStyleSheetRules_processBlockDef = function(blockDefsUpdater, rules) {
  var properties, namedProps, decls;
  // name, contextName, globalStyle, themeOverride, extend, min, max, widget, options, category, variant, help, blockDescription, version, 
  for (var i = 0; i < rules.length; i++) {
    if (rules[i].type == 'rule') {
      var sels = rules[i].selectors;
      var hasDeclarations = false;
      var hasPreviews = false;
      for (var j = 0; j < sels.length; j++) {
        if (sels[j].match(/:preview$/)) {
          hasPreviews = true;
        } else {
          hasDeclarations = true;
        }
      }
      if (hasPreviews && hasDeclarations) {
        console.log("cannot mix selectors type (:preview and declarations) in @supports -ko-blockdefs ", sels);
        throw "Cannot mix selectors type (:preview and declarations) in @supports -ko-blockdefs";
      }
      if (!hasPreviews && !hasDeclarations) {
        console.log("cannot find known selectors in @supports -ko-blockdefs ", sels);
        throw "Cannot find known selectors in @supports -ko-blockdefs";
      }
      if (hasDeclarations) {
        properties = '';
        namedProps = {};

/*
        name = undefined;
        contextName = undefined;
        globalStyle = undefined;
        themeOverride = undefined;
        extend = undefined;
        max = undefined;
        min = undefined;
        widget = undefined;
        options = undefined;
        category = undefined;
        variant = undefined;
        help = undefined;
        blockDescription = undefined;
        version = undefined;
        */
        decls = rules[i].declarations;
        for (var k = 0; k < decls.length; k++) if (decls[k].type == 'property') {
          if (decls[k].name == 'label') namedProps.name = decls[k].value;
          else if (decls[k].name == 'context') namedProps.contextName = decls[k].value;
          else if (decls[k].name == 'properties') properties = decls[k].value;
          else if (decls[k].name == 'theme') namedProps.globalStyle = '_theme_.' + decls[k].value;
          else if (decls[k].name == 'themeOverride') namedProps.themeOverride = String(decls[k].value).toLowerCase() == 'true';
          // else if (decls[k].name == 'extend') extend = decls[k].value;

          // else if (decls[k].name == 'max') max = decls[k].value;
          // else if (decls[k].name == 'min') min = decls[k].value;
          // else if (decls[k].name == 'options') options = decls[k].value;

          // else if (decls[k].name == 'widget') widget = decls[k].value;
          // else if (decls[k].name == 'category') category = decls[k].value;
          // else if (decls[k].name == 'variant') variant = decls[k].value;
          // else if (decls[k].name == 'help') help = decls[k].value;
          // else if (decls[k].name == 'blockDescription') blockDescription = decls[k].value;
          // else if (decls[k].name == 'version') version = decls[k].value;
          else {
            namedProps[decls[k].name] = decls[k].value;
            // TODO in past we detected unsupported properties, while now we simple push every declaration in a namedProperty.
            // This make it harder to spot errors in declarations.
            // console.warn("Unknown property processing @supports -ko-blockdefs ", decls[k], sels);
          }
        }
        for (var l = 0; l < sels.length; l++) {
          blockDefsUpdater(sels[l], properties, namedProps);
        }
      }
      if (hasPreviews) {
        for (var m = 0; m < sels.length; m++) {
          var localBlockName = sels[m].substr(0, sels[m].indexOf(':'));
          var previewBindings = rules[i].declarations;
          blockDefsUpdater(localBlockName, undefined, { previewBindings: previewBindings });
        }
      }

    } else {
      // Ignoring comments or other content
    }
  }
};

var processStylesheetRules = function(style, rules, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName) {
  var newStyle = style;
  var lastStart = null;

  if (typeof rules == 'undefined') {
    var styleSheet = cssParse(style, {
      comments: true,
      position: true
    });
    if (styleSheet.type != 'stylesheet' || typeof styleSheet.stylesheet == 'undefined') {
      console.log("unable to process styleSheet", styleSheet);
      throw "Unable to parse stylesheet";
    }
    rules = styleSheet.stylesheet.rules;
  }

  // WARN currenlty this parses rules in reverse order so that string replacements works using input "positions"
  // otherwise it should compute new offsets on every replacement.
  // But this create issues because of definitions being parsed in reverse order, so this is not a good idea.
  // Sometimes, to work around this issues, you need to create 2 different <style> blocks.
  var bindingProvider;

  for (var i = rules.length - 1; i >= 0; i--) {
    if (rules[i].type == 'supports' && rules[i].name == '-ko-blockdefs') {
      _processStyleSheetRules_processBlockDef(blockDefsUpdater, rules[i].rules);
      newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, lastStart, 0, 0, 0, '');
      /* temporary experimental code not used
      } else if (rules[i].type == 'supports' && rules[i].name == '-ko-themes') {
        bindingProvider = localWithBindingProvider.bind(this, 'theme', '');
        _processStyleSheetRules_processThemes(bindingProvider, themeUpdater, rules[i].rules);
        newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, lastStart, 0, 0, 0, '');
      */
    } else if (rules[i].type == 'media' || rules[i].type == 'supports') {
      newStyle = processStylesheetRules(newStyle, rules[i].rules, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName);
    } else if (rules[i].type == 'comment') {
      // ignore comments
    } else if (rules[i].type == 'rule') {
      var sels = rules[i].selectors;
      var newSel = "";
      var foundBlockMatch = null;
      for (var j = 0; j < sels.length; j++) {
        if (newSel.length > 0) newSel += ", ";
        var match = sels[j].match(/\[data-ko-block=([^ ]*)\]/);
        if (match !== null) {
          if (foundBlockMatch !== null && foundBlockMatch != match[1]) throw "Found multiple block-match attribute selectors: cannot translate it (" + foundBlockMatch + " vs " + match[1] + ")";
          foundBlockMatch = match[1];
        }
        newSel += '<!-- ko text: templateMode ==\'wysiwyg\' ? \'#main-wysiwyg-area \' : \'\' --><!-- /ko -->' + sels[j];
      }
      if (foundBlockMatch) {
        var loopPrefix = '<!-- ko foreach: $root.findObjectsOfType($data, \'' + foundBlockMatch + '\') -->';
        var loopPostfix = '<!-- /ko -->';
        var end = lastStart;
        var spacing = " ";
        if (rules[i].declarations.length > 0) {
          if (rules[i].declarations[0].position.start.line != rules[i].position.end.line) {
            spacing = "\n" + (new Array(rules[i].position.start.col)).join(" ");
          }
          end = rules[i].declarations[rules[i].declarations.length - 1].position.end;
        }
        if (end === null) newStyle += spacing + loopPostfix;
        else if (end == lastStart) newStyle = converterUtils.removeStyle(newStyle, end, lastStart, 0, 0, 0, spacing + loopPostfix);
        else newStyle = converterUtils.removeStyle(newStyle, end, lastStart, 0, 0, 0, spacing + '}' + spacing + loopPostfix);
        newSel = loopPrefix + spacing + newSel.replace(new RegExp('\\[data-ko-block=' + foundBlockMatch + '\\]', 'g'), '<!-- ko text: \'#\'+id() -->' + foundBlockMatch + '<!-- /ko -->');

        blockDefsUpdater(foundBlockMatch, '', { contextName: 'block' });
      }
      // TODO mensch update (using original mensch library we needed this line, while the patched one doesn't need this code)
      // newSel += " {";
      var localBlockName = foundBlockMatch ? foundBlockMatch : templateName;
      bindingProvider = localWithBindingProvider.bind(this, localBlockName, '');
      var elaboratedStyle = elaborateDeclarations(newStyle, rules[i].declarations, templateUrlConverter, bindingProvider);
      if (elaboratedStyle !== null) newStyle = elaboratedStyle;

      newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, rules[i].position.end, 0, 0, 0, newSel);
    } else {
      console.log("Unknown rule type", rules[i].type, "while parsing <style> rules");
    }
    lastStart = rules[i].position.start;
  }
  return newStyle;
};

module.exports = processStylesheetRules;
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/mensch/lib/parser.js":15,"./declarations.js":70,"./utils.js":77}],77:[function(require,module,exports){
"use strict";
var console = require("./../../../bower_components/console-browserify/index.js");
var jsep = require("./../../../bower_components/jsep/src/jsep.js");

jsep.addBinaryOp("or", 1);
jsep.addBinaryOp("and", 2);
jsep.addBinaryOp("eq", 6);
jsep.addBinaryOp("neq", 6);
jsep.addBinaryOp("lt", 7);
jsep.addBinaryOp("lte", 7);
jsep.addBinaryOp("gt", 7);
jsep.addBinaryOp("gte", 7);

var addSlashes = function(str) {
  return str.replace(/[\\"']/g, '\\$&').replace(/\u0000/g, '\\0');
};

var removeStyle = function(style, startPos, endPos, skipRows, startOffset, endOffset, insert) {
  var styleRows = style.split("\n");
  var start = startOffset;
  var end = endOffset;
  for (var r = 1 + skipRows; r < startPos.line; r++) start += styleRows[r - 1 - skipRows].length + 1;
  start += startPos.col;
  if (endPos !== null) {
    for (var r2 = 1 + skipRows; r2 < endPos.line; r2++) end += styleRows[r2 - 1 - skipRows].length + 1;
    end += endPos.col;
  } else end += style.length + 1;
  var newStyle = style.substr(0, start - 1) + insert + style.substr(end - 1);
  return newStyle;
};

var expressionGenerator = function(node, bindingProvider, defVal) {
  function mapOperator(op) {
    switch (op) {
      case 'or':
        return '||';
      case 'and':
        return '&&';
      case 'lt':
        return '<';
      case 'lte':
        return '<=';
      case 'gt':
        return '>';
      case 'gte':
        return '>=';
      case 'eq':
        return '==';
      case 'neq':
        return '!=';
      default:
        return op;
    }
  }

  function gen(node, bindingProvider, lookupmember, defVal) {
    if (typeof lookupmember == 'undefined') lookupmember = true;

    if (typeof defVal !== 'undefined' && node.type !== "Identifier" && node.type !== "MemberExpression") console.log("Cannot apply default value to variable when using expressions");

    if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
      return '(' + gen(node.left, bindingProvider, lookupmember) + ' ' + mapOperator(node.operator) + ' ' + gen(node.right, bindingProvider, lookupmember) + ')';
    } else if (node.type === 'CallExpression') {
      var args = node.arguments.map(function(n) {
        return gen(n, bindingProvider, lookupmember);
      });
      return gen(node.callee, bindingProvider, lookupmember) + '(' + args.join(', ') + ')';
    } else if (node.type === "UnaryExpression") {
      return node.operator + gen(node.argument, bindingProvider, lookupmember);
    } else if (node.type == 'MemberExpression' && node.computed) {
      throw "Unexpected computed member expression";
      // return gen(node.object) + '[' + gen(node.property) + ']';
    } else if (node.type == 'MemberExpression' && !node.computed) {
      var me = gen(node.object, bindingProvider, false) + '.' + gen(node.property, bindingProvider, false);
      if (lookupmember && node.object.name !== 'Math' && node.object.name !== 'Color') return bindingProvider(me, defVal) + '()';
      return me;
    } else if (node.type === "Literal") {
      return node.raw;
    } else if (node.type === 'Identifier') {
      var id = node.name;
      if (lookupmember) return bindingProvider(id, defVal) + '()';
      else return id;
    } else if (node.type === 'ConditionalExpression') {
      return '(' + gen(node.test, bindingProvider, lookupmember) + ' ? ' + gen(node.consequent, bindingProvider, lookupmember) + ' : ' + gen(node.alternate, bindingProvider, lookupmember) + ')';
    } else if (node.type === 'Compound') {
      throw "Syntax error in expression: operator expected after " + gen(node.body[0], bindingProvider, false);
    } else {
      throw "Found an unsupported expression type: " + node.type;
    }
  }

  return gen(node, bindingProvider, undefined, defVal);
};

var expressionBinding = function(expression, bindingProvider, defaultValue) {
  var matches;
  if (typeof defaultValue !== 'undefined' && defaultValue !== null) {
    var check = expression.trim().replace(/@\[([^\]]+)\]|@([a-zA-Z0-9\._]+)\b/g, '###var###');
    check = check.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    if (check == '###var###') matches = [null, defaultValue];
    else {
      check = '^' + check.replace(/###var###/g, '(.+)') + '$';
      matches = defaultValue.trim().match(new RegExp(check));
      if (!matches) {
        // TODO throw error?
        console.log("Cannot find matches", matches, "for", defaultValue, expression, check, expression);
        throw "Cannot find default value for " + expression + " in " + defaultValue;
      }
    }
  }
  try {
    var vars = 0;
    var result = "'" + expression.replace(/@\[([^\]]+)\]|@([a-zA-Z0-9\._]+)\b|(')/g, function(match, p1, p2, p3) {
      // escaping..
      if (p3) return "\\" + p3;
      vars++;
      var varName = p1 || p2;
      var defVal;
      if (matches) {
        if (typeof matches[vars] !== 'undefined') {
          defVal = matches[vars].trim();
        } else {
          console.log("ABZZZ Cannot find default value for", varName, "in", matches, "as", vars);
        }
      }
      // in case we found p1 we are in a @[sequence] so we start an expression parser
      if (p1) {
        var parsetree = jsep(p1);
        var gentree = expressionGenerator(parsetree, bindingProvider, defVal);
        return "'+" + gentree + "+'";
      }
      return "'+" + bindingProvider(varName, defVal) + "()+'";
    }) + "'";
    result = result.replace(/(^|[^\\])''\+/g, '$1').replace(/\+''/g, '');

    if (vars === 0 && result !== 'false' && result !== 'true') {
      console.error("Unexpected expression with no valid @variable references", expression);
    }
    return result;
  } catch (e) {
    throw "Exception parsing expression " + expression + " " + e;
  }
};

var conditionBinding = function(condition, bindingProvider) {
  var parsetree = jsep(condition);
  var gentree = expressionGenerator(parsetree, bindingProvider);
  return gentree;
};

module.exports = {
  addSlashes: addSlashes,
  removeStyle: removeStyle,
  conditionBinding: conditionBinding,
  expressionBinding: expressionBinding
};
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/jsep/src/jsep.js":3}],78:[function(require,module,exports){
(function (global){
"use strict";

// This is complex code to handle "live" model instrumentation and dependency tracking.
// This adds _wrap and _unwrap methods to the model and also instrument the block list so to automatically
// wrap/upwrap objects on simple array methods (push, splice)

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kowrap = require("./../../../bower_components/knockout.wrap/knockout.wrap.js");
var console = require("./../../../bower_components/console-browserify/index.js");

var _getOptionsObject = function(options) {
  var optionsCouples = options.split('|');
  var opts = {};
  for (var i = 0; i < optionsCouples.length; i++) {
    var opt = optionsCouples[i].split('=');
    opts[opt[0]] = opt.length > 1 ? opt[1] : opt[0];
  }
  return opts;
};

// generate a computed variable handling the fallback to theme variable
var _makeComputed = function(target, def, nullIfEqual, schemeSelector, themePath, themes) {
  var res = ko.computed({
    'read': function() {
      var val = target();
      if (val === null) {
        var scheme = ko.utils.unwrapObservable(schemeSelector);
        if (typeof scheme == 'undefined' || scheme == 'custom') {
          return ko.utils.unwrapObservable(def);
        } else {
          return themes[scheme][themePath];
        }
      } else {
        return val;
      }
    },
    'write': function(value) {
      var scheme = ko.utils.unwrapObservable(schemeSelector);
      var defVal;
      if (typeof scheme == 'undefined' || scheme == 'custom') {
        defVal = ko.utils.peekObservable(def);
      } else {
        defVal = themes[scheme][themePath];
      }

      if (!!nullIfEqual) {
        if (value == defVal) target(null);
        else target(value);
      } else {
        var current = ko.utils.peekObservable(target);
        if (value != defVal || current !== null) target(value);
      }

    }
  });
  return res;
};

var _nextVariantFunction = function(ko, prop, variants) {
  var currentValue = ko.utils.unwrapObservable(prop);
  var variantValue;

  for (var i = 0; i < variants.length; i++) {
    variantValue = ko.utils.peekObservable(variants[i]);
    if (variantValue == currentValue) break;
  }

  if (i == variants.length) {
    console.warn("Didn't find a variant!", prop, currentValue, variants);
    i = variants.length - 1;
  }

  var nextVariant = i + 1;
  if (nextVariant == variants.length) nextVariant = 0;
  var nextValue = ko.utils.peekObservable(variants[nextVariant]);

  prop(nextValue);
};

var _getVariants = function(def) {
  var variantProp = def._variant;
  var variantOptions;
  if (typeof def[variantProp] !== 'object' || typeof def[variantProp]._widget === 'undefined' || (typeof def[variantProp]._options !== 'string' && def[variantProp]._widget !== 'boolean')) {
    console.error("Unexpected variant declaration", variantProp, def[variantProp]);
    throw "Unexpected variant declaration: cannot find property " + variantProp + " or its _options string and it is not a boolean";
  }
  // TODO I read the "keys" but this is not 100% correct because they are not garanteed to be sorted as in declaration
  if (typeof def[variantProp]._options == 'string') {
    variantOptions = Object.keys(_getOptionsObject(def[variantProp]._options));
  } else {
    variantOptions = [true, false];
  }
  return variantOptions;
};

var _makeComputedFunction = function(def, defs, thms, ko, contentModel, isContent, t) {
  if (typeof def == 'undefined') {
    if (typeof ko.utils.unwrapObservable(t).type === 'undefined') {
      console.log("TODO ERROR Found a non-typed def ", def, t);
      throw "Found a non-typed def " + def;
    }
    var type = ko.utils.unwrapObservable(ko.utils.unwrapObservable(t).type);
    def = defs[type];
    if (typeof def !== 'object') console.log("TODO ERROR Found a non-object def ", def, "for", type);
  }

  if (typeof contentModel == 'undefined' && typeof isContent != 'undefined' && isContent) {
    contentModel = t;
  }

  var selfPath = '$root.content().';

  var pp = def._globalStyles;
  if (typeof pp != 'undefined')
    for (var p in pp)
      if (pp.hasOwnProperty(p)) {
        var schemePathOrig = '$root.content().theme().scheme';
        var schemePath, vm, path;

        if (pp[p].substr(0, selfPath.length) == selfPath) {
          path = pp[p].substr(selfPath.length);
          vm = contentModel;
        } else {
          throw "UNEXPECTED globalStyle path (" + pp[p] + ") outside selfPath (" + selfPath + ")";
        }
        if (schemePathOrig.substr(0, selfPath.length) == selfPath) {
          schemePath = schemePathOrig.substr(selfPath.length);
        } else {
          console.log("IS THIS CORRECT?", schemePathOrig, selfPath);
          schemePath = schemePathOrig;
        }

        var schemeSelector = vm;

        var pathParts = path.split('().');
        var themePath = '';
        var skip = true;
        for (var i = 0; i < pathParts.length; i++) {
          vm = ko.utils.unwrapObservable(vm)[pathParts[i]];
          // ugly thing to find the path to the schema color property (sometimes we have theme.bodyTheme, some other we have content.theme.bodyTheme...)
          if (skip) {
            if (pathParts[i] == 'theme') skip = false;
          } else {
            if (themePath.length > 0) themePath += '.';
            themePath += pathParts[i];
          }
        }

        var schemeParts = schemePath.split('().');
        for (var i3 = 0; i3 < schemeParts.length; i3++) {
          schemeSelector = ko.utils.unwrapObservable(schemeSelector)[schemeParts[i3]];
        }

        var nullIfEqual = true;
        var tParts = p.split('.');
        var target = t;
        for (var i2 = 0; i2 < tParts.length; i2++) {
          target = ko.utils.unwrapObservable(target)[tParts[i2]];
        }

        if (!ko.isObservable(target)) throw "Unexpected non observable target " + p + "/" + themePath;

        target._defaultComputed = _makeComputed(target, vm, nullIfEqual, schemeSelector, themePath, thms);
      }

  if (typeof def._variant != 'undefined') {
    var pParts = def._variant.split('.');
    // looks in t and not contentModel because variants are declared on single blocks.
    var pTarget = t;
    var pParent = ko.utils.unwrapObservable(t);
    for (var i4 = 0; i4 < pParts.length; i4++) {
      pTarget = ko.utils.unwrapObservable(pTarget)[pParts[i4]];
    }
    if (typeof pTarget._defaultComputed != 'undefined') {
      console.log("Found variant on a style property: beware variants should be only used on content properties because they don't match the theme fallback behaviour", def._variant);
      pTarget = pTarget._defaultComputed;
    }
    if (typeof pTarget == 'undefined') {
      console.log("ERROR looking for variant target", def._variant, t);
      throw "ERROR looking for variant target " + def._variant;
    }
    pParent._nextVariant = _nextVariantFunction.bind(pTarget, ko, pTarget, _getVariants(def));
  }

  for (var prop2 in def)
    if (def.hasOwnProperty(prop2)) {
      var val = def[prop2];
      if (typeof val == 'object' && val !== null && typeof val._context != 'undefined' && val._context == 'block') {
        var propVm = contentModel[prop2]();
        var newVm = _makeComputedFunction(defs[prop2], defs, thms, ko, contentModel, isContent, propVm);
        t[prop2](newVm);
      } else if (typeof val == 'object' && val !== null && val.type == 'blocks') {
        var mainVm = contentModel[prop2]();
        var blocksVm = mainVm.blocks();
        var oldBlock, blockType, newBlock;
        for (var ib = 0; ib < blocksVm.length; ib++) {
          oldBlock = ko.utils.unwrapObservable(blocksVm[ib]);
          blockType = ko.utils.unwrapObservable(oldBlock.type);
          newBlock = _makeComputedFunction(defs[blockType], defs, thms, ko, contentModel, isContent, oldBlock);
          blocksVm[ib](newBlock);
        }

        var blocksObs = mainVm.blocks;

        _augmentBlocksObservable(blocksObs, _blockInstrumentFunction.bind(mainVm, undefined, defs, thms, ko, undefined, contentModel, isContent));

        contentModel[prop2]._wrap = _makeBlocksWrap.bind(contentModel[prop2], blocksObs._instrumentBlock);
        contentModel[prop2]._unwrap = _unwrap.bind(contentModel[prop2]);
      }
    }

  return t;
};

var _augmentBlocksObservable = function(blocksObs, instrument) {
  blocksObs._instrumentBlock = instrument;
  if (typeof blocksObs.origPush == 'undefined') {
    blocksObs.origPush = blocksObs.push;
    blocksObs.push = _makePush.bind(blocksObs);
    blocksObs.origSplice = blocksObs.splice;
    blocksObs.splice = _makeSplice.bind(blocksObs);
  }
};

var _makeBlocksWrap = function(instrument, inputModel) {
  var model = ko.toJS(inputModel);
  var input = model.blocks;
  model.blocks = [];
  var res = kowrap.fromJS(model, undefined, true)();
  _augmentBlocksObservable(res.blocks, instrument);
  for (var i = 0; i < input.length; i++) {
    var obj = ko.toJS(input[i]);
    // console.log("_makeBlocksWrap set blockId", obj.id, 'block_'+i);
    obj.id = 'block_' + i;
    res.blocks.push(obj);
  }
  this(res);
};

var _makePush = function() {
  if (arguments.length > 1) throw "Array push with multiple arguments not implemented";
  // unwrap observable blocks, otherwise visibility (dependency) handling breaks
  if (arguments.length > 0 && ko.isObservable(arguments[0])) {
    if (typeof arguments[0]._unwrap == 'function') {
      arguments[0] = arguments[0]._unwrap();
    } else {
      console.log("WARN: pushing observable with no _unwrap function (TODO remove me, expected condition)");
    }
  }
  if (!ko.isObservable(arguments[0])) {
    var instrumented = this._instrumentBlock(arguments[0]);
    return this.origPush.apply(this, [instrumented]);
  } else {
    return this.origPush.apply(this, arguments);
  }
};

var _makeSplice = function() {
  if (arguments.length > 3) throw "Array splice with multiple objects not implemented";
  if (arguments.length > 2 && ko.isObservable(arguments[2])) {
    if (typeof arguments[2]._unwrap == 'function') {
      arguments[2] = arguments[2]._unwrap();
    } else {
      console.log("WARN: splicing observable with no _unwrap function (TODO remove me, expected condition)");
    }
  }
  if (arguments.length > 2 && !ko.isObservable(arguments[2])) {
    var instrumented = this._instrumentBlock(arguments[2]);
    return this.origSplice.apply(this, [arguments[0], arguments[1], instrumented]);
  } else {
    return this.origSplice.apply(this, arguments);
  }
};

// def, defs and themes are bound in "_modelInstrument" while the next parameters are exposed by this module
var _blockInstrumentFunction = function(def, defs, themes, knockout, self, modelContent, isContent, self2) {
  // ugly: sometimes we have to bind content but not self, so we repeat self at the end as "self2"
  if (typeof self == 'undefined') self = self2;

  var computedFunctions;
  computedFunctions = {
    '': _makeComputedFunction.bind(self, def, defs, themes, knockout, modelContent, isContent)
  };

  var res = kowrap.fromJS(self, computedFunctions, true);
  res._unwrap = _unwrap.bind(res);
  return res;
};

var _wrap = function(instrument, unwrapped) {
  var newContent = ko.utils.unwrapObservable(instrument(ko, unwrapped, undefined, true));
  this(newContent);
};

var _unwrap = function() {
  return ko.toJS(this);
};

var _modelInstrument = function(model, modelDef, defs) {
  var _instrument = _blockInstrumentFunction.bind(undefined, modelDef, defs, defs['themes']);
  var res = _instrument(ko, model, undefined, true);
  // res._instrument = _instrument;
  res._wrap = _wrap.bind(res, _instrument);
  res._unwrap = _unwrap.bind(res);
  return res;
};

module.exports = _modelInstrument;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/knockout.wrap/knockout.wrap.js":10}],79:[function(require,module,exports){
(function (global){
'use strict'

var $       = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null)
var ko      = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null)
var console = require("./../../../bower_components/console-browserify/index.js")

function handleCreationName(viewModel) {
  var originalValue
  viewModel.titleMode         = ko.observable('show')
  viewModel.metadata.name     = ko.observable(viewModel.metadata.name)

  viewModel.creationName      = ko.computed(function() {
    return viewModel.metadata.name() || viewModel.t('title-empty')
  }, viewModel)

  viewModel.enableEditCreationName  = function (data, event) {
    console.log('enableEditCreationName', data)
    originalValue = viewModel.metadata.name()
    viewModel.titleMode('edit')
  }

  viewModel.cancelEditCreationName  = function (data, event) {
    console.log('cancelEditCreationName')
    viewModel.metadata.name(originalValue)
    originalValue = ''
    viewModel.titleMode('show')
  }

  viewModel.saveEditCreationName  = function (data, event) {
    console.log('saveEditCreationName', viewModel.metadata.name())
    viewModel.titleMode('saving')
    viewModel.notifier.info(viewModel.t('edit-title-ajax-pending'))

    $.ajax({
      method: 'PUT',
      url:    viewModel.metadata.url.update,
      data:   {
        name: viewModel.metadata.name(),
      },
      success: function () {
        viewModel.notifier.success(viewModel.t('edit-title-ajax-success'))
      },
      error: function () {
        viewModel.notifier.error(viewModel.t('edit-title-ajax-fail'))
      },
      complete: function () {
        originalValue = ''
        viewModel.titleMode('show')
      },
    })
  }
}

module.exports = handleCreationName

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],80:[function(require,module,exports){
(function (global){
'use strict'

var ko            = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null)
var url           = require('url')
var slugFilename  = require('../../../shared/slug-filename.js')

// https://github.com/voidlabs/mosaico/wiki/Mosaico-Plugins

//////
// VIEW-MODEL PLUGINS
//////

var serverStorage = require('./badsender-server-storage')
var editTitle     = require('./badsender-edit-title')

function setEditorIcon(viewModel) {
  viewModel.logoPath  = '/media/editor-icon.png'
  viewModel.logoUrl   = '/'
  viewModel.logoAlt   = 'Badsender'
}

function extendViewModel(opts, customExtensions) {
  customExtensions.push(serverStorage)
  customExtensions.push(setEditorIcon)
  customExtensions.push(editTitle)
}

// OPTIONS

var tinymceConfigFull = {
  toolbar1: 'bold italic forecolor backcolor hr fontsizeselect styleselect removeformat | link unlink | pastetext code',
  //- font-size select
  //- https://www.tinymce.com/docs/configure/content-formatting/#fontsize_formats
  fontsize_formats: '8px 10px 12px 14px 18px 24px 36px',
  //- add colorpicker
  //- https://www.tinymce.com/docs/plugins/colorpicker/
  plugins: ["link hr paste lists textcolor colorpicker code"],
  //- https://www.tinymce.com/docs/configure/content-formatting/#style_formats
  style_formats: [
    {title: 'Inline', items: [
      {title: 'Bold'         , icon: "bold"         , inline: 'strong'},
      {title: 'Italic'       , icon: "italic"       , inline: 'em'},
      {title: 'Underline'    , icon: "underline"    , inline: 'span', styles: {'text-decoration' : 'underline'}},
      {title: 'Strikethrough', icon: "strikethrough", inline: 'span', styles: {'text-decoration' : 'line-through'}},
      {title: 'Superscript'  , icon: "superscript"  , inline: 'sup'},
      {title: 'Subscript'    , icon: "subscript"    , inline: 'sub'},
      {title: 'Code'         , icon: "code"         , inline: 'code'},
    ]},
    {title: 'Alignment', items: [
      {title: 'Left'   , icon: "alignleft"   , block: 'div', styles: {'text-align' : 'left'}},
      {title: 'Center' , icon: "aligncenter" , block: 'div', styles: {'text-align' : 'center'}},
      {title: 'Right'  , icon: "alignright"  , block: 'div', styles: {'text-align' : 'right'}},
      {title: 'Justify', icon: "alignjustify", block: 'div', styles: {'text-align' : 'justify'}},
    ]},
  ],
}

//////
// KNOCKOUT EXTEND
//////

function templateUrlConverter(opts) {
  return function badsenderTemplateUrlConverter(url) {
    if (!url) return null
    // handle: [unsubscribe_link] or mailto:[mail]
    if (/\]$/.test(url)) return null
    // handle absolute url: http
    if (/^http/.test(url)) return null
    // handle ESP tags: in URL <%
    if (/<%/.test(url)) return null
    // handle other urls: img/social_def/twitter_ok.png
    var urlRegexp       = /([^\/]*)$/
    var extentionRegexp = /\.[0-9a-z]+$/
    // as it is done, all files are flatten in asset folder (uploads or S3)
    url = urlRegexp.exec(url)[1]
    // handle every other case:
    //   *|UNSUB|*
    //   #pouic
    if (!extentionRegexp.test(url)) return null
    // All images at upload are slugged
    //    block thumbnails are based on html block ID
    //    we need to retreive the file url by slugging the id
    // The same applies for uploaded resources images:
    //    html img src may differ from uploaded names
    url = slugFilename(url)
    url = opts.imgProcessorBackend + opts.metadata._wireframe  + '-' + url
    return url
  }
}

// knockout is a global object.
// So we can extend it easily

// this equivalent to the original app.js#applyBindingOptions
function extendKnockout(opts) {

  // Change tinyMCE full editor options
  ko.bindingHandlers.wysiwyg.fullOptions = tinymceConfigFull

  // This is not used by knockout per se.
  // Store this function in KO global object so it can be accessed by template-loader.js#templateLoader
  // badsenderTemplateUrlConverter is used:
  //  - for preview images on left bar
  //  - for static links in templates
  ko.bindingHandlers.wysiwygSrc.templateUrlConverter = templateUrlConverter(opts)

  // options have been set in the editor template
  var imgProcessorBackend = url.parse(opts.imgProcessorBackend)

  // send the non-resized image url
  ko.bindingHandlers.fileupload.remoteFilePreprocessor = function (file) {
    console.info('REMOTE FILE PREPROCESSOR')
    console.log(file)
    var fileUrl = url.format({
      protocol: imgProcessorBackend.protocol,
      host:     imgProcessorBackend.host,
      pathname: imgProcessorBackend.pathname,
    });
    file.url = url.resolve(fileUrl, url.parse(file.url).pathname)
    return file
  }

  // push "convertedUrl" method to the wysiwygSrc binding
  ko.bindingHandlers.wysiwygSrc.convertedUrl = function(src, method, width, height) {
    var imageName = url.parse(src).pathname
    if (!imageName) console.warn('no pathname for image', src)
    console.info('CONVERTED URL', imageName, method, width, height)
    imageName     = imageName.replace('/img/', '')
    var path      = opts.basePath + '/' + method
    path          = path + '/' + width + 'x' + height + '/' + imageName
    return path
  }

  ko.bindingHandlers.wysiwygSrc.placeholderUrl = function(width, height, text) {
    // console.info('PLACEHOLDER URL', width, height, text)
    return opts.basePath + '/placeholder/' + width + 'x' + height + '.png'
  }
}

module.exports = {
  extendViewModel:  extendViewModel,
  extendKnockout:   extendKnockout,
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../shared/slug-filename.js":46,"./badsender-edit-title":79,"./badsender-server-storage":81,"url":37}],81:[function(require,module,exports){
(function (global){
'use strict'

var console = require("./../../../bower_components/console-browserify/index.js")
var $       = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null)
var ko      = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null)
var _omit   = require('lodash.omit')
var isEmail = require('validator/lib/isEmail')

function getData(viewModel) {
  // gather meta
  // remove keys that aren't necessary to update
  var datas  = _omit(ko.toJS(viewModel.metadata), ['urlConverter', 'template'])
  datas.data = viewModel.exportJS()
  return datas
}

var loader = function (viewModel) {
  console.info('init server storage (save, test, download)')

  var saveCmd = {
    name: 'Save', // l10n happens in the template
    enabled: ko.observable(true)
  };
  saveCmd.execute = function() {
    saveCmd.enabled(false);
    var data = getData(viewModel)
    console.info('SAVE DATA')
    console.log(data)

    // force JSON for bodyparser to catch up
    // => keep types server side
    $.ajax({
      url: window.location.href,
      method:       'POST',
      contentType:  'application/json',
      data:         JSON.stringify(data),
      success:      onPostSuccess,
      error:        onPostError,
      complete:     onPostComplete,
    })

    // use callback for easier jQuery updates
    // => Deprecation notice for .success(), .error(), and .complete()
    function onPostSuccess(data, textStatus, jqXHR) {
      console.log('save success')
      if (data.meta.redirect) {
        history.replaceState({}, 'editor', data.meta.redirect)
      }
      viewModel.notifier.success(viewModel.t("Creation has been saved"))
    }

    function onPostError(jqXHR, textStatus, errorThrown) {
      console.log('save error')
      console.log(errorThrown)
      viewModel.notifier.error(viewModel.t("Save errir"))
    }

    function onPostComplete() {
      saveCmd.enabled(true);
    }
  }

  var testCmd = {
    name: 'Test', // l10n happens in the template
    enabled: ko.observable(true)
  }
  testCmd.execute = function() {
    console.info('TEST')
    testCmd.enabled(false)
    var email = viewModel.t('Insert here the recipient email address')
    email     = global.prompt(viewModel.t("Test email address"), email)

    if (!isEmail(email)) {
      global.alert(viewModel.t('Invalid email address'));
      return testCmd.enabled(true)
    }

    console.log("TODO testing...", email)
    var metadata  = ko.toJS(viewModel.metadata)
    var datas     = {
      action:   'email',
      rcpt:     email,
      subject:  '[test] ' + metadata.id,
      html:     viewModel.exportHTML()
    }
    $.ajax({
      url:          /dl/,
      method:       'POST',
      data:         datas,
      success:      onTestSuccess,
      error:        onTestError,
      complete:     onTestComplete,
    })

    function onTestSuccess(data, textStatus, jqXHR) {
      console.log('test success')
      viewModel.notifier.success(viewModel.t("Test email sent..."))
    }

    function onTestError(jqXHR, textStatus, errorThrown) {
      console.log('test error')
      console.log(errorThrown)
      viewModel.notifier.error(viewModel.t('Unexpected error talking to server: contact us!'))
    }

    function onTestComplete() {
      testCmd.enabled(true);
    }
  }

  var downloadCmd = {
    name: 'Download', // l10n happens in the template
    enabled: ko.observable(true)
  }
  downloadCmd.execute = function() {
    console.info('DOWNLOAD')
    downloadCmd.enabled(false)
    viewModel.notifier.info(viewModel.t("Downloading..."))
    viewModel.exportHTMLtoTextarea('#downloadHtmlTextarea')
    $('#downloadHtmlFilename').val(viewModel.metadata.name())
    $('#downloadForm')
    .attr('action', '/dl/')
    .submit()
    downloadCmd.enabled(true)
  }

  viewModel.save      = saveCmd
  viewModel.test      = testCmd
  viewModel.download  = downloadCmd

}

module.exports = loader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"lodash.omit":27,"validator/lib/isEmail":42}],82:[function(require,module,exports){
(function (global){
var tinycolor = require("./../../../bower_components/tinycolor/tinycolor.js");

function Color(tinycolor) {
  this.getBrightness = function(color) {
    return tinycolor(color).getBrightness();
  };
  this.isLight = function(color) {
    return tinycolor(color).isLight();
  };
  this.isDark = function(color) {
    return tinycolor(color).isDark();
  };
  this.getLuminance = function(color) {
    return tinycolor(color).getLuminance();
  };


  this.lighten = function(color, amount) {
    return tinycolor(color).lighten(amount).toHexString();
  };
  this.brighten = function(color, amount) {
    return tinycolor(color).brighten(amount).toHexString();
  };
  this.darken = function(color, amount) {
    return tinycolor(color).darken(amount).toHexString();
  };
  this.desaturate = function(color, amount) {
    return tinycolor(color).desaturate(amount).toHexString();
  };
  this.saturate = function(color, amount) {
    return tinycolor(color).saturate(amount).toHexString();
  };
  this.greyscale = function(color) {
    return tinycolor(color).greyscale().toHexString();
  };
  this.spin = function(color, amount) {
    return tinycolor(color).spin(amount).toHexString();
  };
  this.complement = function(color) {
    return tinycolor(color).complement().toHexString();
  };

  this.mix = tinycolor.mix;
  this.readability = tinycolor.readability;
  this.isReadable = tinycolor.isReadable;
  this.mostReadable = tinycolor.mostReadable;
}

var colorPlugin = function(vm) {
  global.Color = new Color(tinycolor);
};

module.exports = colorPlugin;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/tinycolor/tinycolor.js":18}],83:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */
var console = require("./../../../bower_components/console-browserify/index.js");
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var inlineDocument = require("./../../../bower_components/juice/lib/inline")({}).inlineDocument;

var inlinerPlugin = function(vm) {
  vm.inline = function(doc) {
    var style = [];
    $('style[data-inline="true"]', doc).each(function(index, element) {
      var content = $(element).html();
      content = content.replace(/<!-- ko ((?!--).)*? -->/g, ''); // this replaces the above with a more formal (but slower) solution
      content = content.replace(/<!-- \/ko -->/g, '');
      style.push(content);
      $(element).removeAttr('data-inline');
    });
    var styleText = style.join("\n");
    var $context = function(selector, context) {
      if (typeof context == 'undefined') context = doc;
      return $(selector, context);
    };
    $context.root = function() {
      return $(':root', doc);
    };
    inlineDocument($context, styleText, { styleAttributeName: 'replacedstyle' });
  };
};

module.exports = inlinerPlugin;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/juice/lib/inline":4}],84:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */
var console = require("./../../../bower_components/console-browserify/index.js");
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);

if (false) {

var lsLoader = function(hash_key, emailProcessorBackend) {
  var mdStr = global.localStorage.getItem("metadata-" + hash_key);
  if (mdStr !== null) {
    var model;
    var td = global.localStorage.getItem("template-" + hash_key);
    if (td !== null) model = JSON.parse(td);
    var md = JSON.parse(mdStr);
    return {
      metadata: md,
      model: model,
      extension: lsCommandPluginFactory(md, emailProcessorBackend)
    };
  } else {
    throw "Cannot find stored data for "+hash_key;
  }
};

var lsCommandPluginFactory = function(md, emailProcessorBackend) {
  var commandsPlugin = function(mdkey, mdname, viewModel) {

    // console.log("loading from metadata", md, model);
    var saveCmd = {
      name: 'Save', // l10n happens in the template
      enabled: ko.observable(true)
    };
    saveCmd.execute = function() {
      saveCmd.enabled(false);
      viewModel.metadata.changed = Date.now();
      if (typeof viewModel.metadata.key == 'undefined') {
        console.warn("Unable to find ket in metadata object...", viewModel.metadata);
        viewModel.metadata.key = mdkey;
      }
      global.localStorage.setItem("metadata-" + mdkey, viewModel.exportMetadata());
      global.localStorage.setItem("template-" + mdkey, viewModel.exportJSON());
      saveCmd.enabled(true);
    };
    var testCmd = {
      name: 'Test', // l10n happens in the template
      enabled: ko.observable(true)
    };
    var downloadCmd = {
      name: 'Download', // l10n happens in the template
      enabled: ko.observable(true)
    };
    testCmd.execute = function() {
      testCmd.enabled(false);
      var email = global.localStorage.getItem("testemail");
      if (email === null || email == 'null') email = viewModel.t('Insert here the recipient email address');
      email = global.prompt(viewModel.t("Test email address"), email);
      if (email.match(/@/)) {
        global.localStorage.setItem("testemail", email);
        console.log("TODO testing...", email);
        var postUrl = emailProcessorBackend ? emailProcessorBackend : '/dl/';
        var post = $.post(postUrl, {
          action: 'email',
          rcpt: email,
          subject: "[test] " + mdkey + " - " + mdname,
          html: viewModel.exportHTML()
        }, null, 'html');
        post.fail(function() {
          console.log("fail", arguments);
          viewModel.notifier.error(viewModel.t('Unexpected error talking to server: contact us!'));
        });
        post.success(function() {
          console.log("success", arguments);
          viewModel.notifier.success(viewModel.t("Test email sent..."));
        });
        post.always(function() {
          testCmd.enabled(true);
        });
      } else {
        global.alert(viewModel.t('Invalid email address'));
        testCmd.enabled(true);
      }
    };
    downloadCmd.execute = function() {
      downloadCmd.enabled(false);
      viewModel.notifier.info(viewModel.t("Downloading..."));
      viewModel.exportHTMLtoTextarea('#downloadHtmlTextarea');
      var postUrl = emailProcessorBackend ? emailProcessorBackend : '/dl/';
      global.document.getElementById('downloadForm').setAttribute("action", postUrl);
      global.document.getElementById('downloadForm').submit();
      downloadCmd.enabled(true);
    };

    viewModel.save = saveCmd;
    viewModel.test = testCmd;
    viewModel.download = downloadCmd;
  }.bind(undefined, md.key, md.name);

  return commandsPlugin;
};

module.exports = lsLoader;

} else if (true) {

module.exports = function() {}

}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],85:[function(require,module,exports){
"use strict";

require("./../../bower_components/knockout-sortable/build/knockout-sortable.min.js");

require("./bindings/jqueryui-spinner.js");
require("./bindings/jqueryui-tabs.js");
require("./bindings/colorpicker.js");
require("./bindings/blocks.js");
require("./bindings/csstext.js");
require("./bindings/bind-iframe.js");
require("./bindings/droppable.js");
require("./bindings/fileupload.js");
require("./bindings/virtuals.js");
require("./bindings/wysiwygs.js");
require("./bindings/scrollfix.js");
require("./bindings/if-subs.js");
require("./bindings/extsortables.js");
require("./bindings/eventable.js");
require("./bindings/tooltips.js");
require("./bindings/extender-pagination.js");
require("./bindings/validated-value.js");
require("./bindings/scrollintoview.js");
},{"./../../bower_components/knockout-sortable/build/knockout-sortable.min.js":8,"./bindings/bind-iframe.js":48,"./bindings/blocks.js":49,"./bindings/colorpicker.js":51,"./bindings/csstext.js":52,"./bindings/droppable.js":53,"./bindings/eventable.js":54,"./bindings/extender-pagination.js":55,"./bindings/extsortables.js":56,"./bindings/fileupload.js":57,"./bindings/if-subs.js":58,"./bindings/jqueryui-spinner.js":59,"./bindings/jqueryui-tabs.js":60,"./bindings/scrollfix.js":62,"./bindings/scrollintoview.js":63,"./bindings/tooltips.js":65,"./bindings/validated-value.js":66,"./bindings/virtuals.js":67,"./bindings/wysiwygs.js":68}],86:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null); // just for the widget plugins
var templateConverter = require("./converter/main.js");
var console = require("./../../bower_components/console-browserify/index.js");
var initializeViewmodel = require("./viewmodel.js");
var templateSystem = require('./bindings/choose-template.js');

// call a given method on every plugin implementing it.
// supports a "reverse" parameter to call the methods from the last one to the first one.
var pluginsCall = function(plugins, methodName, args, reverse) {
  var start, end, diff, res, results;
  results = [];
  if (typeof reverse !== 'undefined' && reverse) {
    start = plugins.length - 1;
    end = 0;
    diff = -1;
  } else {
    start = 0;
    end = plugins.length - 1;
    diff = 1;
  }
  for (var i = start; i != end + diff; i += diff) {
    if (typeof plugins[i][methodName] !== 'undefined') {
      res = plugins[i][methodName].apply(plugins[i], args);
      if (typeof res !== 'undefined') results.push(res);
    }
  }
  return results;
};

// workaround for knockout-jqueryui's buttonset/button disposal:
// https://github.com/gvas/knockout-jqueryui/issues/25
var origDisposeCallback = ko.utils.domNodeDisposal.addDisposeCallback;
ko.utils.domNodeDisposal.addDisposeCallback = function(node, callback) {
  var newCallback = function(node) {
    try {
      callback(node);
    } catch (e) {
      console.log("cought dispose callback exception", e);
    }
  };
  origDisposeCallback(node, newCallback);
};

var bindingPluginMaker = function(performanceAwareCaller) {
  return {
    viewModel: function(viewModel) {
      try {
        performanceAwareCaller('applyBindings', ko.applyBindings.bind(undefined, viewModel));
      } catch (err) {
        console.log(err, err.stack);
        throw err;
      }
    },
    dispose: function() {
      try {
        performanceAwareCaller('unapplyBindings', ko.cleanNode.bind(this, global.document.body));
      } catch (err) {
        console.log(err, err.stack);
        throw err;
      }
    }
  };
};

var templateCreator = function(templatePlugin, htmlOrElement, optionalName, templateMode) {
  var tmpName = optionalName;
  if (typeof optionalName != 'undefined' && typeof templateMode != 'undefined') {
    if (typeof htmlOrElement != 'object' || htmlOrElement.tagName.toLowerCase() != 'replacedhtml') tmpName += '-' + templateMode;
  }

  while (typeof tmpName == 'undefined' || tmpName === null || templatePlugin.exists(tmpName)) {
    tmpName = 'anonymous-' + Math.floor((Math.random() * 100000) + 1);
  }

  if (typeof htmlOrElement == 'object' && htmlOrElement.tagName.toLowerCase() == 'replacedhtml') {
    var $el = $(htmlOrElement);
    var $head = $('replacedhead', $el);
    var $body = $('replacedbody', $el);
    templatePlugin.adder(tmpName + '-head', $head.html() || '');
    templatePlugin.adder(tmpName + '-show', $body.html() || '');
    templatePlugin.adder(tmpName + '-preview', $el.html());
    templatePlugin.adder(tmpName + '-wysiwyg', $el.html());

    // $head.attr('data-bind', 'block: content');
    $head.children().detach();
    $head.html("<!-- ko block: content --><!-- /ko -->");
    $head.before('<!-- ko withProperties: { templateMode: \'head\' } -->');
    $head.after('<!-- /ko -->');
    $body.html("<!-- ko block: content --><!-- /ko -->");

    templatePlugin.adder(tmpName + '-iframe', $el[0].outerHTML);

  } else if (typeof htmlOrElement == 'object') {
    templatePlugin.adder(tmpName, htmlOrElement.outerHTML);
  } else {
    templatePlugin.adder(tmpName, htmlOrElement);
  }

  return tmpName;
};

// Adapter to transform "viewModel plugins" into more generic plugins.
function _viewModelPluginInstance(pluginFunction) {
  var instance;
  return {
    viewModel: function(viewModel) {
      instance = pluginFunction(viewModel);
    },
    init: function() {
      if (typeof instance !== 'undefined' && typeof instance.init !== 'undefined') instance.init();
    },
    dispose: function() {
      if (typeof instance !== 'undefined' && typeof instance.dispose !== 'undefined') instance.dispose();
    }
  };
}

if (false) {

var _templateUrlConverter = function(basePath, url) {
  if (!url.match(/^[^\/]*:/) && !url.match(/^\//) && !url.match(/^\[/) && !url.match(/^#?$/)) {
    // TODO this could be smarter joining the urls...
    return basePath + url;
  } else {
    return null;
  }
};

var templateLoader = function(performanceAwareCaller, templateFileName, templateMetadata, jsorjson, extensions, galleryUrl) {
  var templateFile = typeof templateFileName == 'string' ? templateFileName : templateMetadata.template;
  var templatePath = "./";
  var p = templateFile.lastIndexOf('/');
  if (p != -1) {
    templatePath = templateFile.substr(0, p + 1);
  }

  var templateUrlConverter = _templateUrlConverter.bind(undefined, templatePath);

  var metadata;
  if (typeof templateMetadata == 'undefined') {
    metadata = {
      template: templateFile,
      // TODO l10n?
      name: 'No name',
      created: Date.now()
    };
  } else {
    metadata = templateMetadata;
  }

  $.get(templateFile, function(templatecode) {
    var res = templateCompiler(performanceAwareCaller, templateUrlConverter, "template", templatecode, jsorjson, metadata, extensions, galleryUrl);
    res.init();
  });
};

} else if (true) {

// keep function signatures
var templateLoader = function(performanceAwareCaller, templateFileName, templateMetadata, jsorjson, extensions, galleryUrl) {
  console.info('TEMPLATE LOADER')

  // see ext/badsender-extensions.js#templateUrlConverter
  var templateUrlConverter = ko.bindingHandlers.wysiwygSrc.templateUrlConverter;

  var metadata  = templateMetadata;

  // Keep XHR to load template.
  // Don't want to output all the html in initialization
  // Should handle errors
  $.get(templateFileName, function(templatecode) {
    var res = templateCompiler(performanceAwareCaller, templateUrlConverter, "template", templatecode, jsorjson, metadata, extensions, galleryUrl);
    res.init();
  });
};

}

var templateCompiler = function(performanceAwareCaller, templateUrlConverter, templateName, templatecode, jsorjson, metadata, extensions, galleryUrl) {
  // we strip content before <html> tag and after </html> because jquery doesn't parse it.
  // we'll keep it "raw" and use it in the preview/output methods.
  var res = templatecode.match(/^([\S\s]*)([<]html[^>]*>[\S\s]*<\/html>)([\S\s]*)$/i);
  if (res === null) throw "Unable to find <html> opening and closing tags in the template";
  var prefix = res[1];
  // we parse the html content after replacing the tag name for html/head/body so to avoid jquery issues in parsing.
  var basicStructure = { '<html': 0, '<head': 0, '<body': 0, '</html': 0, '</body': 0, '</head': 0 };
  var html = res[2].replace(/(<\/?)(html|head|body)([^>]*>)/gi, function(match, p1, p2, p3) {
    basicStructure[(p1+p2).toLowerCase()] += 1;
    return p1 + 'replaced' + p2 + p3;
  });
  for (var ele in basicStructure) if (basicStructure.hasOwnProperty(ele)) if (basicStructure[ele] != 1) {
    if (basicStructure[ele] === 0) throw "ERROR: missing mandatory element "+ele+">";
    if (basicStructure[ele] > 1) throw "ERROR: multiple element "+ele+"> occourences are not supported (found "+basicStructure[ele]+" occourences)";
  }
  var postfix = res[3];
  var blockDefs = [];
  var enableUndo = true;
  var enableRecorder = true;
  var baseThreshold = '+$root.contentListeners()';

  var plugins = [];

  if (typeof extensions !== 'undefined') {
    for (var i = 0; i < extensions.length; i++) {
      if (typeof extensions[i] == 'function') {
        plugins.push(_viewModelPluginInstance(extensions[i]));
      } else {
        plugins.push(extensions[i]);
      }
    }
  }

  var createdTemplates = [];
  var templatesPlugin = {
    adder: function(id, html) {
      if (typeof html !== 'string') throw "Template system: cannot create new template " + id;
      var trash = html.match(/(data)?-ko-[^ =:]*/g);
      if (trash) {
        console.error("ERROR: found unexpected -ko- attribute in compiled template", id, ", you probably mispelled it:", trash);
      }
      templateSystem.addTemplate(id, html);
      createdTemplates.push(id);
    },
    exists: function(id) {
      var el = templateSystem.getTemplateContent(id);
      if (typeof el !== 'undefined') return true;
      else return false;
    },
    dispose: function() {
      for (var i = createdTemplates.length - 1; i >= 0; i--) {
        templateSystem.removeTemplate(createdTemplates[i]);
      }
    }
  };

  ko.bindingHandlers['block'].templateExists = templatesPlugin.exists;

  // templatecreator tracks created template (via templateAdder) so to be able to dispose them later
  var myTemplateCreator = templateCreator.bind(undefined, templatesPlugin);

  // first pass: we "compile" the template into a termplateDef object
  var templateDef = performanceAwareCaller('translateTemplate', templateConverter.translateTemplate.bind(undefined, templateName, html, templateUrlConverter, myTemplateCreator));

  // second pass: given the templateDef we create a base content model object for this template.
  var content = performanceAwareCaller('generateModel', templateConverter.wrappedResultModel.bind(undefined, templateDef));

  // third pass: we create "style/content editors" for every block
  var widgets = {};
  var widgetPlugins = pluginsCall(plugins, 'widget', [$, ko, kojqui]);
  for (var wi = 0; wi < widgetPlugins.length; wi++) {
    widgets[widgetPlugins[wi].widget] = widgetPlugins[wi];
  }
  blockDefs.push.apply(blockDefs, performanceAwareCaller('generateEditors', templateConverter.generateEditors.bind(undefined, templateDef, widgets, templateUrlConverter, myTemplateCreator, baseThreshold)));

  var incompatibleTemplate = false;
  if (typeof jsorjson !== 'undefined' && jsorjson !== null) {
    var unwrapped;
    if (typeof jsorjson == 'string') {
      unwrapped = ko.utils.parseJson(jsorjson);
    } else {
      unwrapped = jsorjson;
    }

    // we run a basic compatibility check between the content-model we expect and the initialization model
    var checkModelRes = performanceAwareCaller('checkModel', templateConverter.checkModel.bind(undefined, content._unwrap(), blockDefs, unwrapped));
    // if checkModelRes is 1 then the model is not fully compatible but we fixed it
    if (checkModelRes == 2) {
      console.error("Trying to compile an incompatible template version!", content._unwrap(), blockDefs, unwrapped);
      incompatibleTemplate = true;
    }

    try {
      content._wrap(unwrapped);
    } catch (ex) {
      console.error("Unable to inject model content!", ex);
      incompatibleTemplate = true;
    }
  }

  // This build the template for the preview/output, but concatenating prefix, template and content and stripping the "replaced" prefix added to "problematic" tag (html/head/body)
  var iframeTpl = prefix + templateSystem.getTemplateContent(templateName + '-iframe').replace(/(<\/?)replaced(html|head|body)([^>]*>)/gi, function(match, p1, p2, p3) {
    return p1 + p2 + p3;
  }) + postfix;

  // store this so to restore it on disposale
  var origiFrameTpl = ko.bindingHandlers.bindIframe.tpl;
  ko.bindingHandlers.bindIframe.tpl = iframeTpl;
  var iFramePlugin = {
    dispose: function() {
      ko.bindingHandlers.bindIframe.tpl = origiFrameTpl;
    }
  };

  plugins.push(iFramePlugin);
  plugins.push(templatesPlugin);

  // initialize the viewModel object based on the content model.
  var viewModel = performanceAwareCaller('initializeViewmodel', initializeViewmodel.bind(this, content, blockDefs, templateUrlConverter, galleryUrl));

  viewModel.metadata = metadata;
  // let's run some version check on template and editor used to build the model being loaded.
  var editver = '0.15.0';
  if (typeof viewModel.metadata.editorversion !== 'undefined' && viewModel.metadata.editorversion !== editver) {
    console.warn("The model being loaded has been created with an older editor version", viewModel.metadata.editorversion, "vs", editver);
  }
  viewModel.metadata.editorversion = editver;

  if (typeof templateDef.version !== 'undefined') {
    if (typeof viewModel.metadata.templateversion !== 'undefined' && viewModel.metadata.templateversion !== templateDef.version) {
      console.error("The model being loaded has been created with a different template version", templateDef.version, "vs", viewModel.metadata.templateversion);
    }
    viewModel.metadata.templateversion = templateDef.version;
  }

  templateSystem.init();

  // everything's ready, start knockout bindings.
  plugins.push(bindingPluginMaker(performanceAwareCaller));

  pluginsCall(plugins, 'viewModel', [viewModel]);

  if (incompatibleTemplate) {
    $('#incompatible-template').dialog({
      modal: true,
      appendTo: '#mo-body',
      buttons: {
        Ok: function() {
          $(this).dialog("close");
        }
      }
    });
  }

  return {
    model: viewModel,
    init: function() {
      pluginsCall(plugins, 'init', undefined, true);
    },
    dispose: function() {
      pluginsCall(plugins, 'dispose', undefined, true);
    }
  };

};


var checkFeature = function(feature, func) {
  if (!func()) {
    console.warn("Missing feature", feature);
    throw "Missing feature " + feature;
  }
};

var isCompatible = function() {
  try {
    // window.msMatchMedia would match also IE9
    // IE9 wouldn't be so hard to support, but it doesn't worth it. (preview iframe and automatic scroll are 2 things not working in IE9)
    checkFeature('matchMedia', function() {
      return typeof global.matchMedia != 'undefined';
    });
    checkFeature('XMLHttpRequest 2', function() {
      return 'XMLHttpRequest' in global && 'withCredentials' in new global.XMLHttpRequest();
    });
    checkFeature('ES5 strict', function() {
      return function() { /* "use strict";*/
        return typeof this == 'undefined';
      }();
    });
    checkFeature('CSS borderRadius', function() {
      return typeof global.document.body.style['borderRadius'] != 'undefined';
    });
    checkFeature('CSS boxShadow', function() {
      return typeof global.document.body.style['boxShadow'] != 'undefined';
    });
    checkFeature('CSS boxSizing', function() {
      return typeof global.document.body.style['boxSizing'] != 'undefined';
    });
    checkFeature('CSS backgroundSize', function() {
      return typeof global.document.body.style['backgroundSize'] != 'undefined';
    });
    checkFeature('CSS backgroundOrigin', function() {
      return typeof global.document.body.style['backgroundOrigin'] != 'undefined';
    });
    checkBadBrowserExtensions();
    return true;
  } catch (exception) {
    return false;
  }
};

var checkBadBrowserExtensions = function() {
  var id = 'checkbadbrowsersframe';
  var origTpl = ko.bindingHandlers.bindIframe.tpl;
  ko.bindingHandlers.bindIframe.tpl = "<!DOCTYPE html>\r\n<html>\r\n<head><title>A</title>\r\n</head>\r\n<body><p style=\"color: blue\" align=\"right\" data-bind=\"style: { color: 'red' }\">B</p><div data-bind=\"text: content\"></div></body>\r\n</html>\r\n";
  $('body').append('<iframe id="' + id + '" data-bind="bindIframe: $data"></iframe>');
  var frameEl = global.document.getElementById(id);
  ko.applyBindings({ content: "dummy content" }, frameEl);
  // Obsolete method didn't work on IE11 when using "HTML5 doctype":
  // var docType = new XMLSerializer().serializeToString(global.document.doctype);
  var node = frameEl.contentWindow.document.doctype;
  var docType = "<!DOCTYPE " + node.name +
    (node.publicId ? ' PUBLIC "' + node.publicId + '"' : '') +
    (!node.publicId && node.systemId ? ' SYSTEM' : '') +
    (node.systemId ? ' "' + node.systemId + '"' : '') + '>';
  var content = docType + "\n" + frameEl.contentWindow.document.documentElement.outerHTML;
  ko.cleanNode(frameEl);
  ko.removeNode(frameEl);
  ko.bindingHandlers.bindIframe.tpl = origTpl;

  var expected = "<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p align=\"right\" style=\"color: red;\" data-bind=\"style: { color: 'red' }\">B</p><div data-bind=\"text: content\">dummy content</div>\n\n</body></html>";
  var expected2 = "<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p style=\"color: red;\" data-bind=\"style: { color: 'red' }\" align=\"right\">B</p><div data-bind=\"text: content\">dummy content</div>\n\n</body></html>";
  var expected3 = "<!DOCTYPE html>\n<html><head><title>A</title>\n</head>\n<body><p style=\"color: red;\" align=\"right\" data-bind=\"style: { color: 'red' }\">B</p><div data-bind=\"text: content\">dummy content</div>\n\n</body></html>";
  if (expected !== content && expected2 !== content && expected3 !== content) {
    console.log("BadBrowser.FrameContentCheck", content.length, expected.length, expected2.length, expected3.length, content == expected, content == expected2, content == expected3);
    console.log(content);
    throw "Unexpected frame content. Misbehaving browser: "+content.length+"/"+expected.length+"/"+expected2.length+"/"+expected3.length;
  }
};

var fixPageEvents = function() {
  // This is global code to prevent dragging/dropping in the page where we don't deal with it.
  // IE8 doesn't have window.addEventListener, but doesn't support drag&drop too.
  if (global.addEventListener) {
    // prevent generic file droppping in the page
    global.addEventListener("drag", function(e) {
      // console.log("browser is using drag listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("dragstart", function(e) {
      // console.log("browser is using dragstart listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("dragover", function(e) {
      // this is called on mouse move on every supported browser.
      // console.log("browser is using dragover listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("drop", function(e) {
      // console.log("browser is using drop listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.document.body.addEventListener('drop', function(e) {
      // I browser supportati entrato tutti qui quando si droppa qualcosa sul body
      // console.log("browser is using drop listener on body tag");
      e.preventDefault();
    }, false);
  }
  if (global.document.ondragstart) {
    global.document.ondragstart = function() {
      // console.log("browser called ondragstart. return false!");
      return false;
    };
  }
};

module.exports = {
  compile: templateCompiler,
  load: templateLoader,
  isCompatible: isCompatible,
  fixPageEvents: fixPageEvents
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./bindings/choose-template.js":50,"./converter/main.js":73,"./viewmodel.js":90}],87:[function(require,module,exports){
"use strict";

var console = require("./../../bower_components/console-browserify/index.js");

var _call = function(whatToCall) {
  return whatToCall();
};

var logs = [];

var _timedCall = function(name, whatToCall) {
  var res;
  var start = new Date().getTime();
  if (typeof console == 'object' && console.time) console.time(name);
  res = _call(whatToCall);
  if (typeof console == 'object' && console.time) console.timeEnd(name);
  var diff = new Date().getTime() - start;
  if (typeof console == 'object' && !console.time) console.log(name, "took", diff, "ms");
  logs.push({
    name: name,
    time: diff
  });
  // max logs
  if (logs.length > 100) logs.unshift();
  return res;
};

module.exports = {
  timedCall: _timedCall,
  logs: logs
};
},{"./../../bower_components/console-browserify/index.js":1}],88:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var undoManager = require("./../../../bower_components/knockout-undomanager/knockout-undomanager.js");
var undoserializer = require("./undoserializer.js");

var addUndoStackExtensionMaker = function(performanceAwareCaller) {
  return function(viewModel) {

    viewModel.contentListeners(viewModel.contentListeners() + 2);

    // TODO the labels should be computed observables (needs changes in undomanager projects)
    var undoRedoStack = undoManager(viewModel.content, {
      levels: 100,
      undoLabel: ko.computed(function() { return viewModel.t("Undo (#COUNT#)"); }),
      redoLabel: ko.computed(function() { return viewModel.t("Redo"); })
    });
    viewModel.undo = undoRedoStack.undoCommand;
    viewModel.undo.execute = performanceAwareCaller.bind(viewModel, 'undo', viewModel.undo.execute);
    viewModel.redo = undoRedoStack.redoCommand;
    viewModel.redo.execute = performanceAwareCaller.bind(viewModel, 'redo', viewModel.redo.execute);
    viewModel.undoReset = performanceAwareCaller.bind(viewModel, 'undoReset', undoRedoStack.reset);
    viewModel.setUndoModeMerge = undoRedoStack.setModeMerge;
    viewModel.setUndoModeOnce = undoRedoStack.setModeOnce;
    undoRedoStack.setModeIgnore();
    undoRedoStack.setUndoActionMaker(undoserializer.makeUndoAction.bind(undefined, viewModel.content));
    undoserializer.watchEnabled(true);

    return {
      pause: function() {
        undoRedoStack.setModeIgnore();
      },
      run: function() {
        undoRedoStack.setModeOnce();
      },
      init: function() {
        undoRedoStack.setModeOnce();
      },
      dispose: function() {
        viewModel.contentListeners(viewModel.contentListeners() - 2);
        undoserializer.watchEnabled(false);
        undoRedoStack.dispose();
      }
    };

  };
};

module.exports = addUndoStackExtensionMaker;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/knockout-undomanager/knockout-undomanager.js":9,"./undoserializer.js":89}],89:[function(require,module,exports){
(function (global){
"use strict";
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
// This module deals with serialization/deserialization of a "tree-path" representing the path to reach the given leaf.
// In order to be correctly serialized we have to move from "reference" to "string" and viceversa.

var _reference = function(model, path) {
  var p = 0;
  var p1, p2;
  var m = model;
  while (p < path.length) {
    switch (path.charAt(p)) {
      case '(':
        if (path.charAt(p + 1) == ')') {
          m = m();
        } else {
          // TODO error
        }
        p += 2;
        break;
      case '[':
        p2 = path.indexOf(']', p);
        m = m[path.substring(p + 1, p2)];
        p = p2 + 1;
        break;
      case '.':
        p1 = path.indexOf('(', p);
        if (p1 == -1) p1 = path.length;
        p2 = path.indexOf('[', p);
        if (p2 == -1) p2 = path.length;
        p2 = Math.min(p1, p2);
        m = m[path.substring(p + 1, p2)];
        p = p2;
        break;
      default:
        // TODO error
    }
  }
  return m;
};

var _getPath = function(parents, child) {
  var path = "";
  var p;
  for (var k = 0; k <= parents.length; k++) {
    p = k < parents.length ? parents[k] : child;
    if (ko.isObservable(p)) path += '()';
    if (typeof p._fieldName !== 'undefined') {
      path += "." + p._fieldName;
    } else if (k > 0 && typeof parents[k - 1].pop == 'function') {
      var parentArray = ko.isObservable(parents[k - 1]) ? ko.utils.peekObservable(parents[k - 1]) : parents[k - 1];
      var pos = ko.utils.arrayIndexOf(parentArray, p);
      if (pos != -1) {
        path += "[" + pos + "]";
      } else {
        // NOTE this happen, sometimes when TinyMCE sends updates for objects already removed.
        console.error("Unexpected object not found in parent array", parentArray, p, k, parents.length, ko.toJS(parentArray), ko.utils.unwrapObservable(p));
        throw "Unexpected object not found in parent array";
      }
    } else {
      console.error("Unexpected parent with no _fieldName and no parent array", k, parents);
      throw "Unexpected parent with no _fieldName and no parent array";
    }
  }
  return path;
};

var makeDereferencedUndoAction = function(undoFunc, model, path, value, item) {
  var child = _reference(model, path);
  undoFunc(child, value, item);
};

var listener;

var _setListener = function(listenfunc) {
  listener = listenfunc;
};

/* dereferencing path and changing value with "toJS" */
var makeUndoActionDereferenced = function(model, undoFunc, parents, child, oldVal, item) {
  try {
    var path = _getPath(parents, child);

    // Transform actions in simple JS objects.
    if (typeof oldVal === 'object' || typeof oldVal === 'function') oldVal = ko.toJS(oldVal);
    if (typeof item !== 'undefined' && (typeof item.value === 'object' || typeof item.value === 'function')) {
      var newItem = ko.toJS(item);
      item = newItem;
    }

    if (typeof listener !== 'undefined') {
      try {
        listener(path, child, oldVal, item);
      } catch (e) {
        console.log("Undoserializer ignoring exception in listener callback");
      }
    }

    return makeDereferencedUndoAction.bind(undefined, undoFunc, model, path, oldVal, item);
  } catch (e) {
    // NOTE this happens, from time to time, when TinyMCE sends updates for deleted content.
    console.error("Exception processing undo", e, parents, child, item);
  }
};

var watchEnabled;
var _watchEnabled = function(newVal) {
  if (typeof newVal !== 'undefined')
    watchEnabled = newVal;
  else
    return watchEnabled;
};

module.exports = {
  dereference: _getPath,
  reference: _reference,
  makeUndoAction: makeUndoActionDereferenced,
  setListener: _setListener,
  watchEnabled: _watchEnabled
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],90:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../bower_components/console-browserify/index.js");
var performanceAwareCaller = require("./timed-call.js").timedCall;

var toastr = require("./../../bower_components/toastr/toastr.js");
toastr.options = {
  "closeButton": false,
  "debug": false,
  "positionClass": "toast-bottom-full-width",
  "target": "#mo-body",
  "onclick": null,
  "showDuration": "300",
  "hideDuration": "1000",
  "timeOut": "5000",
  "extendedTimeOut": "1000",
  "showEasing": "swing",
  "hideEasing": "linear",
  "showMethod": "fadeIn",
  "hideMethod": "fadeOut"
};

/* NOTE: translations moved to "plugin"
var strings = {
  'show preview and send test': 'Visualizza una anteprima e fai un invio di test',
  // Strings for app.js
  'Download': 'Download',
  'Test': 'Test',
  'Save': 'Salva',
  'Downloading...': "Download in corso...",
  'Invalid email address': "Indirizzo email invalido",
  "Test email sent...": "Email di test inviata...",
  'Unexpected error talking to server: contact us!': 'Errore di comunicazione con il server: contattaci!',
  'Insert here the recipient email address': 'Inserisci qui l\'indirizzo email a cui spedire',
  "Test email address": "Indirizzo email di test",
  // viewModel
  'Block removed: use undo button to restore it...': 'Blocco eliminato: usa il pulsante annulla per recuperarlo...',
  'New block added after the selected one (__pos__)': 'Nuovo blocco aggiunto sotto a quello selezionato (__pos__)',
  'New block added at the model bottom (__pos__)': 'Nuovo blocco aggiunto in fondo al modello (__pos__)',
  // undomain.js
  'Undo (#COUNT#)': 'Annulla (#COUNT#)',
  'Redo': 'Ripristina',
  // editor.js
  'Selected element has no editable properties': 'L\'elemento selezionato non fornisce proprietà editabili',
  'This style is specific for this block: click here to remove the custom style and revert to the theme value': 'Questo stile è specifico di questo blocco: clicca qui per annullare lo stile personalizzato',
  'Switch between global and block level styles editing': 'Permette di specificare se si vuole modificare lo stile generale o solamente quello specifico del blocco selezionato',
  // main.tpl.html
  'Undo last operation': 'Annulla ultima operazione',
  'Redo last operation': 'Ripeti operazione annullata',
  'Show image gallery': 'Visualizza galleria immagini',
  'Gallery': 'Galleria',
  'Preview': 'Anteprima',
  'Show live preview': 'Mostra anteprima live',
  'Large screen': 'Schermo grande',
  'Tablet': 'Tablet',
  'Smartphone': 'Smartphone',
  'Show preview and send test': 'Visualizza una anteprima e fai un invio di test',
  'Download template': 'Scarica il template',
  'Save template': 'Salva il template',
  'Saved model is obsolete': 'Modello salvato obsoleto',
  '<p>The saved model has been created with a previous, non completely compatible version, of the template</p><p>Some content or style in the model <b>COULD BE LOST</b> if you will <b>save</b></p><p>Contact us for more informations!</p>': '<p>Il modello salvato è stato creato con una versione precedente del template non del tutto compatibile</p><p>Alcuni contenuti o stili del modello <b>POTREBBERO ESSERE PERSI</b> se procederai e deciderai di <b>salvare</b></p><p>Contattaci se hai dei dubbi!</p>',

  // TODO this cannot be done in knockout as with uncompatible browsers we don't initialize
  // 'Usupported browser': 'Browser non compatibile',
  // '<p>Your browser is not supported.</p><p>Use a different browser or try updaring your browser.</p><p>Supported browsers: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>': '<p>Il tuo browser non è supportato.</p><p>Accedi con un browser differente o prova ad aggiornare il tuo browser.</p><p>Browser supportati: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>',

  // toolbox
  'Blocks': 'Blocchi',
  'Blocks ready to be added to the template': 'Elenco contenuti aggiungibili al messaggio',
  'Content': 'Contenuto',
  'Edit content options': 'Modifica opzioni contenuti',
  'Style': 'Stile',
  'Edit style options': 'Modifica opzioni grafiche',
  'Block __name__': 'Blocco __name__',
  'Click or drag to add this block to the template': 'Clicca o trascina per aggiungere al messaggio',
  'Add': 'Aggiungi',
  'By clicking on message parts you will select a block and content options, if any, will show here': 'Cliccando su alcune parti del messaggio selezionerai un blocco e le opzioni contenutistiche, se disponibili, compariranno qui',
  'By clicking on message parts you will select a block and style options, if available, will show here': 'Cliccando su alcune parti del messaggio selezionerai un blocco e le opzioni di stile, se disponibili, compariranno qui',
  'Click or drag files here': 'Clicca o trascina i file qui!',
  'No images uploaded, yet': 'Non hai ancora caricato immagini',
  'Show images from the gallery': 'Visualizza le immagini caricate nella tua area',
  'Loading...': 'Caricamento...',
  'Load gallery': 'Carica galleria',
  'Loading gallery...': 'Caricamento in corso...',
  'The gallery is empty': 'Nessuna immagine nella galleria',
  // img-wysiwyg.tmlp
  'Remove image': 'Rimuovi immagine',
  'Open the image editing tool': 'Avvia strumento modifica immagine',
  'Upload a new image': 'Carica una nuova immagine',
  'Drop an image here': 'Trascina una immagine qui',
  'Drop an image here or click the upload button': 'Trascina una immagine qui o clicca sul pulsante di caricamento',
  // gallery
  'Drag this image and drop it on any template image placeholder': 'Trascina questa immagine sulla posizione in cui vuoi inserirla',
  'Gallery:': 'Galleria:',
  'Session images': 'Immagini di sessione',
  'Recents': 'Recenti',
  'Remote gallery': 'Galleria remota',

  // customstyle
  'Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class="customStyled"><span>"small cube" </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul>': 'Blocco personalizzato.<ul><li>In questa modalità se cambi una proprietà verrà modificata solamente per questo specifico blocco (invece che per tutti i blocchi della stessa sezione).</li><li>Per segnalare la personalizzazione apparirà l\'icona <span class="customStyled"><span> del "cubetto"</span></span> a fianco delle proprietà. Cliccando questa icona tornerai al valore comune.</li></ul>',
  // blocks-wysiwyg
  'Drop here blocks from the "Blocks" tab': 'Trascina qui i blocchi dalla scheda \'Blocchi\'',
  // block-wysiwyg
  'Drag this handle to move the block': 'Trascina per spostare il blocco altrove',
  'Move this block upside': 'Sposta il blocco in su',
  'Move this block downside': 'Sposta il blocco in giu',
  'Delete block': 'Elimina blocco',
  'Duplicate block': 'Duplica blocco',
  'Switch block variant': 'Cambia variante blocco',
  // colorpicker
  'Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet.': 'Colori Tema,Colori Standard,Colori Web,Colori Tema,Torna alla tavolozza,Storico,storico colori vuoto',

  'Drop here': 'Rilascia qui',

};
*/

function initializeEditor(content, blockDefs, thumbPathConverter, galleryUrl) {

  var viewModel = {
    galleryRecent: ko.observableArray([]).extend({
      paging: 16
    }),
    galleryRemote: ko.observableArray([]).extend({
      paging: 16
    }),
    selectedBlock: ko.observable(null),
    selectedItem: ko.observable(null),
    selectedTool: ko.observable(0),
    selectedImageTab: ko.observable(0),
    dragging: ko.observable(false),
    draggingImage: ko.observable(false),
    galleryLoaded: ko.observable(false),
    showPreviewFrame: ko.observable(false),
    previewMode: ko.observable('mobile'),
    showToolbox: ko.observable(true),
    showTheme: ko.observable(false),
    showGallery: ko.observable(false),
    debug: ko.observable(false),
    contentListeners: ko.observable(0),

    logoPath: 'dist/img/mosaico32.png',
    logoUrl: '.',
    logoAlt: 'mosaico'
  };

  // viewModel.content = content._instrument(ko, content, undefined, true);
  viewModel.content = content;
  viewModel.blockDefs = blockDefs;

  viewModel.notifier = toastr;

  // Does token substitution in i18next style
  viewModel.tt = function(key, paramObj) {
    if (typeof paramObj !== 'undefined')
      for (var prop in paramObj)
        if (paramObj.hasOwnProperty(prop)) {
          key = key.replace(new RegExp('__' + prop + '__', 'g'), paramObj[prop]);
        }
    return key;
  };

  // Simply maps to tt: language plugins can override this method to define their own language
  // handling.
  // If this method invokes an observable (e.g: viewModel.lang()) then the UI language will automatically
  // update when the "lang" observable changes.
  viewModel.t = viewModel.tt;

  // currently called by editor.html to translate template-defined keys (label, help, descriptions)
  // the editor always uses the "template" category for that strings.
  // you can override this method as you like in order to provide translation or change the strings in any way.
  viewModel.ut = function(category, key) {
    return key;
  };

  viewModel.templatePath = thumbPathConverter;

  viewModel.remoteUrlProcessor = function(url) {
    return url;
  };

  viewModel.remoteFileProcessor = function(fileObj) {
    if (typeof fileObj.url !== 'undefined') fileObj.url = viewModel.remoteUrlProcessor(fileObj.url);
    if (typeof fileObj.thumbnailUrl !== 'undefined') fileObj.thumbnailUrl = viewModel.remoteUrlProcessor(fileObj.thumbnailUrl);
    // deleteUrl?
    return fileObj;
  };

  // toolbox.tmpl.html
  viewModel.loadGallery = function() {
    viewModel.galleryLoaded('loading');
    var url = galleryUrl ? galleryUrl : '/upload/';
    // retrieve the full list of remote files
    $.getJSON(url, function(data) {
      for (var i = 0; i < data.files.length; i++) data.files[i] = viewModel.remoteFileProcessor(data.files[i]);
      viewModel.galleryLoaded(data.files.length);
      // TODO do I want this call to return relative paths? Or just absolute paths?
      viewModel.galleryRemote(data.files.reverse());
    }).fail(function() {
      viewModel.galleryLoaded(false);
      viewModel.notifier.error(viewModel.t('Unexpected error listing files'));
    });
  };

  // img-wysiwyg.tmpl.html
  viewModel.fileToImage = function(obj, event, ui) {
    // console.log("fileToImage", obj);
    return obj.url;
  };

  // block-wysiwyg.tmpl.html
  viewModel.removeBlock = function(data, parent) {
    // let's unselect the block
    if (ko.utils.unwrapObservable(viewModel.selectedBlock) == ko.utils.unwrapObservable(data)) {
      viewModel.selectBlock(null, true);
    }
    var res = parent.blocks.remove(data);
    // TODO This message should be different depending on undo plugin presence.
    viewModel.notifier.info(viewModel.t('Block removed: use undo button to restore it...'));
    return res;
  };

  // block-wysiwyg.tmpl.html
  viewModel.duplicateBlock = function(index, parent) {
    var idx = ko.utils.unwrapObservable(index);
    // Deinstrument/deobserve the object
    var unwrapped = ko.toJS(ko.utils.unwrapObservable(parent.blocks)[idx]);
    // We need to remove the id so that a new one will be assigned to the clone
    if (typeof unwrapped.id !== 'undefined') unwrapped.id = '';
    // insert the cloned block
    parent.blocks.splice(idx + 1, 0, unwrapped);
  };

  // block-wysiwyg.tmpl.html
  viewModel.moveBlock = function(index, parent, up) {
    var idx = ko.utils.unwrapObservable(index);
    var parentBlocks = ko.utils.unwrapObservable(parent.blocks);
    if ((up && idx > 0) || (!up && idx < parentBlocks.length - 1)) {
      var destIndex = idx + (up ? -1 : 1);
      var destBlock = parentBlocks[destIndex];
      viewModel.startMultiple();
      parent.blocks.splice(destIndex, 1);
      parent.blocks.splice(idx, 0, destBlock);
      viewModel.stopMultiple();
    }
  };

  // test method, command line use only
  viewModel.loadDefaultBlocks = function() {
    // cloning the whole "mainBlocks" object so that undomanager will
    // see it as a single operation (maybe I could use "startMultiple"/"stopMultiple".
    var res = ko.toJS(viewModel.content().mainBlocks);
    res.blocks = [];
    var input = ko.utils.unwrapObservable(viewModel.blockDefs);
    for (var i = 0; i < input.length; i++) {
      var obj = ko.toJS(input[i]);
      // generating ids for blocks, maybe this would work also leaving it empty.
      obj.id = 'block_' + i;
      res.blocks.push(obj);
    }
    performanceAwareCaller('setMainBlocks', viewModel.content().mainBlocks._wrap.bind(viewModel.content().mainBlocks, res));
  };

  // gallery-images.tmpl.html
  viewModel.addImage = function(img) {
    var selectedImg = $('#main-wysiwyg-area .selectable-img.selecteditem');
    if (selectedImg.length == 1 && typeof img == 'object' && typeof img.url !== 'undefined') {
      ko.contextFor(selectedImg[0])._src(img.url);
      return true;
    } else {
      return false;
    }
  };

  // toolbox.tmpl.html
  viewModel.addBlock = function(obj, event) {
    // if there is a selected block we try to add the block just after the selected one.
    var selected = viewModel.selectedBlock();
    // search the selected block position.
    var found;
    if (selected !== null) {
      // TODO "mainBlocks" is an hardcoded thing.
      for (var i = viewModel.content().mainBlocks().blocks().length - 1; i >= 0; i--) {
        if (viewModel.content().mainBlocks().blocks()[i]() == selected) {
          found = i;
          break;
        }
      }
    }
    var pos;
    if (typeof found !== 'undefined') {
      pos = found + 1;
      viewModel.content().mainBlocks().blocks.splice(pos, 0, obj);
      viewModel.notifier.info(viewModel.t('New block added after the selected one (__pos__)', {
        pos: pos
      }));
    } else {
      viewModel.content().mainBlocks().blocks.push(obj);
      pos = viewModel.content().mainBlocks().blocks().length - 1;
      viewModel.notifier.info(viewModel.t('New block added at the model bottom (__pos__)', {
        pos: pos
      }));
    }
    // find the newly added block and select it!
    var added = viewModel.content().mainBlocks().blocks()[pos]();
    viewModel.selectBlock(added, true);
    // prevent click propagation (losing url hash - see #43)
    return false;
  };

  // Used by stylesheet.js to create multiple styles
  viewModel.findObjectsOfType = function(data, type) {
    var res = [];
    var obj = ko.utils.unwrapObservable(data);
    for (var prop in obj)
      if (obj.hasOwnProperty(prop)) {
        var val = ko.utils.unwrapObservable(obj[prop]);
        // TODO this is not the right way to deal with "block list" objects.
        if (prop.match(/Blocks$/)) {
          var contents = ko.utils.unwrapObservable(val.blocks);
          for (var i = 0; i < contents.length; i++) {
            var c = ko.utils.unwrapObservable(contents[i]);
            if (type === null || ko.utils.unwrapObservable(c.type) == type) res.push(c);
          }
          // TODO investigate which condition provide a null value.
        } else if (typeof val == 'object' && val !== null) {
          if (type === null || ko.utils.unwrapObservable(val.type) == type) res.push(val);
        }
      }
    return res;
  };

  /*
  viewModel.placeholderHelper = 'sortable-placeholder';
  if (false) {
    viewModel.placeholderHelper = {
      element: function(currentItem) {
        return $('<div />').removeClass('ui-draggable').addClass('sortable-placeholder').css('position', 'relative').css('width', '100%').css('height', currentItem.css('height')).css('opacity', '.8')[0];
      },
      update: function(container, p) {
       return;
      }
    };
  }
  */

  // Attempt to insert the block in the destination layout during dragging
  viewModel.placeholderHelper = {
    element: function(currentItem) {
      return $(currentItem[0].outerHTML).removeClass('ui-draggable').addClass('sortable-placeholder').css('display', 'block').css('position', 'relative').css('width', '100%').css('height', 'auto').css('opacity', '.8')[0];
    },
    update: function(container, p) {
      return;
    }
  };

  // TODO the undumanager should be pluggable.
  // Used by "moveBlock" and blocks-wysiwyg.tmpl.html to "merge" drag/drop operations into a single undo/redo op.
  viewModel.startMultiple = function() {
    if (typeof viewModel.setUndoModeMerge !== 'undefined') viewModel.setUndoModeMerge();
  };
  viewModel.stopMultiple = function() {
    if (typeof viewModel.setUndoModeOnce !== 'undefined') viewModel.setUndoModeOnce();
  };

  // Used by code generated by editor.js
  viewModel.localGlobalSwitch = function(prop, globalProp) {
    var current = prop();
    if (current === null) prop(globalProp());
    else prop(null);
    return false;
  };

  // Used by editor and main "converter" to support item selection
  viewModel.selectItem = function(valueAccessor, item, block) {
    var val = ko.utils.peekObservable(valueAccessor);
    if (typeof block !== 'undefined') viewModel.selectBlock(block, false, true);
    if (val != item) {
      valueAccessor(item);
      // On selectItem if we were on "Blocks" toolbox tab we move to "Content" toolbox tab.
      if (item !== null && viewModel.selectedTool() === 0) viewModel.selectedTool(1);
    }
    return false;
  }.bind(viewModel, viewModel.selectedItem);

  viewModel.isSelectedItem = function(item) {
    return viewModel.selectedItem() == item;
  };

  viewModel.selectBlock = function(valueAccessor, item, doNotSelect, doNotUnselectItem) {
    var val = ko.utils.peekObservable(valueAccessor);
    if (!doNotUnselectItem) viewModel.selectItem(null);
    if (val != item) {
      valueAccessor(item);
      // hide gallery on block selection
      viewModel.showGallery(false);
      if (item !== null && !doNotSelect && viewModel.selectedTool() === 0) viewModel.selectedTool(1);
    }
  }.bind(viewModel, viewModel.selectedBlock);

  // DEBUG
  viewModel.countSubscriptions = function(model, debug) {
    var res = 0;
    for (var prop in model)
      if (model.hasOwnProperty(prop)) {
        var p = model[prop];
        if (ko.isObservable(p)) {
          if (typeof p._defaultComputed != 'undefined') {
            if (typeof debug != 'undefined') console.log(debug + "/" + prop + "/_", p._defaultComputed.getSubscriptionsCount());
            res += p._defaultComputed.getSubscriptionsCount();
          }
          if (typeof debug != 'undefined') console.log(debug + "/" + prop + "/-", p.getSubscriptionsCount());
          res += p.getSubscriptionsCount();
          p = ko.utils.unwrapObservable(p);
        }
        if (typeof p == 'object' && p !== null) {
          var tot = viewModel.countSubscriptions(p, typeof debug != 'undefined' ? debug + '/' + prop + "@" : undefined);
          if (typeof debug != 'undefined') console.log(debug + "/" + prop + "@", tot);
          res += tot;
        }
      }
    return res;
  };

  // DEBUG
  viewModel.loopSubscriptionsCount = function() {
    var count = viewModel.countSubscriptions(viewModel.content());
    global.document.getElementById('subscriptionsCount').innerHTML = count;
    global.setTimeout(viewModel.loopSubscriptionsCount, 1000);
  };

  viewModel.export = function() {
    var content = performanceAwareCaller("exportHTML", viewModel.exportHTML);
    return content;
  };

  function conditional_restore(html) {
    return html.replace(/<replacedcc[^>]* condition="([^"]*)"[^>]*>([\s\S]*?)<\/replacedcc>/g, function(match, condition, body) {
      var dd = '<!--[if '+condition.replace(/&amp;/, '&')+']>';
      dd += body.replace(/<!-- cc:bc:([A-Za-z:]*) -->(<\/cc>)?<!-- cc:ac:\1 -->/g, '</$1>') // restore closing tags (including lost tags)
            .replace(/><\/cc><!-- cc:sc -->/g, '/>') // restore selfclosing tags
            .replace(/<!-- cc:bo:([A-Za-z:]*) --><cc/g, '<$1') // restore open tags
            .replace(/^.*<!-- cc:start -->/,'') // remove content before start
            .replace(/<!-- cc:end -->.*$/,''); // remove content after end
      dd += '<![endif]-->';
      return dd;
    });
  }

  viewModel.exportHTML = function() {
    console.log('viewModel.exportHTML')
    var id = 'exportframe';
    $('body').append('<iframe id="' + id + '" data-bind="bindIframe: $data"></iframe>');
    var frameEl = global.document.getElementById(id);
    ko.applyBindings(viewModel, frameEl);

    ko.cleanNode(frameEl);
    if (viewModel.inline) viewModel.inline(frameEl.contentWindow.document);

    // Obsolete method didn't work on IE11 when using "HTML5 doctype":
    // var docType = new XMLSerializer().serializeToString(global.document.doctype);
    var node = frameEl.contentWindow.document.doctype;
    var docType = "<!DOCTYPE " + node.name +
      (node.publicId ? ' PUBLIC "' + node.publicId + '"' : '') +
      (!node.publicId && node.systemId ? ' SYSTEM' : '') +
      (node.systemId ? ' "' + node.systemId + '"' : '') + '>';
    var content = docType + "\n" + frameEl.contentWindow.document.documentElement.outerHTML;
    ko.removeNode(frameEl);

    content = content.replace(/<script ([^>]* )?type="text\/html"[^>]*>[\s\S]*?<\/script>/gm, '');
    // content = content.replace(/<!-- ko .*? -->/g, ''); // sometimes we have expressions like (<!-- ko var > 2 -->)
    content = content.replace(/<!-- ko ((?!--).)*? -->/g, ''); // this replaces the above with a more formal (but slower) solution
    content = content.replace(/<!-- \/ko -->/g, '');
    // Remove data-bind/data-block attributes
    content = content.replace(/ data-bind="[^"]*"/gm, '');
    // Remove trash leftover by TinyMCE
    content = content.replace(/ data-mce-(href|src)="[^"]*"/gm, '');

    // Replace "replacedstyle" to "style" attributes (chrome puts replacedstyle after style)
    content = content.replace(/ style="[^"]*"([^>]*) replaced(style="[^"]*")/gm, '$1 $2');
    // Replace "replacedstyle" to "style" attributes (ie/ff have reverse order)
    content = content.replace(/ replaced(style="[^"]*")([^>]*) style="[^"]*"/gm, ' $1$2');
    content = content.replace(/ replaced(style="[^"]*")/gm, ' $1');

    // same as style, but for http-equiv (some browser break it if we don't replace, but then we find it duplicated)
    content = content.replace(/ http-equiv="[^"]*"([^>]*) replaced(http-equiv="[^"]*")/gm, '$1 $2');
    content = content.replace(/ replaced(http-equiv="[^"]*")([^>]*) http-equiv="[^"]*"/gm, ' $1$2');
    content = content.replace(/ replaced(http-equiv="[^"]*")/gm, ' $1');

    // BADSENDER: Restore ESP tags
    // https://github.com/goodenough/mosaico/issues/2
    content = content.replace(/&lt;%/g, '<%');
    content = content.replace(/%&gt;/g, '%>');

    // We already replace style and http-equiv and we don't need this.
    // content = content.replace(/ replaced([^= ]*=)/gm, ' $1');
    // Restore conditional comments
    content = conditional_restore(content);
    var trash = content.match(/ data-[^ =]+(="[^"]+")? /) || content.match(/ replaced([^= ]*=)/);
    if (trash) {
      console.warn("Output HTML contains unexpected data- attributes or replaced attributes", trash);
    }

    return content;
  };

  viewModel.exportHTMLtoTextarea = function(textareaid) {
    $(textareaid).val(viewModel.exportHTML());
  };

  viewModel.exportJSONtoTextarea = function(textareaid) {
    $(textareaid).val(viewModel.exportJSON());
  };

  viewModel.importJSONfromTextarea = function(textareaid) {
    viewModel.importJSON($(textareaid).val());
  };

  viewModel.exportMetadata = function() {
    var json = ko.toJSON(viewModel.metadata);
    return json;
  };

  viewModel.exportJSON = function() {
    var json = ko.toJSON(viewModel.content);
    return json;
  };

  viewModel.exportJS = function() {
    return ko.toJS(viewModel.content);
  };

  viewModel.importJSON = function(json) {
    var unwrapped = ko.utils.parseJson(json);
    viewModel.content._wrap(unwrapped);
  };

  viewModel.exportTheme = function() {
    var flat = {};
    var mod = viewModel.content().theme();

    var _export = function(prefix, flat, mod) {
      for (var prop in mod)
        if (mod.hasOwnProperty(prop)) {
          var a = ko.utils.unwrapObservable(mod[prop]);
          if (a !== null && typeof a == 'object') {
            _export(prop + '.', flat, a);
          } else {
            flat[prefix + prop] = a;
          }
        }
    };

    _export('', flat, mod);

    var output = '';
    for (var prop in flat)
      if (flat.hasOwnProperty(prop) && prop != 'type') {
        output += prop + ": " + flat[prop] + ";" + "\n";
      }

    return output;
  };

  // moxiemanager (or file browser/imageeditor) extension points.
  // Just implement editImage or linkDialog methods
  // viewModel.editImage = function(src, done) {} : implement this method to enable image editing (src is a wirtableObservable).
  // viewModel.linkDialog = function() {}: implement this method using "this" to find the input element $(this).val is a writableObservable.

  viewModel.loadImage = function(img) {
    // push image at top of "recent" gallery
    viewModel.galleryRecent.unshift(img);
    // select recent gallery tab
    viewModel.selectedImageTab(0);
  };

  viewModel.dialog = function(selector, options) {
    $(selector).dialog(options);
  };

  // Dummy log method overridden by extensions
  viewModel.log = function(category, msg) {
    // console.log("viewModel.log", category, msg);
  };

  // automatically load the gallery when the gallery tab is selected
  viewModel.selectedImageTab.subscribe(function(newValue) {
    if (newValue == 1 && viewModel.galleryLoaded() === false) {
      viewModel.loadGallery();
    }
  }, viewModel, 'change');

  return viewModel;

}

module.exports = initializeEditor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./../../bower_components/toastr/toastr.js":19,"./timed-call.js":87}]},{},[47,20])(47)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZXZvbC1jb2xvcnBpY2tlci9qcy9ldm9sLmNvbG9ycGlja2VyLm1pbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvanNlcC9zcmMvanNlcC5qcyIsImJvd2VyX2NvbXBvbmVudHMvanVpY2UvbGliL2lubGluZS5qcyIsImJvd2VyX2NvbXBvbmVudHMvanVpY2UvbGliL3Byb3BlcnR5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9qdWljZS9saWIvc2VsZWN0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL2p1aWNlL2xpYi91dGlscy5qcyIsImJvd2VyX2NvbXBvbmVudHMva25vY2tvdXQtc29ydGFibGUvYnVpbGQva25vY2tvdXQtc29ydGFibGUubWluLmpzIiwiYm93ZXJfY29tcG9uZW50cy9rbm9ja291dC11bmRvbWFuYWdlci9rbm9ja291dC11bmRvbWFuYWdlci5qcyIsImJvd2VyX2NvbXBvbmVudHMva25vY2tvdXQud3JhcC9rbm9ja291dC53cmFwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9rbm9ja291dGpzLXJlYWN0b3Ivc3JjL2tub2Nrb3V0LnJlYWN0b3IuanMiLCJib3dlcl9jb21wb25lbnRzL21lbnNjaC9pbmRleC5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9kZWJ1Zy5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9sZXhlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9wYXJzZXIuanMiLCJib3dlcl9jb21wb25lbnRzL21lbnNjaC9saWIvc3RyaW5naWZ5LmpzIiwiYm93ZXJfY29tcG9uZW50cy9zbGljay9kaXN0L3NsaWNrLmpzIiwiYm93ZXJfY29tcG9uZW50cy90aW55Y29sb3IvdGlueWNvbG9yLmpzIiwiYm93ZXJfY29tcG9uZW50cy90b2FzdHIvdG9hc3RyLmpzIiwiYnVpbGQvdGVtcGxhdGVzLmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2VkaWZmZXJlbmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWZsYXR0ZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLl9yb290L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5rZXlzaW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLm9taXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLnJlc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3MtYnJvd3NlcmlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwZWFraW5ndXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NwZWFraW5ndXJsL2xpYi9zcGVha2luZ3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNCeXRlTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvaXNFbWFpbC5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL2lzRlFETi5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0b3IvbGliL3V0aWwvYXNzZXJ0U3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3ZhbGlkYXRvci9saWIvdXRpbC9tZXJnZS5qcyIsInNoYXJlZC9zbHVnLWZpbGVuYW1lLmpzIiwic3JjL2pzL2FwcC5qcyIsInNyYy9qcy9iaW5kaW5ncy9iaW5kLWlmcmFtZS5qcyIsInNyYy9qcy9iaW5kaW5ncy9ibG9ja3MuanMiLCJzcmMvanMvYmluZGluZ3MvY2hvb3NlLXRlbXBsYXRlLmpzIiwic3JjL2pzL2JpbmRpbmdzL2NvbG9ycGlja2VyLmpzIiwic3JjL2pzL2JpbmRpbmdzL2Nzc3RleHQuanMiLCJzcmMvanMvYmluZGluZ3MvZHJvcHBhYmxlLmpzIiwic3JjL2pzL2JpbmRpbmdzL2V2ZW50YWJsZS5qcyIsInNyYy9qcy9iaW5kaW5ncy9leHRlbmRlci1wYWdpbmF0aW9uLmpzIiwic3JjL2pzL2JpbmRpbmdzL2V4dHNvcnRhYmxlcy5qcyIsInNyYy9qcy9iaW5kaW5ncy9maWxldXBsb2FkLmpzIiwic3JjL2pzL2JpbmRpbmdzL2lmLXN1YnMuanMiLCJzcmMvanMvYmluZGluZ3MvanF1ZXJ5dWktc3Bpbm5lci5qcyIsInNyYy9qcy9iaW5kaW5ncy9qcXVlcnl1aS10YWJzLmpzIiwic3JjL2pzL2JpbmRpbmdzL3NjcmlwdC10ZW1wbGF0ZS5qcyIsInNyYy9qcy9iaW5kaW5ncy9zY3JvbGxmaXguanMiLCJzcmMvanMvYmluZGluZ3Mvc2Nyb2xsaW50b3ZpZXcuanMiLCJzcmMvanMvYmluZGluZ3Mvc3RyaW5nLXRlbXBsYXRlLmpzIiwic3JjL2pzL2JpbmRpbmdzL3Rvb2x0aXBzLmpzIiwic3JjL2pzL2JpbmRpbmdzL3ZhbGlkYXRlZC12YWx1ZS5qcyIsInNyYy9qcy9iaW5kaW5ncy92aXJ0dWFscy5qcyIsInNyYy9qcy9iaW5kaW5ncy93eXNpd3lncy5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvY2hlY2ttb2RlbC5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvZGVjbGFyYXRpb25zLmpzIiwic3JjL2pzL2NvbnZlcnRlci9kb211dGlscy5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvZWRpdG9yLmpzIiwic3JjL2pzL2NvbnZlcnRlci9tYWluLmpzIiwic3JjL2pzL2NvbnZlcnRlci9tb2RlbC5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvcGFyc2VyLmpzIiwic3JjL2pzL2NvbnZlcnRlci9zdHlsZXNoZWV0LmpzIiwic3JjL2pzL2NvbnZlcnRlci91dGlscy5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvd3JhcHBlci5qcyIsInNyYy9qcy9leHQvYmFkc2VuZGVyLWVkaXQtdGl0bGUuanMiLCJzcmMvanMvZXh0L2JhZHNlbmRlci1leHRlbnNpb25zLmpzIiwic3JjL2pzL2V4dC9iYWRzZW5kZXItc2VydmVyLXN0b3JhZ2UuanMiLCJzcmMvanMvZXh0L2NvbG9yLmpzIiwic3JjL2pzL2V4dC9pbmxpbmVyLmpzIiwic3JjL2pzL2V4dC9sb2NhbHN0b3JhZ2UuanMiLCJzcmMvanMva28tYmluZGluZ3MuanMiLCJzcmMvanMvdGVtcGxhdGUtbG9hZGVyLmpzIiwic3JjL2pzL3RpbWVkLWNhbGwuanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb21haW4uanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb3NlcmlhbGl6ZXIuanMiLCJzcmMvanMvdmlld21vZGVsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdktBO0FBQ0E7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM29DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25iQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDamdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIilcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXVxuICAgICwgW2luZm8sIFwiaW5mb1wiXVxuICAgICwgW3dhcm4sIFwid2FyblwiXVxuICAgICwgW2Vycm9yLCBcImVycm9yXCJdXG4gICAgLCBbdGltZSwgXCJ0aW1lXCJdXG4gICAgLCBbdGltZUVuZCwgXCJ0aW1lRW5kXCJdXG4gICAgLCBbdHJhY2UsIFwidHJhY2VcIl1cbiAgICAsIFtkaXIsIFwiZGlyXCJdXG4gICAgLCBbYXNzZXJ0LCBcImFzc2VydFwiXVxuXVxuXG5mb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0dXBsZSA9IGZ1bmN0aW9uc1tpXVxuICAgIHZhciBmID0gdHVwbGVbMF1cbiAgICB2YXIgbmFtZSA9IHR1cGxlWzFdXG5cbiAgICBpZiAoIWNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgY29uc29sZVtuYW1lXSA9IGZcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc29sZVxuXG5mdW5jdGlvbiBsb2coKSB7fVxuXG5mdW5jdGlvbiBpbmZvKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gd2FybigpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHRpbWUobGFiZWwpIHtcbiAgICB0aW1lc1tsYWJlbF0gPSBEYXRlLm5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbiA9IERhdGUubm93KCkgLSB0aW1lXG4gICAgY29uc29sZS5sb2cobGFiZWwgKyBcIjogXCIgKyBkdXJhdGlvbiArIFwibXNcIilcbn1cblxuZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpXG4gICAgZXJyLm5hbWUgPSBcIlRyYWNlXCJcbiAgICBlcnIubWVzc2FnZSA9IHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjaylcbn1cblxuZnVuY3Rpb24gZGlyKG9iamVjdCkge1xuICAgIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdChvYmplY3QpICsgXCJcXG5cIilcbn1cblxuZnVuY3Rpb24gYXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuIiwiLypcbiAgIGV2b2wuY29sb3JwaWNrZXIgMy4yLjJcbiAgIChjKSAyMDE1IE9saXZpZXIgR2l1bGllcmlcbiAgIGh0dHA6Ly9ldm9sdXRldXIuZ2l0aHViLmlvL2NvbG9ycGlja2VyL1xuKi9cbiFmdW5jdGlvbihhLGIpe3ZhciBjPTAsZD13aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCxlPWQuaW5kZXhPZihcIk1TSUUgXCIpPjAsZj1lP1wiLWllXCI6XCJcIixnPWU/ITE6L21vemlsbGEvLnRlc3QoZC50b0xvd2VyQ2FzZSgpKSYmIS93ZWJraXQvLnRlc3QoZC50b0xvd2VyQ2FzZSgpKSxoPVtdLGk9W1wiZmZmZmZmXCIsXCIwMDAwMDBcIixcImVlZWNlMVwiLFwiMWY0OTdkXCIsXCI0ZjgxYmRcIixcImMwNTA0ZFwiLFwiOWJiYjU5XCIsXCI4MDY0YTJcIixcIjRiYWNjNlwiLFwiZjc5NjQ2XCJdLGo9W1wiZjJmMmYyXCIsXCI3ZjdmN2ZcIixcImRkZDljM1wiLFwiYzZkOWYwXCIsXCJkYmU1ZjFcIixcImYyZGNkYlwiLFwiZWJmMWRkXCIsXCJlNWUwZWNcIixcImRiZWVmM1wiLFwiZmRlYWRhXCIsXCJkOGQ4ZDhcIixcIjU5NTk1OVwiLFwiYzRiZDk3XCIsXCI4ZGIzZTJcIixcImI4Y2NlNFwiLFwiZTViOWI3XCIsXCJkN2UzYmNcIixcImNjYzFkOVwiLFwiYjdkZGU4XCIsXCJmYmQ1YjVcIixcImJmYmZiZlwiLFwiM2YzZjNmXCIsXCI5Mzg5NTNcIixcIjU0OGRkNFwiLFwiOTViM2Q3XCIsXCJkOTk2OTRcIixcImMzZDY5YlwiLFwiYjJhMmM3XCIsXCI5MmNkZGNcIixcImZhYzA4ZlwiLFwiYTVhNWE1XCIsXCIyNjI2MjZcIixcIjQ5NDQyOVwiLFwiMTczNjVkXCIsXCIzNjYwOTJcIixcIjk1MzczNFwiLFwiNzY5MjNjXCIsXCI1ZjQ5N2FcIixcIjMxODU5YlwiLFwiZTM2YzA5XCIsXCI3ZjdmN2ZcIixcIjBjMGMwY1wiLFwiMWQxYjEwXCIsXCIwZjI0M2VcIixcIjI0NDA2MVwiLFwiNjMyNDIzXCIsXCI0ZjYxMjhcIixcIjNmMzE1MVwiLFwiMjA1ODY3XCIsXCI5NzQ4MDZcIl0saz1bXCJjMDAwMDBcIixcImZmMDAwMFwiLFwiZmZjMDAwXCIsXCJmZmZmMDBcIixcIjkyZDA1MFwiLFwiMDBiMDUwXCIsXCIwMGIwZjBcIixcIjAwNzBjMFwiLFwiMDAyMDYwXCIsXCI3MDMwYTBcIl0sbD1bW1wiMDAzMzY2XCIsXCIzMzY2OTlcIixcIjMzNjZjY1wiLFwiMDAzMzk5XCIsXCIwMDAwOTlcIixcIjAwMDBjY1wiLFwiMDAwMDY2XCJdLFtcIjAwNjY2NlwiLFwiMDA2Njk5XCIsXCIwMDk5Y2NcIixcIjAwNjZjY1wiLFwiMDAzM2NjXCIsXCIwMDAwZmZcIixcIjMzMzNmZlwiLFwiMzMzMzk5XCJdLFtcIjY2OTk5OVwiLFwiMDA5OTk5XCIsXCIzM2NjY2NcIixcIjAwY2NmZlwiLFwiMDA5OWZmXCIsXCIwMDY2ZmZcIixcIjMzNjZmZlwiLFwiMzMzM2NjXCIsXCI2NjY2OTlcIl0sW1wiMzM5OTY2XCIsXCIwMGNjOTlcIixcIjAwZmZjY1wiLFwiMDBmZmZmXCIsXCIzM2NjZmZcIixcIjMzOTlmZlwiLFwiNjY5OWZmXCIsXCI2NjY2ZmZcIixcIjY2MDBmZlwiLFwiNjYwMGNjXCJdLFtcIjMzOTkzM1wiLFwiMDBjYzY2XCIsXCIwMGZmOTlcIixcIjY2ZmZjY1wiLFwiNjZmZmZmXCIsXCI2NmNjZmZcIixcIjk5Y2NmZlwiLFwiOTk5OWZmXCIsXCI5OTY2ZmZcIixcIjk5MzNmZlwiLFwiOTkwMGZmXCJdLFtcIjAwNjYwMFwiLFwiMDBjYzAwXCIsXCIwMGZmMDBcIixcIjY2ZmY5OVwiLFwiOTlmZmNjXCIsXCJjY2ZmZmZcIixcImNjY2NmZlwiLFwiY2M5OWZmXCIsXCJjYzY2ZmZcIixcImNjMzNmZlwiLFwiY2MwMGZmXCIsXCI5OTAwY2NcIl0sW1wiMDAzMzAwXCIsXCIwMDk5MzNcIixcIjMzY2MzM1wiLFwiNjZmZjY2XCIsXCI5OWZmOTlcIixcImNjZmZjY1wiLFwiZmZmZmZmXCIsXCJmZmNjZmZcIixcImZmOTlmZlwiLFwiZmY2NmZmXCIsXCJmZjAwZmZcIixcImNjMDBjY1wiLFwiNjYwMDY2XCJdLFtcIjMzMzMwMFwiLFwiMDA5OTAwXCIsXCI2NmZmMzNcIixcIjk5ZmY2NlwiLFwiY2NmZjk5XCIsXCJmZmZmY2NcIixcImZmY2NjY1wiLFwiZmY5OWNjXCIsXCJmZjY2Y2NcIixcImZmMzNjY1wiLFwiY2MwMDk5XCIsXCI5OTMzOTlcIl0sW1wiMzM2NjAwXCIsXCI2Njk5MDBcIixcIjk5ZmYzM1wiLFwiY2NmZjY2XCIsXCJmZmZmOTlcIixcImZmY2M5OVwiLFwiZmY5OTk5XCIsXCJmZjY2OTlcIixcImZmMzM5OVwiLFwiY2MzMzk5XCIsXCI5OTAwOTlcIl0sW1wiNjY2NjMzXCIsXCI5OWNjMDBcIixcImNjZmYzM1wiLFwiZmZmZjY2XCIsXCJmZmNjNjZcIixcImZmOTk2NlwiLFwiZmY2NjY2XCIsXCJmZjAwNjZcIixcImQ2MDA5NFwiLFwiOTkzMzY2XCJdLFtcImE1ODgwMFwiLFwiY2NjYzAwXCIsXCJmZmZmMDBcIixcImZmY2MwMFwiLFwiZmY5OTMzXCIsXCJmZjY2MDBcIixcImZmMDAzM1wiLFwiY2MwMDY2XCIsXCI2NjAwMzNcIl0sW1wiOTk2NjMzXCIsXCJjYzk5MDBcIixcImZmOTkwMFwiLFwiY2M2NjAwXCIsXCJmZjMzMDBcIixcImZmMDAwMFwiLFwiY2MwMDAwXCIsXCI5OTAwMzNcIl0sW1wiNjYzMzAwXCIsXCI5OTY2MDBcIixcImNjMzMwMFwiLFwiOTkzMzAwXCIsXCI5OTAwMDBcIixcIjgwMDAwMFwiLFwiOTkzMzMzXCJdXSxtPVwiIzAwMDBmZmZmXCIsbj1mdW5jdGlvbihhKXt2YXIgYj1hLnRvU3RyaW5nKDE2KTtyZXR1cm4gMT09Yi5sZW5ndGgmJihiPVwiMFwiK2IpLGJ9LG89ZnVuY3Rpb24oYSl7cmV0dXJuIG4oTnVtYmVyKGEpKX0scD1mdW5jdGlvbihhKXt2YXIgYj1uKGEpO3JldHVybiBiK2IrYn0scT1mdW5jdGlvbihhKXtpZihhLmxlbmd0aD4xMCl7dmFyIGI9MSthLmluZGV4T2YoXCIoXCIpLGM9YS5pbmRleE9mKFwiKVwiKSxkPWEuc3Vic3RyaW5nKGIsYykuc3BsaXQoXCIsXCIpO3JldHVybltcIiNcIixvKGRbMF0pLG8oZFsxXSksbyhkWzJdKV0uam9pbihcIlwiKX1yZXR1cm4gYX07YS53aWRnZXQoXCJldm9sLmNvbG9ycGlja2VyXCIse3ZlcnNpb246XCIzLjIuMVwiLG9wdGlvbnM6e2NvbG9yOm51bGwsc2hvd09uOlwiYm90aFwiLGhpZGVCdXR0b246ITEsZGlzcGxheUluZGljYXRvcjohMCx0cmFuc3BhcmVudENvbG9yOiExLGhpc3Rvcnk6ITAsZGVmYXVsdFBhbGV0dGU6XCJ0aGVtZVwiLHN0cmluZ3M6XCJUaGVtZSBDb2xvcnMsU3RhbmRhcmQgQ29sb3JzLFdlYiBDb2xvcnMsVGhlbWUgQ29sb3JzLEJhY2sgdG8gUGFsZXR0ZSxIaXN0b3J5LE5vIGhpc3RvcnkgeWV0LlwifSxfYWN0aXZlOiExLF9jcmVhdGU6ZnVuY3Rpb24oKXt2YXIgYj10aGlzO3N3aXRjaCh0aGlzLl9wYWxldHRlSWR4PVwidGhlbWVcIj09dGhpcy5vcHRpb25zLmRlZmF1bHRQYWxldHRlPzE6Mix0aGlzLl9pZD1cImV2by1jcFwiK2MrKyx0aGlzLl9lbmFibGVkPSEwLHRoaXMub3B0aW9ucy5zaG93T249dGhpcy5vcHRpb25zLmhpZGVCdXR0b24/XCJmb2N1c1wiOnRoaXMub3B0aW9ucy5zaG93T24sdGhpcy5lbGVtZW50LmdldCgwKS50YWdOYW1lKXtjYXNlXCJJTlBVVFwiOnZhciBkPXRoaXMub3B0aW9ucy5jb2xvcixoPXRoaXMuZWxlbWVudCxpPShcImZvY3VzXCI9PT10aGlzLm9wdGlvbnMuc2hvd09uP1wiXCI6XCJldm8tcG9pbnRlciBcIikrXCJldm8tY29sb3JpbmRcIisoZz9cIi1mZlwiOmYpKyh0aGlzLm9wdGlvbnMuaGlkZUJ1dHRvbj9cIiBldm8taGlkZGVuLWJ1dHRvblwiOlwiXCIpLGo9XCJcIjtpZih0aGlzLl9pc1BvcHVwPSEwLHRoaXMuX3BhbGV0dGU9bnVsbCxudWxsIT09ZCloLnZhbChkKTtlbHNle3ZhciBrPWgudmFsKCk7XCJcIiE9PWsmJihkPXRoaXMub3B0aW9ucy5jb2xvcj1rKX1kPT09bT9pKz1cIiBldm8tdHJhbnNwYXJlbnRcIjpqPW51bGwhPT1kP1wiYmFja2dyb3VuZC1jb2xvcjpcIitkOlwiXCIsaC5hZGRDbGFzcyhcImNvbG9yUGlja2VyIFwiK3RoaXMuX2lkKS53cmFwKCc8ZGl2IHN0eWxlPVwid2lkdGg6JysodGhpcy5vcHRpb25zLmhpZGVCdXR0b24/dGhpcy5lbGVtZW50LndpZHRoKCk6dGhpcy5lbGVtZW50LndpZHRoKCkrMzIpK1wicHg7XCIrKGU/XCJtYXJnaW4tYm90dG9tOi0yMXB4O1wiOlwiXCIpKyhnP1wicGFkZGluZzoxcHggMDtcIjpcIlwiKSsnXCI+PC9kaXY+JykuYWZ0ZXIoJzxkaXYgY2xhc3M9XCInK2krJ1wiIHN0eWxlPVwiJytqKydcIj48L2Rpdj4nKS5vbihcImtleXVwIG9ucGFzdGVcIixmdW5jdGlvbihjKXt2YXIgZD1hKHRoaXMpLnZhbCgpO2QhPWIub3B0aW9ucy5jb2xvciYmYi5fc2V0VmFsdWUoZCwhMCl9KTt2YXIgbD10aGlzLm9wdGlvbnMuc2hvd09uOyhcImJvdGhcIj09PWx8fFwiZm9jdXNcIj09PWwpJiZoLm9uKFwiZm9jdXNcIixmdW5jdGlvbigpe2Iuc2hvd1BhbGV0dGUoKX0pLChcImJvdGhcIj09PWx8fFwiYnV0dG9uXCI9PT1sKSYmaC5uZXh0KCkub24oXCJjbGlja1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnN0b3BQcm9wYWdhdGlvbigpLGIuc2hvd1BhbGV0dGUoKSwhMX0pO2JyZWFrO2RlZmF1bHQ6dGhpcy5faXNQb3B1cD0hMSx0aGlzLl9wYWxldHRlPXRoaXMuZWxlbWVudC5odG1sKHRoaXMuX3BhbGV0dGVIVE1MKCkpLmF0dHIoXCJhcmlhLWhhc3BvcHVwXCIsXCJ0cnVlXCIpLHRoaXMuX2JpbmRDb2xvcnMoKX1pZih0aGlzLm9wdGlvbnMuaGlzdG9yeSYmKGQmJnRoaXMuX2FkZDJIaXN0b3J5KGQpLHRoaXMub3B0aW9ucy5pbml0aWFsSGlzdG9yeSkpe3ZhciBuPXRoaXMub3B0aW9ucy5pbml0aWFsSGlzdG9yeTtmb3IodmFyIG8gaW4gbil0aGlzLl9hZGQySGlzdG9yeShuW29dKX19LF9wYWxldHRlSFRNTDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX3BhbGV0dGVJZHg9TWF0aC5hYnModGhpcy5fcGFsZXR0ZUlkeCksYj10aGlzLm9wdGlvbnMsYz1iLnN0cmluZ3Muc3BsaXQoXCIsXCIpLGQ9JzxkaXYgY2xhc3M9XCJldm8tcG9wJytmKycgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIicrKHRoaXMuX2lzUG9wdXA/JyBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlXCInOlwiXCIpK1wiPjxzcGFuPlwiK3RoaXNbXCJfcGFsZXR0ZUhUTUxcIithXSgpKyc8L3NwYW4+PGRpdiBjbGFzcz1cImV2by1tb3JlXCI+PGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiPicrY1sxK2FdK1wiPC9hPlwiO3JldHVybiBiLmhpc3RvcnkmJihkKz0nPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIGNsYXNzPVwiZXZvLWhpc3RcIj4nK2NbNV0rXCI8L2E+XCIpLGQrPVwiPC9kaXY+XCIsYi5kaXNwbGF5SW5kaWNhdG9yJiYoZCs9dGhpcy5fY29sb3JJbmRIVE1MKHRoaXMub3B0aW9ucy5jb2xvcikrdGhpcy5fY29sb3JJbmRIVE1MKFwiXCIpKSxkKz1cIjwvZGl2PlwifSxfY29sb3JJbmRIVE1MOmZ1bmN0aW9uKGEpe3ZhciBiPWU/XCJldm8tY29sb3Jib3gtaWUgXCI6XCJcIixjPVwiXCI7cmV0dXJuIGE/YT09PW0/Yis9XCJldm8tdHJhbnNwYXJlbnRcIjpjPVwiYmFja2dyb3VuZC1jb2xvcjpcIithOmM9XCJkaXNwbGF5Om5vbmVcIiwnPGRpdiBjbGFzcz1cImV2by1jb2xvclwiIHN0eWxlPVwiZmxvYXQ6bGVmdFwiPjxkaXYgc3R5bGU9XCInK2MrJ1wiIGNsYXNzPVwiJytiKydcIj48L2Rpdj48c3Bhbj4nKyhhP2E6XCJcIikrXCI8L3NwYW4+PC9kaXY+XCJ9LF9wYWxldHRlSFRNTDE6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5vcHRpb25zLGI9YS5zdHJpbmdzLnNwbGl0KFwiLFwiKSxjPSc8dGQgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiMnLGQ9ZT8nXCI+PGRpdiBzdHlsZT1cIndpZHRoOjJweDtcIj48L2Rpdj48L3RkPic6J1wiPjxzcGFuLz48L3RkPicsZz0nPHRyPjx0aCBjb2xzcGFuPVwiMTBcIiBjbGFzcz1cInVpLXdpZGdldC1jb250ZW50XCI+JyxoPSc8dGFibGUgY2xhc3M9XCJldm8tcGFsZXR0ZScrZisnXCI+JytnK2JbMF0rXCI8L3RoPjwvdHI+PHRyPlwiLGw9MDsxMD5sO2wrKyloKz1jK2lbbF0rZDtmb3IoaCs9XCI8L3RyPlwiLGV8fChoKz0nPHRyPjx0aCBjb2xzcGFuPVwiMTBcIj48L3RoPjwvdHI+JyksaCs9Jzx0ciBjbGFzcz1cInRvcFwiPicsbD0wOzEwPmw7bCsrKWgrPWMraltsXStkO2Zvcih2YXIgbT0xOzQ+bTttKyspZm9yKGgrPSc8L3RyPjx0ciBjbGFzcz1cImluXCI+JyxsPTA7MTA+bDtsKyspaCs9YytqWzEwKm0rbF0rZDtmb3IoaCs9JzwvdHI+PHRyIGNsYXNzPVwiYm90dG9tXCI+JyxsPTQwOzUwPmw7bCsrKWgrPWMraltsXStkO2ZvcihoKz1cIjwvdHI+XCIrZyxhLnRyYW5zcGFyZW50Q29sb3ImJihoKz0nPGRpdiBjbGFzcz1cImV2by10cmFuc3BhcmVudCBldm8tdHItYm94XCI+PC9kaXY+JyksaCs9YlsxXStcIjwvdGg+PC90cj48dHI+XCIsbD0wOzEwPmw7bCsrKWgrPWMra1tsXStkO3JldHVybiBoKz1cIjwvdHI+PC90YWJsZT5cIn0sX3BhbGV0dGVIVE1MMjpmdW5jdGlvbigpe2Zvcih2YXIgYSxiLGM9Jzx0ZCBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IycsZD1lPydcIj48ZGl2IHN0eWxlPVwid2lkdGg6NXB4O1wiPjwvZGl2PjwvdGQ+JzonXCI+PHNwYW4vPjwvdGQ+JyxnPSc8dGFibGUgY2xhc3M9XCJldm8tcGFsZXR0ZTInK2YrJ1wiPjx0cj4nLGg9XCI8L3RyPjwvdGFibGU+XCIsaT0nPGRpdiBjbGFzcz1cImV2by1wYWxjZW50ZXJcIj4nLGo9MCxrPWwubGVuZ3RoO2s+ajtqKyspe2krPWc7dmFyIG09bFtqXTtmb3IoYT0wLGI9bS5sZW5ndGg7Yj5hO2ErKylpKz1jK21bYV0rZDtpKz1ofWkrPSc8ZGl2IGNsYXNzPVwiZXZvLXNlcFwiLz4nO3ZhciBuPVwiXCI7Zm9yKGkrPWcsYT0yNTU7YT4xMDthLT0xMClpKz1jK3AoYSkrZCxhLT0xMCxuKz1jK3AoYSkrZDtyZXR1cm4gaSs9aCtnK24raCtcIjwvZGl2PlwifSxfc3dpdGNoUGFsZXR0ZTpmdW5jdGlvbihiKXtpZih0aGlzLl9lbmFibGVkKXt2YXIgYyxkLGUsZj10aGlzLm9wdGlvbnMuc3RyaW5ncy5zcGxpdChcIixcIik7aWYoYShiKS5oYXNDbGFzcyhcImV2by1oaXN0XCIpKXt2YXIgZz1bJzx0YWJsZSBjbGFzcz1cImV2by1wYWxldHRlXCI+PHRyPjx0aCBjbGFzcz1cInVpLXdpZGdldC1jb250ZW50XCI+JyxmWzVdLFwiPC90aD48L3RyPjwvdHI+PC90YWJsZT5cIiwnPGRpdiBjbGFzcz1cImV2by1jSGlzdFwiPiddO2lmKDA9PT1oLmxlbmd0aClnLnB1c2goXCI8cD4mbmJzcDtcIixmWzZdLFwiPC9wPlwiKTtlbHNlIGZvcih2YXIgaT1oLmxlbmd0aC0xO2k+LTE7aS0tKTk9PT1oW2ldLmxlbmd0aD9nLnB1c2goJzxkaXYgY2xhc3M9XCJldm8tdHJhbnNwYXJlbnRcIj48L2Rpdj4nKTpnLnB1c2goJzxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicsaFtpXSwnXCI+PC9kaXY+Jyk7Zy5wdXNoKFwiPC9kaXY+XCIpLGM9LXRoaXMuX3BhbGV0dGVJZHgsZD1nLmpvaW4oXCJcIiksZT1mWzRdfWVsc2UgdGhpcy5fcGFsZXR0ZUlkeDwwPyhjPS10aGlzLl9wYWxldHRlSWR4LHRoaXMuX3BhbGV0dGUuZmluZChcIi5ldm8taGlzdFwiKS5zaG93KCkpOmM9Mj09dGhpcy5fcGFsZXR0ZUlkeD8xOjIsZD10aGlzW1wiX3BhbGV0dGVIVE1MXCIrY10oKSxlPWZbYysxXSx0aGlzLl9wYWxldHRlSWR4PWM7dGhpcy5fcGFsZXR0ZUlkeD1jO3ZhciBqPXRoaXMuX3BhbGV0dGUuZmluZChcIi5ldm8tbW9yZVwiKS5wcmV2KCkuaHRtbChkKS5lbmQoKS5jaGlsZHJlbigpLmVxKDApLmh0bWwoZSk7MD5jJiZqLm5leHQoKS5oaWRlKCl9fSxfZG93bk9yVXBQb3NpdGlvbmluZzpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLmVsZW1lbnQsYj0wO251bGwhPT1hJiYxMDA+Yjspe2lmKFwidmlzaWJsZVwiIT1hLmNzcyhcIm92ZXJmbG93XCIpKXt2YXIgYz10aGlzLl9wYWxldHRlLm9mZnNldCgpLnRvcCt0aGlzLl9wYWxldHRlLmhlaWdodCgpLGQ9YS5vZmZzZXQoKS50b3ArYS5oZWlnaHQoKSxlPXRoaXMuX3BhbGV0dGUub2Zmc2V0KCkudG9wLXRoaXMuX3BhbGV0dGUuaGVpZ2h0KCktdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCksZj1hLm9mZnNldCgpLnRvcCxnPWM+ZCYmZT5mO2c/dGhpcy5fcGFsZXR0ZS5jc3Moe2JvdHRvbTp0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKStcInB4XCJ9KTp0aGlzLl9wYWxldHRlLmNzcyh7Ym90dG9tOlwiYXV0b1wifSk7YnJlYWt9aWYoXCJIVE1MXCI9PWFbMF0udGFnTmFtZSlicmVhazthPWEub2Zmc2V0UGFyZW50KCksYisrfX0sc2hvd1BhbGV0dGU6ZnVuY3Rpb24oKXtpZih0aGlzLl9lbmFibGVkJiYodGhpcy5fYWN0aXZlPSEwLGEoXCIuY29sb3JQaWNrZXJcIikubm90KFwiLlwiK3RoaXMuX2lkKS5jb2xvcnBpY2tlcihcImhpZGVQYWxldHRlXCIpLG51bGw9PT10aGlzLl9wYWxldHRlKSl7dGhpcy5fcGFsZXR0ZT10aGlzLmVsZW1lbnQubmV4dCgpLmFmdGVyKHRoaXMuX3BhbGV0dGVIVE1MKCkpLm5leHQoKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3RvcFByb3BhZ2F0aW9uKCksITF9KSx0aGlzLl9iaW5kQ29sb3JzKCk7dmFyIGI9dGhpczt0aGlzLl9pc1BvcHVwJiYodGhpcy5fZG93bk9yVXBQb3NpdGlvbmluZygpLGEoZG9jdW1lbnQuYm9keSkub24oXCJjbGljay5cIitiLl9pZCxmdW5jdGlvbihhKXthLnRhcmdldCE9Yi5lbGVtZW50LmdldCgwKSYmYi5oaWRlUGFsZXR0ZSgpfSkub24oXCJrZXl1cC5cIitiLl9pZCxmdW5jdGlvbihhKXsyNz09PWEua2V5Q29kZSYmYi5oaWRlUGFsZXR0ZSgpfSkpfXJldHVybiB0aGlzfSxoaWRlUGFsZXR0ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2lzUG9wdXAmJnRoaXMuX3BhbGV0dGUpe2EoZG9jdW1lbnQuYm9keSkub2ZmKFwiY2xpY2suXCIrdGhpcy5faWQpO3ZhciBiPXRoaXM7dGhpcy5fcGFsZXR0ZS5vZmYoXCJtb3VzZW92ZXIgY2xpY2tcIixcInRkLC5ldm8tdHJhbnNwYXJlbnRcIikuZmFkZU91dChmdW5jdGlvbigpe2IuX3BhbGV0dGUucmVtb3ZlKCksYi5fcGFsZXR0ZT1iLl9jVHh0PW51bGx9KS5maW5kKFwiLmV2by1tb3JlIGFcIikub2ZmKFwiY2xpY2tcIil9cmV0dXJuIHRoaXN9LF9iaW5kQ29sb3JzOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxjPXRoaXMub3B0aW9ucyxkPXRoaXMuX3BhbGV0dGUuZmluZChcImRpdi5ldm8tY29sb3JcIiksZT1jLmhpc3Rvcnk/XCJ0ZCwuZXZvLWNIaXN0PmRpdlwiOlwidGRcIjtjLnRyYW5zcGFyZW50Q29sb3ImJihlKz1cIiwuZXZvLXRyYW5zcGFyZW50XCIpLHRoaXMuX2NUeHQxPWQuZXEoMCkuY2hpbGRyZW4oKS5lcSgwKSx0aGlzLl9jVHh0Mj1kLmVxKDEpLmNoaWxkcmVuKCkuZXEoMCksdGhpcy5fcGFsZXR0ZS5vbihcImNsaWNrXCIsZSxmdW5jdGlvbihjKXtpZihiLl9lbmFibGVkKXt2YXIgZD1hKHRoaXMpO2IuX3NldFZhbHVlKGQuaGFzQ2xhc3MoXCJldm8tdHJhbnNwYXJlbnRcIik/bTpxKGQuYXR0cihcInN0eWxlXCIpLnN1YnN0cmluZygxNykpKSxiLl9hY3RpdmU9ITF9fSkub24oXCJtb3VzZW92ZXJcIixlLGZ1bmN0aW9uKGMpe2lmKGIuX2VuYWJsZWQpe3ZhciBkPWEodGhpcyksZT1kLmhhc0NsYXNzKFwiZXZvLXRyYW5zcGFyZW50XCIpP206cShkLmF0dHIoXCJzdHlsZVwiKS5zdWJzdHJpbmcoMTcpKTtiLm9wdGlvbnMuZGlzcGxheUluZGljYXRvciYmYi5fc2V0Q29sb3JJbmQoZSwyKSxiLl9hY3RpdmUmJmIuZWxlbWVudC50cmlnZ2VyKFwibW91c2VvdmVyLmNvbG9yXCIsZSl9fSkuZmluZChcIi5ldm8tbW9yZSBhXCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe2IuX3N3aXRjaFBhbGV0dGUodGhpcyl9KX0sdmFsOmZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBhP3RoaXMub3B0aW9ucy5jb2xvcjoodGhpcy5fc2V0VmFsdWUoYSksdGhpcyl9LF9zZXRWYWx1ZTpmdW5jdGlvbihhLGIpe2E9YS5yZXBsYWNlKC8gL2csXCJcIiksdGhpcy5vcHRpb25zLmNvbG9yPWEsdGhpcy5faXNQb3B1cD8oYnx8dGhpcy5oaWRlUGFsZXR0ZSgpLHRoaXMuX3NldEJveENvbG9yKHRoaXMuZWxlbWVudC52YWwoYSkubmV4dCgpLGEpKTp0aGlzLl9zZXRDb2xvckluZChhLDEpLHRoaXMub3B0aW9ucy5oaXN0b3J5JiZ0aGlzLl9wYWxldHRlSWR4PjAmJnRoaXMuX2FkZDJIaXN0b3J5KGEpLHRoaXMuZWxlbWVudC50cmlnZ2VyKFwiY2hhbmdlLmNvbG9yXCIsYSl9LF9zZXRDb2xvckluZDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXNbXCJfY1R4dFwiK2JdO3RoaXMuX3NldEJveENvbG9yKGMsYSksYy5uZXh0KCkuaHRtbChhKX0sX3NldEJveENvbG9yOmZ1bmN0aW9uKGEsYil7Yj09PW0/YS5hZGRDbGFzcyhcImV2by10cmFuc3BhcmVudFwiKS5yZW1vdmVBdHRyKFwic3R5bGVcIik6YS5yZW1vdmVDbGFzcyhcImV2by10cmFuc3BhcmVudFwiKS5hdHRyKFwic3R5bGVcIixcImJhY2tncm91bmQtY29sb3I6XCIrYil9LF9zZXRPcHRpb246ZnVuY3Rpb24oYSxiKXtcImNvbG9yXCI9PWE/dGhpcy5fc2V0VmFsdWUoYiwhMCk6dGhpcy5vcHRpb25zW2FdPWJ9LF9hZGQySGlzdG9yeTpmdW5jdGlvbihhKXtmb3IodmFyIGI9aC5sZW5ndGgsYz0wO2I+YztjKyspaWYoYT09aFtjXSlyZXR1cm47Yj4yNyYmaC5zaGlmdCgpLGgucHVzaChhKX0sY2xlYXI6ZnVuY3Rpb24oKXt0aGlzLmhpZGVQYWxldHRlKCkudmFsKFwiXCIpfSxlbmFibGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnQ7cmV0dXJuIHRoaXMuX2lzUG9wdXA/YS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik6YS5jc3Moe29wYWNpdHk6XCIxXCIsXCJwb2ludGVyLWV2ZW50c1wiOlwiYXV0b1wifSksXCJmb2N1c1wiIT09dGhpcy5vcHRpb25zLnNob3dPbiYmdGhpcy5lbGVtZW50Lm5leHQoKS5hZGRDbGFzcyhcImV2by1wb2ludGVyXCIpLGEucmVtb3ZlQXR0cihcImFyaWEtZGlzYWJsZWRcIiksdGhpcy5fZW5hYmxlZD0hMCx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50O3JldHVybiB0aGlzLl9pc1BvcHVwP2EuYXR0cihcImRpc2FibGVkXCIsXCJkaXNhYmxlZFwiKToodGhpcy5oaWRlUGFsZXR0ZSgpLGEuY3NzKHtvcGFjaXR5OlwiMC4zXCIsXCJwb2ludGVyLWV2ZW50c1wiOlwibm9uZVwifSkpLFwiZm9jdXNcIiE9PXRoaXMub3B0aW9ucy5zaG93T24mJnRoaXMuZWxlbWVudC5uZXh0KCkucmVtb3ZlQ2xhc3MoXCJldm8tcG9pbnRlclwiKSxhLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsXCJ0cnVlXCIpLHRoaXMuX2VuYWJsZWQ9ITEsdGhpc30saXNEaXNhYmxlZDpmdW5jdGlvbigpe3JldHVybiF0aGlzLl9lbmFibGVkfSxkZXN0cm95OmZ1bmN0aW9uKCl7YShkb2N1bWVudC5ib2R5KS5vZmYoXCJjbGljay5cIit0aGlzLl9pZCksdGhpcy5fcGFsZXR0ZSYmKHRoaXMuX3BhbGV0dGUub2ZmKFwibW91c2VvdmVyIGNsaWNrXCIsXCJ0ZCwuZXZvLWNIaXN0PmRpdiwuZXZvLXRyYW5zcGFyZW50XCIpLmZpbmQoXCIuZXZvLW1vcmUgYVwiKS5vZmYoXCJjbGlja1wiKSx0aGlzLl9pc1BvcHVwJiZ0aGlzLl9wYWxldHRlLnJlbW92ZSgpLHRoaXMuX3BhbGV0dGU9dGhpcy5fY1R4dD1udWxsKSx0aGlzLl9pc1BvcHVwJiZ0aGlzLmVsZW1lbnQubmV4dCgpLm9mZihcImNsaWNrXCIpLnJlbW92ZSgpLmVuZCgpLm9mZihcImZvY3VzXCIpLnVud3JhcCgpLHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcImNvbG9yUGlja2VyIFwiK3RoaXMuaWQpLmVtcHR5KCksYS5XaWRnZXQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKX19KX0oalF1ZXJ5KTsiLCIvLyAgICAgSmF2YVNjcmlwdCBFeHByZXNzaW9uIFBhcnNlciAoSlNFUCkgPCU9IHZlcnNpb24gJT5cbi8vICAgICBKU0VQIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4vLyAgICAgaHR0cDovL2pzZXAuZnJvbS5zby9cblxuLypnbG9iYWwgbW9kdWxlOiB0cnVlLCBleHBvcnRzOiB0cnVlLCBjb25zb2xlOiB0cnVlICovXG4oZnVuY3Rpb24gKHJvb3QpIHtcblx0J3VzZSBzdHJpY3QnO1xuXHQvLyBOb2RlIFR5cGVzXG5cdC8vIC0tLS0tLS0tLS1cblx0XG5cdC8vIFRoaXMgaXMgdGhlIGZ1bGwgc2V0IG9mIHR5cGVzIHRoYXQgYW55IEpTRVAgbm9kZSBjYW4gYmUuXG5cdC8vIFN0b3JlIHRoZW0gaGVyZSB0byBzYXZlIHNwYWNlIHdoZW4gbWluaWZpZWRcblx0dmFyIENPTVBPVU5EID0gJ0NvbXBvdW5kJyxcblx0XHRJREVOVElGSUVSID0gJ0lkZW50aWZpZXInLFxuXHRcdE1FTUJFUl9FWFAgPSAnTWVtYmVyRXhwcmVzc2lvbicsXG5cdFx0TElURVJBTCA9ICdMaXRlcmFsJyxcblx0XHRUSElTX0VYUCA9ICdUaGlzRXhwcmVzc2lvbicsXG5cdFx0Q0FMTF9FWFAgPSAnQ2FsbEV4cHJlc3Npb24nLFxuXHRcdFVOQVJZX0VYUCA9ICdVbmFyeUV4cHJlc3Npb24nLFxuXHRcdEJJTkFSWV9FWFAgPSAnQmluYXJ5RXhwcmVzc2lvbicsXG5cdFx0TE9HSUNBTF9FWFAgPSAnTG9naWNhbEV4cHJlc3Npb24nLFxuXHRcdENPTkRJVElPTkFMX0VYUCA9ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuXHRcdEFSUkFZX0VYUCA9ICdBcnJheUV4cHJlc3Npb24nLFxuXG5cdFx0UEVSSU9EX0NPREUgPSA0NiwgLy8gJy4nXG5cdFx0Q09NTUFfQ09ERSAgPSA0NCwgLy8gJywnXG5cdFx0U1FVT1RFX0NPREUgPSAzOSwgLy8gc2luZ2xlIHF1b3RlXG5cdFx0RFFVT1RFX0NPREUgPSAzNCwgLy8gZG91YmxlIHF1b3Rlc1xuXHRcdE9QQVJFTl9DT0RFID0gNDAsIC8vIChcblx0XHRDUEFSRU5fQ09ERSA9IDQxLCAvLyApXG5cdFx0T0JSQUNLX0NPREUgPSA5MSwgLy8gW1xuXHRcdENCUkFDS19DT0RFID0gOTMsIC8vIF1cblx0XHRRVU1BUktfQ09ERSA9IDYzLCAvLyA/XG5cdFx0U0VNQ09MX0NPREUgPSA1OSwgLy8gO1xuXHRcdENPTE9OX0NPREUgID0gNTgsIC8vIDpcblxuXHRcdHRocm93RXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBpbmRleCkge1xuXHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UgKyAnIGF0IGNoYXJhY3RlciAnICsgaW5kZXgpO1xuXHRcdFx0ZXJyb3IuaW5kZXggPSBpbmRleDtcblx0XHRcdGVycm9yLmRlc2NyaXB0aW9uID0gbWVzc2FnZTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH0sXG5cblx0Ly8gT3BlcmF0aW9uc1xuXHQvLyAtLS0tLS0tLS0tXG5cdFxuXHQvLyBTZXQgYHRgIHRvIGB0cnVlYCB0byBzYXZlIHNwYWNlICh3aGVuIG1pbmlmaWVkLCBub3QgZ3ppcHBlZClcblx0XHR0ID0gdHJ1ZSxcblx0Ly8gVXNlIGEgcXVpY2tseS1hY2Nlc3NpYmxlIG1hcCB0byBzdG9yZSBhbGwgb2YgdGhlIHVuYXJ5IG9wZXJhdG9yc1xuXHQvLyBWYWx1ZXMgYXJlIHNldCB0byBgdHJ1ZWAgKGl0IHJlYWxseSBkb2Vzbid0IG1hdHRlcilcblx0XHR1bmFyeV9vcHMgPSB7Jy0nOiB0LCAnISc6IHQsICd+JzogdCwgJysnOiB0fSxcblx0Ly8gQWxzbyB1c2UgYSBtYXAgZm9yIHRoZSBiaW5hcnkgb3BlcmF0aW9ucyBidXQgc2V0IHRoZWlyIHZhbHVlcyB0byB0aGVpclxuXHQvLyBiaW5hcnkgcHJlY2VkZW5jZSBmb3IgcXVpY2sgcmVmZXJlbmNlOlxuXHQvLyBzZWUgW09yZGVyIG9mIG9wZXJhdGlvbnNdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3JkZXJfb2Zfb3BlcmF0aW9ucyNQcm9ncmFtbWluZ19sYW5ndWFnZSlcblx0XHRiaW5hcnlfb3BzID0ge1xuXHRcdFx0J3x8JzogMSwgJyYmJzogMiwgJ3wnOiAzLCAgJ14nOiA0LCAgJyYnOiA1LFxuXHRcdFx0Jz09JzogNiwgJyE9JzogNiwgJz09PSc6IDYsICchPT0nOiA2LFxuXHRcdFx0JzwnOiA3LCAgJz4nOiA3LCAgJzw9JzogNywgICc+PSc6IDcsIFxuXHRcdFx0Jzw8Jzo4LCAgJz4+JzogOCwgJz4+Pic6IDgsXG5cdFx0XHQnKyc6IDksICctJzogOSxcblx0XHRcdCcqJzogMTAsICcvJzogMTAsICclJzogMTBcblx0XHR9LFxuXHQvLyBHZXQgcmV0dXJuIHRoZSBsb25nZXN0IGtleSBsZW5ndGggb2YgYW55IG9iamVjdFxuXHRcdGdldE1heEtleUxlbiA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0dmFyIG1heF9sZW4gPSAwLCBsZW47XG5cdFx0XHRmb3IodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdFx0aWYoKGxlbiA9IGtleS5sZW5ndGgpID4gbWF4X2xlbiAmJiBvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdG1heF9sZW4gPSBsZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXhfbGVuO1xuXHRcdH0sXG5cdFx0bWF4X3Vub3BfbGVuID0gZ2V0TWF4S2V5TGVuKHVuYXJ5X29wcyksXG5cdFx0bWF4X2Jpbm9wX2xlbiA9IGdldE1heEtleUxlbihiaW5hcnlfb3BzKSxcblx0Ly8gTGl0ZXJhbHNcblx0Ly8gLS0tLS0tLS0tLVxuXHQvLyBTdG9yZSB0aGUgdmFsdWVzIHRvIHJldHVybiBmb3IgdGhlIHZhcmlvdXMgbGl0ZXJhbHMgd2UgbWF5IGVuY291bnRlclxuXHRcdGxpdGVyYWxzID0ge1xuXHRcdFx0J3RydWUnOiB0cnVlLFxuXHRcdFx0J2ZhbHNlJzogZmFsc2UsXG5cdFx0XHQnbnVsbCc6IG51bGxcblx0XHR9LFxuXHQvLyBFeGNlcHQgZm9yIGB0aGlzYCwgd2hpY2ggaXMgc3BlY2lhbC4gVGhpcyBjb3VsZCBiZSBjaGFuZ2VkIHRvIHNvbWV0aGluZyBsaWtlIGAnc2VsZidgIGFzIHdlbGxcblx0XHR0aGlzX3N0ciA9ICd0aGlzJyxcblx0Ly8gUmV0dXJucyB0aGUgcHJlY2VkZW5jZSBvZiBhIGJpbmFyeSBvcGVyYXRvciBvciBgMGAgaWYgaXQgaXNuJ3QgYSBiaW5hcnkgb3BlcmF0b3Jcblx0XHRiaW5hcnlQcmVjZWRlbmNlID0gZnVuY3Rpb24ob3BfdmFsKSB7XG5cdFx0XHRyZXR1cm4gYmluYXJ5X29wc1tvcF92YWxdIHx8IDA7XG5cdFx0fSxcblx0Ly8gVXRpbGl0eSBmdW5jdGlvbiAoZ2V0cyBjYWxsZWQgZnJvbSBtdWx0aXBsZSBwbGFjZXMpXG5cdC8vIEFsc28gbm90ZSB0aGF0IGBhICYmIGJgIGFuZCBgYSB8fCBiYCBhcmUgKmxvZ2ljYWwqIGV4cHJlc3Npb25zLCBub3QgYmluYXJ5IGV4cHJlc3Npb25zXG5cdFx0Y3JlYXRlQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcblx0XHRcdHZhciB0eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IExPR0lDQUxfRVhQIDogQklOQVJZX0VYUDtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9wZXJhdG9yOiBvcGVyYXRvcixcblx0XHRcdFx0bGVmdDogbGVmdCxcblx0XHRcdFx0cmlnaHQ6IHJpZ2h0XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0Ly8gYGNoYCBpcyBhIGNoYXJhY3RlciBjb2RlIGluIHRoZSBuZXh0IHRocmVlIGZ1bmN0aW9uc1xuXHRcdGlzRGVjaW1hbERpZ2l0ID0gZnVuY3Rpb24oY2gpIHtcblx0XHRcdHJldHVybiAoY2ggPj0gNDggJiYgY2ggPD0gNTcpOyAvLyAwLi4uOVxuXHRcdH0sXG5cdFx0aXNJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihjaCkge1xuXHRcdFx0cmV0dXJuIChjaCA9PT0gMzYpIHx8IChjaCA9PT0gOTUpIHx8IC8vIGAkYCBhbmQgYF9gXG5cdFx0XHRcdFx0KGNoID49IDY1ICYmIGNoIDw9IDkwKSB8fCAvLyBBLi4uWlxuXHRcdFx0XHRcdChjaCA+PSA5NyAmJiBjaCA8PSAxMjIpOyAvLyBhLi4uelxuXHRcdH0sXG5cdFx0aXNJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKGNoKSB7XG5cdFx0XHRyZXR1cm4gKGNoID09PSAzNikgfHwgKGNoID09PSA5NSkgfHwgLy8gYCRgIGFuZCBgX2Bcblx0XHRcdFx0XHQoY2ggPj0gNjUgJiYgY2ggPD0gOTApIHx8IC8vIEEuLi5aXG5cdFx0XHRcdFx0KGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgLy8gYS4uLnpcblx0XHRcdFx0XHQoY2ggPj0gNDggJiYgY2ggPD0gNTcpOyAvLyAwLi4uOVxuXHRcdH0sXG5cblx0XHQvLyBQYXJzaW5nXG5cdFx0Ly8gLS0tLS0tLVxuXHRcdC8vIGBleHByYCBpcyBhIHN0cmluZyB3aXRoIHRoZSBwYXNzZWQgaW4gZXhwcmVzc2lvblxuXHRcdGpzZXAgPSBmdW5jdGlvbihleHByKSB7XG5cdFx0XHQvLyBgaW5kZXhgIHN0b3JlcyB0aGUgY2hhcmFjdGVyIG51bWJlciB3ZSBhcmUgY3VycmVudGx5IGF0IHdoaWxlIGBsZW5ndGhgIGlzIGEgY29uc3RhbnRcblx0XHRcdC8vIEFsbCBvZiB0aGUgZ29iYmxlcyBiZWxvdyB3aWxsIG1vZGlmeSBgaW5kZXhgIGFzIHdlIG1vdmUgYWxvbmdcblx0XHRcdHZhciBpbmRleCA9IDAsXG5cdFx0XHRcdGNoYXJBdEZ1bmMgPSBleHByLmNoYXJBdCxcblx0XHRcdFx0Y2hhckNvZGVBdEZ1bmMgPSBleHByLmNoYXJDb2RlQXQsXG5cdFx0XHRcdGV4cHJJID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gY2hhckF0RnVuYy5jYWxsKGV4cHIsIGkpOyB9LFxuXHRcdFx0XHRleHBySUNvZGUgPSBmdW5jdGlvbihpKSB7IHJldHVybiBjaGFyQ29kZUF0RnVuYy5jYWxsKGV4cHIsIGkpOyB9LFxuXHRcdFx0XHRsZW5ndGggPSBleHByLmxlbmd0aCxcblxuXHRcdFx0XHQvLyBQdXNoIGBpbmRleGAgdXAgdG8gdGhlIG5leHQgbm9uLXNwYWNlIGNoYXJhY3RlclxuXHRcdFx0XHRnb2JibGVTcGFjZXMgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgY2ggPSBleHBySUNvZGUoaW5kZXgpO1xuXHRcdFx0XHRcdC8vIHNwYWNlIG9yIHRhYlxuXHRcdFx0XHRcdHdoaWxlKGNoID09PSAzMiB8fCBjaCA9PT0gOSkge1xuXHRcdFx0XHRcdFx0Y2ggPSBleHBySUNvZGUoKytpbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gVGhlIG1haW4gcGFyc2luZyBmdW5jdGlvbi4gTXVjaCBvZiB0aGlzIGNvZGUgaXMgZGVkaWNhdGVkIHRvIHRlcm5hcnkgZXhwcmVzc2lvbnNcblx0XHRcdFx0Z29iYmxlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciB0ZXN0ID0gZ29iYmxlQmluYXJ5RXhwcmVzc2lvbigpLFxuXHRcdFx0XHRcdFx0Y29uc2VxdWVudCwgYWx0ZXJuYXRlO1xuXHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdGlmKGV4cHJJQ29kZShpbmRleCkgPT09IFFVTUFSS19DT0RFKSB7XG5cdFx0XHRcdFx0XHQvLyBUZXJuYXJ5IGV4cHJlc3Npb246IHRlc3QgPyBjb25zZXF1ZW50IDogYWx0ZXJuYXRlXG5cdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0Y29uc2VxdWVudCA9IGdvYmJsZUV4cHJlc3Npb24oKTtcblx0XHRcdFx0XHRcdGlmKCFjb25zZXF1ZW50KSB7XG5cdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ0V4cGVjdGVkIGV4cHJlc3Npb24nLCBpbmRleCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRcdGlmKGV4cHJJQ29kZShpbmRleCkgPT09IENPTE9OX0NPREUpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlID0gZ29iYmxlRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRcdFx0XHRpZighYWx0ZXJuYXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3dFcnJvcignRXhwZWN0ZWQgZXhwcmVzc2lvbicsIGluZGV4KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IENPTkRJVElPTkFMX0VYUCxcblx0XHRcdFx0XHRcdFx0XHR0ZXN0OiB0ZXN0LFxuXHRcdFx0XHRcdFx0XHRcdGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQsXG5cdFx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlOiBhbHRlcm5hdGVcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ0V4cGVjdGVkIDonLCBpbmRleCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiB0ZXN0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTZWFyY2ggZm9yIHRoZSBvcGVyYXRpb24gcG9ydGlvbiBvZiB0aGUgc3RyaW5nIChlLmcuIGArYCwgYD09PWApXG5cdFx0XHRcdC8vIFN0YXJ0IGJ5IHRha2luZyB0aGUgbG9uZ2VzdCBwb3NzaWJsZSBiaW5hcnkgb3BlcmF0aW9ucyAoMyBjaGFyYWN0ZXJzOiBgPT09YCwgYCE9PWAsIGA+Pj5gKVxuXHRcdFx0XHQvLyBhbmQgbW92ZSBkb3duIGZyb20gMyB0byAyIHRvIDEgY2hhcmFjdGVyIHVudGlsIGEgbWF0Y2hpbmcgYmluYXJ5IG9wZXJhdGlvbiBpcyBmb3VuZFxuXHRcdFx0XHQvLyB0aGVuLCByZXR1cm4gdGhhdCBiaW5hcnkgb3BlcmF0aW9uXG5cdFx0XHRcdGdvYmJsZUJpbmFyeU9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0dmFyIGJpb3AsIHRvX2NoZWNrID0gZXhwci5zdWJzdHIoaW5kZXgsIG1heF9iaW5vcF9sZW4pLCB0Y19sZW4gPSB0b19jaGVjay5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUodGNfbGVuID4gMCkge1xuXHRcdFx0XHRcdFx0aWYoYmluYXJ5X29wcy5oYXNPd25Qcm9wZXJ0eSh0b19jaGVjaykpIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggKz0gdGNfbGVuO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdG9fY2hlY2s7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0b19jaGVjayA9IHRvX2NoZWNrLnN1YnN0cigwLCAtLXRjX2xlbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBnb2JibGluZyBhbiBpbmRpdmlkdWFsIGV4cHJlc3Npb24sXG5cdFx0XHRcdC8vIGUuZy4gYDFgLCBgMSsyYCwgYGErKGIqMiktTWF0aC5zcXJ0KDIpYFxuXHRcdFx0XHRnb2JibGVCaW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGNoX2ksIG5vZGUsIGJpb3AsIHByZWMsIHN0YWNrLCBiaW9wX2luZm8sIGxlZnQsIHJpZ2h0LCBpO1xuXG5cdFx0XHRcdFx0Ly8gRmlyc3QsIHRyeSB0byBnZXQgdGhlIGxlZnRtb3N0IHRoaW5nXG5cdFx0XHRcdFx0Ly8gVGhlbiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBiaW5hcnkgb3BlcmF0b3Igb3BlcmF0aW5nIG9uIHRoYXQgbGVmdG1vc3QgdGhpbmdcblx0XHRcdFx0XHRsZWZ0ID0gZ29iYmxlVG9rZW4oKTtcblx0XHRcdFx0XHRiaW9wID0gZ29iYmxlQmluYXJ5T3AoKTtcblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIHdhc24ndCBhIGJpbmFyeSBvcGVyYXRvciwganVzdCByZXR1cm4gdGhlIGxlZnRtb3N0IG5vZGVcblx0XHRcdFx0XHRpZighYmlvcCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHN0YXJ0IGEgc3RhY2sgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGJpbmFyeSBvcGVyYXRpb25zIGluIHRoZWlyXG5cdFx0XHRcdFx0Ly8gcHJlY2VkZW5jZSBzdHJ1Y3R1cmVcblx0XHRcdFx0XHRiaW9wX2luZm8gPSB7IHZhbHVlOiBiaW9wLCBwcmVjOiBiaW5hcnlQcmVjZWRlbmNlKGJpb3ApfTtcblxuXHRcdFx0XHRcdHJpZ2h0ID0gZ29iYmxlVG9rZW4oKTtcblx0XHRcdFx0XHRpZighcmlnaHQpIHtcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uIGFmdGVyIFwiICsgYmlvcCwgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGFjayA9IFtsZWZ0LCBiaW9wX2luZm8sIHJpZ2h0XTtcblxuXHRcdFx0XHRcdC8vIFByb3Blcmx5IGRlYWwgd2l0aCBwcmVjZWRlbmNlIHVzaW5nIFtyZWN1cnNpdmUgZGVzY2VudF0oaHR0cDovL3d3dy5lbmdyLm11bi5jYS9+dGhlby9NaXNjL2V4cF9wYXJzaW5nLmh0bSlcblx0XHRcdFx0XHR3aGlsZSgoYmlvcCA9IGdvYmJsZUJpbmFyeU9wKCkpKSB7XG5cdFx0XHRcdFx0XHRwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShiaW9wKTtcblxuXHRcdFx0XHRcdFx0aWYocHJlYyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJpb3BfaW5mbyA9IHsgdmFsdWU6IGJpb3AsIHByZWM6IHByZWMgfTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuXHRcdFx0XHRcdFx0d2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSkge1xuXHRcdFx0XHRcdFx0XHRyaWdodCA9IHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHRiaW9wID0gc3RhY2sucG9wKCkudmFsdWU7XG5cdFx0XHRcdFx0XHRcdGxlZnQgPSBzdGFjay5wb3AoKTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IGNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oYmlvcCwgbGVmdCwgcmlnaHQpO1xuXHRcdFx0XHRcdFx0XHRzdGFjay5wdXNoKG5vZGUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRub2RlID0gZ29iYmxlVG9rZW4oKTtcblx0XHRcdFx0XHRcdGlmKCFub2RlKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uIGFmdGVyIFwiICsgYmlvcCwgaW5kZXgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3RhY2sucHVzaChiaW9wX2luZm8sIG5vZGUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGkgPSBzdGFjay5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdG5vZGUgPSBzdGFja1tpXTtcblx0XHRcdFx0XHR3aGlsZShpID4gMSkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIG5vZGUpOyBcblx0XHRcdFx0XHRcdGkgLT0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQW4gaW5kaXZpZHVhbCBwYXJ0IG9mIGEgYmluYXJ5IGV4cHJlc3Npb246XG5cdFx0XHRcdC8vIGUuZy4gYGZvby5iYXIoYmF6KWAsIGAxYCwgYFwiYWJjXCJgLCBgKGEgJSAyKWAgKGJlY2F1c2UgaXQncyBpbiBwYXJlbnRoZXNpcylcblx0XHRcdFx0Z29iYmxlVG9rZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgY2gsIHRvX2NoZWNrLCB0Y19sZW47XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0Y2ggPSBleHBySUNvZGUoaW5kZXgpO1xuXG5cdFx0XHRcdFx0aWYoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSBQRVJJT0RfQ09ERSkge1xuXHRcdFx0XHRcdFx0Ly8gQ2hhciBjb2RlIDQ2IGlzIGEgZG90IGAuYCB3aGljaCBjYW4gc3RhcnQgb2ZmIGEgbnVtZXJpYyBsaXRlcmFsXG5cdFx0XHRcdFx0XHRyZXR1cm4gZ29iYmxlTnVtZXJpY0xpdGVyYWwoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoY2ggPT09IFNRVU9URV9DT0RFIHx8IGNoID09PSBEUVVPVEVfQ09ERSkge1xuXHRcdFx0XHRcdFx0Ly8gU2luZ2xlIG9yIGRvdWJsZSBxdW90ZXNcblx0XHRcdFx0XHRcdHJldHVybiBnb2JibGVTdHJpbmdMaXRlcmFsKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGlzSWRlbnRpZmllclN0YXJ0KGNoKSB8fCBjaCA9PT0gT1BBUkVOX0NPREUpIHsgLy8gb3BlbiBwYXJlbnRoZXNpc1xuXHRcdFx0XHRcdFx0Ly8gYGZvb2AsIGBiYXIuYmF6YFxuXHRcdFx0XHRcdFx0cmV0dXJuIGdvYmJsZVZhcmlhYmxlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjaCA9PT0gT0JSQUNLX0NPREUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnb2JibGVBcnJheSgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0b19jaGVjayA9IGV4cHIuc3Vic3RyKGluZGV4LCBtYXhfdW5vcF9sZW4pO1xuXHRcdFx0XHRcdFx0dGNfbGVuID0gdG9fY2hlY2subGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUodGNfbGVuID4gMCkge1xuXHRcdFx0XHRcdFx0XHRpZih1bmFyeV9vcHMuaGFzT3duUHJvcGVydHkodG9fY2hlY2spKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggKz0gdGNfbGVuO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBVTkFSWV9FWFAsXG5cdFx0XHRcdFx0XHRcdFx0XHRvcGVyYXRvcjogdG9fY2hlY2ssXG5cdFx0XHRcdFx0XHRcdFx0XHRhcmd1bWVudDogZ29iYmxlVG9rZW4oKSxcblx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeDogdHJ1ZVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dG9fY2hlY2sgPSB0b19jaGVjay5zdWJzdHIoMCwgLS10Y19sZW4pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBQYXJzZSBzaW1wbGUgbnVtZXJpYyBsaXRlcmFsczogYDEyYCwgYDMuNGAsIGAuNWAuIERvIHRoaXMgYnkgdXNpbmcgYSBzdHJpbmcgdG9cblx0XHRcdFx0Ly8ga2VlcCB0cmFjayBvZiBldmVyeXRoaW5nIGluIHRoZSBudW1lcmljIGxpdGVyYWwgYW5kIHRoZW4gY2FsbGluZyBgcGFyc2VGbG9hdGAgb24gdGhhdCBzdHJpbmdcblx0XHRcdFx0Z29iYmxlTnVtZXJpY0xpdGVyYWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgbnVtYmVyID0gJycsIGNoLCBjaENvZGU7XG5cdFx0XHRcdFx0d2hpbGUoaXNEZWNpbWFsRGlnaXQoZXhwcklDb2RlKGluZGV4KSkpIHtcblx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZihleHBySUNvZGUoaW5kZXgpID09PSBQRVJJT0RfQ09ERSkgeyAvLyBjYW4gc3RhcnQgd2l0aCBhIGRlY2ltYWwgbWFya2VyXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XG5cblx0XHRcdFx0XHRcdHdoaWxlKGlzRGVjaW1hbERpZ2l0KGV4cHJJQ29kZShpbmRleCkpKSB7XG5cdFx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y2ggPSBleHBySShpbmRleCk7XG5cdFx0XHRcdFx0aWYoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7IC8vIGV4cG9uZW50IG1hcmtlclxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGV4cHJJKGluZGV4KyspO1xuXHRcdFx0XHRcdFx0Y2ggPSBleHBySShpbmRleCk7XG5cdFx0XHRcdFx0XHRpZihjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHsgLy8gZXhwb25lbnQgc2lnblxuXHRcdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR3aGlsZShpc0RlY2ltYWxEaWdpdChleHBySUNvZGUoaW5kZXgpKSkgeyAvL2V4cG9uZW50IGl0c2VsZlxuXHRcdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZighaXNEZWNpbWFsRGlnaXQoZXhwcklDb2RlKGluZGV4LTEpKSApIHtcblx0XHRcdFx0XHRcdFx0dGhyb3dFcnJvcignRXhwZWN0ZWQgZXhwb25lbnQgKCcgKyBudW1iZXIgKyBleHBySShpbmRleCkgKyAnKScsIGluZGV4KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cblx0XHRcdFx0XHRjaENvZGUgPSBleHBySUNvZGUoaW5kZXgpO1xuXHRcdFx0XHRcdC8vIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGlzIGlzbid0IGEgdmFyaWFibGUgbmFtZSB0aGF0IHN0YXJ0IHdpdGggYSBudW1iZXIgKDEyM2FiYylcblx0XHRcdFx0XHRpZihpc0lkZW50aWZpZXJTdGFydChjaENvZGUpKSB7XG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdWYXJpYWJsZSBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCBhIG51bWJlciAoJyArXG5cdFx0XHRcdFx0XHRcdFx0XHRudW1iZXIgKyBleHBySShpbmRleCkgKyAnKScsIGluZGV4KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoY2hDb2RlID09PSBQRVJJT0RfQ09ERSkge1xuXHRcdFx0XHRcdFx0dGhyb3dFcnJvcignVW5leHBlY3RlZCBwZXJpb2QnLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IExJVEVSQUwsXG5cdFx0XHRcdFx0XHR2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuXHRcdFx0XHRcdFx0cmF3OiBudW1iZXJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFBhcnNlcyBhIHN0cmluZyBsaXRlcmFsLCBzdGFyaW5nIHdpdGggc2luZ2xlIG9yIGRvdWJsZSBxdW90ZXMgd2l0aCBiYXNpYyBzdXBwb3J0IGZvciBlc2NhcGUgY29kZXNcblx0XHRcdFx0Ly8gZS5nLiBgXCJoZWxsbyB3b3JsZFwiYCwgYCd0aGlzIGlzXFxuSlNFUCdgXG5cdFx0XHRcdGdvYmJsZVN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgc3RyID0gJycsIHF1b3RlID0gZXhwckkoaW5kZXgrKyksIGNsb3NlZCA9IGZhbHNlLCBjaDtcblxuXHRcdFx0XHRcdHdoaWxlKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjaCA9IGV4cHJJKGluZGV4KyspO1xuXHRcdFx0XHRcdFx0aWYoY2ggPT09IHF1b3RlKSB7XG5cdFx0XHRcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNoID09PSAnXFxcXCcpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGFsbCBvZiB0aGUgY29tbW9uIGVzY2FwZSBjb2Rlc1xuXHRcdFx0XHRcdFx0XHRjaCA9IGV4cHJJKGluZGV4KyspO1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2goY2gpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlICduJzogc3RyICs9ICdcXG4nOyBicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdyJzogc3RyICs9ICdcXHInOyBicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd0Jzogc3RyICs9ICdcXHQnOyBicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdiJzogc3RyICs9ICdcXGInOyBicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdmJzogc3RyICs9ICdcXGYnOyBicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd2Jzogc3RyICs9ICdcXHgwQic7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdHIgKz0gY2g7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoIWNsb3NlZCkge1xuXHRcdFx0XHRcdFx0dGhyb3dFcnJvcignVW5jbG9zZWQgcXVvdGUgYWZ0ZXIgXCInK3N0cisnXCInLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IExJVEVSQUwsXG5cdFx0XHRcdFx0XHR2YWx1ZTogc3RyLFxuXHRcdFx0XHRcdFx0cmF3OiBxdW90ZSArIHN0ciArIHF1b3RlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSxcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEdvYmJsZXMgb25seSBpZGVudGlmaWVyc1xuXHRcdFx0XHQvLyBlLmcuOiBgZm9vYCwgYF92YWx1ZWAsIGAkeDFgXG5cdFx0XHRcdC8vIEFsc28sIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoYXQgaWRlbnRpZmllciBpcyBhIGxpdGVyYWw6XG5cdFx0XHRcdC8vIChlLmcuIGB0cnVlYCwgYGZhbHNlYCwgYG51bGxgKSBvciBgdGhpc2Bcblx0XHRcdFx0Z29iYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBjaCA9IGV4cHJJQ29kZShpbmRleCksIHN0YXJ0ID0gaW5kZXgsIGlkZW50aWZpZXI7XG5cblx0XHRcdFx0XHRpZihpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcblx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ1VuZXhwZWN0ZWQgJyArIGV4cHJJKGluZGV4KSwgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdoaWxlKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjaCA9IGV4cHJJQ29kZShpbmRleCk7XG5cdFx0XHRcdFx0XHRpZihpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlkZW50aWZpZXIgPSBleHByLnNsaWNlKHN0YXJ0LCBpbmRleCk7XG5cblx0XHRcdFx0XHRpZihsaXRlcmFscy5oYXNPd25Qcm9wZXJ0eShpZGVudGlmaWVyKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dHlwZTogTElURVJBTCxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGxpdGVyYWxzW2lkZW50aWZpZXJdLFxuXHRcdFx0XHRcdFx0XHRyYXc6IGlkZW50aWZpZXJcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGlkZW50aWZpZXIgPT09IHRoaXNfc3RyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyB0eXBlOiBUSElTX0VYUCB9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiBJREVOVElGSUVSLFxuXHRcdFx0XHRcdFx0XHRuYW1lOiBpZGVudGlmaWVyXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHb2JibGVzIGEgbGlzdCBvZiBhcmd1bWVudHMgd2l0aGluIHRoZSBjb250ZXh0IG9mIGEgZnVuY3Rpb24gY2FsbFxuXHRcdFx0XHQvLyBvciBhcnJheSBsaXRlcmFsLiBUaGlzIGZ1bmN0aW9uIGFsc28gYXNzdW1lcyB0aGF0IHRoZSBvcGVuaW5nIGNoYXJhY3RlclxuXHRcdFx0XHQvLyBgKGAgb3IgYFtgIGhhcyBhbHJlYWR5IGJlZW4gZ29iYmxlZCwgYW5kIGdvYmJsZXMgZXhwcmVzc2lvbnMgYW5kIGNvbW1hc1xuXHRcdFx0XHQvLyB1bnRpbCB0aGUgdGVybWluYXRvciBjaGFyYWN0ZXIgYClgIG9yIGBdYCBpcyBlbmNvdW50ZXJlZC5cblx0XHRcdFx0Ly8gZS5nLiBgZm9vKGJhciwgYmF6KWAsIGBteV9mdW5jKClgLCBvciBgW2JhciwgYmF6XWBcblx0XHRcdFx0Z29iYmxlQXJndW1lbnRzID0gZnVuY3Rpb24odGVybWluYXRpb24pIHtcblx0XHRcdFx0XHR2YXIgY2hfaSwgYXJncyA9IFtdLCBub2RlO1xuXHRcdFx0XHRcdHdoaWxlKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xuXHRcdFx0XHRcdFx0aWYoY2hfaSA9PT0gdGVybWluYXRpb24pIHsgLy8gZG9uZSBwYXJzaW5nXG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjaF9pID09PSBDT01NQV9DT0RFKSB7IC8vIGJldHdlZW4gZXhwcmVzc2lvbnNcblx0XHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBnb2JibGVFeHByZXNzaW9uKCk7XG5cdFx0XHRcdFx0XHRcdGlmKCFub2RlIHx8IG5vZGUudHlwZSA9PT0gQ09NUE9VTkQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdFeHBlY3RlZCBjb21tYScsIGluZGV4KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRhcmdzLnB1c2gobm9kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBhcmdzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdvYmJsZSBhIG5vbi1saXRlcmFsIHZhcmlhYmxlIG5hbWUuIFRoaXMgdmFyaWFibGUgbmFtZSBtYXkgaW5jbHVkZSBwcm9wZXJ0aWVzXG5cdFx0XHRcdC8vIGUuZy4gYGZvb2AsIGBiYXIuYmF6YCwgYGZvb1snYmFyJ10uYmF6YFxuXHRcdFx0XHQvLyBJdCBhbHNvIGdvYmJsZXMgZnVuY3Rpb24gY2FsbHM6XG5cdFx0XHRcdC8vIGUuZy4gYE1hdGguYWNvcyhvYmouYW5nbGUpYFxuXHRcdFx0XHRnb2JibGVWYXJpYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBjaF9pLCBub2RlO1xuXHRcdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYoY2hfaSA9PT0gT1BBUkVOX0NPREUpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBnb2JibGVHcm91cCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZ29iYmxlSWRlbnRpZmllcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHR3aGlsZShjaF9pID09PSBQRVJJT0RfQ09ERSB8fCBjaF9pID09PSBPQlJBQ0tfQ09ERSB8fCBjaF9pID09PSBPUEFSRU5fQ09ERSkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdGlmKGNoX2kgPT09IFBFUklPRF9DT0RFKSB7XG5cdFx0XHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdFx0XHRub2RlID0ge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IE1FTUJFUl9FWFAsXG5cdFx0XHRcdFx0XHRcdFx0Y29tcHV0ZWQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdDogbm9kZSxcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eTogZ29iYmxlSWRlbnRpZmllcigpXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoY2hfaSA9PT0gT0JSQUNLX0NPREUpIHtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBNRU1CRVJfRVhQLFxuXHRcdFx0XHRcdFx0XHRcdGNvbXB1dGVkOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdDogbm9kZSxcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eTogZ29iYmxlRXhwcmVzc2lvbigpXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHRcdFx0aWYoY2hfaSAhPT0gQ0JSQUNLX0NPREUpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmNsb3NlZCBbJywgaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoY2hfaSA9PT0gT1BBUkVOX0NPREUpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQSBmdW5jdGlvbiBjYWxsIGlzIGJlaW5nIG1hZGU7IGdvYmJsZSBhbGwgdGhlIGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRub2RlID0ge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IENBTExfRVhQLFxuXHRcdFx0XHRcdFx0XHRcdCdhcmd1bWVudHMnOiBnb2JibGVBcmd1bWVudHMoQ1BBUkVOX0NPREUpLFxuXHRcdFx0XHRcdFx0XHRcdGNhbGxlZTogbm9kZVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmVzcG9uc2libGUgZm9yIHBhcnNpbmcgYSBncm91cCBvZiB0aGluZ3Mgd2l0aGluIHBhcmVudGhlc2VzIGAoKWBcblx0XHRcdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgaXQgbmVlZHMgdG8gZ29iYmxlIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdC8vIGFuZCB0aGVuIHRyaWVzIHRvIGdvYmJsZSBldmVyeXRoaW5nIHdpdGhpbiB0aGF0IHBhcmVudGhlc2lzLCBhc3N1bWluZ1xuXHRcdFx0XHQvLyB0aGF0IHRoZSBuZXh0IHRoaW5nIGl0IHNob3VsZCBzZWUgaXMgdGhlIGNsb3NlIHBhcmVudGhlc2lzLiBJZiBub3QsXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV4cHJlc3Npb24gcHJvYmFibHkgZG9lc24ndCBoYXZlIGEgYClgXG5cdFx0XHRcdGdvYmJsZUdyb3VwID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHR2YXIgbm9kZSA9IGdvYmJsZUV4cHJlc3Npb24oKTtcblx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRpZihleHBySUNvZGUoaW5kZXgpID09PSBDUEFSRU5fQ09ERSkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmNsb3NlZCAoJywgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSZXNwb25zaWJsZSBmb3IgcGFyc2luZyBBcnJheSBsaXRlcmFscyBgWzEsIDIsIDNdYFxuXHRcdFx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpdCBuZWVkcyB0byBnb2JibGUgdGhlIG9wZW5pbmcgYnJhY2tldFxuXHRcdFx0XHQvLyBhbmQgdGhlbiB0cmllcyB0byBnb2JibGUgdGhlIGV4cHJlc3Npb25zIGFzIGFyZ3VtZW50cy5cblx0XHRcdFx0Z29iYmxlQXJyYXkgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBBUlJBWV9FWFAsXG5cdFx0XHRcdFx0XHRlbGVtZW50czogZ29iYmxlQXJndW1lbnRzKENCUkFDS19DT0RFKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0bm9kZXMgPSBbXSwgY2hfaSwgbm9kZTtcblx0XHRcdFx0XG5cdFx0XHR3aGlsZShpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHRjaF9pID0gZXhwcklDb2RlKGluZGV4KTtcblxuXHRcdFx0XHQvLyBFeHByZXNzaW9ucyBjYW4gYmUgc2VwYXJhdGVkIGJ5IHNlbWljb2xvbnMsIGNvbW1hcywgb3IganVzdCBpbmZlcnJlZCB3aXRob3V0IGFueVxuXHRcdFx0XHQvLyBzZXBhcmF0b3JzXG5cdFx0XHRcdGlmKGNoX2kgPT09IFNFTUNPTF9DT0RFIHx8IGNoX2kgPT09IENPTU1BX0NPREUpIHtcblx0XHRcdFx0XHRpbmRleCsrOyAvLyBpZ25vcmUgc2VwYXJhdG9yc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFRyeSB0byBnb2JibGUgZWFjaCBleHByZXNzaW9uIGluZGl2aWR1YWxseVxuXHRcdFx0XHRcdGlmKChub2RlID0gZ29iYmxlRXhwcmVzc2lvbigpKSkge1xuXHRcdFx0XHRcdFx0bm9kZXMucHVzaChub2RlKTtcblx0XHRcdFx0XHQvLyBJZiB3ZSB3ZXJlbid0IGFibGUgdG8gZmluZCBhIGJpbmFyeSBleHByZXNzaW9uIGFuZCBhcmUgb3V0IG9mIHJvb20sIHRoZW5cblx0XHRcdFx0XHQvLyB0aGUgZXhwcmVzc2lvbiBwYXNzZWQgaW4gcHJvYmFibHkgaGFzIHRvbyBtdWNoXG5cdFx0XHRcdFx0fSBlbHNlIGlmKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmV4cGVjdGVkIFwiJyArIGV4cHJJKGluZGV4KSArICdcIicsIGluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBvbmx5IG9uZSBleHByZXNzaW9uIGp1c3QgdHJ5IHJldHVybmluZyB0aGUgZXhwcmVzc2lvblxuXHRcdFx0aWYobm9kZXMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiBub2Rlc1swXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogQ09NUE9VTkQsXG5cdFx0XHRcdFx0Ym9keTogbm9kZXNcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdC8vIFRvIGJlIGZpbGxlZCBpbiBieSB0aGUgdGVtcGxhdGVcblx0anNlcC52ZXJzaW9uID0gJzwlPSB2ZXJzaW9uICU+Jztcblx0anNlcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0phdmFTY3JpcHQgRXhwcmVzc2lvbiBQYXJzZXIgKEpTRVApIHYnICsganNlcC52ZXJzaW9uOyB9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGpzZXAuYWRkVW5hcnlPcFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BfbmFtZSBUaGUgbmFtZSBvZiB0aGUgdW5hcnkgb3AgdG8gYWRkXG5cdCAqIEByZXR1cm4ganNlcFxuXHQgKi9cblx0anNlcC5hZGRVbmFyeU9wID0gZnVuY3Rpb24ob3BfbmFtZSkge1xuXHRcdHVuYXJ5X29wc1tvcF9uYW1lXSA9IHQ7IHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGpzZXAuYWRkQmluYXJ5T3Bcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wX25hbWUgVGhlIG5hbWUgb2YgdGhlIGJpbmFyeSBvcCB0byBhZGRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHByZWNlZGVuY2UgVGhlIHByZWNlZGVuY2Ugb2YgdGhlIGJpbmFyeSBvcCAoY2FuIGJlIGEgZmxvYXQpXG5cdCAqIEByZXR1cm4ganNlcFxuXHQgKi9cblx0anNlcC5hZGRCaW5hcnlPcCA9IGZ1bmN0aW9uKG9wX25hbWUsIHByZWNlZGVuY2UpIHtcblx0XHRtYXhfYmlub3BfbGVuID0gTWF0aC5tYXgob3BfbmFtZS5sZW5ndGgsIG1heF9iaW5vcF9sZW4pO1xuXHRcdGJpbmFyeV9vcHNbb3BfbmFtZV0gPSBwcmVjZWRlbmNlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGpzZXAucmVtb3ZlVW5hcnlPcFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BfbmFtZSBUaGUgbmFtZSBvZiB0aGUgdW5hcnkgb3AgdG8gcmVtb3ZlXG5cdCAqIEByZXR1cm4ganNlcFxuXHQgKi9cblx0anNlcC5yZW1vdmVVbmFyeU9wID0gZnVuY3Rpb24ob3BfbmFtZSkge1xuXHRcdGRlbGV0ZSB1bmFyeV9vcHNbb3BfbmFtZV07XG5cdFx0aWYob3BfbmFtZS5sZW5ndGggPT09IG1heF91bm9wX2xlbikge1xuXHRcdFx0bWF4X3Vub3BfbGVuID0gZ2V0TWF4S2V5TGVuKHVuYXJ5X29wcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGpzZXAucmVtb3ZlQmluYXJ5T3Bcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wX25hbWUgVGhlIG5hbWUgb2YgdGhlIGJpbmFyeSBvcCB0byByZW1vdmVcblx0ICogQHJldHVybiBqc2VwXG5cdCAqL1xuXHRqc2VwLnJlbW92ZUJpbmFyeU9wID0gZnVuY3Rpb24ob3BfbmFtZSkge1xuXHRcdGRlbGV0ZSBiaW5hcnlfb3BzW29wX25hbWVdO1xuXHRcdGlmKG9wX25hbWUubGVuZ3RoID09PSBtYXhfYmlub3BfbGVuKSB7XG5cdFx0XHRtYXhfYmlub3BfbGVuID0gZ2V0TWF4S2V5TGVuKGJpbmFyeV9vcHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvLyBJbiBkZXNrdG9wIGVudmlyb25tZW50cywgaGF2ZSBhIHdheSB0byByZXN0b3JlIHRoZSBvbGQgdmFsdWUgZm9yIGBqc2VwYFxuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIG9sZF9qc2VwID0gcm9vdC5qc2VwO1xuXHRcdC8vIFRoZSBzdGFyIG9mIHRoZSBzaG93ISBJdCdzIGEgZnVuY3Rpb24hXG5cdFx0cm9vdC5qc2VwID0ganNlcDtcblx0XHQvLyBBbmQgYSBjb3VydGVvdXMgZnVuY3Rpb24gd2lsbGluZyB0byBtb3ZlIG91dCBvZiB0aGUgd2F5IGZvciBvdGhlciBzaW1pbGFybHktbmFtZWQgb2JqZWN0cyFcblx0XHRqc2VwLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmKHJvb3QuanNlcCA9PT0ganNlcCkge1xuXHRcdFx0XHRyb290LmpzZXAgPSBvbGRfanNlcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBqc2VwO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSW4gTm9kZS5KUyBlbnZpcm9ubWVudHNcblx0XHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRcdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGpzZXA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMucGFyc2UgPSBqc2VwO1xuXHRcdH1cblx0fVxufSh0aGlzKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYWtlSnVpY2VDbGllbnQoanVpY2VDbGllbnQpIHtcblxuanVpY2VDbGllbnQuaWdub3JlZFBzZXVkb3MgPSBbJ2hvdmVyJywgJ2FjdGl2ZScsICdmb2N1cycsICd2aXNpdGVkJywgJ2xpbmsnXTtcbmp1aWNlQ2xpZW50LndpZHRoRWxlbWVudHMgPSBbJ1RBQkxFJywgJ1REJywgJ0lNRyddO1xuanVpY2VDbGllbnQuaGVpZ2h0RWxlbWVudHMgPSBbJ1RBQkxFJywgJ1REJywgJ0lNRyddO1xuanVpY2VDbGllbnQudGFibGVFbGVtZW50cyA9IFsnVEFCTEUnLCAnVEQnLCAnVEgnLCAnVFInLCAnVEQnLCAnQ0FQVElPTicsICdDT0xHUk9VUCcsICdDT0wnLCAnVEhFQUQnLCAnVEJPRFknLCAnVEZPT1QnXTtcbmp1aWNlQ2xpZW50Lm5vblZpc3VhbEVsZW1lbnRzID0gWyAnSEVBRCcsICdUSVRMRScsICdCQVNFJywgJ0xJTksnLCAnU1RZTEUnLCAnTUVUQScsICdTQ1JJUFQnLCAnTk9TQ1JJUFQnIF07XG5qdWljZUNsaWVudC5zdHlsZVRvQXR0cmlidXRlID0ge1xuICAnYmFja2dyb3VuZC1jb2xvcic6ICdiZ2NvbG9yJyxcbiAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnYmFja2dyb3VuZCcsXG4gICd0ZXh0LWFsaWduJzogJ2FsaWduJyxcbiAgJ3ZlcnRpY2FsLWFsaWduJzogJ3ZhbGlnbidcbn07XG5qdWljZUNsaWVudC5leGNsdWRlZFByb3BlcnRpZXMgPSBbXTtcblxuanVpY2VDbGllbnQuanVpY2VEb2N1bWVudCA9IGp1aWNlRG9jdW1lbnQ7XG5qdWljZUNsaWVudC5pbmxpbmVEb2N1bWVudCA9IGlubGluZURvY3VtZW50O1xuXG5mdW5jdGlvbiBpbmxpbmVEb2N1bWVudCgkLCBjc3MsIG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJ1bGVzID0gdXRpbHMucGFyc2VDU1MoY3NzKTtcbiAgdmFyIGVkaXRlZEVsZW1lbnRzID0gW107XG4gIHZhciBzdHlsZUF0dHJpYnV0ZU5hbWUgPSAnc3R5bGUnO1xuICBcbiAgaWYgKG9wdGlvbnMuc3R5bGVBdHRyaWJ1dGVOYW1lKSB7XG4gICAgc3R5bGVBdHRyaWJ1dGVOYW1lID0gb3B0aW9ucy5zdHlsZUF0dHJpYnV0ZU5hbWU7XG4gIH1cblxuICBydWxlcy5mb3JFYWNoKGhhbmRsZVJ1bGUpO1xuICBlZGl0ZWRFbGVtZW50cy5mb3JFYWNoKHNldFN0eWxlQXR0cnMpO1xuXG4gIGlmIChvcHRpb25zLmlubGluZVBzZXVkb0VsZW1lbnRzKSB7XG4gICAgZWRpdGVkRWxlbWVudHMuZm9yRWFjaChpbmxpbmVQc2V1ZG9FbGVtZW50cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hcHBseVdpZHRoQXR0cmlidXRlcykge1xuICAgIGVkaXRlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIHNldERpbWVuc2lvbkF0dHJzKGVsLCAnd2lkdGgnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmFwcGx5SGVpZ2h0QXR0cmlidXRlcykge1xuICAgIGVkaXRlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIHNldERpbWVuc2lvbkF0dHJzKGVsLCAnaGVpZ2h0Jyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hcHBseUF0dHJpYnV0ZXNUYWJsZUVsZW1lbnRzKSB7XG4gICAgZWRpdGVkRWxlbWVudHMuZm9yRWFjaChzZXRBdHRyaWJ1dGVzT25UYWJsZUVsZW1lbnRzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmluc2VydFByZXNlcnZlZEV4dHJhQ3NzICYmIG9wdGlvbnMuZXh0cmFDc3MpIHtcbiAgICB2YXIgcHJlc2VydmVkVGV4dCA9IHV0aWxzLmdldFByZXNlcnZlZFRleHQob3B0aW9ucy5leHRyYUNzcywge1xuICAgICAgbWVkaWFRdWVyaWVzOiBvcHRpb25zLnByZXNlcnZlTWVkaWFRdWVyaWVzLFxuICAgICAgZm9udEZhY2VzOiBvcHRpb25zLnByZXNlcnZlRm9udEZhY2VzXG4gICAgfSk7XG4gICAgaWYgKHByZXNlcnZlZFRleHQpIHtcbiAgICAgIHZhciAkYXBwZW5kVG8gPSBudWxsO1xuICAgICAgaWYgKG9wdGlvbnMuaW5zZXJ0UHJlc2VydmVkRXh0cmFDc3MgIT09IHRydWUpIHtcbiAgICAgICAgJGFwcGVuZFRvID0gJChvcHRpb25zLmluc2VydFByZXNlcnZlZEV4dHJhQ3NzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRhcHBlbmRUbyA9ICQoJ2hlYWQnKTtcbiAgICAgICAgaWYgKCEkYXBwZW5kVG8ubGVuZ3RoKSB7ICRhcHBlbmRUbyA9ICQoJ2JvZHknKTsgfVxuICAgICAgICBpZiAoISRhcHBlbmRUby5sZW5ndGgpIHsgJGFwcGVuZFRvID0gJC5yb290KCk7IH1cbiAgICAgIH1cblxuICAgICAgJGFwcGVuZFRvLmZpcnN0KCkuYXBwZW5kKCc8c3R5bGU+JyArIHByZXNlcnZlZFRleHQgKyAnPC9zdHlsZT4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSdWxlKHJ1bGUpIHtcbiAgICB2YXIgc2VsID0gcnVsZVswXTtcbiAgICB2YXIgc3R5bGUgPSBydWxlWzFdO1xuICAgIHZhciBzZWxlY3RvciA9IG5ldyB1dGlscy5TZWxlY3RvcihzZWwpO1xuICAgIHZhciBwYXJzZWRTZWxlY3RvciA9IHNlbGVjdG9yLnBhcnNlZCgpO1xuICAgIHZhciBwc2V1ZG9FbGVtZW50VHlwZSA9IGdldFBzZXVkb0VsZW1lbnRUeXBlKHBhcnNlZFNlbGVjdG9yKTtcblxuICAgIC8vIHNraXAgcnVsZSBpZiB0aGUgc2VsZWN0b3IgaGFzIGFueSBwc2V1ZG9zIHdoaWNoIGFyZSBpZ25vcmVkXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWRTZWxlY3Rvci5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHN1YlNlbCA9IHBhcnNlZFNlbGVjdG9yW2ldO1xuICAgICAgaWYgKHN1YlNlbC5wc2V1ZG9zKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViU2VsLnBzZXVkb3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgc3ViU2VsUHNldWRvID0gc3ViU2VsLnBzZXVkb3Nbal07XG4gICAgICAgICAgaWYgKGp1aWNlQ2xpZW50Lmlnbm9yZWRQc2V1ZG9zLmluZGV4T2Yoc3ViU2VsUHNldWRvLm5hbWUpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHNldWRvRWxlbWVudFR5cGUpIHtcbiAgICAgIHZhciBsYXN0ID0gcGFyc2VkU2VsZWN0b3JbcGFyc2VkU2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcHNldWRvcyA9IGxhc3QucHNldWRvcztcbiAgICAgIGxhc3QucHNldWRvcyA9IGZpbHRlckVsZW1lbnRQc2V1ZG9zKGxhc3QucHNldWRvcyk7XG4gICAgICBzZWwgPSBwYXJzZWRTZWxlY3Rvci50b1N0cmluZygpO1xuICAgICAgbGFzdC5wc2V1ZG9zID0gcHNldWRvcztcbiAgICB9XG5cbiAgICB2YXIgZWxzO1xuICAgIHRyeSB7XG4gICAgICBlbHMgPSAkKHNlbCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBza2lwIGludmFsaWQgc2VsZWN0b3JcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbHMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbCA9IHRoaXM7XG5cbiAgICAgIGlmIChlbC5uYW1lICYmIGp1aWNlQ2xpZW50Lm5vblZpc3VhbEVsZW1lbnRzLmluZGV4T2YoZWwubmFtZS50b1VwcGVyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBzZXVkb0VsZW1lbnRUeXBlKSB7XG4gICAgICAgIHZhciBwc2V1ZG9FbFByb3BOYW1lID0gJ3BzZXVkbycgKyBwc2V1ZG9FbGVtZW50VHlwZTtcbiAgICAgICAgdmFyIHBzZXVkb0VsID0gZWxbcHNldWRvRWxQcm9wTmFtZV07XG4gICAgICAgIGlmICghcHNldWRvRWwpIHtcbiAgICAgICAgICBwc2V1ZG9FbCA9IGVsW3BzZXVkb0VsUHJvcE5hbWVdID0gJCgnPHNwYW4gLz4nKS5nZXQoMCk7XG4gICAgICAgICAgcHNldWRvRWwucHNldWRvRWxlbWVudFR5cGUgPSBwc2V1ZG9FbGVtZW50VHlwZTtcbiAgICAgICAgICBwc2V1ZG9FbC5wc2V1ZG9FbGVtZW50UGFyZW50ID0gZWw7XG4gICAgICAgICAgZWxbcHNldWRvRWxQcm9wTmFtZV0gPSBwc2V1ZG9FbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IHBzZXVkb0VsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsLnN0eWxlUHJvcHMpIHtcbiAgICAgICAgZWwuc3R5bGVQcm9wcyA9IHt9O1xuXG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyBpbmxpbmUgc3R5bGVzLCBmYWtlIHNlbGVjdG9yIHdpdGggdG9wbW9zdCBzcGVjaWZpY2l0eVxuICAgICAgICBpZiAoJChlbCkuYXR0cihzdHlsZUF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNzc1RleHQgPSAnKiB7ICcgKyAkKGVsKS5hdHRyKHN0eWxlQXR0cmlidXRlTmFtZSkgKyAnIH0gJztcbiAgICAgICAgICBhZGRQcm9wcyh1dGlscy5wYXJzZUNTUyhjc3NUZXh0KVswXVsxXSwgbmV3IHV0aWxzLlNlbGVjdG9yKCc8c3R5bGU+JywgdHJ1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgcmVmZXJlbmNlIHRvIGFuIGVsZW1lbnQgd2UgbmVlZCB0byBjb21waWxlIHN0eWxlPVwiXCIgYXR0ciBmb3JcbiAgICAgICAgZWRpdGVkRWxlbWVudHMucHVzaChlbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHByb3BlcnRpZXNcbiAgICAgIGZ1bmN0aW9uIGFkZFByb3BzKHN0eWxlLCBzZWxlY3Rvcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0eWxlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChzdHlsZVtpXS50eXBlID09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gc3R5bGVbaV0ubmFtZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW2ldLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGltcG9ydGFudCA9IHN0eWxlW2ldLnZhbHVlLm1hdGNoKC8haW1wb3J0YW50JC8pICE9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGltcG9ydGFudCAmJiAhb3B0aW9ucy5wcmVzZXJ2ZUltcG9ydGFudCkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHMqIWltcG9ydGFudCQvLCAnJyk7XG4gICAgICAgICAgICAvLyBhZGRzIGxpbmUgbnVtYmVyIGFuZCBjb2x1bW4gbnVtYmVyIGZvciB0aGUgcHJvcGVydGllcyBhcyBcImFkZGl0aW9uYWxQcmlvcml0eVwiIHRvIHRoZSBcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgYmVjYXVzZSBpbiBDU1MgdGhlIHBvc2l0aW9uIGRpcmVjdGx5IGFmZmVjdCB0aGUgcHJpb3JpdHkuXG4gICAgICAgICAgICB2YXIgYWRkaXRpb25hbFByaW9yaXR5ID0gW3N0eWxlW2ldLnBvc2l0aW9uLnN0YXJ0LmxpbmUsIHN0eWxlW2ldLnBvc2l0aW9uLnN0YXJ0LmNvbF07XG4gICAgICAgICAgICB2YXIgcHJvcCA9IG5ldyB1dGlscy5Qcm9wZXJ0eShuYW1lLCB2YWx1ZSwgc2VsZWN0b3IsIGltcG9ydGFudCA/IDIgOiAwLCBhZGRpdGlvbmFsUHJpb3JpdHkpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gZWwuc3R5bGVQcm9wc1tuYW1lXTtcblxuICAgICAgICAgICAgLy8gaWYgcHJvcGVydHkgbmFtZSBpcyBub3QgaW4gdGhlIGV4Y2x1ZGVkIHByb3BlcnRpZXMgYXJyYXlcbiAgICAgICAgICAgIGlmIChqdWljZUNsaWVudC5leGNsdWRlZFByb3BlcnRpZXMuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nLmNvbXBhcmUocHJvcCkgPT09IHByb3AgfHwgIWV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRpbmcgYSBwcm9wZXJ0eSBsZXQgdXMgY2hhbmdlIHRoZSBvcmRlciAobW92ZSBpdCB0byB0aGUgZW5kIGluIHRoZSBzZXRTdHlsZUF0dHJzIGxvb3ApXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nLnNlbGVjdG9yICE9PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsLnN0eWxlUHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgLy8gbWFrZSBcInByb3BcIiBhIHNwZWNpYWwgY29tcG9zZWQgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICBwcm9wLm5leHRQcm9wID0gZXhpc3Rpbmc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuc3R5bGVQcm9wc1tuYW1lXSA9IHByb3A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWRkUHJvcHMoc3R5bGUsIHNlbGVjdG9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFN0eWxlQXR0cnMoZWwpIHtcbiAgICB2YXIgbCA9IE9iamVjdC5rZXlzKGVsLnN0eWxlUHJvcHMpLmxlbmd0aDtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICAvLyBIZXJlIHdlIGxvb3AgZWFjaCBwcm9wZXJ0eSBhbmQgbWFrZSBzdXJlIHRvIFwiZXhwYW5kXCJcbiAgICAvLyBsaW5rZWQgXCJuZXh0UHJvcFwiIHByb3BlcnRpZXMgaGFwcGVuaW5nIHdoZW4gdGhlIHNhbWUgcHJvcGVydHlcbiAgICAvLyBpcyBkZWNsYXJlZCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSBzZWxlY3Rvci5cbiAgICBPYmplY3Qua2V5cyhlbC5zdHlsZVByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG5wID0gZWwuc3R5bGVQcm9wc1trZXldO1xuICAgICAgd2hpbGUgKHR5cGVvZiBucCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvcHMucHVzaChucCk7XG4gICAgICAgIG5wID0gbnAubmV4dFByb3A7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gc29ydCBwcm9wZXJ0aWVzIGJ5IHRoZWlyIG9yaWdpbmF0aW5nIHNlbGVjdG9yJ3Mgc3BlY2lmaWNpdHkgc28gdGhhdFxuICAgIC8vIHByb3BzIGxpa2UgXCJwYWRkaW5nXCIgYW5kIFwicGFkZGluZy1ib3R0b21cIiBhcmUgcmVzb2x2ZWQgYXMgZXhwZWN0ZWQuXG4gICAgcHJvcHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYS5jb21wYXJlRnVuYyhiKTtcbiAgICB9KTtcbiAgICB2YXIgc3RyaW5nID0gcHJvcHNcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAvLyBDb250ZW50IGJlY29tZXMgdGhlIGlubmVySFRNTCBvZiBwc2V1ZG8gZWxlbWVudHMsIG5vdCB1c2VkIGFzIGFcbiAgICAgICAgLy8gc3R5bGUgcHJvcGVydHlcbiAgICAgICAgcmV0dXJuIHByb3AucHJvcCAhPT0gJ2NvbnRlbnQnO1xuICAgICAgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcC5wcm9wICsgJzogJyArIHByb3AudmFsdWUucmVwbGFjZSgvW1wiXS9nLCAnXFwnJykgKyAnOyc7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJyAnKTtcbiAgICBpZiAoc3RyaW5nKSB7XG4gICAgICAkKGVsKS5hdHRyKHN0eWxlQXR0cmlidXRlTmFtZSwgc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmxpbmVQc2V1ZG9FbGVtZW50cyhlbCkge1xuICAgIGlmIChlbC5wc2V1ZG9FbGVtZW50VHlwZSAmJiBlbC5zdHlsZVByb3BzLmNvbnRlbnQpIHtcbiAgICAgICQoZWwpLmh0bWwocGFyc2VDb250ZW50KGVsLnN0eWxlUHJvcHMuY29udGVudC52YWx1ZSkpO1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBzZXVkb0VsZW1lbnRQYXJlbnQ7XG4gICAgICBpZiAoZWwucHNldWRvRWxlbWVudFR5cGUgPT09ICdiZWZvcmUnKSB7XG4gICAgICAgICQocGFyZW50KS5wcmVwZW5kKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQocGFyZW50KS5hcHBlbmQoZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERpbWVuc2lvbkF0dHJzKGVsLCBkaW1lbnNpb24pIHtcbiAgICBpZiAoIWVsLm5hbWUpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGVsTmFtZSA9IGVsLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoanVpY2VDbGllbnRbZGltZW5zaW9uICsgJ0VsZW1lbnRzJ10uaW5kZXhPZihlbE5hbWUpID4gLTEpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gZWwuc3R5bGVQcm9wcykge1xuICAgICAgICBpZiAoZWwuc3R5bGVQcm9wc1tpXS5wcm9wID09PSBkaW1lbnNpb24pIHtcbiAgICAgICAgICBpZiAoZWwuc3R5bGVQcm9wc1tpXS52YWx1ZS5tYXRjaCgvcHgvKSkge1xuICAgICAgICAgICAgdmFyIHB4U2l6ZSA9IGVsLnN0eWxlUHJvcHNbaV0udmFsdWUucmVwbGFjZSgncHgnLCAnJyk7XG4gICAgICAgICAgICAkKGVsKS5hdHRyKGRpbWVuc2lvbiwgcHhTaXplKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGp1aWNlQ2xpZW50LnRhYmxlRWxlbWVudHMuaW5kZXhPZihlbE5hbWUpID4gLTEgJiYgZWwuc3R5bGVQcm9wc1tpXS52YWx1ZS5tYXRjaCgvXFwlLykpIHtcbiAgICAgICAgICAgICQoZWwpLmF0dHIoZGltZW5zaW9uLCBlbC5zdHlsZVByb3BzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzT25UYWJsZUVsZW1lbnRzKGVsKSB7XG4gICAgaWYgKCFlbC5uYW1lKSB7IHJldHVybjsgfVxuICAgIHZhciBlbE5hbWUgPSBlbC5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIHN0eWxlUHJvcHMgPSBPYmplY3Qua2V5cyhqdWljZUNsaWVudC5zdHlsZVRvQXR0cmlidXRlKTtcblxuICAgIGlmIChqdWljZUNsaWVudC50YWJsZUVsZW1lbnRzLmluZGV4T2YoZWxOYW1lKSA+IC0xKSB7XG4gICAgICBmb3IgKHZhciBpIGluIGVsLnN0eWxlUHJvcHMpIHtcbiAgICAgICAgaWYgKHN0eWxlUHJvcHMuaW5kZXhPZihlbC5zdHlsZVByb3BzW2ldLnByb3ApID4gLTEpIHtcbiAgICAgICAgICAkKGVsKS5hdHRyKGp1aWNlQ2xpZW50LnN0eWxlVG9BdHRyaWJ1dGVbZWwuc3R5bGVQcm9wc1tpXS5wcm9wXSwgZWwuc3R5bGVQcm9wc1tpXS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDb250ZW50KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgPT09ICdub25lJyB8fCBjb250ZW50ID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIE5haXZlIHBhcnNpbmcsIGFzc3VtZSB3ZWxsLWZvcm1lZCB2YWx1ZVxuICBjb250ZW50ID0gY29udGVudC5zbGljZSgxLCBjb250ZW50Lmxlbmd0aCAtIDEpO1xuICAvLyBOYWl2ZSB1bmVzY2FwZSwgYXNzdW1lIG5vIHVuaWNvZGUgY2hhciBjb2Rlc1xuICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8vIFJldHVybiBcImJlZm9yZVwiIG9yIFwiYWZ0ZXJcIiBpZiB0aGUgZ2l2ZW4gc2VsZWN0b3IgaXMgYSBwc2V1ZG8gZWxlbWVudCAoZS5nLixcbi8vIGE6OmFmdGVyKS5cbmZ1bmN0aW9uIGdldFBzZXVkb0VsZW1lbnRUeXBlKHNlbGVjdG9yKSB7XG4gIGlmIChzZWxlY3Rvci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHNldWRvcyA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdLnBzZXVkb3M7XG4gIGlmICghcHNldWRvcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHNldWRvcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc1BzZXVkb0VsZW1lbnROYW1lKHBzZXVkb3NbaV0pKSB7XG4gICAgICByZXR1cm4gcHNldWRvc1tpXS5uYW1lO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BzZXVkb0VsZW1lbnROYW1lKHBzZXVkbykge1xuICByZXR1cm4gcHNldWRvLm5hbWUgPT09ICdiZWZvcmUnIHx8IHBzZXVkby5uYW1lID09PSAnYWZ0ZXInO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJFbGVtZW50UHNldWRvcyhwc2V1ZG9zKSB7XG4gIHJldHVybiBwc2V1ZG9zLmZpbHRlcihmdW5jdGlvbihwc2V1ZG8pIHtcbiAgICByZXR1cm4gIWlzUHNldWRvRWxlbWVudE5hbWUocHNldWRvKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGp1aWNlRG9jdW1lbnQoJCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gdXRpbHMuZ2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucyk7XG4gIHZhciBjc3MgPSBleHRyYWN0Q3NzRnJvbURvY3VtZW50KCQsIG9wdGlvbnMpO1xuICBjc3MgKz0gJ1xcbicgKyBvcHRpb25zLmV4dHJhQ3NzO1xuICBpbmxpbmVEb2N1bWVudCgkLCBjc3MsIG9wdGlvbnMpO1xuICByZXR1cm4gJDtcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGVzRGF0YSgkLCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBzdHlsZXNMaXN0ID0gJCgnc3R5bGUnKTtcbiAgdmFyIHN0eWxlRGF0YUxpc3QsIHN0eWxlRGF0YSwgc3R5bGVFbGVtZW50O1xuICBzdHlsZXNMaXN0LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgc3R5bGVFbGVtZW50ID0gdGhpcztcbiAgICBzdHlsZURhdGFMaXN0ID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgaWYgKHN0eWxlRGF0YUxpc3QubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0eWxlRGF0YSA9IHN0eWxlRGF0YUxpc3RbMF0uZGF0YTtcbiAgICBpZiAob3B0aW9ucy5hcHBseVN0eWxlVGFncyAmJiAkKHN0eWxlRWxlbWVudCkuYXR0cignZGF0YS1lbWJlZCcpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdHMucHVzaChzdHlsZURhdGEpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZW1vdmVTdHlsZVRhZ3MgJiYgJChzdHlsZUVsZW1lbnQpLmF0dHIoJ2RhdGEtZW1iZWQnKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcHJlc2VydmVkVGV4dCA9IHV0aWxzLmdldFByZXNlcnZlZFRleHQoc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlLCB7XG4gICAgICAgIG1lZGlhUXVlcmllczogb3B0aW9ucy5wcmVzZXJ2ZU1lZGlhUXVlcmllcyxcbiAgICAgICAgZm9udEZhY2VzOiBvcHRpb25zLnByZXNlcnZlRm9udEZhY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChwcmVzZXJ2ZWRUZXh0KSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IHByZXNlcnZlZFRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkKHN0eWxlRWxlbWVudCkucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgICQoc3R5bGVFbGVtZW50KS5yZW1vdmVBdHRyKCdkYXRhLWVtYmVkJyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gZXh0cmFjdENzc0Zyb21Eb2N1bWVudCgkLCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHRzID0gZ2V0U3R5bGVzRGF0YSgkLCBvcHRpb25zKTtcbiAgdmFyIGNzcyA9IHJlc3VsdHMuam9pbignXFxuJyk7XG4gIHJldHVybiBjc3M7XG59XG5cbnJldHVybiBqdWljZUNsaWVudDtcblxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFByb3BlcnR5O1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0eSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtTZWxlY3Rvcn0gc2VsZWN0b3IgdGhlIHByb3BlcnR5IG9yaWdpbmF0ZXMgZnJvbVxuICogQHBhcmFtIHtJbnRlZ2VyfSBwcmlvcml0eSAwIGZvciBub3JtYWwgcHJvcGVydGllcywgMiBmb3IgIWltcG9ydGFudCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtBcnJheX0gYWRkaXRpb25hbCBhcnJheSBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgbW9yZSBkZXRhaWxlZCBwcmlvcml0aWVzIChzb3J0aW5nKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBQcm9wZXJ0eShwcm9wLCB2YWx1ZSwgc2VsZWN0b3IsIHByaW9yaXR5LCBhZGRpdGlvbmFsUHJpb3JpdHkpIHtcbiAgdGhpcy5wcm9wID0gcHJvcDtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuICB0aGlzLmFkZGl0aW9uYWxQcmlvcml0eSA9IGFkZGl0aW9uYWxQcmlvcml0eSB8fCBbXTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB3aXRoIGFub3RoZXIgUHJvcGVydHkgYmFzZWQgb24gU2VsZWN0b3Ijc3BlY2lmaWNpdHkuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUuY29tcGFyZUZ1bmMgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICB2YXIgYSA9IFtdO1xuICBhLnB1c2guYXBwbHkoYSwgdGhpcy5zZWxlY3Rvci5zcGVjaWZpY2l0eSgpKTtcbiAgYS5wdXNoLmFwcGx5KGEsIHRoaXMuYWRkaXRpb25hbFByaW9yaXR5KTtcbiAgYVswXSArPSB0aGlzLnByaW9yaXR5O1xuICB2YXIgYiA9IFtdO1xuICBiLnB1c2guYXBwbHkoYiwgcHJvcGVydHkuc2VsZWN0b3Iuc3BlY2lmaWNpdHkoKSk7XG4gIGIucHVzaC5hcHBseShiLCBwcm9wZXJ0eS5hZGRpdGlvbmFsUHJpb3JpdHkpO1xuICBiWzBdICs9IHByb3BlcnR5LnByaW9yaXR5O1xuICByZXR1cm4gdXRpbHMuY29tcGFyZUZ1bmMoYSwgYik7XG59O1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gIHZhciB3aW5uZXIgPSB0aGlzLmNvbXBhcmVGdW5jKHByb3BlcnR5KTtcbiAgaWYgKHdpbm5lciA9PT0gMSkgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBwcm9wZXJ0eTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIENTUyBwcm9wZXJ0eVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUHJvcGVydHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnByb3AgKyAnOiAnICsgdGhpcy52YWx1ZS5yZXBsYWNlKC9bJ1wiXSsvZywgJycpICsgJzsnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlciA9IHJlcXVpcmUoXCIuLy4uLy4uL3NsaWNrL2Rpc3Qvc2xpY2suanNcIikucGFyc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNlbGVjdG9yO1xuXG4vKipcbiAqIENTUyBzZWxlY3RvciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgdGV4dFxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9uYWxseSwgcHJlY2FsY3VsYXRlZCBzcGVjaWZpY2l0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTZWxlY3Rvcih0ZXh0LCBzdHlsZUF0dHJpYnV0ZSkge1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLnNwZWMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuc3R5bGVBdHRyaWJ1dGUgPSBzdHlsZUF0dHJpYnV0ZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgcGFyc2VkIHNlbGVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2VsZWN0b3IucHJvdG90eXBlLnBhcnNlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudG9rZW5zKSB7IHRoaXMudG9rZW5zID0gcGFyc2UodGhpcy50ZXh0KTsgfVxuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIExhenkgc3BlY2lmaWNpdHkgZ2V0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TZWxlY3Rvci5wcm90b3R5cGUuc3BlY2lmaWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlQXR0cmlidXRlID0gdGhpcy5zdHlsZUF0dHJpYnV0ZTtcbiAgaWYgKCF0aGlzLnNwZWMpIHsgdGhpcy5zcGVjID0gc3BlY2lmaWNpdHkodGhpcy50ZXh0LCB0aGlzLnBhcnNlZCgpKTsgfVxuICByZXR1cm4gdGhpcy5zcGVjO1xuXG4gIGZ1bmN0aW9uIHNwZWNpZmljaXR5KHRleHQsIHBhcnNlZCkge1xuICAgIHZhciBleHByZXNzaW9ucyA9IHBhcnNlZCB8fCBwYXJzZSh0ZXh0KTtcbiAgICB2YXIgc3BlYyA9IFtzdHlsZUF0dHJpYnV0ZSA/IDEgOiAwLCAwLCAwLCAwXTtcbiAgICB2YXIgbm90cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1tpXTtcbiAgICAgIHZhciBwc2V1ZG9zID0gZXhwcmVzc2lvbi5wc2V1ZG9zO1xuXG4gICAgICAvLyBpZCBhd2FyZHMgYSBwb2ludCBpbiB0aGUgc2Vjb25kIGNvbHVtblxuICAgICAgaWYgKGV4cHJlc3Npb24uaWQpIHsgc3BlY1sxXSsrOyB9XG5cbiAgICAgIC8vIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZXMgYXdhcmQgYSBwb2ludCBlYWNoIGluIHRoZSB0aGlyZCBjb2x1bW5cbiAgICAgIGlmIChleHByZXNzaW9uLmF0dHJpYnV0ZXMpIHsgc3BlY1syXSArPSBleHByZXNzaW9uLmF0dHJpYnV0ZXMubGVuZ3RoOyB9XG4gICAgICBpZiAoZXhwcmVzc2lvbi5jbGFzc0xpc3QpIHsgc3BlY1syXSArPSBleHByZXNzaW9uLmNsYXNzTGlzdC5sZW5ndGg7IH1cblxuICAgICAgLy8gdGFnIGF3YXJkcyBhIHBvaW50IGluIHRoZSBmb3VydGggY29sdW1uXG4gICAgICBpZiAoZXhwcmVzc2lvbi50YWcgJiYgZXhwcmVzc2lvbi50YWcgIT09ICcqJykgeyBzcGVjWzNdKys7IH1cblxuICAgICAgLy8gcHNldWRvcyBhd2FyZCBhIHBvaW50IGVhY2ggaW4gdGhlIGZvdXJ0aCBjb2x1bW5cbiAgICAgIGlmIChwc2V1ZG9zKSB7XG4gICAgICAgIHNwZWNbM10gKz0gcHNldWRvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwc2V1ZG9zLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgaWYgKHBzZXVkb3NbcF0ubmFtZSA9PT0gJ25vdCcpIHtcbiAgICAgICAgICAgIG5vdHMucHVzaChwc2V1ZG9zW3BdLnZhbHVlKTtcbiAgICAgICAgICAgIHNwZWNbM10tLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpaSA9IG5vdHMubGVuZ3RoOyBpaS0tOykge1xuICAgICAgdmFyIG5vdCA9IHNwZWNpZmljaXR5KG5vdHNbaWldKTtcbiAgICAgIGZvciAodmFyIGpqID0gNDsgamotLTspIHsgc3BlY1tqal0gKz0gbm90W2pqXTsgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGVjO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNlbGVjdG9yIGFuZCByZXR1cm5zIHRoZSB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UodGV4dCkge1xuICB0cnkge1xuICAgIHJldHVybiBwYXJzZXIodGV4dClbMF07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBtZW5zY2ggPSByZXF1aXJlKFwiLi8uLi8uLi9tZW5zY2gvaW5kZXguanNcIik7XG52YXIgb3duID0ge30uaGFzT3duUHJvcGVydHk7XG52YXIgb3MgPSByZXF1aXJlKCdvcycpO1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSgnLi9zZWxlY3RvcicpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG5leHBvcnRzLlNlbGVjdG9yID0gU2VsZWN0b3I7XG5leHBvcnRzLlByb3BlcnR5ID0gUHJvcGVydHk7XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgc2VsZWN0b3JzLlxuICpcbiAqIEBsaWNlbnNlIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIC0gTUlUXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JUZXh0IGZyb20gbWVuc2NoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZXh0cmFjdCA9IGZ1bmN0aW9uIGV4dHJhY3Qoc2VsZWN0b3JUZXh0KSB7XG4gIHZhciBhdHRyID0gMDtcbiAgdmFyIHNlbHMgPSBbXTtcbiAgdmFyIHNlbCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZWN0b3JUZXh0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjID0gc2VsZWN0b3JUZXh0LmNoYXJBdChpKTtcblxuICAgIGlmIChhdHRyKSB7XG4gICAgICBpZiAoJ10nID09PSBjIHx8ICcpJyA9PT0gYykgeyBhdHRyLS07IH1cbiAgICAgIHNlbCArPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJywnID09PSBjKSB7XG4gICAgICAgIHNlbHMucHVzaChzZWwpO1xuICAgICAgICBzZWwgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgnWycgPT09IGMgfHwgJygnID09PSBjKSB7IGF0dHIrKzsgfVxuICAgICAgICBpZiAoc2VsLmxlbmd0aCB8fCAoYyAhPT0gJywnICYmIGMgIT09ICdcXG4nICYmIGMgIT09ICcgJykpIHsgc2VsICs9IGM7IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsLmxlbmd0aCkge1xuICAgIHNlbHMucHVzaChzZWwpO1xuICB9XG5cbiAgcmV0dXJuIHNlbHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwYXJzZSB0cmVlIGZvciBhIENTUyBzb3VyY2UuXG4gKiBJZiBpdCBlbmNvdW50ZXJzIG11bHRpcGxlIHNlbGVjdG9ycyBzZXBhcmF0ZWQgYnkgYSBjb21tYSwgaXQgc3BsaXRzIHRoZVxuICogdHJlZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzIHNvdXJjZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlQ1NTID0gZnVuY3Rpb24oY3NzKSB7XG4gIHZhciBwYXJzZWQgPSBtZW5zY2gucGFyc2UoY3NzLCB7cG9zaXRpb246IHRydWUsIGNvbW1lbnRzOiB0cnVlfSk7XG4gIHZhciBydWxlcyA9IHR5cGVvZiBwYXJzZWQuc3R5bGVzaGVldCAhPSAndW5kZWZpbmVkJyAmJiBwYXJzZWQuc3R5bGVzaGVldC5ydWxlcyA/IHBhcnNlZC5zdHlsZXNoZWV0LnJ1bGVzIDogW107XG4gIHZhciByZXQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChydWxlc1tpXS50eXBlID09ICdydWxlJykge1xuICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXTtcbiAgICAgIHZhciBzZWxlY3RvcnMgPSBydWxlLnNlbGVjdG9ycztcblxuICAgICAgZm9yICh2YXIgaWkgPSAwLCBsbCA9IHNlbGVjdG9ycy5sZW5ndGg7IGlpIDwgbGw7IGlpKyspIHtcbiAgICAgICAgcmV0LnB1c2goW3NlbGVjdG9yc1tpaV0sIHJ1bGUuZGVjbGFyYXRpb25zXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBwcmVzZXJ2ZWQgdGV4dCBmb3IgYSBDU1Mgc291cmNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3Mgc291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmdldFByZXNlcnZlZFRleHQgPSBmdW5jdGlvbihjc3MsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlZCA9IG1lbnNjaC5wYXJzZShjc3MsIHtwb3NpdGlvbjogdHJ1ZSwgY29tbWVudHM6IHRydWV9KTtcbiAgdmFyIHJ1bGVzID0gdHlwZW9mIHBhcnNlZC5zdHlsZXNoZWV0ICE9ICd1bmRlZmluZWQnICYmIHBhcnNlZC5zdHlsZXNoZWV0LnJ1bGVzID8gcGFyc2VkLnN0eWxlc2hlZXQucnVsZXMgOiBbXTtcbiAgdmFyIHByZXNlcnZlZCA9IFtdO1xuICB2YXIgbGFzdFN0YXJ0ID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gcnVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG9wdGlvbnMuZm9udEZhY2VzICYmIHJ1bGVzW2ldLnR5cGUgPT09ICdmb250LWZhY2UnKSB8fFxuICAgICAgICAob3B0aW9ucy5tZWRpYVF1ZXJpZXMgJiYgcnVsZXNbaV0udHlwZSA9PT0gJ21lZGlhJykpIHtcbiAgICAgIHByZXNlcnZlZC5wdXNoKFxuICAgICAgICBtZW5zY2guc3RyaW5naWZ5KFxuICAgICAgICAgIHsgc3R5bGVzaGVldDogeyBydWxlczogWyBydWxlc1tpXSBdIH19LCBcbiAgICAgICAgICB7IGNvbW1lbnRzOiBmYWxzZSwgaW5kZW50YXRpb246ICcgICcgfVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBsYXN0U3RhcnQgPSBydWxlc1tpXS5wb3NpdGlvbi5zdGFydDtcbiAgfVxuXG4gIGlmIChwcmVzZXJ2ZWQubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcy5FT0wrcHJlc2VydmVkLmpvaW4ob3MuRU9MKStvcy5FT0w7XG59O1xuXG5leHBvcnRzLm5vcm1hbGl6ZUxpbmVFbmRpbmdzID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcbi9nLCAnXFxyXFxuJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIHNwZWNpZmljaXR5IHZlY3RvcnMsIHJldHVybmluZyB0aGUgd2lubmluZyBvbmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVjdG9yIGFcbiAqIEBwYXJhbSB7QXJyYXl9IHZlY3RvciBiXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb21wYXJlRnVuYyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIG1pbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICBpZiAoYVtpXSA9PT0gYltpXSkgeyBjb250aW51ZTsgfVxuICAgIGlmIChhW2ldID4gYltpXSkgeyByZXR1cm4gMTsgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBhLmxlbmd0aC1iLmxlbmd0aDtcbn07XG5cbmV4cG9ydHMuY29tcGFyZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZUZ1bmMoYSwgYikgPT0gMSA/IGEgOiBiO1xufTtcblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbihvYmosIHNyYykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKG93bi5jYWxsKHNyYywga2V5KSkge1xuICAgICAgb2JqW2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydHMuZ2V0RGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSBleHBvcnRzLmV4dGVuZCh7XG4gICAgZXh0cmFDc3M6ICcnLFxuICAgIGluc2VydFByZXNlcnZlZEV4dHJhQ3NzOiB0cnVlLFxuICAgIGFwcGx5U3R5bGVUYWdzOiB0cnVlLFxuICAgIHJlbW92ZVN0eWxlVGFnczogdHJ1ZSxcbiAgICBwcmVzZXJ2ZU1lZGlhUXVlcmllczogdHJ1ZSxcbiAgICBwcmVzZXJ2ZUZvbnRGYWNlczogdHJ1ZSxcbiAgICBhcHBseVdpZHRoQXR0cmlidXRlczogdHJ1ZSxcbiAgICBhcHBseUhlaWdodEF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXBwbHlBdHRyaWJ1dGVzVGFibGVFbGVtZW50czogdHJ1ZSxcbiAgICB1cmw6ICcnXG4gIH0sIG9wdGlvbnMpO1xuXG4gIHJlc3VsdC53ZWJSZXNvdXJjZXMgPSByZXN1bHQud2ViUmVzb3VyY2VzIHx8IHt9O1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8ga25vY2tvdXQtc29ydGFibGUgMC4xMS4wIHwgKGMpIDIwMTUgUnlhbiBOaWVtZXllciB8ICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4hZnVuY3Rpb24oYSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXCJrbm9ja291dFwiLFwianF1ZXJ5XCIsXCJqcXVlcnktdWkvc29ydGFibGVcIixcImpxdWVyeS11aS9kcmFnZ2FibGVcIl0sYSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSl7dmFyIGI9KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCksYz0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpOyh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXVsndWknXVsnc29ydGFibGUnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddWyd1aSddWydzb3J0YWJsZSddIDogbnVsbCksKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddWyd1aSddWydkcmFnZ2FibGUnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddWyd1aSddWydkcmFnZ2FibGUnXSA6IG51bGwpLGEoYixjKX1lbHNlIGEod2luZG93LmtvLHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhLGIpe3ZhciBjPVwia29fc29ydEl0ZW1cIixkPVwia29fc291cmNlSW5kZXhcIixlPVwia29fc29ydExpc3RcIixmPVwia29fcGFyZW50TGlzdFwiLGc9XCJrb19kcmFnSXRlbVwiLGg9YS51dGlscy51bndyYXBPYnNlcnZhYmxlLGk9YS51dGlscy5kb21EYXRhLmdldCxqPWEudXRpbHMuZG9tRGF0YS5zZXQsaz1iLnVpJiZiLnVpLnZlcnNpb24sbD1rJiZrLmluZGV4T2YoXCIxLjYuXCIpJiZrLmluZGV4T2YoXCIxLjcuXCIpJiYoay5pbmRleE9mKFwiMS44LlwiKXx8XCIxLjguMjRcIj09PWspLG09ZnVuY3Rpb24oYixkKXthLnV0aWxzLmFycmF5Rm9yRWFjaChiLGZ1bmN0aW9uKGEpezE9PT1hLm5vZGVUeXBlJiYoaihhLGMsZCksaihhLGYsaShhLnBhcmVudE5vZGUsZSkpKX0pfSxuPWZ1bmN0aW9uKGIsYyl7dmFyIGQsZT17fSxmPWgoYigpKXx8e307cmV0dXJuIGYuZGF0YT8oZVtjXT1mLmRhdGEsZS5uYW1lPWYudGVtcGxhdGUpOmVbY109YigpLGEudXRpbHMuYXJyYXlGb3JFYWNoKFtcImFmdGVyQWRkXCIsXCJhZnRlclJlbmRlclwiLFwiYXNcIixcImJlZm9yZVJlbW92ZVwiLFwiaW5jbHVkZURlc3Ryb3llZFwiLFwidGVtcGxhdGVFbmdpbmVcIixcInRlbXBsYXRlT3B0aW9uc1wiLFwibm9kZXNcIl0sZnVuY3Rpb24oYil7Zi5oYXNPd25Qcm9wZXJ0eShiKT9lW2JdPWZbYl06YS5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGUuaGFzT3duUHJvcGVydHkoYikmJihlW2JdPWEuYmluZGluZ0hhbmRsZXJzLnNvcnRhYmxlW2JdKX0pLFwiZm9yZWFjaFwiPT09YyYmKGUuYWZ0ZXJSZW5kZXI/KGQ9ZS5hZnRlclJlbmRlcixlLmFmdGVyUmVuZGVyPWZ1bmN0aW9uKGEsYil7bS5jYWxsKGIsYSxiKSxkLmNhbGwoYixhLGIpfSk6ZS5hZnRlclJlbmRlcj1tKSxlfSxvPWZ1bmN0aW9uKGEsYil7dmFyIGM9aChiKTtpZihjKWZvcih2YXIgZD0wO2E+ZDtkKyspY1tkXSYmaChjW2RdLl9kZXN0cm95KSYmYSsrO3JldHVybiBhfSxwPWZ1bmN0aW9uKGMsZCl7dmFyIGUsZjtkPyhmPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGQpLGYmJihlPW5ldyBhLnRlbXBsYXRlU291cmNlcy5kb21FbGVtZW50KGYpLGUudGV4dChiLnRyaW0oZS50ZXh0KCkpKSkpOmIoYykuY29udGVudHMoKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcyYmMSE9PXRoaXMubm9kZVR5cGUmJmMucmVtb3ZlQ2hpbGQodGhpcyl9KX07YS5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGU9e2luaXQ6ZnVuY3Rpb24oayxtLHEscixzKXt2YXIgdCx1LHY9YihrKSx3PWgobSgpKXx8e30seD1uKG0sXCJmb3JlYWNoXCIpLHk9e307cChrLHgubmFtZSksYi5leHRlbmQoITAseSxhLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZSksdy5vcHRpb25zJiZ5Lm9wdGlvbnMmJihhLnV0aWxzLmV4dGVuZCh5Lm9wdGlvbnMsdy5vcHRpb25zKSxkZWxldGUgdy5vcHRpb25zKSxhLnV0aWxzLmV4dGVuZCh5LHcpLHkuY29ubmVjdENsYXNzJiYoYS5pc09ic2VydmFibGUoeS5hbGxvd0Ryb3ApfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB5LmFsbG93RHJvcCk/YS5jb21wdXRlZCh7cmVhZDpmdW5jdGlvbigpe3ZhciBiPWgoeS5hbGxvd0Ryb3ApLGM9XCJmdW5jdGlvblwiPT10eXBlb2YgYj9iLmNhbGwodGhpcyx4LmZvcmVhY2gpOmI7YS51dGlscy50b2dnbGVEb21Ob2RlQ3NzQ2xhc3Moayx5LmNvbm5lY3RDbGFzcyxjKX0sZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOmt9LHRoaXMpOmEudXRpbHMudG9nZ2xlRG9tTm9kZUNzc0NsYXNzKGsseS5jb25uZWN0Q2xhc3MseS5hbGxvd0Ryb3ApLGEuYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLmluaXQoayxmdW5jdGlvbigpe3JldHVybiB4fSxxLHIscyksdD15Lm9wdGlvbnMuc3RhcnQsdT15Lm9wdGlvbnMudXBkYXRlO3ZhciB6PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgbTt2LnNvcnRhYmxlKGEudXRpbHMuZXh0ZW5kKHkub3B0aW9ucyx7c3RhcnQ6ZnVuY3Rpb24oYixjKXt2YXIgZT1jLml0ZW1bMF07aihlLGQsYS51dGlscy5hcnJheUluZGV4T2YoYy5pdGVtLnBhcmVudCgpLmNoaWxkcmVuKCksZSkpLGMuaXRlbS5maW5kKFwiaW5wdXQ6Zm9jdXNcIikuY2hhbmdlKCksdCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHJlY2VpdmU6ZnVuY3Rpb24oYSxiKXttPWkoYi5pdGVtWzBdLGcpLG0mJihtLmNsb25lJiYobT1tLmNsb25lKCkpLHkuZHJhZ2dlZCYmKG09eS5kcmFnZ2VkLmNhbGwodGhpcyxtLGEsYil8fG0pKX0sdXBkYXRlOmZ1bmN0aW9uKGcsaCl7dmFyIGssbixwLHEscixzPWguaXRlbVswXSx0PWguaXRlbS5wYXJlbnQoKVswXSx2PWkocyxjKXx8bTtpZihtPW51bGwsdiYmdGhpcz09PXR8fCFsJiZiLmNvbnRhaW5zKHRoaXMsdCkpe2lmKGs9aShzLGYpLHA9aShzLGQpLG49aShzLnBhcmVudE5vZGUsZSkscT1hLnV0aWxzLmFycmF5SW5kZXhPZihoLml0ZW0ucGFyZW50KCkuY2hpbGRyZW4oKSxzKSx4LmluY2x1ZGVEZXN0cm95ZWR8fChwPW8ocCxrKSxxPW8ocSxuKSksKHkuYmVmb3JlTW92ZXx8eS5hZnRlck1vdmUpJiYocj17aXRlbTp2LHNvdXJjZVBhcmVudDprLHNvdXJjZVBhcmVudE5vZGU6ayYmaC5zZW5kZXJ8fHMucGFyZW50Tm9kZSxzb3VyY2VJbmRleDpwLHRhcmdldFBhcmVudDpuLHRhcmdldEluZGV4OnEsY2FuY2VsRHJvcDohMX0seS5iZWZvcmVNb3ZlJiZ5LmJlZm9yZU1vdmUuY2FsbCh0aGlzLHIsZyxoKSksaz9iKGs9PT1uP3RoaXM6aC5zZW5kZXJ8fHRoaXMpLnNvcnRhYmxlKFwiY2FuY2VsXCIpOmIocykucmVtb3ZlKCksciYmci5jYW5jZWxEcm9wKXJldHVybjtxPj0wJiYoayYmKGsuc3BsaWNlKHAsMSksYS5wcm9jZXNzQWxsRGVmZXJyZWRCaW5kaW5nVXBkYXRlcyYmYS5wcm9jZXNzQWxsRGVmZXJyZWRCaW5kaW5nVXBkYXRlcygpKSxuLnNwbGljZShxLDAsdikpLGoocyxjLG51bGwpLGEucHJvY2Vzc0FsbERlZmVycmVkQmluZGluZ1VwZGF0ZXMmJmEucHJvY2Vzc0FsbERlZmVycmVkQmluZGluZ1VwZGF0ZXMoKSx5LmFmdGVyTW92ZSYmeS5hZnRlck1vdmUuY2FsbCh0aGlzLHIsZyxoKX11JiZ1LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sY29ubmVjdFdpdGg6eS5jb25uZWN0Q2xhc3M/XCIuXCIreS5jb25uZWN0Q2xhc3M6ITF9KSksdm9pZCAwIT09eS5pc0VuYWJsZWQmJmEuY29tcHV0ZWQoe3JlYWQ6ZnVuY3Rpb24oKXt2LnNvcnRhYmxlKGgoeS5pc0VuYWJsZWQpP1wiZW5hYmxlXCI6XCJkaXNhYmxlXCIpfSxkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6a30pfSwwKTtyZXR1cm4gYS51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGssZnVuY3Rpb24oKXsodi5kYXRhKFwidWktc29ydGFibGVcIil8fHYuZGF0YShcInNvcnRhYmxlXCIpKSYmdi5zb3J0YWJsZShcImRlc3Ryb3lcIiksYS51dGlscy50b2dnbGVEb21Ob2RlQ3NzQ2xhc3Moayx5LmNvbm5lY3RDbGFzcywhMSksY2xlYXJUaW1lb3V0KHopfSkse2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiEwfX0sdXBkYXRlOmZ1bmN0aW9uKGIsYyxkLGYsZyl7dmFyIGg9bihjLFwiZm9yZWFjaFwiKTtqKGIsZSxoLmZvcmVhY2gpLGEuYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLnVwZGF0ZShiLGZ1bmN0aW9uKCl7cmV0dXJuIGh9LGQsZixnKX0sY29ubmVjdENsYXNzOlwia29fY29udGFpbmVyXCIsYWxsb3dEcm9wOiEwLGFmdGVyTW92ZTpudWxsLGJlZm9yZU1vdmU6bnVsbCxvcHRpb25zOnt9fSxhLmJpbmRpbmdIYW5kbGVycy5kcmFnZ2FibGU9e2luaXQ6ZnVuY3Rpb24oYyxkLGUsZixpKXt2YXIgaz1oKGQoKSl8fHt9LGw9ay5vcHRpb25zfHx7fSxtPWEudXRpbHMuZXh0ZW5kKHt9LGEuYmluZGluZ0hhbmRsZXJzLmRyYWdnYWJsZS5vcHRpb25zKSxvPW4oZCxcImRhdGFcIikscD1rLmNvbm5lY3RDbGFzc3x8YS5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLmNvbm5lY3RDbGFzcyxxPXZvaWQgMCE9PWsuaXNFbmFibGVkP2suaXNFbmFibGVkOmEuYmluZGluZ0hhbmRsZXJzLmRyYWdnYWJsZS5pc0VuYWJsZWQ7cmV0dXJuIGs9XCJkYXRhXCJpbiBrP2suZGF0YTprLGooYyxnLGspLGEudXRpbHMuZXh0ZW5kKG0sbCksbS5jb25uZWN0VG9Tb3J0YWJsZT1wP1wiLlwiK3A6ITEsYihjKS5kcmFnZ2FibGUobSksdm9pZCAwIT09cSYmYS5jb21wdXRlZCh7cmVhZDpmdW5jdGlvbigpe2IoYykuZHJhZ2dhYmxlKGgocSk/XCJlbmFibGVcIjpcImRpc2FibGVcIil9LGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDpjfSksYS51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGMsZnVuY3Rpb24oKXtiKGMpLmRyYWdnYWJsZShcImRlc3Ryb3lcIil9KSxhLmJpbmRpbmdIYW5kbGVycy50ZW1wbGF0ZS5pbml0KGMsZnVuY3Rpb24oKXtyZXR1cm4gb30sZSxmLGkpfSx1cGRhdGU6ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgZz1uKGMsXCJkYXRhXCIpO3JldHVybiBhLmJpbmRpbmdIYW5kbGVycy50ZW1wbGF0ZS51cGRhdGUoYixmdW5jdGlvbigpe3JldHVybiBnfSxkLGUsZil9LGNvbm5lY3RDbGFzczphLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZS5jb25uZWN0Q2xhc3Msb3B0aW9uczp7aGVscGVyOlwiY2xvbmVcIn19fSk7IiwiLy8gS25vY2tvdXQgVW5kb01hbmFnZXIgdjAuMiB8IChjKSAyMDE1IFN0ZWZhbm8gQmFnbmFyYVxuLy8gTGljZW5zZTogTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlKSBcbi8vIHJlcXVpcmVzIFwia28ud2F0Y2hcIiBtZXRob2QgZnJvbSBrbm9ja291dC5yZWFjdG9yXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgLy8gTW9kdWxlIHN5c3RlbXMgbWFnaWMgZGFuY2UuXG4gIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAvLyBDb21tb25KUyBvciBOb2RlOiBoYXJkLWNvZGVkIGRlcGVuZGVuY3kgb24gXCJrbm9ja291dFwiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpLCByZXF1aXJlKFwiLi8uLi9rbm9ja291dGpzLXJlYWN0b3Ivc3JjL2tub2Nrb3V0LnJlYWN0b3IuanNcIikpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmVbXCJhbWRcIl0pIHtcbiAgICAvLyBBTUQgYW5vbnltb3VzIG1vZHVsZSB3aXRoIGhhcmQtY29kZWQgZGVwZW5kZW5jeSBvbiBcImtub2Nrb3V0XCJcbiAgICBkZWZpbmUoW1wia25vY2tvdXRcIiwgXCJrbm9ja291dGpzLXJlYWN0b3JcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyA8c2NyaXB0PiB0YWc6IHVzZSB0aGUgZ2xvYmFsIGBrb2Agb2JqZWN0XG4gICAgZmFjdG9yeShrbywga28ud2F0Y2gpO1xuICB9XG59KGZ1bmN0aW9uIChrbywgcmVhY3RvcikgeyBcblxuICAvLy8gPHN1bW1hcnk+XG4gIC8vLyAgICAgVHJhY2sgbGFzdCBcImxldmVsc1wiIGNoYW5nZXMgd2l0aGluIHRoZSBjaGFpbmVkIG9ic2VydmFibGUgZG93biB0byBhbnkgZ2l2ZW4gbGV2ZWwgYW5kXG4gIC8vLyAgICAgc3VwcG9ydHMgdW5kb2luZy9yZWRvaW5nIHRoZSBjaGFuZ2VzLlxuICAvLy8gPC9zdW1tYXJ5PlxuICAvLy8gPHBhcmFtIG5hbWU9XCJvcHRpb25zXCIgdHlwZT1cIm9iamVjdFwiPlxuICAvLy8gICAgIHsgbGV2ZWxzOiAyIH0gLT4gUmVtZW1iZXIgb25seSBsYXN0IFwibGV2ZWxzXCIgY2hhbmdlczxici8+XG4gIC8vLyAgICAgeyB1bmRvTGFiZWw6IFwiVW5kbyBpdCAoI0NPVU5UKSFcIiB9IC0+IERlZmluZSBhIGxhYmVsIGZvciB0aGUgdW5kbyBjb21tYW5kLiBcIiNDT1VOVCNcIiBzZXF1ZW5jZSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHN0YWNrIGxlbmd0aC48YnIvPlxuICAvLy8gICAgIHsgcmVkb0xhYmVsOiBcIlJlZG8gaXQgKCNDT1VOVCkhXCIgfSAtPiBEZWZpbmUgYSBsYWJlbCBmb3IgdGhlIHJlZG8gY29tbWFuZC4gXCIjQ09VTlQjXCIgc2VxdWVuY2Ugd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBzdGFjayBsZW5ndGguPGJyLz5cbiAgLy8vIDwvcGFyYW0+XG4gIHZhciB1bmRvTWFuYWdlciA9IGZ1bmN0aW9uIChtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciB1bmRvU3RhY2sgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgICB2YXIgcmVkb1N0YWNrID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gICAgdmFyIGxhc3RQdXNoZWRTdGFjaztcbiAgICB2YXIgU1RBVEVfRE9JTkcgPSAwO1xuICAgIHZhciBTVEFURV9VTkRPSU5HID0gMTtcbiAgICB2YXIgU1RBVEVfUkVET0lORyA9IDI7XG4gICAgdmFyIHN0YXRlID0gU1RBVEVfRE9JTkc7XG5cbiAgICB2YXIgTU9ERV9OT1JNQUwgPSAwOyAvLyBhZGQgdG8gc3RhY2sgZXZlcnkgY2hhbmdlXG4gICAgdmFyIE1PREVfSUdOT1JFID0gMTsgLy8gZG8gbm90IGFkZCBhbnl0aGluZyB0byB0aGUgc3RhY2tcbiAgICB2YXIgTU9ERV9PTkNFID0gMjsgLy8gb25seSBvbmUgc2VxdWVudGlhbCBjaGFuZ2UgZm9yIGVhY2ggcHJvcGVydHkgaXMgYWRkZWQgdG8gdGhlIHN0YWNrXG4gICAgdmFyIE1PREVfTUVSR0UgPSAzOyAvLyBtZXJnZSBuZXh0IGNoYW5nZSB3aXRoIHRoZSBsYXN0IG9uZVxuICAgIHZhciBtb2RlID0gTU9ERV9OT1JNQUw7XG5cbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBsZXZlbHM6IDEwMCxcbiAgICAgIHVuZG9MYWJlbDogXCJ1bmRvICgjQ09VTlQjKVwiLFxuICAgICAgcmVkb0xhYmVsOiBcInJlZG8gKCNDT1VOVCMpXCJcbiAgICB9O1xuICAgIFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGtvLnV0aWxzLmV4dGVuZChkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG4gIFxuICAgIHZhciBfcHVzaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIC8vIGR1cmFudGUgVU5ETy9SRURPIGxhdm9yaWFtbyBzZW1wcmUgaW4gbm9ybWFsZVxuICAgICAgaWYgKHN0YXRlID09IFNUQVRFX1VORE9JTkcpIHtcbiAgICAgICAgX3B1c2hJbnQoYWN0aW9uLCByZWRvU3RhY2spO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBTVEFURV9SRURPSU5HKSB7XG4gICAgICAgIF9wdXNoSW50KGFjdGlvbiwgdW5kb1N0YWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gU1RBVEVfRE9JTkcpIHtcbiAgICAgICAgX3B1c2hJbnQoYWN0aW9uLCB1bmRvU3RhY2spO1xuICAgICAgICByZWRvU3RhY2sucmVtb3ZlQWxsKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgX3RyeU1lcmdlID0gZnVuY3Rpb24gKHByZXYsIG5ld0FjdGlvbikge1xuICAgICAgaWYgKHR5cGVvZiBwcmV2Lm1lcmdlZEFjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHByZXYubWVyZ2VkQWN0aW9uKG5ld0FjdGlvbik7XG4gICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBfcHVzaEludCA9IGZ1bmN0aW9uIChhY3Rpb24sIG15U3RhY2spIHtcbiAgICAgIC8qIGdlc3Rpb25lIGRlbCBtZXJnZSBkaSBhemlvbmk6IHNlIGwndWx0aW1hIGF6aW9uZSBuZWxsbyBzdGFjayBoYSB1biBtZXRvZG8gXCJtZXJnZWRBY3Rpb25cIlxuICAgICAgICAgcHJvdmlhbW8gYWQgaW52b2NhcmxvIGUgc2UgY2kgcmVzdGl0dWlzY2UgdW5hIGZ1bnppb25lIGxhIHVzaWFtbyBhbCBwb3N0byBkaSBlbnRyYW1iZSAqL1xuICAgICAgLy8gY29uc29sZS5sb2coXCJVUlwiLCBcIl9wdXNoSW50XCIsIG15U3RhY2soKS5sZW5ndGggPiAwID8gdHlwZW9mIG15U3RhY2soKVtteVN0YWNrKCkubGVuZ3RoIC0gMV0ubWVyZ2VkQWN0aW9uIDogXCJFTVBUWVwiKTtcbiAgICAgIGlmIChteVN0YWNrKCkubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbWVyZ2VkID0gX3RyeU1lcmdlKG15U3RhY2soKVtteVN0YWNrKCkubGVuZ3RoIC0gMV0sIGFjdGlvbik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVVJcIiwgXCJfcHVzaEludC5tZXJnZWRcIiwgbWVyZ2VkLCBcIk1WXCIsIHR5cGVvZiBhY3Rpb24ubWVyZ2VhYmxlTW92ZSwgXCJNQVwiLCB0eXBlb2YgYWN0aW9uLm1lcmdlYWJsZUFjdGlvbiwgXCJNTVwiLCB0eXBlb2YgYWN0aW9uLm1lcmdlTWUpO1xuICAgICAgICBpZiAobWVyZ2VkICE9PSBudWxsKSB7XG4gICAgICAgICAgbXlTdGFjaygpW215U3RhY2soKS5sZW5ndGggLSAxXSA9IG1lcmdlZDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChteVN0YWNrKCkubGVuZ3RoID49IG9wdGlvbnMubGV2ZWxzKSBteVN0YWNrLnNoaWZ0KCk7XG4gICAgICBsYXN0UHVzaGVkU3RhY2sgPSBteVN0YWNrO1xuICAgICAgbXlTdGFjay5wdXNoKGFjdGlvbik7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgX3hkb0NvbW1hbmQgPSBmdW5jdGlvbihsYWJlbCwgd29ya1N0YXRlLCBzdGFjaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZToga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobGFiZWwpLnJlcGxhY2UoLyNDT1VOVCMvLCBzdGFjaygpLmxlbmd0aCk7XG4gICAgICAgIH0pLFxuICAgICAgICBlbmFibGVkOiBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2soKS5sZW5ndGggIT09IDA7XG4gICAgICAgIH0pLFxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYWN0aW9uID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgc3RhdGUgPSB3b3JrU3RhdGU7XG4gICAgICAgICAgICB2YXIgb2xkTW9kZSA9IG1vZGU7XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9NRVJHRTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiWERPXCIsIFwiYmVmb3JlXCIsIGxhYmVsKTtcbiAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJYRE9cIiwgXCJhZnRlclwiLCBsYWJlbCk7XG4gICAgICAgICAgICBfcmVtb3ZlTWVyZ2VkQWN0aW9uKGxhc3RQdXNoZWRTdGFjayk7XG4gICAgICAgICAgICBtb2RlID0gb2xkTW9kZTtcbiAgICAgICAgICAgIHN0YXRlID0gcHJldlN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF9yZW1vdmVNZXJnZWRBY3Rpb24gPSBmdW5jdGlvbihteVN0YWNrKSB7XG4gICAgICBpZiAodHlwZW9mIG15U3RhY2sgPT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiVW5leHBlY3RlZCBvcGVyYXRpb246IHN0YWNrIGNsZWFuZXIgY2FsbGVkIHdpdGggdW5kZWZpbmVkIHN0YWNrXCI7XG4gICAgICBcbiAgICAgIGlmIChteVN0YWNrKCkubGVuZ3RoID4gMCAmJiB0eXBlb2YgbXlTdGFjaygpW215U3RhY2soKS5sZW5ndGggLSAxXS5tZXJnZWRBY3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiUmVtb3ZpbmcgbWVyZ2VkQWN0aW9uIGZyb20gc3RhY2tcIik7XG4gICAgICAgIGRlbGV0ZSBteVN0YWNrKClbbXlTdGFjaygpLmxlbmd0aCAtIDFdLm1lcmdlZEFjdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9jb21iaW5lZEZ1bmN0aW9uID0gZnVuY3Rpb24oZmlyc3QsIHNlY29uZCkge1xuICAgICAgdmFyIHJlcyA9IChmdW5jdGlvbihmMSwgZjIpIHtcbiAgICAgICAgZjEoKTtcbiAgICAgICAgZjIoKTtcbiAgICAgIH0pLmJpbmQodW5kZWZpbmVkLCBmaXJzdCwgc2Vjb25kKTtcbiAgICAgIGlmICh0eXBlb2YgZmlyc3QubWVyZ2VkQWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXMubWVyZ2VkQWN0aW9uID0gZmlyc3QubWVyZ2VkQWN0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgdmFyIGV4ZWN1dGVVbmRvQWN0aW9uID0gZnVuY3Rpb24oY2hpbGQsIHZhbHVlLCBpdGVtKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImV4ZWN1dGVVbmRvQWN0aW9uXCIsIGNoaWxkLCB2YWx1ZSwgaXRlbSk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjaGlsZCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09ICdkZWxldGVkJykge1xuICAgICAgICAgIGNoaWxkLnNwbGljZShpdGVtLmluZGV4LCAwLCBpdGVtLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnN0YXR1cyA9PSAnYWRkZWQnKSB7XG4gICAgICAgICAgY2hpbGQuc3BsaWNlKGl0ZW0uaW5kZXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiVW5zdXBwcm90ZWQgaXRlbS5zdGF0dXM6IFwiK2l0ZW0uc3RhdHVzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgY29uZGl0aW9uOiBubyBpdGVtIGFuZCBubyBjaGlsZC5vbGRWYWx1ZXMhXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBtYWtlVW5kb0FjdGlvbkRlZmF1bHQgPSBmdW5jdGlvbih1bmRvRnVuYywgcGFyZW50cywgY2hpbGQsIG9sZFZhbCwgaXRlbSkge1xuICAgICAgcmV0dXJuIHVuZG9GdW5jLmJpbmQodW5kZWZpbmVkLCBjaGlsZCwgb2xkVmFsLCBpdGVtKTtcbiAgICB9O1xuXG4gICAgdmFyIG1ha2VVbmRvQWN0aW9uID0gbWFrZVVuZG9BY3Rpb25EZWZhdWx0O1xuXG4gICAgdmFyIGNoYW5nZVB1c2hlciA9IGZ1bmN0aW9uKHBhcmVudHMsIGNoaWxkLCBpdGVtKSB7XG4gICAgICB2YXIgb2xkVmFsID0gdHlwZW9mIGNoaWxkLm9sZFZhbHVlcyAhPSAndW5kZWZpbmVkJyA/IGNoaWxkLm9sZFZhbHVlc1swXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhY3QgPSBtYWtlVW5kb0FjdGlvbihleGVjdXRlVW5kb0FjdGlvbiwgcGFyZW50cywgY2hpbGQsIG9sZFZhbCwgaXRlbSk7XG5cbiAgICAgIGlmIChtb2RlID09IE1PREVfSUdOT1JFKSByZXR1cm47XG5cbiAgICAgIGlmIChtb2RlID09IE1PREVfTUVSR0UpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJVUlwiLCBcIm1lcmdlbW9kZVwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgYWN0Lm1lcmdlZEFjdGlvbiA9IGZ1bmN0aW9uKG5ld0FjdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdBY3Rpb24ubWVyZ2VNZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3QWN0aW9uLm1lcmdlTWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb21iaW5lZEZ1bmN0aW9uKG5ld0FjdGlvbiwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhY3QubWVyZ2VNZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChjaGlsZC5vbGRWYWx1ZXMgJiYgbW9kZSA9PSBNT0RFX09OQ0UpIHtcbiAgICAgICAgICAgIGFjdC5tZXJnZWRBY3Rpb24gPSBmdW5jdGlvbihvbGRDaGlsZCwgb2xkSXRlbSwgbmV3QWN0aW9uKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3QWN0aW9uLm1lcmdlYWJsZUFjdGlvbiA9PSAnb2JqZWN0JyAmJiBvbGRDaGlsZCA9PSBuZXdBY3Rpb24ubWVyZ2VhYmxlQWN0aW9uLmNoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJVUlwiLCBcImlnbm9yZSB1cGRhdGUgZm9yIHByb3BlcnR5IGluIE1PREVfT05DRVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfS5iaW5kKGFjdCwgY2hpbGQsIGl0ZW0pO1xuICAgICAgICAgICAgYWN0Lm1lcmdlYWJsZUFjdGlvbiA9IHsgY2hpbGQ6IGNoaWxkLCBpdGVtOiBpdGVtIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVVJcIiwgXCJpdGVtLnN0YXR1c1wiLCBpdGVtLnN0YXR1cyk7XG4gICAgICAgICAgLy8gXCJpdGVtXCIgaXMgdmFsdWVkIHdoZW4gYW4gaXRlbSBpcyBhZGRlZC9yZW1vdmVkL3JldGVpbmVkIGluIGFuIGFycmF5XG4gICAgICAgICAgLy8gc29tZXRpbWVzIEtPIGRldGVjdCBcIm1vdmVzXCIgYW5kIGFkZCBhIFwibW92ZWRcIiBwcm9wZXJ0eSB3aXRoIHRoZSBpbmRleCBidXRcbiAgICAgICAgICAvLyB0aGlzIGRvZXNuJ3QgaGFwcGVuIGZvciBleGFtcGxlIHVzaW5nIGtub2Nrb3V0LXNvcnRhYmxlIG9yIHdoZW4gbW92aW5nIG9iamVjdHNcbiAgICAgICAgICAvLyBiZXR3ZWVuIGFycmF5cy5cbiAgICAgICAgICAvLyBTbyB0aGlzIGVuZHMgdXAgaGFuZGxpbmcgdGhpcyB3aXRoIFwibWVyZ2VhYmxlTW92ZVwiIGFuZCBcIm1lcmdlZEFjdGlvblwiOiBcbiAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLnN0YXR1cyA9PSAnZGVsZXRlZCcpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc2Ugc29ubyBpbiBNT0RFID0gTUVSR0UgZGV2byBtZXR0ZWVyIHVuYSBmdW56aW9uZSBkaSBtZXJnZSBjaGUgYWNjZXR0YSB0dXR0by5cbiAgICAgICAgICAgIC8vIGFsdHJpbWVudGkgbGFzY2lvIHF1ZXN0YS5cbiAgICAgICAgICAgIGFjdC5tZXJnZWRBY3Rpb24gPSBmdW5jdGlvbihvbGRDaGlsZCwgb2xkSXRlbSwgbmV3QWN0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVVJcIiwgXCJhY3QubWVyZ2VkQWN0aW9uXCIsIHR5cGVvZiBuZXdBY3Rpb24ubWVyZ2VhYmxlTW92ZSk7XG4gICAgICAgICAgICAgIC8vIGEgZGVsZXRlZCBhY3Rpb24gaXMgYWJsZSB0byBtZXJnZSB3aXRoIGEgYWRkZWQgYWN0aW9uIGlmIHRoZXkgYXBwbHkgdG8gdGhlIHNhbWVcbiAgICAgICAgICAgICAgLy8gb2JqZWN0LlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld0FjdGlvbi5tZXJnZWFibGVNb3ZlID09ICdvYmplY3QnICYmIG9sZEl0ZW0udmFsdWUgPT0gbmV3QWN0aW9uLm1lcmdlYWJsZU1vdmUuaXRlbS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSBJIHNpbXBseSByZXR1cm4gYSBzaW5nbGUgYWN0aW9uIHJ1bm5pbmcgYm90aCBhY3Rpb25zIGluIHNlcXVlbmNlLFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2F5IHRoZSBcInVuZG9cIiB3aWxsIG5lZWQgdG8gdW5kbyBvbmx5IG9uY2UgZm9yIGEgXCJtb3ZlXCIgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29tYmluZWRGdW5jdGlvbihuZXdBY3Rpb24sIHRoaXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVVJcIiwgXCJub3QgbWVyZ2VhYmxlXCIsIHR5cGVvZiBuZXdBY3Rpb24ubWVyZ2VhYmxlTW92ZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZChhY3QsIGNoaWxkLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5zdGF0dXMgPT0gJ2FkZGVkJykge1xuICAgICAgICAgICAgLy8gYWRkIGEgbWVyZ2VhYmxlTW92ZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgbmV4dCBhY3Rpb24gXCJtZXJnZWRBY3Rpb25cIiB0byBzZWUgaWYgdGhpcyBhY3Rpb25cbiAgICAgICAgICAgIC8vIGNhbiBiZSBtZXJnZWQuXG4gICAgICAgICAgICBhY3QubWVyZ2VhYmxlTW92ZSA9IHsgY2hpbGQ6IGNoaWxkLCBpdGVtOiBpdGVtIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGFjdCAhPT0gJ3VuZGVmaW5lZCcpIF9wdXNoKGFjdCk7XG4gICAgfTtcblxuICAgIHZhciByZWFjdG9yT3B0aW9ucyA9IHsgZGVwdGg6IC0xLCBvbGRWYWx1ZXM6IDEsIG11dGFibGU6IHRydWUsIC8qIHRhZ1BhcmVudHNXaXRoTmFtZTogdHJ1ZSAqLyB0YWdGaWVsZHM6IHRydWUgfTtcblxuICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgdmFyIHJlYWN0ID0gdHlwZW9mIHJlYWN0b3IgPT0gJ2Z1bmN0aW9uJyA/IHJlYWN0b3IgOiBrby53YXRjaDtcbiAgICB2YXIgcmVzID0gcmVhY3QobW9kZWwsIHJlYWN0b3JPcHRpb25zLCBjaGFuZ2VQdXNoZXIsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB1c2g6IF9wdXNoLCBcbiAgICAgIHVuZG9Db21tYW5kOiBfeGRvQ29tbWFuZChvcHRpb25zLnVuZG9MYWJlbCwgU1RBVEVfVU5ET0lORywgdW5kb1N0YWNrKSxcbiAgICAgIHJlZG9Db21tYW5kOiBfeGRvQ29tbWFuZChvcHRpb25zLnJlZG9MYWJlbCwgU1RBVEVfUkVET0lORywgcmVkb1N0YWNrKSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHsgdW5kb1N0YWNrLnJlbW92ZUFsbCgpOyByZWRvU3RhY2sucmVtb3ZlQWxsKCk7IH0sXG4gICAgICAvLyBzZXRNb2RlOiBmdW5jdGlvbihuZXdNb2RlKSB7IG1vZGUgPSBuZXdNb2RlOyBfcmVtb3ZlTWVyZ2VkQWN0aW9uKHVuZG9TdGFjayk7IH0sXG4gICAgICBzZXRNb2RlT25jZTogZnVuY3Rpb24oKSB7IG1vZGUgPSBNT0RFX09OQ0U7IF9yZW1vdmVNZXJnZWRBY3Rpb24odW5kb1N0YWNrKTsgfSxcbiAgICAgIHNldE1vZGVNZXJnZTogZnVuY3Rpb24oKSB7IG1vZGUgPSBNT0RFX01FUkdFOyBfcmVtb3ZlTWVyZ2VkQWN0aW9uKHVuZG9TdGFjayk7IH0sXG4gICAgICBzZXRNb2RlTm9ybWFsOiBmdW5jdGlvbigpIHsgbW9kZSA9IE1PREVfTk9STUFMOyBfcmVtb3ZlTWVyZ2VkQWN0aW9uKHVuZG9TdGFjayk7IH0sXG4gICAgICBzZXRNb2RlSWdub3JlOiBmdW5jdGlvbigpIHsgbW9kZSA9IE1PREVfSUdOT1JFOyBfcmVtb3ZlTWVyZ2VkQWN0aW9uKHVuZG9TdGFjayk7IH0sXG4gICAgICBzZXRVbmRvQWN0aW9uTWFrZXI6IGZ1bmN0aW9uKG1ha2VyKSB7IG1ha2VVbmRvQWN0aW9uID0gbWFrZXI7IH0sXG4gICAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHsgLyoga28udW53YXRjaChtb2RlbCwgcmVhY3Rvck9wdGlvbnMsIGNoYW5nZVB1c2hlcik7ICovIHJlcy5kaXNwb3NlKCk7IH1cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiB1bmRvTWFuYWdlcjtcbiAgXG59KSk7IiwiLy8gS25vY2tvdXQgRmFzdCBNYXBwaW5nIHYwLjFcbi8vIExpY2Vuc2U6IE1JVCAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHQvLyBNb2R1bGUgc3lzdGVtcyBtYWdpYyBkYW5jZS5cblxuXHRpZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlMgb3IgTm9kZTogaGFyZC1jb2RlZCBkZXBlbmRlbmN5IG9uIFwia25vY2tvdXRcIlxuXHRcdGZhY3RvcnkoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCksIGV4cG9ydHMpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmVbXCJhbWRcIl0pIHtcblx0XHQvLyBBTUQgYW5vbnltb3VzIG1vZHVsZSB3aXRoIGhhcmQtY29kZWQgZGVwZW5kZW5jeSBvbiBcImtub2Nrb3V0XCJcblx0XHRkZWZpbmUoW1wia25vY2tvdXRcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcblx0fSBlbHNlIHtcblx0XHQvLyA8c2NyaXB0PiB0YWc6IHVzZSB0aGUgZ2xvYmFsIGBrb2Agb2JqZWN0LCBhdHRhY2hpbmcgYSBgd3JhcGAgcHJvcGVydHlcblx0XHRmYWN0b3J5KGtvLCBrby53cmFwID0ge30pO1xuXHR9XG59KGZ1bmN0aW9uIChrbywgZXhwb3J0cykge1xuICAgIFxuICAgIC8vIHRoaXMgZnVuY3Rpb24gbWltaWNzIGtvLm1hcHBpbmdcbiAgICBleHBvcnRzLmZyb21KUyA9IGZ1bmN0aW9uKGpzT2JqZWN0LCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpXG4gICAge1xuICAgICAgICByZXNldCgpO1xuXHRyZXR1cm4gd3JhcChqc09iamVjdCwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGZ1bmN0aW9uIHVud3JhcHMgdGhlIG91dGVyIGZvciBhc3NpZ25pbmcgdGhlIHJlc3VsdCB0byBhbiBvYnNlcnZhYmxlXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9pc3N1ZXMvNTE3XG4gICAgZXhwb3J0cy51cGRhdGVGcm9tSlMgPSBmdW5jdGlvbihvYnNlcnZhYmxlLCBqc09iamVjdCwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKVxuICAgIHtcbiAgICAgICAgcmVzZXQoKTtcblx0cmV0dXJuIG9ic2VydmFibGUoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh3cmFwKGpzT2JqZWN0LCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpKSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uU3RyaW5nLCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpIHtcblx0dmFyIHBhcnNlZCA9IGtvLnV0aWxzLnBhcnNlSnNvbihqc29uU3RyaW5nKTtcblx0YXJndW1lbnRzWzBdID0gcGFyc2VkO1xuXHRyZXR1cm4gZXhwb3J0cy5mcm9tSlMuYXBwbHkodGhpcywgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKTtcbiAgICB9O1xuICAgIFxuICAgIGV4cG9ydHMudG9KUyA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG5cdHJldHVybiB1bndyYXAob2JzZXJ2YWJsZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy50b0pTT04gPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuXHR2YXIgcGxhaW5KYXZhU2NyaXB0T2JqZWN0ID0gZXhwb3J0cy50b0pTKG9ic2VydmFibGUpO1xuXHRyZXR1cm4ga28udXRpbHMuc3RyaW5naWZ5SnNvbihwbGFpbkphdmFTY3JpcHRPYmplY3QpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0eXBlT2YodmFsdWUpIHtcblx0dmFyIHMgPSB0eXBlb2YgdmFsdWU7XG5cdGlmIChzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09IERhdGUpXG4gICAgICAgICAgICAgICAgICAgIHMgPSAnZGF0ZSc7XG5cdFx0ZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgICAgICAgICAgICAgICBzID0gJ2FycmF5JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0cyA9ICdudWxsJztcbiAgICAgICAgICAgIH1cblx0fVxuXHRyZXR1cm4gcztcbiAgICB9XG5cbiAgICAvLyB1bndyYXBwaW5nXG4gICAgZnVuY3Rpb24gdW53cmFwT2JqZWN0KG8pXG4gICAge1xuXHR2YXIgdCA9IHt9O1xuXG5cdGZvciAodmFyIGsgaW4gbylcblx0e1xuXHQgICAgdmFyIHYgPSBvW2tdO1xuXG5cdCAgICBpZiAoa28uaXNDb21wdXRlZCh2KSlcblx0XHRjb250aW51ZTtcblxuXHQgICAgdFtrXSA9IHVud3JhcCh2KTtcblx0fVxuXG5cdHJldHVybiB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVud3JhcEFycmF5KGEpXG4gICAge1xuXHR2YXIgciA9IFtdO1xuXG5cdGlmICghYSB8fCBhLmxlbmd0aCA9PSAwKVxuXHQgICAgcmV0dXJuIHI7XG5cdFxuXHRmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgKytpKVxuXHQgICAgci5wdXNoKHVud3JhcChhW2ldKSk7XG5cblx0cmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW53cmFwKHYpXG4gICAge1xuXHR2YXIgaXNPYnNlcnZhYmxlID0ga28uaXNPYnNlcnZhYmxlKHYpO1xuXG5cdGlmIChpc09ic2VydmFibGUpXG5cdHtcblx0ICAgIHZhciB2YWwgPSB2KCk7XG5cblx0ICAgIHJldHVybiB1bndyYXAodmFsKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0ICAgIGlmICh0eXBlT2YodikgPT0gXCJhcnJheVwiKVxuXHQgICAge1xuXHRcdHJldHVybiB1bndyYXBBcnJheSh2KTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVPZih2KSA9PSBcIm9iamVjdFwiKVxuXHQgICAge1xuXHRcdHJldHVybiB1bndyYXBPYmplY3Qodik7XG5cdCAgICB9XG5cdCAgICBlbHNlXG5cdCAgICB7XG5cdFx0cmV0dXJuIHY7XG5cdCAgICB9XG5cdH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldCgpXG4gICAge1xuICAgICAgICBwYXJlbnRzID0gW3tvYmo6IG51bGwsIHdyYXBwZWQ6IG51bGwsIGx2bDogXCJcIn1dO1xuICAgIH0gICAgXG4gICAgXG4gICAgLy8gd3JhcHBpbmdcblxuICAgIGZ1bmN0aW9uIHdyYXBPYmplY3QobywgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKVxuICAgIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldLm9iaiA9PT0gbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRzW2ldLndyYXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXHR2YXIgdCA9IHt9O1xuXG5cdGZvciAodmFyIGsgaW4gbylcblx0e1xuXHQgICAgdmFyIHYgPSBvW2tdO1xuXG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goe29iajogbywgd3JhcHBlZDogdCwgbHZsOiBjdXJyZW50THZsKCkgKyBcIi9cIiArIGt9KTtcblxuXHQgICAgdFtrXSA9IHdyYXAodiwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKTtcblxuICAgICAgICAgICAgcGFyZW50cy5wb3AoKTtcblx0fVxuXG5cdGlmIChjb21wdXRlZEZ1bmN0aW9ucyAmJiBjb21wdXRlZEZ1bmN0aW9uc1tjdXJyZW50THZsKCldKVxuXHQgICAgdCA9IGNvbXB1dGVkRnVuY3Rpb25zW2N1cnJlbnRMdmwoKV0odCk7XG5cbiAgICAgICAgaWYgKGhhc0VTNVBsdWdpbigpKVxuICAgICAgICAgICAga28udHJhY2sodCk7XG5cblx0aWYgKG9ic2VydmFibGVPYmplY3RzKSByZXR1cm4ga28ub2JzZXJ2YWJsZSh0KTtcblx0cmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcEFycmF5KGEsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cylcbiAgICB7XG5cdHZhciByID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG5cblx0aWYgKCFhIHx8IGEubGVuZ3RoID09IDApXG5cdCAgICByZXR1cm4gcjtcblxuXHRmb3IgKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgKytpKVxuXHQgICAgci5wdXNoKHdyYXAoYVtpXSwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKSk7XG5cblx0cmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gYSBzdGFjaywgdXNlZCBmb3IgdHdvIHB1cnBvc2VzOlxuICAgIC8vICAtIGNpcmN1bGFyIHJlZmVyZW5jZSBjaGVja2luZ1xuICAgIC8vICAtIGNvbXB1dGVkIGZ1bmN0aW9uc1xuICAgIHZhciBwYXJlbnRzO1xuXG4gICAgZnVuY3Rpb24gY3VycmVudEx2bCgpXG4gICAge1xuXHRyZXR1cm4gcGFyZW50c1twYXJlbnRzLmxlbmd0aC0xXS5sdmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcCh2LCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpXG4gICAge1xuXHRpZiAodHlwZU9mKHYpID09IFwiYXJyYXlcIilcblx0e1xuXHQgICAgcmV0dXJuIHdyYXBBcnJheSh2LCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVPZih2KSA9PSBcIm9iamVjdFwiKVxuXHR7XG5cdCAgICByZXR1cm4gd3JhcE9iamVjdCh2LCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpO1xuXHR9XG5cdGVsc2Vcblx0e1xuICAgICAgICAgICAgaWYgKCFoYXNFUzVQbHVnaW4oKSAmJiB0eXBlb2YgdiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHtcblx0ICAgICAgICB2YXIgdCA9IGtvLm9ic2VydmFibGUoKTtcblx0ICAgICAgICB0KHYpO1xuXHQgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG5cdH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNFUzVQbHVnaW4oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGtvLnRyYWNrICE9IG51bGw7XG4gICAgfVxufSkpO1xuIiwiLy8gRGVlcCBvYnNlcnZlciBwbHVnaW4gZm9yIEtub2Nrb3V0IGh0dHA6Ly9rbm9ja291dGpzLmNvbS9cclxuLy8gKGMpIFppYWQgSmVlcm9idXJraGFuXHJcbi8vIExpY2Vuc2U6IE1JVCAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXHJcbi8vIFZlcnNpb24gMS4zLjZcclxuXHJcbmtvLnN1YnNjcmliYWJsZS5mblsnd2F0Y2gnXSA9IGZ1bmN0aW9uICh0YXJnZXRPckNhbGxiYWNrLCBvcHRpb25zLCBldmFsdWF0b3JDYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vICAgICBUcmFjayBhbmQgbWFuYWdlIGNoYW5nZXMgd2l0aGluIHRoZSBjaGFpbmVkIG9ic2VydmFibGUgZG93biB0byBhbnkgZ2l2ZW4gbGV2ZWwuIFxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cInRhcmdldE9yQ2FsbGJhY2tcIj5cclxuICAgIC8vLyAgICAgIFRoZSBzdWJzY3JpcHRpb24gY2FsbGJhY2sgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN1YnNjcmliYWJsZXMgdG8gYmUgd2F0Y2hlZC5cclxuICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwib3B0aW9uc1wiIHR5cGU9XCJvYmplY3RcIj5cclxuICAgIC8vLyAgICAgZmFsc2UgLT4gRGlzYWJsZXMgdHJhY2tpbmcgb24gdGhlIGNoYWluZWQgb2JzZXJ2YWJsZS5cclxuICAgIC8vLyAgICAgeyBkZXB0aDogMiB9IC0+IFRyYWNrIGFsbCBuZXN0ZWQgc3Vic2NyaWJhYmxlcyBkb3duIHRvIHRoZSAybmQgbGV2ZWwoZGVmYXVsdCBpcyAxKS48YnIvPlxyXG4gICAgLy8vICAgICB7IGRlcHRoOiAtMSB9IC0+IFRyYWNrIGFsbCBuZXN0ZWQgc3Vic2NyaWJhYmxlcy48YnIvPlxyXG4gICAgLy8vICAgICB7IGhpZGU6IFsuLi5dIH0gLT4gUHJvcGVydHkgb3IgYXJyYXkgb2YgcHJvcGVydGllcyB0byBiZSBpZ25vcmVkLjxici8+XHJcbiAgICAvLy8gICAgIHsgaGlkZUFycmF5czogdHJ1ZSB9IC0+IElnbm9yZSBhbGwgbmVzdGVkIGFycmF5cy48YnIvPlxyXG4gICAgLy8vICAgICB7IGhpZGVXcmFwcGVkVmFsdWVzOiB0cnVlIH0gLT4gSWdub3JlIG9ic2VydmFibGVzIHdyYXBwZWQgdW5kZXIgeWV0IGFub3RoZXIgcGFyZW50IG9ic2VydmFibGUuPGJyLz5cclxuICAgIC8vLyAgICAgeyBtdXRhYmxlOiB0cnVlIH0gLT4gRHluYW1pY2FsbHkgYWRhcHQgdG8gY2hhbmdlcyBtYWRlIHRvIHRoZSB0YXJnZXQgc3RydWN0dXJlIHRocm91Z2ggYW55IHN1YnNjcmliYWJsZS48YnIvPlxyXG4gICAgLy8vICAgICB7IHdhdGNoZWRPbmx5OiB0cnVlIH0gLT4gV2F0Y2ggb25seSBzdWJzY3JpYmFibGVzIHRhZ2dlZCB3aXRoIC53YXRjaCgpLjxici8+XHJcbiAgICAvLy8gICAgIHsgYmVmb3JlV2F0Y2g6IGZ1bmN0aW9uKHBhcmVudHMsIGNoaWxkKSB7Li4ufSB9IC0+IEZ1bmN0aW9uIGNhbGxlZCBwcmlvciB0byBjcmVhdGluZyBhIHN1YnNjcmlwdGlvbi4gUmV0dXJuaW5nIGZhbHNlIGFib3J0cyB0aGUgb3BlcmF0aW9uIGFuZCBpZ25vcmVzIGl0cyBjaGlsZHJlbi48YnIvPlxyXG4gICAgLy8vICAgICB7IHdyYXA6IHRydWUgfSAtPiBXcmFwIGFsbCBmaWVsZHMgaW50byBvYnNlcnZhYmxlcy4gVGhpcyBoYXBwZW5zIG9uIHRoZSBmbHkgZm9yIG5ldyBhcnJheSBpdGVtcyhvciBjaGlsZCBvYmplY3RzIHdoZW4gbXV0YWJsZSBpcyBzZXQgdG8gdHJ1ZSkuPGJyLz5cclxuICAgIC8vLyAgICAgeyBiZWZvcmVXcmFwOiBmdW5jdGlvbihwYXJlbnRzLCBmaWVsZCwgdmFsdWUpIHsuLi59IH0gLT4gRnVuY3Rpb24gY2FsbGVkIHByaW9yIHRvIHdyYXBwaW5nIGEgdmFsdWUgaW50byBhbiBvYnNlcnZhYmxlLiBSZXR1cm5pbmcgZmFsc2UgbGVhdmVzIGl0IGFzIGl0IGlzLjxici8+XHJcbiAgICAvLy8gICAgIHsgdGFnRmllbGRzOiB0cnVlIH0gLT4gQWRkIHRoZSBwcm9wZXJ0eSAnX2ZpZWxkTmFtZScgdW5kZXIgZWFjaCBwcm9wZXJ0eSBmb3IgdGV4dHVhbCBpZGVudGlmaWNhdGlvbi48YnIvPlxyXG4gICAgLy8vICAgICB7IHRhZ0ZpZWxkczogJ3BhcmVudHNPbmx5JyB9IC0+IFNhbWUgYXMgYWJvdmUgZXhjZXB0IHRoYXQgaXQgaXMgbGltaXRlZCB0byBwYXJlbnQgcHJvcGVydGllcyBvbmx5Ljxici8+XHJcbiAgICAvLy8gICAgIHsgb2xkVmFsdWVzOiAzIH0gLT4gS2VlcCB0aGUgbGFzdCB0aHJlZSB2YWx1ZXMgZm9yIGVhY2ggc3Vic2NyaWJhYmxlIHVuZGVyIHRoZSBwcm9wZXJ0eSAnb2xkVmFsdWVzJy48YnIvPlxyXG4gICAgLy8vICAgICB7IHNlYWw6IHRydWUgfSAtPiBQcmV2ZW50IGFueSBzdWJzZXF1ZW50IHdhdGNoZXIgZnJvbSB3YXRjaGluZyB0aGUgdGFyZ2V0IGFnYWluLjxici8+XHJcbiAgICAvLy8gICAgIHsgdW5sb29wOiB0cnVlIH0gLT4gQXZvaWQgY2lyY3VsYXIgcGF0aHMgdGhyb3VnaCB0aGUgdXNlIG9mIGEgYnJlYWRjcnVtYiBwcm9wZXJ0eSAnX3dhdGNoZXInIHNldCBhdCBlYWNoIG5vZGUgbGV2ZWwuPGJyLz5cclxuICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwiZXZhbHVhdG9yQ2FsbGJhY2tcIiB0eXBlPVwiZnVuY3Rpb25cIj5cclxuICAgIC8vLyAgICAgVGhlICBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgZHVyaW5nIGNoYW5nZXMuIEFueSByZXR1cm4gdmFsdWUgaXMgYXNzaWduZWQgdG8gdGhlIGNoYWluZWQgb2JzZXJ2YWJsZS5cclxuICAgIC8vLyA8L3BhcmFtPlxyXG5cclxuICAgIHZhciB0YXJnZXRUeXBlID0gdHlwZW9mIHRhcmdldE9yQ2FsbGJhY2s7XHJcblxyXG4gICAgaWYgKHRhcmdldFR5cGUgPT09ICdib29sZWFuJyB8fCB0YXJnZXRUeXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIFR1cm4gb24gb3Igb2ZmIHRoZSB3YXRjaGVyIGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCBhbG9uZyB3aXRoIGFueSBvZiBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAga28ud2F0Y2godGhpcywgeyBlbmFibGVkOiB0YXJnZXRPckNhbGxiYWNrICE9PSBmYWxzZSB9KTtcclxuICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAha28uaXNTdWJzY3JpYmFibGUodGFyZ2V0T3JDYWxsYmFjaykpIHtcclxuICAgICAgICAvLyBUYXJnZXQgdGhlIGNoYWluZWQgc3Vic2NyaWJhYmxlIGl0c2VsZiBpZiBubyB0YXJnZXQgc3Vic2NyaWJhYmxlIG9yIG9iamVjdCB3YXMgcGFzc2VkLlxyXG4gICAgICAgIGtvLndhdGNoKHRoaXMsIG9wdGlvbnMgfHwge30sIHRhcmdldE9yQ2FsbGJhY2ssIGNvbnRleHQgfHwgdGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGtvLndhdGNoKHRhcmdldE9yQ2FsbGJhY2ssIG9wdGlvbnMsIGV2YWx1YXRvckNhbGxiYWNrLCBjb250ZXh0IHx8IHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxua29bJ3dhdGNoJ10gPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zLCBldmFsdWF0b3JDYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vICAgICBUcmFjayBhbmQgbWFuYWdlIGNoYW5nZXMgd2l0aGluIGEgc3BlY2lmaWMgdGFyZ2V0IG9iamVjdCBkb3duIHRvIGFueSBnaXZlbiBsZXZlbC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0YXJnZXRcIj5cclxuICAgIC8vLyAgICAgQW4gb2JqZWN0IG9yIGZ1bmN0aW9uIGNvbnRhaW5pbmcgdGhlIHRhcmdldGVkIHN1YnNjcmliYWJsZShzKS5cclxuICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwib3B0aW9uc1wiIHR5cGU9XCJvYmplY3RcIj5cclxuICAgIC8vLyAgICAgeyBkZXB0aDogMiB9IC0+IFRyYWNrIGFsbCBuZXN0ZWQgc3Vic2NyaWJhYmxlcyBkb3duIHRvIHRoZSAybmQgbGV2ZWwoZGVmYXVsdCBpcyAxKS48YnIvPlxyXG4gICAgLy8vICAgICB7IGRlcHRoOiAtMSB9IC0+IFRyYWNrIGFsbCBuZXN0ZWQgc3Vic2NyaWJhYmxlcy48YnIvPlxyXG4gICAgLy8vICAgICB7IGhpZGU6IFsuLi5dIH0gLT4gUHJvcGVydHkgb3IgYXJyYXkgb2YgcHJvcGVydGllcyB0byBiZSBpZ25vcmVkLjxici8+XHJcbiAgICAvLy8gICAgIHsgaGlkZUFycmF5czogdHJ1ZSB9IC0+IElnbm9yZSBhbGwgbmVzdGVkIGFycmF5cy48YnIvPlxyXG4gICAgLy8vICAgICB7IGhpZGVXcmFwcGVkVmFsdWVzOiB0cnVlIH0gLT4gSWdub3JlIG9ic2VydmFibGVzIHdyYXBwZWQgdW5kZXIgeWV0IGFub3RoZXIgcGFyZW50IG9ic2VydmFibGUuPGJyLz5cclxuICAgIC8vLyAgICAgeyBtdXRhYmxlOiB0cnVlIH0gLT4gRHluYW1pY2FsbHkgYWRhcHQgdG8gY2hhbmdlcyBtYWRlIHRvIHRoZSB0YXJnZXQgc3RydWN0dXJlIHRocm91Z2ggYW55IHN1YnNjcmliYWJsZS48YnIvPlxyXG4gICAgLy8vICAgICB7IHdhdGNoZWRPbmx5OiB0cnVlIH0gLT4gV2F0Y2ggb25seSBzdWJzY3JpYmFibGVzIHRhZ2dlZCB3aXRoIC53YXRjaCgpLjxici8+XHJcbiAgICAvLy8gICAgIHsgYmVmb3JlV2F0Y2g6IGZ1bmN0aW9uKHBhcmVudHMsIGNoaWxkKSB7Li4ufSB9IC0+IEZ1bmN0aW9uIGNhbGxlZCBwcmlvciB0byBjcmVhdGluZyBhIHN1YnNjcmlwdGlvbi4gUmV0dXJuaW5nIGZhbHNlIGFib3J0cyB0aGUgb3BlcmF0aW9uIGFuZCBpZ25vcmVzIGl0cyBjaGlsZHJlbi48YnIvPlxyXG4gICAgLy8vICAgICB7IHdyYXA6IHRydWUgfSAtPiBXcmFwIGFsbCBmaWVsZHMgaW50byBvYnNlcnZhYmxlcy4gVGhpcyBoYXBwZW5zIG9uIHRoZSBmbHkgZm9yIG5ldyBhcnJheSBpdGVtcyhvciBjaGlsZCBvYmplY3RzIHdoZW4gbXV0YWJsZSBpcyBzZXQgdG8gdHJ1ZSkuPGJyLz5cclxuICAgIC8vLyAgICAgeyBiZWZvcmVXcmFwOiBmdW5jdGlvbihwYXJlbnRzLCBmaWVsZCwgdmFsdWUpIHsuLi59IH0gLT4gRnVuY3Rpb24gY2FsbGVkIHByaW9yIHRvIHdyYXBwaW5nIGEgdmFsdWUgaW50byBhbiBvYnNlcnZhYmxlLiBSZXR1cm5pbmcgZmFsc2UgbGVhdmVzIGl0IGFzIGl0IGlzLjxici8+XHJcbiAgICAvLy8gICAgIHsgdGFnRmllbGRzOiB0cnVlIH0gLT4gQWRkIHRoZSBwcm9wZXJ0eSAnX2ZpZWxkTmFtZScgdW5kZXIgZWFjaCBwcm9wZXJ0eSBmb3IgdGV4dHVhbCBpZGVudGlmaWNhdGlvbi48YnIvPlxyXG4gICAgLy8vICAgICB7IHRhZ0ZpZWxkczogJ3BhcmVudHNPbmx5JyB9IC0+IFNhbWUgYXMgYWJvdmUgZXhjZXB0IHRoYXQgaXQgaXMgbGltaXRlZCB0byBwYXJlbnQgcHJvcGVydGllcyBvbmx5Ljxici8+XHJcbiAgICAvLy8gICAgIHsgb2xkVmFsdWVzOiAzIH0gLT4gS2VlcCB0aGUgbGFzdCB0aHJlZSB2YWx1ZXMgZm9yIGVhY2ggc3Vic2NyaWJhYmxlIHVuZGVyIHRoZSBwcm9wZXJ0eSAnb2xkVmFsdWVzJy48YnIvPlxyXG4gICAgLy8vICAgICB7IHNlYWw6IHRydWUgfSAtPiBQcmV2ZW50IGFueSBzdWJzZXF1ZW50IHdhdGNoZXIgZnJvbSB3YXRjaGluZyB0aGUgdGFyZ2V0IGFnYWluLjxici8+XHJcbiAgICAvLy8gICAgIHsgdW5sb29wOiB0cnVlIH0gLT4gQXZvaWQgY2lyY3VsYXIgcGF0aHMgdGhyb3VnaCB0aGUgdXNlIG9mIGEgYnJlYWRjcnVtYiBwcm9wZXJ0eSAnX3dhdGNoZXInIHNldCBhdCBlYWNoIG5vZGUgbGV2ZWwuPGJyLz5cclxuICAgIC8vLyAgICAgeyBnZXR0ZXI6IGZ1bmN0aW9uKHBhcmVudHMsIGNoaWxkLCBwcm9wZXJ0eSkgey4uLn0gfSAtPiBGdW5jdGlvbiB1c2VkIHRvIHJldHJpZXZlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBjaGlsZC4gRmFsc2UgY2FuIGJlIHJldHVybmVkIHRvIGlnbm9yZSB0aGUgcHJvcGVydHkuPGJyLz5cclxuICAgIC8vLyA8L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwiZXZhbHVhdG9yQ2FsbGJhY2tcIiB0eXBlPVwiZnVuY3Rpb25cIj5cclxuICAgIC8vLyAgICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBkdXJpbmcgY2hhbmdlcy5cclxuICAgIC8vLyA8L3BhcmFtPlxyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGV2YWx1YXRvckNhbGxiYWNrO1xyXG4gICAgICAgIGV2YWx1YXRvckNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcclxuXHJcbiAgICBmdW5jdGlvbiB3YXRjaENoaWxkcmVuKGNoaWxkLCBwYXJlbnQsIGdyYW5kUGFyZW50cywgdW53YXRjaCwga2VlcE9mZlBhcmVudExpc3QsIGZpZWxkTmFtZSkge1xyXG4gICAgICAgIGlmIChjaGlsZCAmJiBvcHRpb25zLmRlcHRoICE9PSAwICYmIChvcHRpb25zLmRlcHRoID09PSAtMSB8fCBncmFuZFBhcmVudHMubGVuZ3RoIDwgKG9wdGlvbnMuZGVwdGggfHwgMSkpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBQcm9jZWVkIG9uIHdhdGNoZWQgY2hpbGRyZW4gb25seSB3aGVuIGluIHdhdGNoZWQtb25seSBtb2RlLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy53YXRjaGVkT25seSAmJiAhY2hpbGQud2F0Y2hhYmxlICYmIGNoaWxkICE9IHRhcmdldClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIHRhcmdldCBhcyBmYWxzZSBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdhdGNoZWQgbGF0ZXIgb24uXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlIHx8IG9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIGNoaWxkLndhdGNoYWJsZSA9IG9wdGlvbnMuZW5hYmxlZDtcclxuXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSB3YXRjaC1kaXNhYmxlZCBvYmplY3RzLlxyXG4gICAgICAgICAgICBpZiAoY2hpbGQud2F0Y2hhYmxlID09PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc3Vic2VxdWVudCB3YXRjaGVycyBmcm9tIHdhdGNoaW5nIHRoZSB0YXJnZXQgd2hlbiBzZWFsZWQuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNlYWwgPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICBjaGlsZC53YXRjaGFibGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIEJ5cGFzcyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLl93YXRjaGVyID09PSBjb250ZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaGlkZGVuIG9iamVjdHMuIEFsc28gYXBwbGllcyB0byBhbnkgb2YgdGhlaXIgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oaWRlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrby51dGlscy5hcnJheUluZGV4T2Yob3B0aW9ucy5oaWRlLCBjaGlsZCkgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmVudHMuIFVzaW5nIGEgZnJlc2ggYXJyYXkgc28gaXQgaXMgbm90IHJlZmVyZW5jZWQgaW4gdGhlIG5leHQgcmVjdXJzaW9uIGlmIGFueS5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRzID0gW10uY29uY2F0KGdyYW5kUGFyZW50cywgcGFyZW50ICYmIHBhcmVudCAhPT0gdGFyZ2V0ID8gcGFyZW50IDogW10pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFsnbm90aWZ5U3Vic2NyaWJlcnMnXSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRhcmdldCBpcyBhIHN1YnNjcmliYWJsZS4gV2F0Y2ggaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmFsdWF0b3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSAmJiBjaGlsZC53YXRjaGFibGUgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgd2FraW5nIHVwIGFuIGV4aXN0aW5nIHdhdGNoZXIuIExldCdzIG5vdCBhZGQgYW5vdGhlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVud2F0Y2ggfHwgIW9wdGlvbnMuYmVmb3JlV2F0Y2ggfHwgb3B0aW9ucy5iZWZvcmVXYXRjaC5jYWxsKGNvbnRleHQsIHBhcmVudHMsIGNoaWxkLCBmaWVsZE5hbWUpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0FycmF5ID0gdHlwZW9mIGNoaWxkLnBvcCA9PT0gJ2Z1bmN0aW9uJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVud2F0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVdhdGNoZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbldhdGNoZXIoY2hpbGQsIGlzQXJyYXksIHBhcmVudHMsIGtlZXBPZmZQYXJlbnRMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoQ2hpbGRyZW4oY2hpbGQoKSwga2VlcE9mZlBhcmVudExpc3QgPyBudWxsIDogY2hpbGQsIHBhcmVudHMsIHVud2F0Y2gsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oaWRlV3JhcHBlZFZhbHVlcyAhPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YXRjaENoaWxkcmVuKGNoaWxkKCksIGtlZXBPZmZQYXJlbnRMaXN0ID8gbnVsbCA6IGNoaWxkLCBwYXJlbnRzLCB1bndhdGNoLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY2hpbGQpID09PSAnW29iamVjdCBPYmplY3RdJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKGNoaWxkLCBmdW5jdGlvbiAocHJvcGVydHksIHN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gb3B0aW9ucy5nZXR0ZXIgPyBvcHRpb25zLmdldHRlci5jYWxsKGNvbnRleHQsIHBhcmVudHMsIGNoaWxkLCBwcm9wZXJ0eSkgOiBzdWI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud3JhcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIHNpbXBsZSBvYmplY3RzIGFuZCBhcnJheXMgaW50byBvYnNlcnZhYmxlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgJiYgdHlwZSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5iZWZvcmVXcmFwIHx8IG9wdGlvbnMuYmVmb3JlV3JhcC5jYWxsKGNvbnRleHQsIHBhcmVudHMsIGNoaWxkLCBzdWIpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YiA9IGNoaWxkW3Byb3BlcnR5XSA9IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBrby5vYnNlcnZhYmxlQXJyYXkoc3ViKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGtvLm9ic2VydmFibGUoc3ViKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5sb29wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIuX3dhdGNoZXIgPSB1bndhdGNoID8gdW5kZWZpbmVkIDogY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0NoaWxkcmVuID0gd2F0Y2hDaGlsZHJlbihzdWIsIGtlZXBPZmZQYXJlbnRMaXN0ID8gbnVsbCA6IGNoaWxkLCBwYXJlbnRzLCB1bndhdGNoLCBudWxsLCBwcm9wZXJ0eSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRhZ0ZpZWxkcyAmJiBzdWIuX2ZpZWxkTmFtZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChvcHRpb25zLnRhZ0ZpZWxkcyAhPT0gJ3BhcmVudHNPbmx5JyAmJiB0eXBlb2Ygc3ViID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBzdWIgPT09ICdvYmplY3QnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi5fZmllbGROYW1lID0gcHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vICdbb2JqZWN0IEFycmF5XSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZUFycmF5cyAhPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hDaGlsZHJlbihjaGlsZFtpXSwga2VlcE9mZlBhcmVudExpc3QgPyBudWxsIDogY2hpbGQsIHBhcmVudHMsIHVud2F0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3Vic2NyaXB0aW9ucyBhcmUgc3RvcmVkIHVuZGVyIGVpdGhlciB0aGUgX3N1YnNjcmlwdGlvbnMgZmllbGQgZm9yIHRoZSBkZWJ1ZyB2ZXJzaW9uXHJcbiAgICAvLyBvciB0aGUgRiwgSCBvciBNIGZpZWxkcyB3aGVuIG1pbmlmaWVkIGRlcGVuZGluZyBvbiB0aGUgdmVyc2lvbiB1c2VkLlxyXG4gICAgdmFyIHN1YnNjcmlwdGlvbnNGaWVsZDtcclxuICAgIHN3aXRjaCAoa28uREVCVUcgfHwga28udmVyc2lvbikge1xyXG4gICAgICAgIGNhc2UgdHJ1ZTogc3Vic2NyaXB0aW9uc0ZpZWxkID0gJ19zdWJzY3JpcHRpb25zJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuMC4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdGJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuMS4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdIJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuMi4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdNJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuMy4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdHJzsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIjMuNC4wXCI6IHN1YnNjcmlwdGlvbnNGaWVsZCA9ICdLJzsgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgXCJVbnN1cHBvcnRlZCBLbm9ja291dCB2ZXJzaW9uLiBPbmx5IHYzLjAuMCB0byB2My40LjAgYXJlIHN1cHBvcnRlZCB3aGVuIG1pbmlmaWVkLiBDdXJyZW50IHZlcnNpb24gaXMgXCIgKyBrby52ZXJzaW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpc3Bvc2VXYXRjaGVyKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIHN1YnNjID0gY2hpbGRbc3Vic2NyaXB0aW9uc0ZpZWxkXTtcclxuXHJcbiAgICAgICAgaWYgKHN1YnNjKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJzYy5jaGFuZ2UpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3Vic2MuY2hhbmdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzYy5jaGFuZ2VbaV0uX3dhdGNoZXIgPT09IGNvbnRleHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjLmNoYW5nZVtpXS5kaXNwb3NlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3Vic2MuYmVmb3JlQ2hhbmdlICYmIChvcHRpb25zLm11dGFibGUgfHwgb3B0aW9ucy5vbGRWYWx1ZXMgPiAwKSlcclxuICAgICAgICAgICAgICAgIC8vIEFsc28gY2xlYW4gdXAgYW55IGJlZm9yZS1jaGFuZ2Ugc3Vic2NyaXB0aW9ucyB1c2VkIGZvciB0cmFja2luZyBvbGQgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN1YnNjLmJlZm9yZUNoYW5nZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2MuYmVmb3JlQ2hhbmdlW2ldLl93YXRjaGVyID09PSBjb250ZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzYy5iZWZvcmVDaGFuZ2VbaV0uZGlzcG9zZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN1YnNjLmFycmF5Q2hhbmdlKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN1YnNjLmFycmF5Q2hhbmdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzYy5hcnJheUNoYW5nZVtpXS5fd2F0Y2hlciA9PT0gY29udGV4dClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2MuYXJyYXlDaGFuZ2VbaV0uZGlzcG9zZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IFwiU3Vic2NyaXB0aW9ucyBmaWVsZCAoLlwiICsgc3Vic2NyaXB0aW9uc0ZpZWxkICsgXCIpIG5vdCBkZWZpbmVkIGZvciBvYnNlcnZhYmxlIGNoaWxkIFwiICsgKGNoaWxkLl9maWVsZE5hbWUgfHwgXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFzc2lnbldhdGNoZXIoY2hpbGQsIGlzQXJyYXksIHBhcmVudHMsIGtlZXBPZmZQYXJlbnRMaXN0KSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgICAgLy8gQ2hpbGQgaXMgYW4gb2JzZXJ2YWJsZSBhcnJheS4gV2F0Y2ggYWxsIGNoYW5nZXMgd2l0aGluIGl0LlxyXG4gICAgICAgICAgICBjaGlsZC5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGtvLnV0aWxzLmFycmF5Rm9yRWFjaChjaGFuZ2VzLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGV2YWx1YXRvckNhbGxiYWNrLmNhbGwoY29udGV4dCwgcGFyZW50cywgY2hpbGQsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0KHJldHVyblZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLm1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZWQgb3IgYnJhbmQgbmV3IGl0ZW0uIFVud2F0Y2ggb3Igd2F0Y2ggaXQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hDaGlsZHJlbihpdGVtLnZhbHVlLCAoa2VlcE9mZlBhcmVudExpc3QgPyBudWxsIDogY2hpbGQpLCBwYXJlbnRzLCBpdGVtLnN0YXR1cyA9PT0gJ2RlbGV0ZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgJ2FycmF5Q2hhbmdlJykuX3dhdGNoZXIgPSBjb250ZXh0O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGlsZC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLndhdGNoYWJsZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBldmFsdWF0b3JDYWxsYmFjay5jYWxsKGNvbnRleHQsIHBhcmVudHMsIGNoaWxkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQocmV0dXJuVmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tdXRhYmxlICYmIHR5cGVvZiBjaGlsZCgpID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2F0Y2ggdGhlIG5ldyBjb21lci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hDaGlsZHJlbihjaGlsZCgpLCAoa2VlcE9mZlBhcmVudExpc3QgPyBudWxsIDogY2hpbGQpLCBwYXJlbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0sIG51bGwsICdjaGFuZ2UnKS5fd2F0Y2hlciA9IGNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbGRWYWx1ZXMgPiAwIHx8IG9wdGlvbnMubXV0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuc3Vic2NyaWJlKGZ1bmN0aW9uIChvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9sZFZhbHVlcyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG9sZCB2YWx1ZSB0byBoaXN0b3J5IGxpc3QgYmVmb3JlIGV2ZXJ5IHVwZGF0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IChjaGlsZFsnb2xkVmFsdWVzJ11cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2hpbGRbJ29sZFZhbHVlcyddXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNoaWxkWydvbGRWYWx1ZXMnXSA9IFtdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KG9sZFZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoID4gb3B0aW9ucy5vbGRWYWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tdXRhYmxlICYmIHR5cGVvZiBvbGRWYWx1ZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGFsbCBzdWJzY3JpcHRpb25zIGZvciB0aGUgb2xkIGNoaWxkIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hDaGlsZHJlbihvbGRWYWx1ZSwgKGtlZXBPZmZQYXJlbnRMaXN0ID8gbnVsbCA6IGNoaWxkKSwgcGFyZW50cywgZmFsc2UsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0sIG51bGwsICdiZWZvcmVDaGFuZ2UnKS5fd2F0Y2hlciA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXNlIGEgY29tcHV0ZWQgd2hlbiB0YXJnZXRpbmcgYSBub24td2F0Y2hhYmxlIGZ1bmN0aW9uLlxyXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicgJiYgIWtvLmlzU3Vic2NyaWJhYmxlKHRhcmdldCkpXHJcbiAgICAgICAgcmV0dXJuIGtvLmNvbXB1dGVkKHRhcmdldCwgZXZhbHVhdG9yQ2FsbGJhY2ssIG9wdGlvbnMpO1xyXG5cclxuICAgIHdhdGNoQ2hpbGRyZW4odGFyZ2V0LCBudWxsLCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhdGNoQ2hpbGRyZW4odGFyZ2V0LCBudWxsLCBbXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbGV4ICA6IHJlcXVpcmUoJy4vbGliL2xleGVyJyksXG4gICAgcGFyc2U6IHJlcXVpcmUoJy4vbGliL3BhcnNlcicpLFxuICAgIHN0cmluZ2lmeTogcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5Jylcbn07XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcblxuZnVuY3Rpb24gZGVidWcobGFiZWwpIHtcbiAgcmV0dXJuIF9kZWJ1Zy5iaW5kKG51bGwsIGxhYmVsKTtcbn1cblxuZnVuY3Rpb24gX2RlYnVnKGxhYmVsKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICBhcmdzLnVuc2hpZnQoJ1snICsgbGFiZWwgKyAnXScpO1xuICBwcm9jZXNzLnN0ZGVyci53cml0ZShhcmdzLmpvaW4oJyAnKSArICdcXG4nKTtcbn0iLCJ2YXIgREVCVUcgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHByaW50IGRlYnVnZ2luZyBpbmZvLlxudmFyIFRJTUVSID0gZmFsc2U7IC8vIGB0cnVlYCB0byB0aW1lIGNhbGxzIHRvIGBsZXgoKWAgYW5kIHByaW50IHRoZSByZXN1bHRzLlxuXG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJykoJ2xleCcpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBsZXg7XG5cbi8qKlxuICogQ29udmVydCBhIENTUyBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBsZXhpY2FsIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzIENTU1xuICogQHJldHVybnMge0FycmF5fSBsZXhpY2FsIHRva2Vuc1xuICovXG5mdW5jdGlvbiBsZXgoY3NzKSB7XG4gIHZhciBzdGFydDsgLy8gRGVidWcgdGltZXIgc3RhcnQuXG5cbiAgdmFyIGJ1ZmZlciA9ICcnOyAgICAgIC8vIENoYXJhY3RlciBhY2N1bXVsYXRvclxuICB2YXIgY2g7ICAgICAgICAgICAgICAgLy8gQ3VycmVudCBjaGFyYWN0ZXJcbiAgdmFyIGNvbHVtbiA9IDA7ICAgICAgIC8vIEN1cnJlbnQgc291cmNlIGNvbHVtbiBudW1iZXJcbiAgdmFyIGN1cnNvciA9IC0xOyAgICAgIC8vIEN1cnJlbnQgc291cmNlIGN1cnNvciBwb3NpdGlvblxuICB2YXIgZGVwdGggPSAwOyAgICAgICAgLy8gQ3VycmVudCBuZXN0aW5nIGRlcHRoXG4gIHZhciBsaW5lID0gMTsgICAgICAgICAvLyBDdXJyZW50IHNvdXJjZSBsaW5lIG51bWJlclxuICB2YXIgc3RhdGUgPSAnYmVmb3JlLXNlbGVjdG9yJzsgLy8gQ3VycmVudCBzdGF0ZVxuICB2YXIgc3RhY2sgPSBbc3RhdGVdOyAgLy8gU3RhdGUgc3RhY2tcbiAgdmFyIHRva2VuID0ge307ICAgICAgIC8vIEN1cnJlbnQgdG9rZW5cbiAgdmFyIHRva2VucyA9IFtdOyAgICAgIC8vIFRva2VuIGFjY3VtdWxhdG9yXG5cbiAgLy8gU3VwcG9ydGVkIEAtcnVsZXMsIGluIHJvdWdobHkgZGVzY2VuZGluZyBvcmRlciBvZiB1c2FnZSBwcm9iYWJpbGl0eS5cbiAgdmFyIGF0UnVsZXMgPSBbXG4gICAgJ21lZGlhJyxcbiAgICAna2V5ZnJhbWVzJyxcbiAgICB7IG5hbWU6ICctd2Via2l0LWtleWZyYW1lcycsIHR5cGU6ICdrZXlmcmFtZXMnLCBwcmVmaXg6ICctd2Via2l0LScgfSxcbiAgICB7IG5hbWU6ICctbW96LWtleWZyYW1lcycsIHR5cGU6ICdrZXlmcmFtZXMnLCBwcmVmaXg6ICctbW96LScgfSxcbiAgICB7IG5hbWU6ICctbXMta2V5ZnJhbWVzJywgdHlwZTogJ2tleWZyYW1lcycsIHByZWZpeDogJy1tcy0nIH0sXG4gICAgeyBuYW1lOiAnLW8ta2V5ZnJhbWVzJywgdHlwZTogJ2tleWZyYW1lcycsIHByZWZpeDogJy1vLScgfSxcbiAgICAnZm9udC1mYWNlJyxcbiAgICB7IG5hbWU6ICdpbXBvcnQnLCBzdGF0ZTogJ2JlZm9yZS1hdC12YWx1ZScgfSxcbiAgICB7IG5hbWU6ICdjaGFyc2V0Jywgc3RhdGU6ICdiZWZvcmUtYXQtdmFsdWUnIH0sXG4gICAgJ3N1cHBvcnRzJyxcbiAgICAndmlld3BvcnQnLFxuICAgIHsgbmFtZTogJ25hbWVzcGFjZScsIHN0YXRlOiAnYmVmb3JlLWF0LXZhbHVlJyB9LFxuICAgICdkb2N1bWVudCcsXG4gICAgeyBuYW1lOiAnLW1vei1kb2N1bWVudCcsIHR5cGU6ICdkb2N1bWVudCcsIHByZWZpeDogJy1tb3otJyB9LFxuICAgICdwYWdlJ1xuICBdO1xuXG4gIC8vIC0tIEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQWR2YW5jZSB0aGUgY2hhcmFjdGVyIGN1cnNvciBhbmQgcmV0dXJuIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIG5leHQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q2goKSB7XG4gICAgc2tpcCgpO1xuICAgIHJldHVybiBjc3NbY3Vyc29yXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0YXRlIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgc3RhY2suXG4gICAqIFRoZSBzdGFjayBpcyBMSUZPIHNvIGluZGV4aW5nIGlzIGZyb20gdGhlIHJpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4PTBdIEluZGV4IHRvIHJldHVybi5cbiAgICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIGluZGV4XSA6IHN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgYWhlYWQgZm9yIGEgc3RyaW5nIGJlZ2lubmluZyBmcm9tIHRoZSBuZXh0IHBvc2l0aW9uLiBUaGUgc3RyaW5nXG4gICAqIGJlaW5nIGxvb2tlZCBmb3IgbXVzdCBzdGFydCBhdCB0aGUgbmV4dCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGxvb2sgZm9yLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgc3RyaW5nIHdhcyBmb3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzTmV4dFN0cmluZyhzdHIpIHtcbiAgICB2YXIgc3RhcnQgPSBjdXJzb3IgKyAxO1xuICAgIHJldHVybiAoc3RyID09PSBjc3Muc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgc3RyLmxlbmd0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIGEgc3Vic3RyaW5nIGJlZ2lubmluZyBmcm9tIHRoZSBuZXh0XG4gICAqIHBvc2l0aW9uLiBUaGUgc3RyaW5nIGJlaW5nIGxvb2tlZCBmb3IgbWF5IGJlZ2luIGFueXdoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJzdHJpbmcgdG8gbG9vayBmb3IuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ8ZmFsc2V9IFRoZSBwb3NpdGlvbiwgb3IgYGZhbHNlYCBpZiBub3QgZm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kKHN0cikge1xuICAgIHZhciBwb3MgPSBjc3Muc2xpY2UoY3Vyc29yKS5pbmRleE9mKHN0cik7XG5cbiAgICByZXR1cm4gcG9zID4gMCA/IHBvcyA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY2hhcmFjdGVyIGlzIG5leHQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjaCBDaGFyYWN0ZXIuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgbmV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzTmV4dENoYXIoY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IHBlZWsoMSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGdpdmVuIGN1cnNvciBvZmZzZXQuIFRoZSBvZmZzZXQgaXMgcmVsYXRpdmVcbiAgICogdG8gdGhlIGN1cnNvciwgc28gbmVnYXRpdmUgdmFsdWVzIG1vdmUgYmFja3dhcmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0xXSBDdXJzb3Igb2Zmc2V0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBwZWVrKG9mZnNldCkge1xuICAgIHJldHVybiBjc3NbY3Vyc29yICsgKG9mZnNldCB8fCAxKV07XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjdXJyZW50IHN0YXRlIGZyb20gdGhlIHN0YWNrIGFuZCBzZXQgdGhlIG5ldyBjdXJyZW50IHN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVtb3ZlZCBzdGF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgIHZhciByZW1vdmVkID0gc3RhY2sucG9wKCk7XG4gICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblxuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBzdGF0ZSBhbmQgYWRkIGl0IHRvIHRoZSBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1N0YXRlIFRoZSBuZXcgc3RhdGUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBuZXcgc3RhY2sgbGVuZ3RoLlxuICAgKi9cbiAgZnVuY3Rpb24gcHVzaFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBzdGFjay5wdXNoKHN0YXRlKTtcblxuICAgIHJldHVybiBzdGFjay5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgY3VycmVudCBzdGF0ZSB3aXRoIGEgbmV3IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3U3RhdGUgVGhlIG5ldyBzdGF0ZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlcGxhY2VkIHN0YXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKG5ld1N0YXRlKSB7XG4gICAgdmFyIHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9IHN0YXRlID0gbmV3U3RhdGU7XG5cbiAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBjaGFyYWN0ZXIgY3Vyc29yLiBQb3NpdGl2ZSBudW1iZXJzIG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkLlxuICAgKiBOZWdhdGl2ZSBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkIVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW249MV0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2tpcC5cbiAgICovXG4gIGZ1bmN0aW9uIHNraXAobikge1xuICAgIGlmICgobiB8fCAxKSA9PSAxKSB7XG4gICAgICBpZiAoY3NzW2N1cnNvcl0gPT0gJ1xcbicpIHtcbiAgICAgICAgbGluZSsrO1xuICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uKys7XG4gICAgICB9XG4gICAgICBjdXJzb3IrKztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBTdHIgPSBjc3Muc2xpY2UoY3Vyc29yLCBjdXJzb3IgKyBuKS5zcGxpdCgnXFxuJyk7XG4gICAgICBpZiAoc2tpcFN0ci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxpbmUgKz0gc2tpcFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgfVxuICAgICAgY29sdW1uICs9IHNraXBTdHJbc2tpcFN0ci5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICBjdXJzb3IgPSBjdXJzb3IgKyBuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGN1cnJlbnQgdG9rZW4gdG8gdGhlIHBpbGUgYW5kIHJlc2V0IHRoZSBidWZmZXIuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRUb2tlbigpIHtcbiAgICB0b2tlbi5lbmQgPSB7XG4gICAgICBsaW5lOiBsaW5lLFxuICAgICAgY29sOiBjb2x1bW5cbiAgICB9O1xuXG4gICAgREVCVUcgJiYgZGVidWcoJ2FkZFRva2VuOicsIEpTT04uc3RyaW5naWZ5KHRva2VuLCBudWxsLCAyKSk7XG5cbiAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICBidWZmZXIgPSAnJztcbiAgICB0b2tlbiA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVG9rZW4gdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVUb2tlbih0eXBlKSB7XG4gICAgdG9rZW4gPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgY29sIDogY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIC0tIE1haW4gTG9vcCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKlxuICBUaGUgbWFpbiBsb29wIGlzIGEgc3RhdGUgbWFjaGluZSB0aGF0IHJlYWRzIGluIG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lLFxuICBhbmQgZGV0ZXJtaW5lcyB3aGF0IHRvIGRvIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBjaGFyYWN0ZXIuXG4gIFRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzZXJpZXMgb2YgbmVzdGVkIGBzd2l0Y2hgIHN0YXRlbWVudHMgYW5kIHRoZVxuICBjYXNlIG9yZGVycyBoYXZlIGJlZW4gbWlsZGx5IG9wdGltaXplZCBiYXNlZCBvbiByb3VnaCBwcm9iYWJpbGl0aWVzXG4gIGNhbGN1bGF0ZWQgYnkgcHJvY2Vzc2luZyBhIHNtYWxsIHNhbXBsZSBvZiByZWFsLXdvcmxkIENTUy5cblxuICBGdXJ0aGVyIG9wdGltaXphdGlvbiAoc3VjaCBhcyBhIGRpc3BhdGNoIHRhYmxlKSBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5XG4gIHNpbmNlIHRoZSB0b3RhbCBudW1iZXIgb2YgY2FzZXMgaXMgdmVyeSBsb3cuXG4gICovXG5cbiAgVElNRVIgJiYgKHN0YXJ0ID0gRGF0ZS5ub3coKSk7XG5cbiAgd2hpbGUgKGNoID0gZ2V0Q2goKSkge1xuICAgIERFQlVHICYmIGRlYnVnKGNoLCBnZXRTdGF0ZSgpKTtcblxuICAgIC8vIGNvbHVtbiArPSAxO1xuXG4gICAgc3dpdGNoIChjaCkge1xuICAgIC8vIFNwYWNlXG4gICAgY2FzZSAnICc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgIGNhc2UgJ3ZhbHVlLXBhcmVuJzpcbiAgICAgIGNhc2UgJ2F0LWdyb3VwJzpcbiAgICAgIGNhc2UgJ2F0LXZhbHVlJzpcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XG4gICAgICBjYXNlICdzaW5nbGUtc3RyaW5nJzpcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gTmV3bGluZSBvciB0YWJcbiAgICBjYXNlICdcXG4nOlxuICAgIGNhc2UgJ1xcdCc6XG4gICAgY2FzZSAnXFxyJzpcbiAgICBjYXNlICdcXGYnOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICBjYXNlICd2YWx1ZS1wYXJlbic6XG4gICAgICBjYXNlICdhdC1ncm91cCc6XG4gICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XG4gICAgICBjYXNlICdzZWxlY3Rvcic6XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2F0LXZhbHVlJzpcbiAgICAgICAgLy8gVG9rZW5pemUgYW4gQC1ydWxlIGlmIGEgc2VtaS1jb2xvbiB3YXMgb21pdHRlZC5cbiAgICAgICAgaWYgKCdcXG4nID09PSBjaCkge1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gYnVmZmVyLnRyaW0oKTtcbiAgICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICAgIHBvcFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmICgnXFxuJyA9PT0gY2gpIHtcbiAgICAgIC8vICAgY29sdW1uID0gMDtcbiAgICAgIC8vICAgbGluZSArPSAxO1xuICAgICAgLy8gfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc6JzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgIHRva2VuLm5hbWUgPSBidWZmZXIudHJpbSgpO1xuICAgICAgICBidWZmZXIgPSAnJztcblxuICAgICAgICByZXBsYWNlU3RhdGUoJ2JlZm9yZS12YWx1ZScpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLXNlbGVjdG9yJzpcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuXG4gICAgICAgIGluaXRpYWxpemVUb2tlbignc2VsZWN0b3InKTtcbiAgICAgICAgcHVzaFN0YXRlKCdzZWxlY3RvcicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc7JzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAvLyBUb2tlbml6ZSBhIGRlY2xhcmF0aW9uXG4gICAgICAgIC8vIGlmIHZhbHVlIGlzIGVtcHR5IHNraXAgdGhlIGRlY2xhcmF0aW9uXG4gICAgICAgIGlmIChidWZmZXIudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9IGJ1ZmZlci50cmltKCksXG4gICAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlU3RhdGUoJ2JlZm9yZS1uYW1lJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2YWx1ZS1wYXJlbic6XG4gICAgICAgIC8vIEluc2lnbmlmaWNhbnQgc2VtaS1jb2xvblxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhdC12YWx1ZSc6XG4gICAgICAgIC8vIFRva2VuaXplIGFuIEAtcnVsZVxuICAgICAgICB0b2tlbi52YWx1ZSA9IGJ1ZmZlci50cmltKCk7XG4gICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgIHBvcFN0YXRlKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtbmFtZSc6XG4gICAgICAgIC8vIEV4dHJhbmVvdXMgc2VtaS1jb2xvblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAneyc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcbiAgICAgICAgLy8gSWYgdGhlIHNlcXVlbmNlIGlzIGBcXHtgIHRoZW4gYXNzdW1lIHRoYXQgdGhlIGJyYWNlIHNob3VsZCBiZSBlc2NhcGVkLlxuICAgICAgICBpZiAocGVlaygtMSkgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb2tlbml6ZSBhIHNlbGVjdG9yXG4gICAgICAgIHRva2VuLnRleHQgPSBidWZmZXIudHJpbSgpO1xuICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICByZXBsYWNlU3RhdGUoJ2JlZm9yZS1uYW1lJyk7XG4gICAgICAgIGRlcHRoID0gZGVwdGggKyAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXQtZ3JvdXAnOlxuICAgICAgICAvLyBUb2tlbml6ZSBhbiBALWdyb3VwXG4gICAgICAgIHRva2VuLm5hbWUgPSBidWZmZXIudHJpbSgpO1xuXG4gICAgICAgIC8vIFhYWDogQC1ydWxlcyBhcmUgc3RhcnRpbmcgdG8gZ2V0IGhhaXJ5XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdmb250LWZhY2UnOlxuICAgICAgICBjYXNlICd2aWV3cG9ydCcgOlxuICAgICAgICBjYXNlICdwYWdlJyAgICAgOlxuICAgICAgICAgIHB1c2hTdGF0ZSgnYmVmb3JlLW5hbWUnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hTdGF0ZSgnYmVmb3JlLXNlbGVjdG9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICBkZXB0aCA9IGRlcHRoICsgMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgY2FzZSAnYXQtcnVsZSc6XG4gICAgICAgIC8vIFRva2VuaXplIGEgZGVjbGFyYXRpb24gb3IgYW4gQC1ydWxlXG4gICAgICAgIHRva2VuLm5hbWUgPSBidWZmZXIudHJpbSgpO1xuICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICBwdXNoU3RhdGUoJ2JlZm9yZS1uYW1lJyk7XG4gICAgICAgIGRlcHRoID0gZGVwdGggKyAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgICAvLyBJZ25vcmUgYnJhY2VzIGluIGNvbW1lbnRzIGFuZCBzdHJpbmdzXG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnfSc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ2JlZm9yZS1uYW1lJzpcbiAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgLy8gSWYgdGhlIGJ1ZmZlciBjb250YWlucyBhbnl0aGluZywgaXQgaXMgYSB2YWx1ZVxuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSBidWZmZXIudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgdG9rZW4gaGFzIGEgbmFtZSBhbmQgYSB2YWx1ZSBpdCBzaG91bGQgYmUgdG9rZW5pemVkLlxuICAgICAgICBpZiAodG9rZW4ubmFtZSAmJiB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMZWF2ZSB0aGUgYmxvY2tcbiAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdlbmQnKTtcbiAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgcG9wU3RhdGUoKTtcblxuICAgICAgICAvLyBXZSBtaWdodCBuZWVkIHRvIGxlYXZlIGFnYWluLlxuICAgICAgICAvLyBYWFg6IFdoYXQgYWJvdXQgMyBsZXZlbHMgZGVlcD9cbiAgICAgICAgaWYgKCdhdC1ncm91cCcgPT09IGdldFN0YXRlKCkpIHtcbiAgICAgICAgICBpbml0aWFsaXplVG9rZW4oJ2F0LWdyb3VwLWVuZCcpO1xuICAgICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgICAgIGRlcHRoID0gZGVwdGggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2F0LWdyb3VwJzpcbiAgICAgIGNhc2UgJ2JlZm9yZS1zZWxlY3Rvcic6XG4gICAgICBjYXNlICdzZWxlY3Rvcic6XG4gICAgICAgIC8vIElmIHRoZSBzZXF1ZW5jZSBpcyBgXFx9YCB0aGVuIGFzc3VtZSB0aGF0IHRoZSBicmFjZSBzaG91bGQgYmUgZXNjYXBlZC5cbiAgICAgICAgaWYgKHBlZWsoLTEpID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgICAgIC8vIExlYXZlIGJsb2NrIGlmIGluIGFuIGF0LWdyb3VwXG4gICAgICAgICAgaWYgKCdhdC1ncm91cCcgPT09IGdldFN0YXRlKDEpKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplVG9rZW4oJ2F0LWdyb3VwLWVuZCcpO1xuICAgICAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgICAgICBkZXB0aCA9IGRlcHRoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XG4gICAgICBjYXNlICdzaW5nbGUtc3RyaW5nJzpcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAvLyBJZ25vcmUgYnJhY2VzIGluIGNvbW1lbnRzIGFuZCBzdHJpbmdzLlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIC8vIFN0cmluZ3NcbiAgICBjYXNlICdcIic6XG4gICAgY2FzZSBcIidcIjpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XG4gICAgICAgIGlmICgnXCInID09PSBjaCAmJiAnXFxcXCcgIT09IHBlZWsoLTEpKSB7XG4gICAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XG4gICAgICAgIGlmIChcIidcIiA9PT0gY2ggJiYgJ1xcXFwnICE9PSBwZWVrKC0xKSkge1xuICAgICAgICAgIHBvcFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS1hdC12YWx1ZSc6XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgnYXQtdmFsdWUnKTtcbiAgICAgICAgcHVzaFN0YXRlKCdcIicgPT09IGNoID8gJ2RvdWJsZS1zdHJpbmcnIDogJ3NpbmdsZS1zdHJpbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcbiAgICAgICAgcHVzaFN0YXRlKCdcIicgPT09IGNoID8gJ2RvdWJsZS1zdHJpbmcnIDogJ3NpbmdsZS1zdHJpbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAvLyBJZ25vcmUgc3RyaW5ncyB3aXRoaW4gY29tbWVudHMuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoJ1xcXFwnICE9PSBwZWVrKC0xKSkge1xuICAgICAgICAgIHB1c2hTdGF0ZSgnXCInID09PSBjaCA/ICdkb3VibGUtc3RyaW5nJyA6ICdzaW5nbGUtc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBDb21tZW50c1xuICAgIGNhc2UgJy8nOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgIGNhc2UgJ2RvdWJsZS1zdHJpbmcnOlxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XG4gICAgICAgIC8vIElnbm9yZVxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgY2FzZSAnc2VsZWN0b3InOlxuICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIGlmIChpc05leHRDaGFyKCcqJykpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgY29tbWVudHMgaW4gc2VsZWN0b3JzLCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuIFRoZXkgYXJlXG4gICAgICAgICAgLy8gZGlmZmljdWx0IHRvIHJlcHJlc2VudCBpbiB0aGUgQVNULlxuICAgICAgICAgIHZhciBwb3MgPSBmaW5kKCcqLycpO1xuXG4gICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgc2tpcChwb3MgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGdldFN0YXRlKCkgPT0gJ2JlZm9yZS12YWx1ZScpIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcbiAgICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChpc05leHRDaGFyKCcqJykpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBjb21tZW50IHRva2VuXG4gICAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdjb21tZW50Jyk7XG4gICAgICAgICAgcHVzaFN0YXRlKCdjb21tZW50Jyk7XG4gICAgICAgICAgc2tpcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gQ29tbWVudCBlbmQgb3IgdW5pdmVyc2FsIHNlbGVjdG9yXG4gICAgY2FzZSAnKic6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICBpZiAoaXNOZXh0Q2hhcignLycpKSB7XG4gICAgICAgICAgLy8gVG9rZW5pemUgYSBjb21tZW50XG4gICAgICAgICAgdG9rZW4udGV4dCA9IGJ1ZmZlcjsgLy8gRG9uJ3QgdHJpbSgpIVxuICAgICAgICAgIHNraXAoKTtcbiAgICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICAgIHBvcFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtc2VsZWN0b3InOlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGluaXRpYWxpemVUb2tlbignc2VsZWN0b3InKTtcbiAgICAgICAgcHVzaFN0YXRlKCdzZWxlY3RvcicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIC8vIEAtcnVsZXNcbiAgICBjYXNlICdAJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHN1cHBvcnRlZCBALXJ1bGVzIGFuZCBhdHRlbXB0IHRvIHRva2VuaXplIG9uZS5cbiAgICAgICAgdmFyIHRva2VuaXplZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgdmFyIHJ1bGU7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGF0UnVsZXMubGVuZ3RoOyAhdG9rZW5pemVkICYmIGogPCBsZW47ICsraikge1xuICAgICAgICAgIHJ1bGUgPSBhdFJ1bGVzW2pdO1xuICAgICAgICAgIG5hbWUgPSBydWxlLm5hbWUgfHwgcnVsZTtcblxuICAgICAgICAgIGlmICghaXNOZXh0U3RyaW5nKG5hbWUpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB0b2tlbml6ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaW5pdGlhbGl6ZVRva2VuKG5hbWUpO1xuICAgICAgICAgIHB1c2hTdGF0ZShydWxlLnN0YXRlIHx8ICdhdC1ncm91cCcpO1xuICAgICAgICAgIHNraXAobmFtZS5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKHJ1bGUucHJlZml4KSB7XG4gICAgICAgICAgICB0b2tlbi5wcmVmaXggPSBydWxlLnByZWZpeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocnVsZS50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gcnVsZS50eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9rZW5pemVkKSB7XG4gICAgICAgICAgLy8gS2VlcCBvbiB0cnVja2luJyBBbWVyaWNhIVxuICAgICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gUGFyZW50aGVzZXMgYXJlIHRyYWNrZWQgdG8gZGlzYW1iaWd1YXRlIHNlbWktY29sb25zLCBzdWNoIGFzIHdpdGhpbiBhXG4gICAgLy8gZGF0YSBVUkkuXG4gICAgY2FzZSAnKCc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgcHVzaFN0YXRlKCd2YWx1ZS1wYXJlbicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnKSc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ3ZhbHVlLXBhcmVuJzpcbiAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBidWZmZXIgKz0gY2g7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ2JlZm9yZS1zZWxlY3Rvcic6XG4gICAgICAgIGluaXRpYWxpemVUb2tlbignc2VsZWN0b3InKTtcbiAgICAgICAgcHVzaFN0YXRlKCdzZWxlY3RvcicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLW5hbWUnOlxuICAgICAgICBpbml0aWFsaXplVG9rZW4oJ3Byb3BlcnR5Jyk7XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgnbmFtZScpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgICAgcmVwbGFjZVN0YXRlKCd2YWx1ZScpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLWF0LXZhbHVlJzpcbiAgICAgICAgcmVwbGFjZVN0YXRlKCdhdC12YWx1ZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgVElNRVIgJiYgZGVidWcoJ3JhbiBpbicsIChEYXRlLm5vdygpIC0gc3RhcnQpICsgJ21zJyk7XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cbiIsInZhciBERUJVRyA9IGZhbHNlOyAvLyBgdHJ1ZWAgdG8gcHJpbnQgZGVidWdnaW5nIGluZm8uXG52YXIgVElNRVIgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHRpbWUgY2FsbHMgdG8gYHBhcnNlKClgIGFuZCBwcmludCB0aGUgcmVzdWx0cy5cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpKCdwYXJzZScpO1xudmFyIGxleCA9IHJlcXVpcmUoJy4vbGV4ZXInKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5cbnZhciBfY29tbWVudHM7ICAgLy8gV2hldGhlciBjb21tZW50cyBhcmUgYWxsb3dlZC5cbnZhciBfZGVwdGg7ICAgICAgLy8gQ3VycmVudCBibG9jayBuZXN0aW5nIGRlcHRoLlxudmFyIF9wb3NpdGlvbjsgICAvLyBXaGV0aGVyIHRvIGluY2x1ZGUgbGluZS9jb2x1bW4gcG9zaXRpb24uXG52YXIgX3Rva2VuczsgICAgIC8vIEFycmF5IG9mIGxleGljYWwgdG9rZW5zLlxuXG4vKipcbiAqIENvbnZlcnQgYSBDU1Mgc3RyaW5nIG9yIGFycmF5IG9mIGxleGljYWwgdG9rZW5zIGludG8gYSBgc3RyaW5naWZ5YC1hYmxlIEFTVC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzIENTUyBzdHJpbmcgb3IgYXJyYXkgb2YgbGV4aWNhbCB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21tZW50cz1mYWxzZV0gYWxsb3cgY29tbWVudCBub2RlcyBpbiB0aGUgQVNUXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBgc3RyaW5naWZ5YC1hYmxlIEFTVFxuICovXG5mdW5jdGlvbiBwYXJzZShjc3MsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YXJ0OyAvLyBEZWJ1ZyB0aW1lciBzdGFydC5cblxuICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICBfY29tbWVudHMgPSAhIW9wdGlvbnMuY29tbWVudHM7XG4gIF9wb3NpdGlvbiA9ICEhb3B0aW9ucy5wb3NpdGlvbjtcblxuICBfZGVwdGggPSAwO1xuXG4gIC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHRoZSBnaXZlbiB0b2tlbnMsIG9yIHRoZSBsZXgoKSdkIENTUyBzdHJpbmcuXG4gIF90b2tlbnMgPSBBcnJheS5pc0FycmF5KGNzcykgPyBjc3Muc2xpY2UoKSA6IGxleChjc3MpO1xuXG4gIHZhciBydWxlO1xuICB2YXIgcnVsZXMgPSBbXTtcbiAgdmFyIHRva2VuO1xuXG4gIFRJTUVSICYmIChzdGFydCA9IERhdGUubm93KCkpO1xuXG4gIHdoaWxlICgodG9rZW4gPSBuZXh0KCkpKSB7XG4gICAgcnVsZSA9IHBhcnNlVG9rZW4odG9rZW4pO1xuICAgIHJ1bGUgJiYgcnVsZXMucHVzaChydWxlKTtcbiAgfVxuXG4gIFRJTUVSICYmIGRlYnVnKCdyYW4gaW4nLCAoRGF0ZS5ub3coKSAtIHN0YXJ0KSArICdtcycpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdHlsZXNoZWV0XCIsXG4gICAgc3R5bGVzaGVldDoge1xuICAgICAgcnVsZXM6IHJ1bGVzXG4gICAgfVxuICB9O1xufVxuXG4vLyAtLSBGdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBCdWlsZCBhbiBBU1Qgbm9kZSBmcm9tIGEgbGV4aWNhbCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gbGV4aWNhbCB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvdmVycmlkZV0gb2JqZWN0IGhhc2ggb2YgcHJvcGVydGllcyB0aGF0IG92ZXJyaWRlIHRob3NlXG4gKiAgIGFscmVhZHkgaW4gdGhlIHRva2VuLCBvciB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRva2VuLlxuICogQHJldHVybnMge09iamVjdH0gQVNUIG5vZGVcbiAqL1xuZnVuY3Rpb24gYXN0Tm9kZSh0b2tlbiwgb3ZlcnJpZGUpIHtcbiAgb3ZlcnJpZGUgfHwgKG92ZXJyaWRlID0ge30pO1xuXG4gIHZhciBrZXk7XG4gIHZhciBrZXlzID0gWyd0eXBlJywgJ25hbWUnLCAndmFsdWUnXTtcbiAgdmFyIG5vZGUgPSB7fTtcblxuICAvLyBBdm9pZGluZyBbXS5mb3JFYWNoIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKHRva2VuW2tleV0pIHtcbiAgICAgIG5vZGVba2V5XSA9IG92ZXJyaWRlW2tleV0gfHwgdG9rZW5ba2V5XTtcbiAgICB9XG4gIH1cblxuICBrZXlzID0gT2JqZWN0LmtleXMob3ZlcnJpZGUpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghbm9kZVtrZXldKSB7XG4gICAgICBub2RlW2tleV0gPSBvdmVycmlkZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfcG9zaXRpb24pIHtcbiAgICBub2RlLnBvc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IHRva2VuLnN0YXJ0LFxuICAgICAgZW5kOiB0b2tlbi5lbmRcbiAgICB9O1xuICB9XG5cbiAgREVCVUcgJiYgZGVidWcoJ2FzdE5vZGU6JywgSlNPTi5zdHJpbmdpZnkobm9kZSwgbnVsbCwgMikpO1xuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGxleGljYWwgdG9rZW4gZnJvbSB0aGUgc3RhY2sgYW5kIHJldHVybiB0aGUgcmVtb3ZlZCB0b2tlbi5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsZXhpY2FsIHRva2VuXG4gKi9cbmZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciB0b2tlbiA9IF90b2tlbnMuc2hpZnQoKTtcbiAgREVCVUcgJiYgZGVidWcoJ25leHQ6JywgSlNPTi5zdHJpbmdpZnkodG9rZW4sIG51bGwsIDIpKTtcbiAgcmV0dXJuIHRva2VuO1xufVxuXG4vLyAtLSBQYXJzZSogRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQC1ncm91cCBsZXhpY2FsIHRva2VuIHRvIGFuIEFTVCBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBALWdyb3VwIGxleGljYWwgdG9rZW5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEAtZ3JvdXAgQVNUIG5vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBdEdyb3VwKHRva2VuKSB7XG4gIF9kZXB0aCA9IF9kZXB0aCArIDE7XG5cbiAgLy8gQXMgdGhlIEAtZ3JvdXAgdG9rZW4gaXMgYXNzZW1ibGVkLCByZWxldmFudCB0b2tlbiB2YWx1ZXMgYXJlIGNhcHR1cmVkIGhlcmVcbiAgLy8gdGVtcG9yYXJpbHkuIFRoZXkgd2lsbCBsYXRlciBiZSB1c2VkIGFzIGB0b2tlbml6ZSgpYCBvdmVycmlkZXMuXG4gIHZhciBvdmVycmlkZXMgPSB7fTtcblxuICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgY2FzZSAnZm9udC1mYWNlJzpcbiAgY2FzZSAndmlld3BvcnQnIDpcbiAgICBvdmVycmlkZXMuZGVjbGFyYXRpb25zID0gcGFyc2VEZWNsYXJhdGlvbnMoKTtcbiAgICBicmVhaztcblxuICBjYXNlICdwYWdlJzpcbiAgICBvdmVycmlkZXMucHJlZml4ID0gdG9rZW4ucHJlZml4O1xuICAgIG92ZXJyaWRlcy5kZWNsYXJhdGlvbnMgPSBwYXJzZURlY2xhcmF0aW9ucygpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgb3ZlcnJpZGVzLnByZWZpeCA9IHRva2VuLnByZWZpeDtcbiAgICBvdmVycmlkZXMucnVsZXMgPSBwYXJzZVJ1bGVzKCk7XG4gIH1cblxuICByZXR1cm4gYXN0Tm9kZSh0b2tlbiwgb3ZlcnJpZGVzKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEBpbXBvcnQgbGV4aWNhbCB0b2tlbiB0byBhbiBBU1Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gQGltcG9ydCBsZXhpY2FsIHRva2VuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBAaW1wb3J0IEFTVCBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXRJbXBvcnQodG9rZW4pIHtcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQGNoYXJzZXQgdG9rZW4gdG8gYW4gQVNUIG5vZGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIEBjaGFyc2V0IGxleGljYWwgdG9rZW5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEBjaGFyc2V0IG5vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VDaGFyc2V0KHRva2VuKSB7XG4gIHJldHVybiBhc3ROb2RlKHRva2VuKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgY29tbWVudCB0b2tlbiB0byBhbiBBU1QgTm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gY29tbWVudCBsZXhpY2FsIHRva2VuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjb21tZW50IG5vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VDb21tZW50KHRva2VuKSB7XG4gIHJldHVybiBhc3ROb2RlKHRva2VuLCB7dGV4dDogdG9rZW4udGV4dH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZU5hbWVzcGFjZSh0b2tlbikge1xuICByZXR1cm4gYXN0Tm9kZSh0b2tlbik7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHByb3BlcnR5IGxleGljYWwgdG9rZW4gdG8gYSBwcm9wZXJ0eSBBU1Qgbm9kZS5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwcm9wZXJ0eSBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvcGVydHkodG9rZW4pIHtcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzZWxlY3RvciBsZXhpY2FsIHRva2VuIHRvIGEgc2VsZWN0b3IgQVNUIG5vZGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIHNlbGVjdG9yIGxleGljYWwgdG9rZW5cbiAqIEByZXR1cm5zIHtPYmplY3R9IHNlbGVjdG9yIG5vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VTZWxlY3Rvcih0b2tlbikge1xuICBmdW5jdGlvbiB0cmltKHN0cikge1xuICAgIHJldHVybiBzdHIudHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4sIHtcbiAgICB0eXBlOiAncnVsZScsXG4gICAgc2VsZWN0b3JzOiB0b2tlbi50ZXh0LnNwbGl0KCcsJykubWFwKHRyaW0pLFxuICAgIGRlY2xhcmF0aW9uczogcGFyc2VEZWNsYXJhdGlvbnModG9rZW4pXG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBsZXhpY2FsIHRva2VuIHRvIGFuIEFTVCBub2RlLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSBBU1Qgbm9kZVxuICovXG5mdW5jdGlvbiBwYXJzZVRva2VuKHRva2VuKSB7XG4gIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAvLyBDYXNlcyBhcmUgbGlzdGVkIGluIHJvdWdobHkgZGVzY2VuZGluZyBvcmRlciBvZiBwcm9iYWJpbGl0eS5cbiAgY2FzZSAncHJvcGVydHknOiByZXR1cm4gcGFyc2VQcm9wZXJ0eSh0b2tlbik7XG5cbiAgY2FzZSAnc2VsZWN0b3InOiByZXR1cm4gcGFyc2VTZWxlY3Rvcih0b2tlbik7XG5cbiAgY2FzZSAnYXQtZ3JvdXAtZW5kJzogX2RlcHRoID0gX2RlcHRoIC0gMTsgcmV0dXJuO1xuXG4gIGNhc2UgJ21lZGlhJyAgICAgOlxuICBjYXNlICdrZXlmcmFtZXMnIDpyZXR1cm4gcGFyc2VBdEdyb3VwKHRva2VuKTtcblxuICBjYXNlICdjb21tZW50JzogaWYgKF9jb21tZW50cykgeyByZXR1cm4gcGFyc2VDb21tZW50KHRva2VuKTsgfSBicmVhaztcblxuICBjYXNlICdjaGFyc2V0JzogcmV0dXJuIHBhcnNlQ2hhcnNldCh0b2tlbik7XG4gIGNhc2UgJ2ltcG9ydCc6IHJldHVybiBwYXJzZUF0SW1wb3J0KHRva2VuKTtcblxuICBjYXNlICduYW1lc3BhY2UnOiByZXR1cm4gcGFyc2VOYW1lc3BhY2UodG9rZW4pO1xuXG4gIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gIGNhc2UgJ3N1cHBvcnRzJyA6XG4gIGNhc2UgJ3ZpZXdwb3J0JyA6XG4gIGNhc2UgJ2RvY3VtZW50JyA6XG4gIGNhc2UgJ3BhZ2UnICAgICA6IHJldHVybiBwYXJzZUF0R3JvdXAodG9rZW4pO1xuICB9XG5cbiAgREVCVUcgJiYgZGVidWcoJ3BhcnNlVG9rZW46IHVuZXhwZWN0ZWQgdG9rZW46JywgSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcbn1cblxuLy8gLS0gUGFyc2UgSGVscGVyIEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBJdGVyYXRpdmVseSBwYXJzZXMgbGV4aWNhbCB0b2tlbnMgZnJvbSB0aGUgc3RhY2sgaW50byBBU1Qgbm9kZXMgdW50aWwgYVxuICogY29uZGl0aW9uYWwgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLCBhdCB3aGljaCBwb2ludCBpdGVyYXRpb24gdGVybWluYXRlc1xuICogYW5kIGFueSBBU1Qgbm9kZXMgY29sbGVjdGVkIGFyZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb25GblxuICogICBAcGFyYW0ge09iamVjdH0gdG9rZW4gdGhlIGxleGljYWwgdG9rZW4gYmVpbmcgcGFyc2VkXG4gKiAgIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHRva2VuIHNob3VsZCBiZSBwYXJzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAcmV0dXJuIHtBcnJheX0gQVNUIG5vZGVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zV2hpbGUoY29uZGl0aW9uRm4pIHtcbiAgdmFyIG5vZGU7XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgdG9rZW47XG5cbiAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgJiYgKGNvbmRpdGlvbkZuICYmIGNvbmRpdGlvbkZuKHRva2VuKSkpIHtcbiAgICBub2RlID0gcGFyc2VUb2tlbih0b2tlbik7XG4gICAgbm9kZSAmJiBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgLy8gUGxhY2UgYW4gdW51c2VkIG5vbi1gZW5kYCBsZXhpY2FsIHRva2VuIGJhY2sgb250byB0aGUgc3RhY2suXG4gIGlmICh0b2tlbiAmJiB0b2tlbi50eXBlICE9PSAnZW5kJykge1xuICAgIF90b2tlbnMudW5zaGlmdCh0b2tlbik7XG4gIH1cblxuICByZXR1cm4gbm9kZXM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHNlcmllcyBvZiB0b2tlbnMgaW50byBhIHNlcXVlbmNlIG9mIGRlY2xhcmF0aW9uIEFTVCBub2Rlcy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRlY2xhcmF0aW9uIG5vZGVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGVjbGFyYXRpb25zKCkge1xuICByZXR1cm4gcGFyc2VUb2tlbnNXaGlsZShmdW5jdGlvbiAodG9rZW4pIHtcbiAgICByZXR1cm4gKHRva2VuLnR5cGUgPT09ICdwcm9wZXJ0eScgfHwgdG9rZW4udHlwZSA9PT0gJ2NvbW1lbnQnKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHNlcmllcyBvZiB0b2tlbnMgaW50byBhIHNlcXVlbmNlIG9mIHJ1bGUgbm9kZXMuXG4gKlxuICogQHJldHVybnMge0FycmF5fSBydWxlIG5vZGVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUnVsZXMoKSB7XG4gIHJldHVybiBwYXJzZVRva2Vuc1doaWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9kZXB0aDsgfSk7XG59XG4iLCJ2YXIgREVCVUcgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHByaW50IGRlYnVnZ2luZyBpbmZvLlxudmFyIFRJTUVSID0gZmFsc2U7IC8vIGB0cnVlYCB0byB0aW1lIGNhbGxzIHRvIGBzdHJpbmdpZnkoKWAgYW5kIHByaW50IHRoZSByZXN1bHRzLlxuXG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJykoJ3N0cmluZ2lmeScpO1xuXG52YXIgX2NvbW1lbnRzOyAgICAgIC8vIFdoZXRoZXIgY29tbWVudHMgYXJlIGFsbG93ZWQgaW4gdGhlIHN0cmluZ2lmaWVkIENTUy5cbnZhciBfY29tcHJlc3M7ICAgICAgLy8gV2hldGhlciB0aGUgc3RyaW5naWZpZWQgQ1NTIHNob3VsZCBiZSBjb21wcmVzc2VkLlxudmFyIF9pbmRlbnRhdGlvbjsgICAvLyBJbmRlbnRhdGlvbiBvcHRpb24gdmFsdWUuXG52YXIgX247ICAgICAgICAgICAgIC8vIENvbXByZXNzaW9uLWF3YXJlIG5ld2xpbmUgY2hhcmFjdGVyLlxudmFyIF9zOyAgICAgICAgICAgICAvLyBDb21wcmVzc2lvbi1hd2FyZSBzcGFjZSBjaGFyYWN0ZXIuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2lmeWAtYWJsZSBBU1QgaW50byBhIENTUyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGBzdHJpbmdpZnlgLWFibGUgQVNUXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbW1lbnRzPWZhbHNlXSBhbGxvdyBjb21tZW50cyBpbiB0aGUgQ1NTXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBjb21wcmVzcyB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaW5kZW50YXRpb249JyddIGluZGVudGF0aW9uIHNlcXVlbmNlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDU1NcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5KGFzdCwgb3B0aW9ucykge1xuICB2YXIgc3RhcnQ7IC8vIERlYnVnIHRpbWVyIHN0YXJ0LlxuXG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIF9pbmRlbnRhdGlvbiA9IG9wdGlvbnMuaW5kZW50YXRpb24gfHwgJyc7XG4gIF9jb21wcmVzcyA9ICEhb3B0aW9ucy5jb21wcmVzcztcbiAgX2NvbW1lbnRzID0gISFvcHRpb25zLmNvbW1lbnRzO1xuXG4gIGlmIChfY29tcHJlc3MpIHtcbiAgICBfbiA9IF9zID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgX24gPSAnXFxuJztcbiAgICBfcyA9ICcgJztcbiAgfVxuXG4gIFRJTUVSICYmIChzdGFydCA9IERhdGUubm93KCkpO1xuXG4gIHZhciBjc3MgPSByZWR1Y2UoYXN0LnN0eWxlc2hlZXQucnVsZXMsIHN0cmluZ2lmeU5vZGUpLmpvaW4oJ1xcbicpLnRyaW0oKTtcblxuICBUSU1FUiAmJiBkZWJ1ZygncmFuIGluJywgKERhdGUubm93KCkgLSBzdGFydCkgKyAnbXMnKTtcblxuICByZXR1cm4gY3NzO1xufVxuXG4vLyAtLSBGdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBNb2RpZnkgdGhlIGluZGVudGF0aW9uIGxldmVsLCBvciByZXR1cm4gYSBjb21wcmVzc2lvbi1hd2FyZSBzZXF1ZW5jZSBvZlxuICogc3BhY2VzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGV2ZWw9dW5kZWZpbmVkXSBpbmRlbnRhdGlvbiBsZXZlbCBtb2RpZmllclxuICogQHJldHVybnMge1N0cmluZ30gc2VxdWVuY2Ugb2Ygc3BhY2VzXG4gKi9cbmZ1bmN0aW9uIGluZGVudChsZXZlbCkge1xuICB0aGlzLmxldmVsIHx8ICh0aGlzLmxldmVsID0gMSk7XG5cbiAgaWYgKGxldmVsKSB7XG4gICAgdGhpcy5sZXZlbCArPSBsZXZlbDtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoX2NvbXByZXNzKSB7IHJldHVybiAnJzsgfVxuXG4gIHJldHVybiBBcnJheSh0aGlzLmxldmVsKS5qb2luKF9pbmRlbnRhdGlvbiB8fCAnJyk7XG59XG5cbi8vIC0tIFN0cmluZ2lmeSBGdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU3RyaW5naWZ5IGFuIEAtcnVsZSBBU1Qgbm9kZS5cbiAqXG4gKiBVc2UgYHN0cmluZ2lmeUF0R3JvdXAoKWAgd2hlbiBkZWFsaW5nIHdpdGggQC1ncm91cHMgdGhhdCBtYXkgY29udGFpbiBibG9ja3NcbiAqIHN1Y2ggYXMgQG1lZGlhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEAtcnVsZSB0eXBlLiBFLmcuLCBpbXBvcnQsIGNoYXJzZXRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZ2lmaWVkIEAtcnVsZVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlBdFJ1bGUobm9kZSkge1xuICByZXR1cm4gJ0AnICsgbm9kZS50eXBlICsgJyAnICsgbm9kZS52YWx1ZSArICc7JyArIF9uO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSBhbiBALWdyb3VwIEFTVCBub2RlLlxuICpcbiAqIFVzZSBgc3RyaW5naWZ5QXRSdWxlKClgIHdoZW4gZGVhbGluZyB3aXRoIEAtcnVsZXMgdGhhdCBtYXkgbm90IGNvbnRhaW4gYmxvY2tzXG4gKiBzdWNoIGFzIEBpbXBvcnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgQC1ncm91cCBBU1Qgbm9kZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5QXRHcm91cChub2RlKSB7XG4gIHZhciBsYWJlbCA9ICcnO1xuICB2YXIgcHJlZml4ID0gbm9kZS5wcmVmaXggfHwgJyc7XG5cbiAgaWYgKG5vZGUubmFtZSkge1xuICAgIGxhYmVsID0gJyAnICsgbm9kZS5uYW1lO1xuICB9XG5cbiAgLy8gRklYTUU6IEAtcnVsZSBjb25kaXRpb25hbCBsb2dpYyBpcyBsZWFraW5nIGV2ZXJ5d2hlcmUuXG4gIHZhciBjaG9tcCA9IG5vZGUudHlwZSAhPT0gJ3BhZ2UnO1xuXG4gIHJldHVybiAnQCcgKyBwcmVmaXggKyBub2RlLnR5cGUgKyBsYWJlbCArIF9zICsgc3RyaW5naWZ5QmxvY2sobm9kZSwgY2hvbXApICsgX247XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IGEgY29tbWVudCBBU1Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBjb21tZW50IEFTVCBub2RlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlDb21tZW50KG5vZGUpIHtcbiAgaWYgKCFfY29tbWVudHMpIHsgcmV0dXJuICcnOyB9XG5cbiAgcmV0dXJuICcvKicgKyAobm9kZS50ZXh0IHx8ICcnKSArICcqLycgKyBfbjtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgYSBydWxlIEFTVCBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHJ1bGUgQVNUIG5vZGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVJ1bGUobm9kZSkge1xuICB2YXIgbGFiZWw7XG5cbiAgaWYgKG5vZGUuc2VsZWN0b3JzKSB7XG4gICAgbGFiZWwgPSBub2RlLnNlbGVjdG9ycy5qb2luKCcsJyArIF9uKTtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbCA9ICdAJyArIG5vZGUudHlwZTtcbiAgICBsYWJlbCArPSBub2RlLm5hbWUgPyAnICcgKyBub2RlLm5hbWUgOiAnJztcbiAgfVxuXG4gIHJldHVybiBpbmRlbnQoKSArIGxhYmVsICsgX3MgKyBzdHJpbmdpZnlCbG9jayhub2RlKSArIF9uO1xufVxuXG5cbi8vIC0tIFN0cmluZ2lmeSBIZWxwZXIgRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogUmVkdWNlIGFuIGFycmF5IGJ5IGFwcGx5aW5nIGEgZnVuY3Rpb24gdG8gZWFjaCBpdGVtIGFuZCByZXRhaW5pbmcgdGhlIHRydXRoeVxuICogcmVzdWx0cy5cbiAqXG4gKiBXaGVuIGBpdGVtLnR5cGVgIGlzIGAnY29tbWVudCdgIGBzdHJpbmdpZnlDb21tZW50YCB3aWxsIGJlIGFwcGxpZWQgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBhcnJheSB0byByZWR1Y2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXlcbiAqICAgQHJldHVybnMge01peGVkfSBUcnV0aHkgdmFsdWVzIHdpbGwgYmUgcmV0YWluZWQsIGZhbHN5IHZhbHVlcyBvbWl0dGVkXG4gKiBAcmV0dXJucyB7QXJyYXl9IHJldGFpbmVkIHJlc3VsdHNcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGl0ZW1zLCBmbikge1xuICByZXR1cm4gaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHRzLCBpdGVtKSB7XG4gICAgdmFyIHJlc3VsdCA9IChpdGVtLnR5cGUgPT09ICdjb21tZW50JykgPyBzdHJpbmdpZnlDb21tZW50KGl0ZW0pIDogZm4oaXRlbSk7XG4gICAgcmVzdWx0ICYmIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9LCBbXSk7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IGFuIEFTVCBub2RlIHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCBpdCByZXByZXNlbnRzIGEgYmxvY2sgb2ZcbiAqIGRlY2xhcmF0aW9ucyBvciBvdGhlciBALWdyb3VwIGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIEFTVCBub2RlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4vLyBGSVhNRTogY2hvbXAgc2hvdWxkIG5vdCBiZSBhIG1hZ2ljIGJvb2xlYW4gcGFyYW1ldGVyXG5mdW5jdGlvbiBzdHJpbmdpZnlCbG9jayhub2RlLCBjaG9tcCkge1xuICB2YXIgY2hpbGRyZW4gPSBub2RlLmRlY2xhcmF0aW9ucztcbiAgdmFyIGZuID0gc3RyaW5naWZ5RGVjbGFyYXRpb247XG5cbiAgaWYgKG5vZGUucnVsZXMpIHtcbiAgICBjaGlsZHJlbiA9IG5vZGUucnVsZXM7XG4gICAgZm4gPSBzdHJpbmdpZnlSdWxlO1xuICB9XG5cbiAgY2hpbGRyZW4gPSBzdHJpbmdpZnlDaGlsZHJlbihjaGlsZHJlbiwgZm4pO1xuICBjaGlsZHJlbiAmJiAoY2hpbGRyZW4gPSBfbiArIGNoaWxkcmVuICsgKGNob21wID8gJycgOiBfbikpO1xuXG4gIHJldHVybiAneycgKyBjaGlsZHJlbiArIGluZGVudCgpICsgJ30nO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSBhbiBhcnJheSBvZiBjaGlsZCBBU1Qgbm9kZXMgYnkgY2FsbGluZyB0aGUgZ2l2ZW4gc3RyaW5naWZ5IGZ1bmN0aW9uXG4gKiBvbmNlIGZvciBlYWNoIGNoaWxkLCBhbmQgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjaGlsZHJlbiBgbm9kZS5ydWxlc2Agb3IgYG5vZGUuZGVjbGFyYXRpb25zYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gc3RyaW5naWZ5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlDaGlsZHJlbihjaGlsZHJlbiwgZm4pIHtcbiAgaWYgKCFjaGlsZHJlbikgeyByZXR1cm4gJyc7IH1cblxuICBpbmRlbnQoMSk7XG4gIHZhciByZXN1bHRzID0gcmVkdWNlKGNoaWxkcmVuLCBmbik7XG4gIGluZGVudCgtMSk7XG5cbiAgaWYgKCFyZXN1bHRzLmxlbmd0aCkgeyByZXR1cm4gJyc7IH1cblxuICByZXR1cm4gcmVzdWx0cy5qb2luKF9uKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgYSBkZWNsYXJhdGlvbiBBU1Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBkZWNsYXJhdGlvbiBBU1Qgbm9kZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5RGVjbGFyYXRpb24obm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVByb3BlcnR5KG5vZGUpO1xuICB9XG5cbiAgREVCVUcgJiYgZGVidWcoJ3N0cmluZ2lmeURlY2xhcmF0aW9uOiB1bmV4cGVjdGVkIG5vZGU6JywgSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSBhbiBBU1Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBBU1Qgbm9kZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5Tm9kZShub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gIC8vIENhc2VzIGFyZSBsaXN0ZWQgaW4gcm91Z2hseSBkZXNjZW5kaW5nIG9yZGVyIG9mIHByb2JhYmlsaXR5LlxuICBjYXNlICdydWxlJzogcmV0dXJuIHN0cmluZ2lmeVJ1bGUobm9kZSk7XG5cbiAgY2FzZSAnbWVkaWEnICAgIDpcbiAgY2FzZSAna2V5ZnJhbWVzJzogcmV0dXJuIHN0cmluZ2lmeUF0R3JvdXAobm9kZSk7XG5cbiAgY2FzZSAnY29tbWVudCc6IHJldHVybiBzdHJpbmdpZnlDb21tZW50KG5vZGUpO1xuXG4gIGNhc2UgJ2ltcG9ydCcgICA6XG4gIGNhc2UgJ2NoYXJzZXQnICA6XG4gIGNhc2UgJ25hbWVzcGFjZSc6IHJldHVybiBzdHJpbmdpZnlBdFJ1bGUobm9kZSk7XG5cbiAgY2FzZSAnZm9udC1mYWNlJzpcbiAgY2FzZSAnc3VwcG9ydHMnIDpcbiAgY2FzZSAndmlld3BvcnQnIDpcbiAgY2FzZSAnZG9jdW1lbnQnIDpcbiAgY2FzZSAncGFnZScgICAgIDogcmV0dXJuIHN0cmluZ2lmeUF0R3JvdXAobm9kZSk7XG4gIH1cblxuICBERUJVRyAmJiBkZWJ1Zygnc3RyaW5naWZ5Tm9kZTogdW5leHBlY3RlZCBub2RlOiAnICsgSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSBhbiBBU1QgcHJvcGVydHkgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBBU1QgcHJvcGVydHkgbm9kZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcGVydHkobm9kZSkge1xuICB2YXIgbmFtZSA9IG5vZGUubmFtZSA/IG5vZGUubmFtZSArICc6JyArIF9zIDogJyc7XG5cbiAgcmV0dXJuIGluZGVudCgpICsgbmFtZSArIG5vZGUudmFsdWUgKyAnOyc7XG59XG4iLCIvKiFcbiogc2xpY2suanNcbiogdjEuMC4xIC0gMjAxMy0xMi0yMFxuKiBodHRwczovL2dpdGh1Yi5jb20vc2hhc2hhbmttZWh0YS9zbGljay5qc1xuKiAoYykgU2hhc2hhbmsgTWVodGE7IE1JVCBMaWNlbnNlXG4qL1xuLypnbG9iYWwgalF1ZXJ5ICovXG4oZnVuY3Rpb24gKCQsIHJvb3QpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAkLmZuLmV4aXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoICE9PSAwO1xuICAgIH07XG5cbiAgICB2YXIgU2xpY2sgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgc291cmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGFydDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBrZXlDb250cm9sOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnLnNsaWNrLWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRObzogJy5jdXJyZW50LW5vJyxcbiAgICAgICAgICAgICAgICB0b3RhbE5vOiAnLnRvdGFsJyxcbiAgICAgICAgICAgICAgICBuZXh0OiAnLm5leHQnLFxuICAgICAgICAgICAgICAgIHByZXY6ICcucHJldicsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmIG9wdGlvbiAhPT0gJ3RoZW1lJykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRpb25dID0gY29uZmlnW29wdGlvbl0gIT09IHVuZGVmaW5lZCA/IGNvbmZpZ1tvcHRpb25dIDogdGhpcy5vcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihjb25maWcudGhlbWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBmb3IgKHZhciB2YWwgaW4gdGhpcy5vcHRpb25zLnRoZW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aGVtZS5oYXNPd25Qcm9wZXJ0eSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aGVtZVt2YWxdID0gY29uZmlnLnRoZW1lW3ZhbF0gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy50aGVtZVt2YWxdIDogdGhpcy5vcHRpb25zLnRoZW1lW3ZhbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRlbnQgPSB0aGlzLm9wdGlvbnMudGhlbWUuY29udGFpbmVyICsgJyAnICsgdGhpcy5vcHRpb25zLnRoZW1lLmNvbnRlbnQ7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIC8vIFN0b3JlcyBzbGlkZSB1cmwgbm8gdGhhdCBpcyB2aXNpYmxlXG4gICAgICAgICAgICBjdXJyZW50OiB0aGlzLm9wdGlvbnMuc3RhcnQtMSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMub3B0aW9ucy5zdGFydCxcbiAgICAgICAgICAgIGVuZDogdGhpcy5vcHRpb25zLmVuZCxcblxuICAgICAgICAgICAgLy8gU3RvcmVzIHZhbHVlcyB0aGF0IGlzIHNob3duIGluIGNvbnRyb2xzXG4gICAgICAgICAgICBzbGlkZToge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IDAsXG4gICAgICAgICAgICAgICAgZGlmZmVyZW5jZTogKHRoaXMub3B0aW9ucy5zdGFydCAtIDEpLFxuICAgICAgICAgICAgICAgIHRvdGFsOiAodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCArIDEpLFxuICAgICAgICAgICAgICAgIG1heEhpdDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMpO1xuICAgIH07XG5cbiAgICB2YXIgU2xpY2tQcm90byA9IFNsaWNrLnByb3RvdHlwZTtcblxuICAgIFNsaWNrUHJvdG8uaG9va3MgPSB7XG5cbiAgICAgICAgLy8gTWFpbiBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgbmV4dC9mb3J3YXJkaW5nIG9mIHNsaWRlc1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzbGljayA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmKHNsaWNrLnN0YXRlLnNsaWRlLmN1cnJlbnQgPCBzbGljay5zdGF0ZS5zbGlkZS50b3RhbCl7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSArK3NsaWNrLnN0YXRlLnNsaWRlLmN1cnJlbnQgKyBzbGljay5zdGF0ZS5zbGlkZS5kaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIHNsaWNrLmhvb2tzLnNldFNsaWRlLmFwcGx5KHRoaXMsIFtzdGVwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTWFpbiBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgZ29pbmcgYmFja3dhcmRcbiAgICAgICAgcHJldjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBzbGljayA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmKHNsaWNrLnN0YXRlLnNsaWRlLmN1cnJlbnQgPiAxKXtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IC0tc2xpY2suc3RhdGUuc2xpZGUuY3VycmVudCArIHNsaWNrLnN0YXRlLnNsaWRlLmRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgc2xpY2suaG9va3Muc2V0U2xpZGUuYXBwbHkodGhpcywgW3N0ZXBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRTbGlkZTogZnVuY3Rpb24oc3RlcCl7XG4gICAgICAgICAgICB2YXIgc2xpY2sgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNsaWRlU3RhdHVzID0gc2xpY2suaG9va3Muc2xpZGVTdGF0dXMuYXBwbHkoc2xpY2ssIFtzdGVwXSk7XG4gICAgICAgICAgICBzbGljay5zdGF0ZS5zbGlkZS5jdXJyZW50ID0gc3RlcCAtIHNsaWNrLnN0YXRlLnNsaWRlLmRpZmZlcmVuY2U7XG5cbiAgICAgICAgICAgIGlmKHNsaWNrLnN0YXRlLnNsaWRlLmN1cnJlbnQgPT09IDEpe1xuICAgICAgICAgICAgICAgICQoc2xpY2sub3B0aW9ucy50aGVtZS5jb250YWluZXIpLmFuaW1hdGUoeydvcGFjaXR5JzogJzEnfSwgNTAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJChzbGljay5vcHRpb25zLnRoZW1lLmNvbnRhaW5lciArICcgLnNraXAnICsgc2xpY2sub3B0aW9ucy50aGVtZS5jdXJyZW50Tm8pLmlzKCc6aW5wdXQnKSl7XG4gICAgICAgICAgICAgICAgJChzbGljay5vcHRpb25zLnRoZW1lLmNvbnRhaW5lciArICcgJyArIHNsaWNrLm9wdGlvbnMudGhlbWUuY3VycmVudE5vKS52YWwoc2xpY2suc3RhdGUuc2xpZGUuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHNsaWNrLm9wdGlvbnMudGhlbWUuY29udGFpbmVyICsgJyAuc2tpcCcpLnZhbChzbGljay5zdGF0ZS5zbGlkZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAkKHNsaWNrLm9wdGlvbnMudGhlbWUuY29udGFpbmVyICsgJyAnICsgc2xpY2sub3B0aW9ucy50aGVtZS5jdXJyZW50Tm8pLmh0bWwoc2xpY2suc3RhdGUuc2xpZGUuY3VycmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoc2xpZGVTdGF0dXMgPT09IDEpe1xuICAgICAgICAgICAgICAgICQoc2xpY2sub3B0aW9ucy5jb250ZW50ICsgJyBpbWcuY3VycmVudCcpLnJlbW92ZUNsYXNzKCdjdXJyZW50JykuYWRkQ2xhc3MoJ2NhY2hlZC1zbGlkZScpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkKHNsaWNrLm9wdGlvbnMuY29udGVudCArICcgaW1nW2RhdGEtc2xpZGU9JyArIHN0ZXAgKyAnXScpLnJlbW92ZUNsYXNzKCdjYWNoZWQtc2xpZGUnKS5hZGRDbGFzcygnY3VycmVudCcpLnNob3coKTtcbiAgICAgICAgICAgICAgICBzbGljay5zdGF0ZS5jdXJyZW50ID0gc3RlcDtcbiAgICAgICAgICAgICAgICAkKHNsaWNrLm9wdGlvbnMudGhlbWUuY29udGFpbmVyICsgJyAubGVuZ3RoJykud2lkdGgoMTAwICogc2xpY2suc3RhdGUuc2xpZGUuY3VycmVudCAvIHNsaWNrLnN0YXRlLnNsaWRlLnRvdGFsICsgJyUnKTtcbiAgICAgICAgICAgICAgICBzbGljay5ob29rcy5nZXRTbGlkZS5hcHBseShzbGljaywgW3N0ZXArMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoc2xpZGVTdGF0dXMgPT09IDIpe1xuICAgICAgICAgICAgICAgIHNsaWNrLmhvb2tzLnNsaWRlU3dpdGNoLmFwcGx5KHRoaXMsIFtzdGVwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHNsaWRlU3RhdHVzID09PSAwKXtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmluZyBvbiBsb2FkIGZyb20gYWxsIHByZXZpb3VzIHN0aWxsIGxvYWRpbmcgaW1hZ2VzIFxuICAgICAgICAgICAgICAgICQoc2xpY2sub3B0aW9ucy5jb250ZW50ICsgJyBpbWcubG9hZGluZycpLm9mZignbG9hZC5zbGlkZVN3aXRjaCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHNsaWNrLmhvb2tzLmdldFNsaWRlLmFwcGx5KHNsaWNrLCBbc3RlcF0pO1xuICAgICAgICAgICAgICAgIHNsaWNrLmhvb2tzLnNsaWRlU3dpdGNoLmFwcGx5KHRoaXMsIFtzdGVwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0cyB0aGUgc2xpZGUgZm9yIHRoZSBzdGVwXG4gICAgICAgIGdldFNsaWRlOiBmdW5jdGlvbihzdGVwKXtcbiAgICAgICAgICAgIHZhciBzbGljayA9IHRoaXM7XG4gICAgICAgICAgICBpZihzbGljay5ob29rcy5zbGlkZVN0YXR1cy5hcHBseSh0aGlzLCBbc3RlcF0pID09PSAwICYmIHN0ZXAgPD0gc2xpY2suc3RhdGUuZW5kKXtcbiAgICAgICAgICAgICAgICAkKHNsaWNrLm9wdGlvbnMuY29udGVudCkuYXBwZW5kKCc8aW1nIHNyYz1cIicrIHNsaWNrLmhvb2tzLmltYWdlUGF0aC5hcHBseShzbGljaywgW3N0ZXBdKSArJ1wiIGRhdGEtc2xpZGU9JyArIHN0ZXAgKyAnIGNsYXNzPVwibG9hZGluZ1wiPicpO1xuICAgICAgICAgICAgICAgICQoc2xpY2sub3B0aW9ucy5jb250ZW50ICsgJyBpbWcubG9hZGluZycpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkKHNsaWNrLm9wdGlvbnMuY29udGVudCArICcgaW1nLmxvYWRpbmcnKS5sb2FkKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnKS5hZGRDbGFzcygnY2FjaGVkLXNsaWRlJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2xpZGVTd2l0Y2g6IGZ1bmN0aW9uKHN0ZXApe1xuICAgICAgICAgICAgdmFyIHNsaWNrID0gdGhpcztcbiAgICAgICAgICAgICQoc2xpY2sub3B0aW9ucy5jb250ZW50ICsgJyBpbWdbZGF0YS1zbGlkZT0nICsgc3RlcCArICddJykub24oJ2xvYWQuc2xpZGVTd2l0Y2gnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQoc2xpY2sub3B0aW9ucy5jb250ZW50ICsgJyBpbWcuY3VycmVudCcpLnJlbW92ZUNsYXNzKCdjdXJyZW50JykuYWRkQ2xhc3MoJ2NhY2hlZC1zbGlkZScpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdjYWNoZWQtc2xpZGUnKS5hZGRDbGFzcygnY3VycmVudCcpLnNob3coKTtcbiAgICAgICAgICAgICAgICBzbGljay5zdGF0ZS5jdXJyZW50ID0gc3RlcDtcbiAgICAgICAgICAgICAgICAkKHNsaWNrLm9wdGlvbnMudGhlbWUuY29udGFpbmVyICsgJyAubGVuZ3RoJykud2lkdGgoMTAwICogKHN0ZXAgKyAxKSAvIHNsaWNrLnN0YXRlLnNsaWRlLnRvdGFsICsgJyUnKTtcbiAgICAgICAgICAgICAgICBzbGljay5ob29rcy5nZXRTbGlkZS5hcHBseShzbGljaywgW3N0ZXArMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgc3RhdHVzIG9mIGEgc2xpZGVcbiAgICAgICAgLy8gMDogTm90IHJlcXVlc3RlZCB5ZXRcbiAgICAgICAgLy8gMTogY2FjaGVkXG4gICAgICAgIC8vIDI6IGxvYWRpbmdcbiAgICAgICAgc2xpZGVTdGF0dXM6IGZ1bmN0aW9uKHN0ZXApe1xuICAgICAgICAgICAgdmFyIHNsaWNrID0gdGhpcztcbiAgICAgICAgICAgIHZhciBlbCA9IHNsaWNrLm9wdGlvbnMuY29udGVudCArICcgaW1nW2RhdGEtc2xpZGU9JyArIHN0ZXAgKyAnXSc7XG4gICAgICAgICAgICBpZigkKGVsKS5leGlzdHMoKSl7XG4gICAgICAgICAgICAgICAgaWYoJChlbCkuaGFzQ2xhc3MoJ2xvYWRpbmcnKSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgcGF0aCB3aXRoIHRoZSBjdXJyZW50IG5vIGluc2VydGVkXG4gICAgICAgIGltYWdlUGF0aDogZnVuY3Rpb24oc3RlcCl7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSB0aGlzLm9wdGlvbnMuc291cmNlLnNwbGl0KCcqJyk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMF0gKyBzdGVwICsgcGFydHNbMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2tpcDogZnVuY3Rpb24odmFsKXtcbiAgICAgICAgICAgIGlmKCQuaXNOdW1lcmljKHZhbCkpe1xuICAgICAgICAgICAgICAgIHZhciBzbGljayA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IHBhcnNlSW50KHZhbCkgKyBzbGljay5zdGF0ZS5zbGlkZS5kaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIHNsaWNrLmhvb2tzLmdldFNsaWRlLmFwcGx5KHNsaWNrLCBbc3RlcF0pO1xuICAgICAgICAgICAgICAgIHNsaWNrLmhvb2tzLnNldFNsaWRlLmFwcGx5KHNsaWNrLCBbc3RlcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2tQcm90by5pbml0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNsaWNrID0gdGhpcztcblxuICAgICAgICAkKHNsaWNrLm9wdGlvbnMudGhlbWUuY29udGFpbmVyKS5jc3MoJ29wYWNpdHknLCAnMCcpO1xuXG4gICAgICAgIC8vIFNldHMgdGhlIGZpcnN0IHNsaWRlXG4gICAgICAgIGlmKHR5cGVvZiBzbGljay5vcHRpb25zLnNvdXJjZSA9PT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgc2xpY2suaG9va3MubmV4dC5hcHBseShzbGljayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdHRhY2hlcyBldmVudCBsaXN0ZW5lcnMgZm9yIG5leHQvcHJldiBidXR0b25zXG4gICAgICAgICQoc2xpY2sub3B0aW9ucy50aGVtZS5jb250YWluZXIgKyAnICcgKyBzbGljay5vcHRpb25zLnRoZW1lLm5leHQpLmNsaWNrKGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2xpY2suaG9va3MubmV4dC5hcHBseShzbGljayk7XG4gICAgICAgIH0pO1xuICAgICAgICAkKHNsaWNrLm9wdGlvbnMudGhlbWUuY29udGFpbmVyICsgJyAnICsgc2xpY2sub3B0aW9ucy50aGVtZS5wcmV2KS5jbGljayhmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNsaWNrLmhvb2tzLnByZXYuYXBwbHkoc2xpY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgJChzbGljay5vcHRpb25zLnRoZW1lLmNvbnRhaW5lciArICcgJyArIHNsaWNrLm9wdGlvbnMudGhlbWUudG90YWxObykuaHRtbChzbGljay5zdGF0ZS5lbmQgLSBzbGljay5zdGF0ZS5zdGFydCArIDEpO1xuXG4gICAgICAgIC8vIEF0YWNoZXMga2V5Ym9hcmQgY29udHJvbFxuICAgICAgICBpZihzbGljay5vcHRpb25zLmtleUNvbnRyb2wpe1xuICAgICAgICAgICAgJChkb2N1bWVudCkua2V5dXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICgoZS5rZXlDb2RlID09PSAgMzkpICYmICEkKCdpbnB1dDpmb2N1cycpLmV4aXN0cygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWNrLmhvb2tzLm5leHQuYXBwbHkoc2xpY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGUua2V5Q29kZSA9PT0gIDM3KSAmJiAhJCgnaW5wdXQ6Zm9jdXMnKS5leGlzdHMoKSkge1xuICAgICAgICAgICAgICAgICAgICBzbGljay5ob29rcy5wcmV2LmFwcGx5KHNsaWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgJChzbGljay5vcHRpb25zLnRoZW1lLmNvbnRhaW5lciArICcgLnNraXAnKS5rZXlwcmVzcyhmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGlmKGUua2V5Q29kZSA9PT0gMTMpe1xuICAgICAgICAgICAgICAgIHNsaWNrLmhvb2tzLnNraXAuYXBwbHkoc2xpY2ssIFskKHRoaXMpLnZhbCgpXSk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB3aW5kb3cuU2xpY2sgPSBTbGljaztcblxuICAgIC8vIEV4cG9zaW5nIHByb2dyYW1tYXRpYyBhY2Nlc3NcbiAgICBTbGljay5uZXh0ID0gZnVuY3Rpb24oc2xpY2spe1xuICAgICAgICBpZihzbGljay5jb25zdHJ1Y3RvciA9PT0gU2xpY2spe1xuICAgICAgICAgICAgc2xpY2suaG9va3MubmV4dC5hcHBseShzbGljayk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2xpY2sucHJldiA9IGZ1bmN0aW9uKHNsaWNrKXtcbiAgICAgICAgaWYoc2xpY2suY29uc3RydWN0b3IgPT09IFNsaWNrKXtcbiAgICAgICAgICAgIHNsaWNrLmhvb2tzLnByZXYuYXBwbHkoc2xpY2spO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNsaWNrLnNraXAgPSBmdW5jdGlvbihzbGljaywgc3RlcCl7XG4gICAgICAgIGlmKHNsaWNrLmNvbnN0cnVjdG9yID09PSBTbGljayl7XG4gICAgICAgICAgICBzbGljay5ob29rcy5za2lwLmFwcGx5KHNsaWNrLCBbc3RlcF0pO1xuICAgICAgICB9XG4gICAgfTtcblxufShqUXVlcnksIHdpbmRvdykpOyIsIi8vIFRpbnlDb2xvciB2MS4yLjFcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZ3JpbnMvVGlueUNvbG9yXG4vLyBCcmlhbiBHcmluc3RlYWQsIE1JVCBMaWNlbnNlXG5cbihmdW5jdGlvbigpIHtcblxudmFyIHRyaW1MZWZ0ID0gL15bXFxzLCNdKy8sXG4gICAgdHJpbVJpZ2h0ID0gL1xccyskLyxcbiAgICB0aW55Q291bnRlciA9IDAsXG4gICAgbWF0aCA9IE1hdGgsXG4gICAgbWF0aFJvdW5kID0gbWF0aC5yb3VuZCxcbiAgICBtYXRoTWluID0gbWF0aC5taW4sXG4gICAgbWF0aE1heCA9IG1hdGgubWF4LFxuICAgIG1hdGhSYW5kb20gPSBtYXRoLnJhbmRvbTtcblxuZnVuY3Rpb24gdGlueWNvbG9yIChjb2xvciwgb3B0cykge1xuXG4gICAgY29sb3IgPSAoY29sb3IpID8gY29sb3IgOiAnJztcbiAgICBvcHRzID0gb3B0cyB8fCB7IH07XG5cbiAgICAvLyBJZiBpbnB1dCBpcyBhbHJlYWR5IGEgdGlueWNvbG9yLCByZXR1cm4gaXRzZWxmXG4gICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgdGlueWNvbG9yKSB7XG4gICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBhcmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGNhbGwgdXNpbmcgbmV3IGluc3RlYWRcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgdGlueWNvbG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IHRpbnljb2xvcihjb2xvciwgb3B0cyk7XG4gICAgfVxuXG4gICAgdmFyIHJnYiA9IGlucHV0VG9SR0IoY29sb3IpO1xuICAgIHRoaXMuX29yaWdpbmFsSW5wdXQgPSBjb2xvcixcbiAgICB0aGlzLl9yID0gcmdiLnIsXG4gICAgdGhpcy5fZyA9IHJnYi5nLFxuICAgIHRoaXMuX2IgPSByZ2IuYixcbiAgICB0aGlzLl9hID0gcmdiLmEsXG4gICAgdGhpcy5fcm91bmRBID0gbWF0aFJvdW5kKDEwMCp0aGlzLl9hKSAvIDEwMCxcbiAgICB0aGlzLl9mb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCByZ2IuZm9ybWF0O1xuICAgIHRoaXMuX2dyYWRpZW50VHlwZSA9IG9wdHMuZ3JhZGllbnRUeXBlO1xuXG4gICAgLy8gRG9uJ3QgbGV0IHRoZSByYW5nZSBvZiBbMCwyNTVdIGNvbWUgYmFjayBpbiBbMCwxXS5cbiAgICAvLyBQb3RlbnRpYWxseSBsb3NlIGEgbGl0dGxlIGJpdCBvZiBwcmVjaXNpb24gaGVyZSwgYnV0IHdpbGwgZml4IGlzc3VlcyB3aGVyZVxuICAgIC8vIC41IGdldHMgaW50ZXJwcmV0ZWQgYXMgaGFsZiBvZiB0aGUgdG90YWwsIGluc3RlYWQgb2YgaGFsZiBvZiAxXG4gICAgLy8gSWYgaXQgd2FzIHN1cHBvc2VkIHRvIGJlIDEyOCwgdGhpcyB3YXMgYWxyZWFkeSB0YWtlbiBjYXJlIG9mIGJ5IGBpbnB1dFRvUmdiYFxuICAgIGlmICh0aGlzLl9yIDwgMSkgeyB0aGlzLl9yID0gbWF0aFJvdW5kKHRoaXMuX3IpOyB9XG4gICAgaWYgKHRoaXMuX2cgPCAxKSB7IHRoaXMuX2cgPSBtYXRoUm91bmQodGhpcy5fZyk7IH1cbiAgICBpZiAodGhpcy5fYiA8IDEpIHsgdGhpcy5fYiA9IG1hdGhSb3VuZCh0aGlzLl9iKTsgfVxuXG4gICAgdGhpcy5fb2sgPSByZ2Iub2s7XG4gICAgdGhpcy5fdGNfaWQgPSB0aW55Q291bnRlcisrO1xufVxuXG50aW55Y29sb3IucHJvdG90eXBlID0ge1xuICAgIGlzRGFyazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJyaWdodG5lc3MoKSA8IDEyODtcbiAgICB9LFxuICAgIGlzTGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNEYXJrKCk7XG4gICAgfSxcbiAgICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29rO1xuICAgIH0sXG4gICAgZ2V0T3JpZ2luYWxJbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxJbnB1dDtcbiAgICB9LFxuICAgIGdldEZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XG4gICAgfSxcbiAgICBnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgIH0sXG4gICAgZ2V0QnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vaHR0cDovL3d3dy53My5vcmcvVFIvQUVSVCNjb2xvci1jb250cmFzdFxuICAgICAgICB2YXIgcmdiID0gdGhpcy50b1JnYigpO1xuICAgICAgICByZXR1cm4gKHJnYi5yICogMjk5ICsgcmdiLmcgKiA1ODcgKyByZ2IuYiAqIDExNCkgLyAxMDAwO1xuICAgIH0sXG4gICAgZ2V0THVtaW5hbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgIHZhciBSc1JHQiwgR3NSR0IsIEJzUkdCLCBSLCBHLCBCO1xuICAgICAgICBSc1JHQiA9IHJnYi5yLzI1NTtcbiAgICAgICAgR3NSR0IgPSByZ2IuZy8yNTU7XG4gICAgICAgIEJzUkdCID0gcmdiLmIvMjU1O1xuXG4gICAgICAgIGlmIChSc1JHQiA8PSAwLjAzOTI4KSB7UiA9IFJzUkdCIC8gMTIuOTI7fSBlbHNlIHtSID0gTWF0aC5wb3coKChSc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIGlmIChHc1JHQiA8PSAwLjAzOTI4KSB7RyA9IEdzUkdCIC8gMTIuOTI7fSBlbHNlIHtHID0gTWF0aC5wb3coKChHc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIGlmIChCc1JHQiA8PSAwLjAzOTI4KSB7QiA9IEJzUkdCIC8gMTIuOTI7fSBlbHNlIHtCID0gTWF0aC5wb3coKChCc1JHQiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTt9XG4gICAgICAgIHJldHVybiAoMC4yMTI2ICogUikgKyAoMC43MTUyICogRykgKyAoMC4wNzIyICogQik7XG4gICAgfSxcbiAgICBzZXRBbHBoYTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYSA9IGJvdW5kQWxwaGEodmFsdWUpO1xuICAgICAgICB0aGlzLl9yb3VuZEEgPSBtYXRoUm91bmQoMTAwKnRoaXMuX2EpIC8gMTAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRvSHN2OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICByZXR1cm4geyBoOiBoc3YuaCAqIDM2MCwgczogaHN2LnMsIHY6IGhzdi52LCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b0hzdlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc3YgPSByZ2JUb0hzdih0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgdmFyIGggPSBtYXRoUm91bmQoaHN2LmggKiAzNjApLCBzID0gbWF0aFJvdW5kKGhzdi5zICogMTAwKSwgdiA9IG1hdGhSb3VuZChoc3YudiAqIDEwMCk7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJoc3YoXCIgICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgdiArIFwiJSlcIiA6XG4gICAgICAgICAgXCJoc3ZhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgdiArIFwiJSwgXCIrIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9Ic2w6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHJldHVybiB7IGg6IGhzbC5oICogMzYwLCBzOiBoc2wucywgbDogaHNsLmwsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvSHNsU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzbCA9IHJnYlRvSHNsKHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc2wuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHNsLnMgKiAxMDApLCBsID0gbWF0aFJvdW5kKGhzbC5sICogMTAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcImhzbChcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlKVwiIDpcbiAgICAgICAgICBcImhzbGEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0hleDogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgICAgICByZXR1cm4gcmdiVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgYWxsb3czQ2hhcik7XG4gICAgfSxcbiAgICB0b0hleFN0cmluZzogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgICAgICByZXR1cm4gJyMnICsgdGhpcy50b0hleChhbGxvdzNDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4ODogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2JhVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XG4gICAgfSxcbiAgICB0b0hleDhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJyMnICsgdGhpcy50b0hleDgoKTtcbiAgICB9LFxuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0aFJvdW5kKHRoaXMuX3IpLCBnOiBtYXRoUm91bmQodGhpcy5fZyksIGI6IG1hdGhSb3VuZCh0aGlzLl9iKSwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9SZ2JTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwicmdiKFwiICArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9nKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9iKSArIFwiKVwiIDpcbiAgICAgICAgICBcInJnYmEoXCIgKyBtYXRoUm91bmQodGhpcy5fcikgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fZykgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fYikgKyBcIiwgXCIgKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvUGVyY2VudGFnZVJnYjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlXCIsIGc6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlXCIsIGI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlXCIsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvUGVyY2VudGFnZVJnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUpXCIgOlxuICAgICAgICAgIFwicmdiYShcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9OYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2EgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZXhOYW1lc1tyZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0cnVlKV0gfHwgZmFsc2U7XG4gICAgfSxcbiAgICB0b0ZpbHRlcjogZnVuY3Rpb24oc2Vjb25kQ29sb3IpIHtcbiAgICAgICAgdmFyIGhleDhTdHJpbmcgPSAnIycgKyByZ2JhVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgdGhpcy5fYSk7XG4gICAgICAgIHZhciBzZWNvbmRIZXg4U3RyaW5nID0gaGV4OFN0cmluZztcbiAgICAgICAgdmFyIGdyYWRpZW50VHlwZSA9IHRoaXMuX2dyYWRpZW50VHlwZSA/IFwiR3JhZGllbnRUeXBlID0gMSwgXCIgOiBcIlwiO1xuXG4gICAgICAgIGlmIChzZWNvbmRDb2xvcikge1xuICAgICAgICAgICAgdmFyIHMgPSB0aW55Y29sb3Ioc2Vjb25kQ29sb3IpO1xuICAgICAgICAgICAgc2Vjb25kSGV4OFN0cmluZyA9IHMudG9IZXg4U3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoXCIrZ3JhZGllbnRUeXBlK1wic3RhcnRDb2xvcnN0cj1cIitoZXg4U3RyaW5nK1wiLGVuZENvbG9yc3RyPVwiK3NlY29uZEhleDhTdHJpbmcrXCIpXCI7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBmb3JtYXRTZXQgPSAhIWZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuX2Zvcm1hdDtcblxuICAgICAgICB2YXIgZm9ybWF0dGVkU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNBbHBoYSA9IHRoaXMuX2EgPCAxICYmIHRoaXMuX2EgPj0gMDtcbiAgICAgICAgdmFyIG5lZWRzQWxwaGFGb3JtYXQgPSAhZm9ybWF0U2V0ICYmIGhhc0FscGhhICYmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIiB8fCBmb3JtYXQgPT09IFwiaGV4M1wiIHx8IGZvcm1hdCA9PT0gXCJuYW1lXCIpO1xuXG4gICAgICAgIGlmIChuZWVkc0FscGhhRm9ybWF0KSB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIFwidHJhbnNwYXJlbnRcIiwgYWxsIG90aGVyIG5vbi1hbHBoYSBmb3JtYXRzXG4gICAgICAgICAgICAvLyB3aWxsIHJldHVybiByZ2JhIHdoZW4gdGhlcmUgaXMgdHJhbnNwYXJlbmN5LlxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJuYW1lXCIgJiYgdGhpcy5fYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvTmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcInJnYlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJwcmdiXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9QZXJjZW50YWdlUmdiU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoZXhcIiB8fCBmb3JtYXQgPT09IFwiaGV4NlwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoZXgzXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoZXg4XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXg4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9OYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoc2xcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzbFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiaHN2XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9Ic3ZTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTdHJpbmcgfHwgdGhpcy50b0hleFN0cmluZygpO1xuICAgIH0sXG5cbiAgICBfYXBwbHlNb2RpZmljYXRpb246IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGZuLmFwcGx5KG51bGwsIFt0aGlzXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgICAgICB0aGlzLl9yID0gY29sb3IuX3I7XG4gICAgICAgIHRoaXMuX2cgPSBjb2xvci5fZztcbiAgICAgICAgdGhpcy5fYiA9IGNvbG9yLl9iO1xuICAgICAgICB0aGlzLnNldEFscGhhKGNvbG9yLl9hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBsaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGxpZ2h0ZW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBicmlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihicmlnaHRlbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGRhcmtlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihkYXJrZW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBkZXNhdHVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGRlc2F0dXJhdGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzYXR1cmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihzYXR1cmF0ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdyZXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihncmV5c2NhbGUsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzcGluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKHNwaW4sIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIF9hcHBseUNvbWJpbmF0aW9uOiBmdW5jdGlvbihmbiwgYXJncykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgfSxcbiAgICBhbmFsb2dvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihhbmFsb2dvdXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBjb21wbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oY29tcGxlbWVudCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1vbm9jaHJvbWF0aWM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihtb25vY2hyb21hdGljLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc3BsaXRjb21wbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oc3BsaXRjb21wbGVtZW50LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgdHJpYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbih0cmlhZCwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHRldHJhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHRldHJhZCwgYXJndW1lbnRzKTtcbiAgICB9XG59O1xuXG4vLyBJZiBpbnB1dCBpcyBhbiBvYmplY3QsIGZvcmNlIDEgaW50byBcIjEuMFwiIHRvIGhhbmRsZSByYXRpb3MgcHJvcGVybHlcbi8vIFN0cmluZyBpbnB1dCByZXF1aXJlcyBcIjEuMFwiIGFzIGlucHV0LCBzbyAxIHdpbGwgYmUgdHJlYXRlZCBhcyAxXG50aW55Y29sb3IuZnJvbVJhdGlvID0gZnVuY3Rpb24oY29sb3IsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIGNvbG9yID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIG5ld0NvbG9yID0ge307XG4gICAgICAgIGZvciAodmFyIGkgaW4gY29sb3IpIHtcbiAgICAgICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBcImFcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb2xvcltpXSA9IGNvbG9yW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3JbaV0gPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yLCBvcHRzKTtcbn07XG5cbi8vIEdpdmVuIGEgc3RyaW5nIG9yIG9iamVjdCwgY29udmVydCB0aGF0IGlucHV0IHRvIFJHQlxuLy8gUG9zc2libGUgc3RyaW5nIGlucHV0czpcbi8vXG4vLyAgICAgXCJyZWRcIlxuLy8gICAgIFwiI2YwMFwiIG9yIFwiZjAwXCJcbi8vICAgICBcIiNmZjAwMDBcIiBvciBcImZmMDAwMFwiXG4vLyAgICAgXCIjZmYwMDAwMDBcIiBvciBcImZmMDAwMDAwXCJcbi8vICAgICBcInJnYiAyNTUgMCAwXCIgb3IgXCJyZ2IgKDI1NSwgMCwgMClcIlxuLy8gICAgIFwicmdiIDEuMCAwIDBcIiBvciBcInJnYiAoMSwgMCwgMClcIlxuLy8gICAgIFwicmdiYSAoMjU1LCAwLCAwLCAxKVwiIG9yIFwicmdiYSAyNTUsIDAsIDAsIDFcIlxuLy8gICAgIFwicmdiYSAoMS4wLCAwLCAwLCAxKVwiIG9yIFwicmdiYSAxLjAsIDAsIDAsIDFcIlxuLy8gICAgIFwiaHNsKDAsIDEwMCUsIDUwJSlcIiBvciBcImhzbCAwIDEwMCUgNTAlXCJcbi8vICAgICBcImhzbGEoMCwgMTAwJSwgNTAlLCAxKVwiIG9yIFwiaHNsYSAwIDEwMCUgNTAlLCAxXCJcbi8vICAgICBcImhzdigwLCAxMDAlLCAxMDAlKVwiIG9yIFwiaHN2IDAgMTAwJSAxMDAlXCJcbi8vXG5mdW5jdGlvbiBpbnB1dFRvUkdCKGNvbG9yKSB7XG5cbiAgICB2YXIgcmdiID0geyByOiAwLCBnOiAwLCBiOiAwIH07XG4gICAgdmFyIGEgPSAxO1xuICAgIHZhciBvayA9IGZhbHNlO1xuICAgIHZhciBmb3JtYXQgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb2xvciA9IHN0cmluZ0lucHV0VG9PYmplY3QoY29sb3IpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJyXCIpICYmIGNvbG9yLmhhc093blByb3BlcnR5KFwiZ1wiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcImJcIikpIHtcbiAgICAgICAgICAgIHJnYiA9IHJnYlRvUmdiKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybWF0ID0gU3RyaW5nKGNvbG9yLnIpLnN1YnN0cigtMSkgPT09IFwiJVwiID8gXCJwcmdiXCIgOiBcInJnYlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiaFwiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcInNcIikgJiYgY29sb3IuaGFzT3duUHJvcGVydHkoXCJ2XCIpKSB7XG4gICAgICAgICAgICBjb2xvci5zID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5zKTtcbiAgICAgICAgICAgIGNvbG9yLnYgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnYpO1xuICAgICAgICAgICAgcmdiID0gaHN2VG9SZ2IoY29sb3IuaCwgY29sb3IucywgY29sb3Iudik7XG4gICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImhzdlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiaFwiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcInNcIikgJiYgY29sb3IuaGFzT3duUHJvcGVydHkoXCJsXCIpKSB7XG4gICAgICAgICAgICBjb2xvci5zID0gY29udmVydFRvUGVyY2VudGFnZShjb2xvci5zKTtcbiAgICAgICAgICAgIGNvbG9yLmwgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLmwpO1xuICAgICAgICAgICAgcmdiID0gaHNsVG9SZ2IoY29sb3IuaCwgY29sb3IucywgY29sb3IubCk7XG4gICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImhzbFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiYVwiKSkge1xuICAgICAgICAgICAgYSA9IGNvbG9yLmE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhID0gYm91bmRBbHBoYShhKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG9rOiBvayxcbiAgICAgICAgZm9ybWF0OiBjb2xvci5mb3JtYXQgfHwgZm9ybWF0LFxuICAgICAgICByOiBtYXRoTWluKDI1NSwgbWF0aE1heChyZ2IuciwgMCkpLFxuICAgICAgICBnOiBtYXRoTWluKDI1NSwgbWF0aE1heChyZ2IuZywgMCkpLFxuICAgICAgICBiOiBtYXRoTWluKDI1NSwgbWF0aE1heChyZ2IuYiwgMCkpLFxuICAgICAgICBhOiBhXG4gICAgfTtcbn1cblxuXG4vLyBDb252ZXJzaW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gYHJnYlRvSHNsYCwgYHJnYlRvSHN2YCwgYGhzbFRvUmdiYCwgYGhzdlRvUmdiYCBtb2RpZmllZCBmcm9tOlxuLy8gPGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQ+XG5cbi8vIGByZ2JUb1JnYmBcbi8vIEhhbmRsZSBib3VuZHMgLyBwZXJjZW50YWdlIGNoZWNraW5nIHRvIGNvbmZvcm0gdG8gQ1NTIGNvbG9yIHNwZWNcbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLz5cbi8vICpBc3N1bWVzOiogciwgZywgYiBpbiBbMCwgMjU1XSBvciBbMCwgMV1cbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gWzAsIDI1NV1cbmZ1bmN0aW9uIHJnYlRvUmdiKHIsIGcsIGIpe1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IGJvdW5kMDEociwgMjU1KSAqIDI1NSxcbiAgICAgICAgZzogYm91bmQwMShnLCAyNTUpICogMjU1LFxuICAgICAgICBiOiBib3VuZDAxKGIsIDI1NSkgKiAyNTVcbiAgICB9O1xufVxuXG4vLyBgcmdiVG9Ic2xgXG4vLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNMLlxuLy8gKkFzc3VtZXM6KiByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIFswLCAyNTVdIG9yIFswLCAxXVxuLy8gKlJldHVybnM6KiB7IGgsIHMsIGwgfSBpbiBbMCwxXVxuZnVuY3Rpb24gcmdiVG9Ic2wociwgZywgYikge1xuXG4gICAgciA9IGJvdW5kMDEociwgMjU1KTtcbiAgICBnID0gYm91bmQwMShnLCAyNTUpO1xuICAgIGIgPSBib3VuZDAxKGIsIDI1NSk7XG5cbiAgICB2YXIgbWF4ID0gbWF0aE1heChyLCBnLCBiKSwgbWluID0gbWF0aE1pbihyLCBnLCBiKTtcbiAgICB2YXIgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgIGlmKG1heCA9PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgICAgICBzd2l0Y2gobWF4KSB7XG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGggLz0gNjtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoOiBoLCBzOiBzLCBsOiBsIH07XG59XG5cbi8vIGBoc2xUb1JnYmBcbi8vIENvbnZlcnRzIGFuIEhTTCBjb2xvciB2YWx1ZSB0byBSR0IuXG4vLyAqQXNzdW1lczoqIGggaXMgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMzYwXSBhbmQgcyBhbmQgbCBhcmUgY29udGFpbmVkIFswLCAxXSBvciBbMCwgMTAwXVxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiB0aGUgc2V0IFswLCAyNTVdXG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBoID0gYm91bmQwMShoLCAzNjApO1xuICAgIHMgPSBib3VuZDAxKHMsIDEwMCk7XG4gICAgbCA9IGJvdW5kMDEobCwgMTAwKTtcblxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgICBpZih0IDwgMCkgdCArPSAxO1xuICAgICAgICBpZih0ID4gMSkgdCAtPSAxO1xuICAgICAgICBpZih0IDwgMS82KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgICAgaWYodCA8IDEvMikgcmV0dXJuIHE7XG4gICAgICAgIGlmKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGlmKHMgPT09IDApIHtcbiAgICAgICAgciA9IGcgPSBiID0gbDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEvMyk7XG4gICAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMS8zKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyByOiByICogMjU1LCBnOiBnICogMjU1LCBiOiBiICogMjU1IH07XG59XG5cbi8vIGByZ2JUb0hzdmBcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU1Zcbi8vICpBc3N1bWVzOiogciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIG9yIFswLCAxXVxuLy8gKlJldHVybnM6KiB7IGgsIHMsIHYgfSBpbiBbMCwxXVxuZnVuY3Rpb24gcmdiVG9Ic3YociwgZywgYikge1xuXG4gICAgciA9IGJvdW5kMDEociwgMjU1KTtcbiAgICBnID0gYm91bmQwMShnLCAyNTUpO1xuICAgIGIgPSBib3VuZDAxKGIsIDI1NSk7XG5cbiAgICB2YXIgbWF4ID0gbWF0aE1heChyLCBnLCBiKSwgbWluID0gbWF0aE1pbihyLCBnLCBiKTtcbiAgICB2YXIgaCwgcywgdiA9IG1heDtcblxuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBtYXggPT09IDAgPyAwIDogZCAvIG1heDtcblxuICAgIGlmKG1heCA9PSBtaW4pIHtcbiAgICAgICAgaCA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICB9XG4gICAgcmV0dXJuIHsgaDogaCwgczogcywgdjogdiB9O1xufVxuXG4vLyBgaHN2VG9SZ2JgXG4vLyBDb252ZXJ0cyBhbiBIU1YgY29sb3IgdmFsdWUgdG8gUkdCLlxuLy8gKkFzc3VtZXM6KiBoIGlzIGNvbnRhaW5lZCBpbiBbMCwgMV0gb3IgWzAsIDM2MF0gYW5kIHMgYW5kIHYgYXJlIGNvbnRhaW5lZCBpbiBbMCwgMV0gb3IgWzAsIDEwMF1cbi8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gdGhlIHNldCBbMCwgMjU1XVxuIGZ1bmN0aW9uIGhzdlRvUmdiKGgsIHMsIHYpIHtcblxuICAgIGggPSBib3VuZDAxKGgsIDM2MCkgKiA2O1xuICAgIHMgPSBib3VuZDAxKHMsIDEwMCk7XG4gICAgdiA9IGJvdW5kMDEodiwgMTAwKTtcblxuICAgIHZhciBpID0gbWF0aC5mbG9vcihoKSxcbiAgICAgICAgZiA9IGggLSBpLFxuICAgICAgICBwID0gdiAqICgxIC0gcyksXG4gICAgICAgIHEgPSB2ICogKDEgLSBmICogcyksXG4gICAgICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyksXG4gICAgICAgIG1vZCA9IGkgJSA2LFxuICAgICAgICByID0gW3YsIHEsIHAsIHAsIHQsIHZdW21vZF0sXG4gICAgICAgIGcgPSBbdCwgdiwgdiwgcSwgcCwgcF1bbW9kXSxcbiAgICAgICAgYiA9IFtwLCBwLCB0LCB2LCB2LCBxXVttb2RdO1xuXG4gICAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYiAqIDI1NSB9O1xufVxuXG4vLyBgcmdiVG9IZXhgXG4vLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdG8gaGV4XG4vLyBBc3N1bWVzIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XVxuLy8gUmV0dXJucyBhIDMgb3IgNiBjaGFyYWN0ZXIgaGV4XG5mdW5jdGlvbiByZ2JUb0hleChyLCBnLCBiLCBhbGxvdzNDaGFyKSB7XG5cbiAgICB2YXIgaGV4ID0gW1xuICAgICAgICBwYWQyKG1hdGhSb3VuZChyKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChnKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChiKS50b1N0cmluZygxNikpXG4gICAgXTtcblxuICAgIC8vIFJldHVybiBhIDMgY2hhcmFjdGVyIGhleCBpZiBwb3NzaWJsZVxuICAgIGlmIChhbGxvdzNDaGFyICYmIGhleFswXS5jaGFyQXQoMCkgPT0gaGV4WzBdLmNoYXJBdCgxKSAmJiBoZXhbMV0uY2hhckF0KDApID09IGhleFsxXS5jaGFyQXQoMSkgJiYgaGV4WzJdLmNoYXJBdCgwKSA9PSBoZXhbMl0uY2hhckF0KDEpKSB7XG4gICAgICAgIHJldHVybiBoZXhbMF0uY2hhckF0KDApICsgaGV4WzFdLmNoYXJBdCgwKSArIGhleFsyXS5jaGFyQXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xufVxuXG4vLyBgcmdiYVRvSGV4YFxuLy8gQ29udmVydHMgYW4gUkdCQSBjb2xvciBwbHVzIGFscGhhIHRyYW5zcGFyZW5jeSB0byBoZXhcbi8vIEFzc3VtZXMgciwgZywgYiBhbmQgYSBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV1cbi8vIFJldHVybnMgYW4gOCBjaGFyYWN0ZXIgaGV4XG5mdW5jdGlvbiByZ2JhVG9IZXgociwgZywgYiwgYSkge1xuXG4gICAgdmFyIGhleCA9IFtcbiAgICAgICAgcGFkMihjb252ZXJ0RGVjaW1hbFRvSGV4KGEpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoZykudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgcGFkMihtYXRoUm91bmQoYikudG9TdHJpbmcoMTYpKVxuICAgIF07XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGBlcXVhbHNgXG4vLyBDYW4gYmUgY2FsbGVkIHdpdGggYW55IHRpbnljb2xvciBpbnB1dFxudGlueWNvbG9yLmVxdWFscyA9IGZ1bmN0aW9uIChjb2xvcjEsIGNvbG9yMikge1xuICAgIGlmICghY29sb3IxIHx8ICFjb2xvcjIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcjEpLnRvUmdiU3RyaW5nKCkgPT0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2JTdHJpbmcoKTtcbn07XG5cbnRpbnljb2xvci5yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yLmZyb21SYXRpbyh7XG4gICAgICAgIHI6IG1hdGhSYW5kb20oKSxcbiAgICAgICAgZzogbWF0aFJhbmRvbSgpLFxuICAgICAgICBiOiBtYXRoUmFuZG9tKClcbiAgICB9KTtcbn07XG5cblxuLy8gTW9kaWZpY2F0aW9uIEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhhbmtzIHRvIGxlc3MuanMgZm9yIHNvbWUgb2YgdGhlIGJhc2ljcyBoZXJlXG4vLyA8aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkaGVhZC9sZXNzLmpzL2Jsb2IvbWFzdGVyL2xpYi9sZXNzL2Z1bmN0aW9ucy5qcz5cblxuZnVuY3Rpb24gZGVzYXR1cmF0ZShjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wucyAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIHNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5zICs9IGFtb3VudCAvIDEwMDtcbiAgICBoc2wucyA9IGNsYW1wMDEoaHNsLnMpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gZ3JleXNjYWxlKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZGVzYXR1cmF0ZSgxMDApO1xufVxuXG5mdW5jdGlvbiBsaWdodGVuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCArPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIGJyaWdodGVuKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgcmdiID0gdGlueWNvbG9yKGNvbG9yKS50b1JnYigpO1xuICAgIHJnYi5yID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLnIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuZyA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5nIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmdiLmIgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuYiAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJldHVybiB0aW55Y29sb3IocmdiKTtcbn1cblxuZnVuY3Rpb24gZGFya2VuIChjb2xvciwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBjbGFtcDAxKGhzbC5sKTtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbi8vIFNwaW4gdGFrZXMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBhbW91bnQgd2l0aGluIFstMzYwLCAzNjBdIGluZGljYXRpbmcgdGhlIGNoYW5nZSBvZiBodWUuXG4vLyBWYWx1ZXMgb3V0c2lkZSBvZiB0aGlzIHJhbmdlIHdpbGwgYmUgd3JhcHBlZCBpbnRvIHRoaXMgcmFuZ2UuXG5mdW5jdGlvbiBzcGluKGNvbG9yLCBhbW91bnQpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBodWUgPSAobWF0aFJvdW5kKGhzbC5oKSArIGFtb3VudCkgJSAzNjA7XG4gICAgaHNsLmggPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuLy8gQ29tYmluYXRpb24gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRoYW5rcyB0byBqUXVlcnkgeENvbG9yIGZvciBzb21lIG9mIHRoZSBpZGVhcyBiZWhpbmQgdGhlc2Vcbi8vIDxodHRwczovL2dpdGh1Yi5jb20vaW5mdXNpb24valF1ZXJ5LXhjb2xvci9ibG9iL21hc3Rlci9qcXVlcnkueGNvbG9yLmpzPlxuXG5mdW5jdGlvbiBjb21wbGVtZW50KGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICBoc2wuaCA9IChoc2wuaCArIDE4MCkgJSAzNjA7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG5mdW5jdGlvbiB0cmlhZChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDEyMCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAyNDApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiB0ZXRyYWQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyA5MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAxODApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjcwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gc3BsaXRjb21wbGVtZW50KGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgNzIpICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmx9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAyMTYpICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmx9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIGFuYWxvZ291cyhjb2xvciwgcmVzdWx0cywgc2xpY2VzKSB7XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgNjtcbiAgICBzbGljZXMgPSBzbGljZXMgfHwgMzA7XG5cbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBwYXJ0ID0gMzYwIC8gc2xpY2VzO1xuICAgIHZhciByZXQgPSBbdGlueWNvbG9yKGNvbG9yKV07XG5cbiAgICBmb3IgKGhzbC5oID0gKChoc2wuaCAtIChwYXJ0ICogcmVzdWx0cyA+PiAxKSkgKyA3MjApICUgMzYwOyAtLXJlc3VsdHM7ICkge1xuICAgICAgICBoc2wuaCA9IChoc2wuaCArIHBhcnQpICUgMzYwO1xuICAgICAgICByZXQucHVzaCh0aW55Y29sb3IoaHNsKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG1vbm9jaHJvbWF0aWMoY29sb3IsIHJlc3VsdHMpIHtcbiAgICByZXN1bHRzID0gcmVzdWx0cyB8fCA2O1xuICAgIHZhciBoc3YgPSB0aW55Y29sb3IoY29sb3IpLnRvSHN2KCk7XG4gICAgdmFyIGggPSBoc3YuaCwgcyA9IGhzdi5zLCB2ID0gaHN2LnY7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciBtb2RpZmljYXRpb24gPSAxIC8gcmVzdWx0cztcblxuICAgIHdoaWxlIChyZXN1bHRzLS0pIHtcbiAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKHsgaDogaCwgczogcywgdjogdn0pKTtcbiAgICAgICAgdiA9ICh2ICsgbW9kaWZpY2F0aW9uKSAlIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLy8gVXRpbGl0eSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG50aW55Y29sb3IubWl4ID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgNTApO1xuXG4gICAgdmFyIHJnYjEgPSB0aW55Y29sb3IoY29sb3IxKS50b1JnYigpO1xuICAgIHZhciByZ2IyID0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2IoKTtcblxuICAgIHZhciBwID0gYW1vdW50IC8gMTAwO1xuICAgIHZhciB3ID0gcCAqIDIgLSAxO1xuICAgIHZhciBhID0gcmdiMi5hIC0gcmdiMS5hO1xuXG4gICAgdmFyIHcxO1xuXG4gICAgaWYgKHcgKiBhID09IC0xKSB7XG4gICAgICAgIHcxID0gdztcbiAgICB9IGVsc2Uge1xuICAgICAgICB3MSA9ICh3ICsgYSkgLyAoMSArIHcgKiBhKTtcbiAgICB9XG5cbiAgICB3MSA9ICh3MSArIDEpIC8gMjtcblxuICAgIHZhciB3MiA9IDEgLSB3MTtcblxuICAgIHZhciByZ2JhID0ge1xuICAgICAgICByOiByZ2IyLnIgKiB3MSArIHJnYjEuciAqIHcyLFxuICAgICAgICBnOiByZ2IyLmcgKiB3MSArIHJnYjEuZyAqIHcyLFxuICAgICAgICBiOiByZ2IyLmIgKiB3MSArIHJnYjEuYiAqIHcyLFxuICAgICAgICBhOiByZ2IyLmEgKiBwICArIHJnYjEuYSAqICgxIC0gcClcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRpbnljb2xvcihyZ2JhKTtcbn07XG5cblxuLy8gUmVhZGFiaWxpdHkgRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmIChXQ0FHIFZlcnNpb24gMilcblxuLy8gYGNvbnRyYXN0YFxuLy8gQW5hbHl6ZSB0aGUgMiBjb2xvcnMgYW5kIHJldHVybnMgdGhlIGNvbG9yIGNvbnRyYXN0IGRlZmluZWQgYnkgKFdDQUcgVmVyc2lvbiAyKVxudGlueWNvbG9yLnJlYWRhYmlsaXR5ID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcbiAgICB2YXIgYzEgPSB0aW55Y29sb3IoY29sb3IxKTtcbiAgICB2YXIgYzIgPSB0aW55Y29sb3IoY29sb3IyKTtcbiAgICByZXR1cm4gKE1hdGgubWF4KGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KSAvIChNYXRoLm1pbihjMS5nZXRMdW1pbmFuY2UoKSxjMi5nZXRMdW1pbmFuY2UoKSkrMC4wNSk7XG59O1xuXG4vLyBgaXNSZWFkYWJsZWBcbi8vIEVuc3VyZSB0aGF0IGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IgY29tYmluYXRpb25zIG1lZXQgV0NBRzIgZ3VpZGVsaW5lcy5cbi8vIFRoZSB0aGlyZCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCBPYmplY3QuXG4vLyAgICAgIHRoZSAnbGV2ZWwnIHByb3BlcnR5IHN0YXRlcyAnQUEnIG9yICdBQUEnIC0gaWYgbWlzc2luZyBvciBpbnZhbGlkLCBpdCBkZWZhdWx0cyB0byAnQUEnO1xuLy8gICAgICB0aGUgJ3NpemUnIHByb3BlcnR5IHN0YXRlcyAnbGFyZ2UnIG9yICdzbWFsbCcgLSBpZiBtaXNzaW5nIG9yIGludmFsaWQsIGl0IGRlZmF1bHRzIHRvICdzbWFsbCcuXG4vLyBJZiB0aGUgZW50aXJlIG9iamVjdCBpcyBhYnNlbnQsIGlzUmVhZGFibGUgZGVmYXVsdHMgdG8ge2xldmVsOlwiQUFcIixzaXplOlwic21hbGxcIn0uXG5cbi8vICpFeGFtcGxlKlxuLy8gICAgdGlueWNvbG9yLmlzUmVhZGFibGUoXCIjMDAwXCIsIFwiIzExMVwiKSA9PiBmYWxzZVxuLy8gICAgdGlueWNvbG9yLmlzUmVhZGFibGUoXCIjMDAwXCIsIFwiIzExMVwiLHtsZXZlbDpcIkFBXCIsc2l6ZTpcImxhcmdlXCJ9KSA9PiBmYWxzZVxudGlueWNvbG9yLmlzUmVhZGFibGUgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgd2NhZzIpIHtcbiAgICB2YXIgcmVhZGFiaWxpdHkgPSB0aW55Y29sb3IucmVhZGFiaWxpdHkoY29sb3IxLCBjb2xvcjIpO1xuICAgIHZhciB3Y2FnMlBhcm1zLCBvdXQ7XG5cbiAgICBvdXQgPSBmYWxzZTtcblxuICAgIHdjYWcyUGFybXMgPSB2YWxpZGF0ZVdDQUcyUGFybXMod2NhZzIpO1xuICAgIHN3aXRjaCAod2NhZzJQYXJtcy5sZXZlbCArIHdjYWcyUGFybXMuc2l6ZSkge1xuICAgICAgICBjYXNlIFwiQUFzbWFsbFwiOlxuICAgICAgICBjYXNlIFwiQUFBbGFyZ2VcIjpcbiAgICAgICAgICAgIG91dCA9IHJlYWRhYmlsaXR5ID49IDQuNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQUFsYXJnZVwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQUFBc21hbGxcIjpcbiAgICAgICAgICAgIG91dCA9IHJlYWRhYmlsaXR5ID49IDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcblxufTtcblxuLy8gYG1vc3RSZWFkYWJsZWBcbi8vIEdpdmVuIGEgYmFzZSBjb2xvciBhbmQgYSBsaXN0IG9mIHBvc3NpYmxlIGZvcmVncm91bmQgb3IgYmFja2dyb3VuZFxuLy8gY29sb3JzIGZvciB0aGF0IGJhc2UsIHJldHVybnMgdGhlIG1vc3QgcmVhZGFibGUgY29sb3IuXG4vLyBPcHRpb25hbGx5IHJldHVybnMgQmxhY2sgb3IgV2hpdGUgaWYgdGhlIG1vc3QgcmVhZGFibGUgY29sb3IgaXMgdW5yZWFkYWJsZS5cbi8vICpFeGFtcGxlKlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSh0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiIzEyM1wiLCBbXCIjMTI0XCIsIFwiIzEyNVwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOmZhbHNlfSkudG9IZXhTdHJpbmcoKTsgLy8gXCIjMTEyMjU1XCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUodGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiMxMjNcIiwgW1wiIzEyNFwiLCBcIiMxMjVcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlfSkudG9IZXhTdHJpbmcoKTsgIC8vIFwiI2ZmZmZmZlwiXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiI2E4MDE1YVwiLCBbXCIjZmFmM2YzXCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6dHJ1ZSxsZXZlbDpcIkFBQVwiLHNpemU6XCJsYXJnZVwifSkudG9IZXhTdHJpbmcoKTsgLy8gXCIjZmFmM2YzXCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjYTgwMTVhXCIsIFtcIiNmYWYzZjNcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlLGxldmVsOlwiQUFBXCIsc2l6ZTpcInNtYWxsXCJ9KS50b0hleFN0cmluZygpOyAvLyBcIiNmZmZmZmZcIlxudGlueWNvbG9yLm1vc3RSZWFkYWJsZSA9IGZ1bmN0aW9uKGJhc2VDb2xvciwgY29sb3JMaXN0LCBhcmdzKSB7XG4gICAgdmFyIGJlc3RDb2xvciA9IG51bGw7XG4gICAgdmFyIGJlc3RTY29yZSA9IDA7XG4gICAgdmFyIHJlYWRhYmlsaXR5O1xuICAgIHZhciBpbmNsdWRlRmFsbGJhY2tDb2xvcnMsIGxldmVsLCBzaXplIDtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBpbmNsdWRlRmFsbGJhY2tDb2xvcnMgPSBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycyA7XG4gICAgbGV2ZWwgPSBhcmdzLmxldmVsO1xuICAgIHNpemUgPSBhcmdzLnNpemU7XG5cbiAgICBmb3IgKHZhciBpPSAwOyBpIDwgY29sb3JMaXN0Lmxlbmd0aCA7IGkrKykge1xuICAgICAgICByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShiYXNlQ29sb3IsIGNvbG9yTGlzdFtpXSk7XG4gICAgICAgIGlmIChyZWFkYWJpbGl0eSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgYmVzdFNjb3JlID0gcmVhZGFiaWxpdHk7XG4gICAgICAgICAgICBiZXN0Q29sb3IgPSB0aW55Y29sb3IoY29sb3JMaXN0W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aW55Y29sb3IuaXNSZWFkYWJsZShiYXNlQ29sb3IsIGJlc3RDb2xvciwge1wibGV2ZWxcIjpsZXZlbCxcInNpemVcIjpzaXplfSkgfHwgIWluY2x1ZGVGYWxsYmFja0NvbG9ycykge1xuICAgICAgICByZXR1cm4gYmVzdENvbG9yO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJncy5pbmNsdWRlRmFsbGJhY2tDb2xvcnM9ZmFsc2U7XG4gICAgICAgIHJldHVybiB0aW55Y29sb3IubW9zdFJlYWRhYmxlKGJhc2VDb2xvcixbXCIjZmZmXCIsIFwiIzAwMFwiXSxhcmdzKTtcbiAgICB9XG59O1xuXG5cbi8vIEJpZyBMaXN0IG9mIENvbG9yc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yPlxudmFyIG5hbWVzID0gdGlueWNvbG9yLm5hbWVzID0ge1xuICAgIGFsaWNlYmx1ZTogXCJmMGY4ZmZcIixcbiAgICBhbnRpcXVld2hpdGU6IFwiZmFlYmQ3XCIsXG4gICAgYXF1YTogXCIwZmZcIixcbiAgICBhcXVhbWFyaW5lOiBcIjdmZmZkNFwiLFxuICAgIGF6dXJlOiBcImYwZmZmZlwiLFxuICAgIGJlaWdlOiBcImY1ZjVkY1wiLFxuICAgIGJpc3F1ZTogXCJmZmU0YzRcIixcbiAgICBibGFjazogXCIwMDBcIixcbiAgICBibGFuY2hlZGFsbW9uZDogXCJmZmViY2RcIixcbiAgICBibHVlOiBcIjAwZlwiLFxuICAgIGJsdWV2aW9sZXQ6IFwiOGEyYmUyXCIsXG4gICAgYnJvd246IFwiYTUyYTJhXCIsXG4gICAgYnVybHl3b29kOiBcImRlYjg4N1wiLFxuICAgIGJ1cm50c2llbm5hOiBcImVhN2U1ZFwiLFxuICAgIGNhZGV0Ymx1ZTogXCI1ZjllYTBcIixcbiAgICBjaGFydHJldXNlOiBcIjdmZmYwMFwiLFxuICAgIGNob2NvbGF0ZTogXCJkMjY5MWVcIixcbiAgICBjb3JhbDogXCJmZjdmNTBcIixcbiAgICBjb3JuZmxvd2VyYmx1ZTogXCI2NDk1ZWRcIixcbiAgICBjb3Juc2lsazogXCJmZmY4ZGNcIixcbiAgICBjcmltc29uOiBcImRjMTQzY1wiLFxuICAgIGN5YW46IFwiMGZmXCIsXG4gICAgZGFya2JsdWU6IFwiMDAwMDhiXCIsXG4gICAgZGFya2N5YW46IFwiMDA4YjhiXCIsXG4gICAgZGFya2dvbGRlbnJvZDogXCJiODg2MGJcIixcbiAgICBkYXJrZ3JheTogXCJhOWE5YTlcIixcbiAgICBkYXJrZ3JlZW46IFwiMDA2NDAwXCIsXG4gICAgZGFya2dyZXk6IFwiYTlhOWE5XCIsXG4gICAgZGFya2toYWtpOiBcImJkYjc2YlwiLFxuICAgIGRhcmttYWdlbnRhOiBcIjhiMDA4YlwiLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiBcIjU1NmIyZlwiLFxuICAgIGRhcmtvcmFuZ2U6IFwiZmY4YzAwXCIsXG4gICAgZGFya29yY2hpZDogXCI5OTMyY2NcIixcbiAgICBkYXJrcmVkOiBcIjhiMDAwMFwiLFxuICAgIGRhcmtzYWxtb246IFwiZTk5NjdhXCIsXG4gICAgZGFya3NlYWdyZWVuOiBcIjhmYmM4ZlwiLFxuICAgIGRhcmtzbGF0ZWJsdWU6IFwiNDgzZDhiXCIsXG4gICAgZGFya3NsYXRlZ3JheTogXCIyZjRmNGZcIixcbiAgICBkYXJrc2xhdGVncmV5OiBcIjJmNGY0ZlwiLFxuICAgIGRhcmt0dXJxdW9pc2U6IFwiMDBjZWQxXCIsXG4gICAgZGFya3Zpb2xldDogXCI5NDAwZDNcIixcbiAgICBkZWVwcGluazogXCJmZjE0OTNcIixcbiAgICBkZWVwc2t5Ymx1ZTogXCIwMGJmZmZcIixcbiAgICBkaW1ncmF5OiBcIjY5Njk2OVwiLFxuICAgIGRpbWdyZXk6IFwiNjk2OTY5XCIsXG4gICAgZG9kZ2VyYmx1ZTogXCIxZTkwZmZcIixcbiAgICBmaXJlYnJpY2s6IFwiYjIyMjIyXCIsXG4gICAgZmxvcmFsd2hpdGU6IFwiZmZmYWYwXCIsXG4gICAgZm9yZXN0Z3JlZW46IFwiMjI4YjIyXCIsXG4gICAgZnVjaHNpYTogXCJmMGZcIixcbiAgICBnYWluc2Jvcm86IFwiZGNkY2RjXCIsXG4gICAgZ2hvc3R3aGl0ZTogXCJmOGY4ZmZcIixcbiAgICBnb2xkOiBcImZmZDcwMFwiLFxuICAgIGdvbGRlbnJvZDogXCJkYWE1MjBcIixcbiAgICBncmF5OiBcIjgwODA4MFwiLFxuICAgIGdyZWVuOiBcIjAwODAwMFwiLFxuICAgIGdyZWVueWVsbG93OiBcImFkZmYyZlwiLFxuICAgIGdyZXk6IFwiODA4MDgwXCIsXG4gICAgaG9uZXlkZXc6IFwiZjBmZmYwXCIsXG4gICAgaG90cGluazogXCJmZjY5YjRcIixcbiAgICBpbmRpYW5yZWQ6IFwiY2Q1YzVjXCIsXG4gICAgaW5kaWdvOiBcIjRiMDA4MlwiLFxuICAgIGl2b3J5OiBcImZmZmZmMFwiLFxuICAgIGtoYWtpOiBcImYwZTY4Y1wiLFxuICAgIGxhdmVuZGVyOiBcImU2ZTZmYVwiLFxuICAgIGxhdmVuZGVyYmx1c2g6IFwiZmZmMGY1XCIsXG4gICAgbGF3bmdyZWVuOiBcIjdjZmMwMFwiLFxuICAgIGxlbW9uY2hpZmZvbjogXCJmZmZhY2RcIixcbiAgICBsaWdodGJsdWU6IFwiYWRkOGU2XCIsXG4gICAgbGlnaHRjb3JhbDogXCJmMDgwODBcIixcbiAgICBsaWdodGN5YW46IFwiZTBmZmZmXCIsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiZmFmYWQyXCIsXG4gICAgbGlnaHRncmF5OiBcImQzZDNkM1wiLFxuICAgIGxpZ2h0Z3JlZW46IFwiOTBlZTkwXCIsXG4gICAgbGlnaHRncmV5OiBcImQzZDNkM1wiLFxuICAgIGxpZ2h0cGluazogXCJmZmI2YzFcIixcbiAgICBsaWdodHNhbG1vbjogXCJmZmEwN2FcIixcbiAgICBsaWdodHNlYWdyZWVuOiBcIjIwYjJhYVwiLFxuICAgIGxpZ2h0c2t5Ymx1ZTogXCI4N2NlZmFcIixcbiAgICBsaWdodHNsYXRlZ3JheTogXCI3ODlcIixcbiAgICBsaWdodHNsYXRlZ3JleTogXCI3ODlcIixcbiAgICBsaWdodHN0ZWVsYmx1ZTogXCJiMGM0ZGVcIixcbiAgICBsaWdodHllbGxvdzogXCJmZmZmZTBcIixcbiAgICBsaW1lOiBcIjBmMFwiLFxuICAgIGxpbWVncmVlbjogXCIzMmNkMzJcIixcbiAgICBsaW5lbjogXCJmYWYwZTZcIixcbiAgICBtYWdlbnRhOiBcImYwZlwiLFxuICAgIG1hcm9vbjogXCI4MDAwMDBcIixcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiBcIjY2Y2RhYVwiLFxuICAgIG1lZGl1bWJsdWU6IFwiMDAwMGNkXCIsXG4gICAgbWVkaXVtb3JjaGlkOiBcImJhNTVkM1wiLFxuICAgIG1lZGl1bXB1cnBsZTogXCI5MzcwZGJcIixcbiAgICBtZWRpdW1zZWFncmVlbjogXCIzY2IzNzFcIixcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFwiN2I2OGVlXCIsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiMDBmYTlhXCIsXG4gICAgbWVkaXVtdHVycXVvaXNlOiBcIjQ4ZDFjY1wiLFxuICAgIG1lZGl1bXZpb2xldHJlZDogXCJjNzE1ODVcIixcbiAgICBtaWRuaWdodGJsdWU6IFwiMTkxOTcwXCIsXG4gICAgbWludGNyZWFtOiBcImY1ZmZmYVwiLFxuICAgIG1pc3R5cm9zZTogXCJmZmU0ZTFcIixcbiAgICBtb2NjYXNpbjogXCJmZmU0YjVcIixcbiAgICBuYXZham93aGl0ZTogXCJmZmRlYWRcIixcbiAgICBuYXZ5OiBcIjAwMDA4MFwiLFxuICAgIG9sZGxhY2U6IFwiZmRmNWU2XCIsXG4gICAgb2xpdmU6IFwiODA4MDAwXCIsXG4gICAgb2xpdmVkcmFiOiBcIjZiOGUyM1wiLFxuICAgIG9yYW5nZTogXCJmZmE1MDBcIixcbiAgICBvcmFuZ2VyZWQ6IFwiZmY0NTAwXCIsXG4gICAgb3JjaGlkOiBcImRhNzBkNlwiLFxuICAgIHBhbGVnb2xkZW5yb2Q6IFwiZWVlOGFhXCIsXG4gICAgcGFsZWdyZWVuOiBcIjk4ZmI5OFwiLFxuICAgIHBhbGV0dXJxdW9pc2U6IFwiYWZlZWVlXCIsXG4gICAgcGFsZXZpb2xldHJlZDogXCJkYjcwOTNcIixcbiAgICBwYXBheWF3aGlwOiBcImZmZWZkNVwiLFxuICAgIHBlYWNocHVmZjogXCJmZmRhYjlcIixcbiAgICBwZXJ1OiBcImNkODUzZlwiLFxuICAgIHBpbms6IFwiZmZjMGNiXCIsXG4gICAgcGx1bTogXCJkZGEwZGRcIixcbiAgICBwb3dkZXJibHVlOiBcImIwZTBlNlwiLFxuICAgIHB1cnBsZTogXCI4MDAwODBcIixcbiAgICByZWJlY2NhcHVycGxlOiBcIjY2MzM5OVwiLFxuICAgIHJlZDogXCJmMDBcIixcbiAgICByb3N5YnJvd246IFwiYmM4ZjhmXCIsXG4gICAgcm95YWxibHVlOiBcIjQxNjllMVwiLFxuICAgIHNhZGRsZWJyb3duOiBcIjhiNDUxM1wiLFxuICAgIHNhbG1vbjogXCJmYTgwNzJcIixcbiAgICBzYW5keWJyb3duOiBcImY0YTQ2MFwiLFxuICAgIHNlYWdyZWVuOiBcIjJlOGI1N1wiLFxuICAgIHNlYXNoZWxsOiBcImZmZjVlZVwiLFxuICAgIHNpZW5uYTogXCJhMDUyMmRcIixcbiAgICBzaWx2ZXI6IFwiYzBjMGMwXCIsXG4gICAgc2t5Ymx1ZTogXCI4N2NlZWJcIixcbiAgICBzbGF0ZWJsdWU6IFwiNmE1YWNkXCIsXG4gICAgc2xhdGVncmF5OiBcIjcwODA5MFwiLFxuICAgIHNsYXRlZ3JleTogXCI3MDgwOTBcIixcbiAgICBzbm93OiBcImZmZmFmYVwiLFxuICAgIHNwcmluZ2dyZWVuOiBcIjAwZmY3ZlwiLFxuICAgIHN0ZWVsYmx1ZTogXCI0NjgyYjRcIixcbiAgICB0YW46IFwiZDJiNDhjXCIsXG4gICAgdGVhbDogXCIwMDgwODBcIixcbiAgICB0aGlzdGxlOiBcImQ4YmZkOFwiLFxuICAgIHRvbWF0bzogXCJmZjYzNDdcIixcbiAgICB0dXJxdW9pc2U6IFwiNDBlMGQwXCIsXG4gICAgdmlvbGV0OiBcImVlODJlZVwiLFxuICAgIHdoZWF0OiBcImY1ZGViM1wiLFxuICAgIHdoaXRlOiBcImZmZlwiLFxuICAgIHdoaXRlc21va2U6IFwiZjVmNWY1XCIsXG4gICAgeWVsbG93OiBcImZmMFwiLFxuICAgIHllbGxvd2dyZWVuOiBcIjlhY2QzMlwiXG59O1xuXG4vLyBNYWtlIGl0IGVhc3kgdG8gYWNjZXNzIGNvbG9ycyB2aWEgYGhleE5hbWVzW2hleF1gXG52YXIgaGV4TmFtZXMgPSB0aW55Y29sb3IuaGV4TmFtZXMgPSBmbGlwKG5hbWVzKTtcblxuXG4vLyBVdGlsaXRpZXNcbi8vIC0tLS0tLS0tLVxuXG4vLyBgeyAnbmFtZTEnOiAndmFsMScgfWAgYmVjb21lcyBgeyAndmFsMSc6ICduYW1lMScgfWBcbmZ1bmN0aW9uIGZsaXAobykge1xuICAgIHZhciBmbGlwcGVkID0geyB9O1xuICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgZmxpcHBlZFtvW2ldXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZsaXBwZWQ7XG59XG5cbi8vIFJldHVybiBhIHZhbGlkIGFscGhhIHZhbHVlIFswLDFdIHdpdGggYWxsIGludmFsaWQgdmFsdWVzIGJlaW5nIHNldCB0byAxXG5mdW5jdGlvbiBib3VuZEFscGhhKGEpIHtcbiAgICBhID0gcGFyc2VGbG9hdChhKTtcblxuICAgIGlmIChpc05hTihhKSB8fCBhIDwgMCB8fCBhID4gMSkge1xuICAgICAgICBhID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuLy8gVGFrZSBpbnB1dCBmcm9tIFswLCBuXSBhbmQgcmV0dXJuIGl0IGFzIFswLCAxXVxuZnVuY3Rpb24gYm91bmQwMShuLCBtYXgpIHtcbiAgICBpZiAoaXNPbmVQb2ludFplcm8obikpIHsgbiA9IFwiMTAwJVwiOyB9XG5cbiAgICB2YXIgcHJvY2Vzc1BlcmNlbnQgPSBpc1BlcmNlbnRhZ2Uobik7XG4gICAgbiA9IG1hdGhNaW4obWF4LCBtYXRoTWF4KDAsIHBhcnNlRmxvYXQobikpKTtcblxuICAgIC8vIEF1dG9tYXRpY2FsbHkgY29udmVydCBwZXJjZW50YWdlIGludG8gbnVtYmVyXG4gICAgaWYgKHByb2Nlc3NQZXJjZW50KSB7XG4gICAgICAgIG4gPSBwYXJzZUludChuICogbWF4LCAxMCkgLyAxMDA7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yc1xuICAgIGlmICgobWF0aC5hYnMobiAtIG1heCkgPCAwLjAwMDAwMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnRvIFswLCAxXSByYW5nZSBpZiBpdCBpc24ndCBhbHJlYWR5XG4gICAgcmV0dXJuIChuICUgbWF4KSAvIHBhcnNlRmxvYXQobWF4KTtcbn1cblxuLy8gRm9yY2UgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG5mdW5jdGlvbiBjbGFtcDAxKHZhbCkge1xuICAgIHJldHVybiBtYXRoTWluKDEsIG1hdGhNYXgoMCwgdmFsKSk7XG59XG5cbi8vIFBhcnNlIGEgYmFzZS0xNiBoZXggdmFsdWUgaW50byBhIGJhc2UtMTAgaW50ZWdlclxuZnVuY3Rpb24gcGFyc2VJbnRGcm9tSGV4KHZhbCkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWwsIDE2KTtcbn1cblxuLy8gTmVlZCB0byBoYW5kbGUgMS4wIGFzIDEwMCUsIHNpbmNlIG9uY2UgaXQgaXMgYSBudW1iZXIsIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiBpdCBhbmQgMVxuLy8gPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQyMjA3Mi9qYXZhc2NyaXB0LWhvdy10by1kZXRlY3QtbnVtYmVyLWFzLWEtZGVjaW1hbC1pbmNsdWRpbmctMS0wPlxuZnVuY3Rpb24gaXNPbmVQb2ludFplcm8obikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZignLicpICE9IC0xICYmIHBhcnNlRmxvYXQobikgPT09IDE7XG59XG5cbi8vIENoZWNrIHRvIHNlZSBpZiBzdHJpbmcgcGFzc2VkIGluIGlzIGEgcGVyY2VudGFnZVxuZnVuY3Rpb24gaXNQZXJjZW50YWdlKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKCclJykgIT0gLTE7XG59XG5cbi8vIEZvcmNlIGEgaGV4IHZhbHVlIHRvIGhhdmUgMiBjaGFyYWN0ZXJzXG5mdW5jdGlvbiBwYWQyKGMpIHtcbiAgICByZXR1cm4gYy5sZW5ndGggPT0gMSA/ICcwJyArIGMgOiAnJyArIGM7XG59XG5cbi8vIFJlcGxhY2UgYSBkZWNpbWFsIHdpdGggaXQncyBwZXJjZW50YWdlIHZhbHVlXG5mdW5jdGlvbiBjb252ZXJ0VG9QZXJjZW50YWdlKG4pIHtcbiAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgIG4gPSAobiAqIDEwMCkgKyBcIiVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn1cblxuLy8gQ29udmVydHMgYSBkZWNpbWFsIHRvIGEgaGV4IHZhbHVlXG5mdW5jdGlvbiBjb252ZXJ0RGVjaW1hbFRvSGV4KGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KGQpICogMjU1KS50b1N0cmluZygxNik7XG59XG4vLyBDb252ZXJ0cyBhIGhleCB2YWx1ZSB0byBhIGRlY2ltYWxcbmZ1bmN0aW9uIGNvbnZlcnRIZXhUb0RlY2ltYWwoaCkge1xuICAgIHJldHVybiAocGFyc2VJbnRGcm9tSGV4KGgpIC8gMjU1KTtcbn1cblxudmFyIG1hdGNoZXJzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdmFsdWVzLyNpbnRlZ2Vycz5cbiAgICB2YXIgQ1NTX0lOVEVHRVIgPSBcIlstXFxcXCtdP1xcXFxkKyU/XCI7XG5cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI251bWJlci12YWx1ZT5cbiAgICB2YXIgQ1NTX05VTUJFUiA9IFwiWy1cXFxcK10/XFxcXGQqXFxcXC5cXFxcZCslP1wiO1xuXG4gICAgLy8gQWxsb3cgcG9zaXRpdmUvbmVnYXRpdmUgaW50ZWdlci9udW1iZXIuICBEb24ndCBjYXB0dXJlIHRoZSBlaXRoZXIvb3IsIGp1c3QgdGhlIGVudGlyZSBvdXRjb21lLlxuICAgIHZhciBDU1NfVU5JVCA9IFwiKD86XCIgKyBDU1NfTlVNQkVSICsgXCIpfCg/OlwiICsgQ1NTX0lOVEVHRVIgKyBcIilcIjtcblxuICAgIC8vIEFjdHVhbCBtYXRjaGluZy5cbiAgICAvLyBQYXJlbnRoZXNlcyBhbmQgY29tbWFzIGFyZSBvcHRpb25hbCwgYnV0IG5vdCByZXF1aXJlZC5cbiAgICAvLyBXaGl0ZXNwYWNlIGNhbiB0YWtlIHRoZSBwbGFjZSBvZiBjb21tYXMgb3Igb3BlbmluZyBwYXJlblxuICAgIHZhciBQRVJNSVNTSVZFX01BVENIMyA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuICAgIHZhciBQRVJNSVNTSVZFX01BVENINCA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmdiOiBuZXcgUmVnRXhwKFwicmdiXCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIHJnYmE6IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhzbDogbmV3IFJlZ0V4cChcImhzbFwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICBoc2xhOiBuZXcgUmVnRXhwKFwiaHNsYVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoc3Y6IG5ldyBSZWdFeHAoXCJoc3ZcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgaHN2YTogbmV3IFJlZ0V4cChcImhzdmFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaGV4MzogL14oWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgICAgICAgaGV4NjogL14oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkLyxcbiAgICAgICAgaGV4ODogL14oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pJC9cbiAgICB9O1xufSkoKTtcblxuLy8gYHN0cmluZ0lucHV0VG9PYmplY3RgXG4vLyBQZXJtaXNzaXZlIHN0cmluZyBwYXJzaW5nLiAgVGFrZSBpbiBhIG51bWJlciBvZiBmb3JtYXRzLCBhbmQgb3V0cHV0IGFuIG9iamVjdFxuLy8gYmFzZWQgb24gZGV0ZWN0ZWQgZm9ybWF0LiAgUmV0dXJucyBgeyByLCBnLCBiIH1gIG9yIGB7IGgsIHMsIGwgfWAgb3IgYHsgaCwgcywgdn1gXG5mdW5jdGlvbiBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKSB7XG5cbiAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UodHJpbUxlZnQsJycpLnJlcGxhY2UodHJpbVJpZ2h0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZWQgPSBmYWxzZTtcbiAgICBpZiAobmFtZXNbY29sb3JdKSB7XG4gICAgICAgIGNvbG9yID0gbmFtZXNbY29sb3JdO1xuICAgICAgICBuYW1lZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbG9yID09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogMCwgZzogMCwgYjogMCwgYTogMCwgZm9ybWF0OiBcIm5hbWVcIiB9O1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBtYXRjaCBzdHJpbmcgaW5wdXQgdXNpbmcgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAvLyBLZWVwIG1vc3Qgb2YgdGhlIG51bWJlciBib3VuZGluZyBvdXQgb2YgdGhpcyBmdW5jdGlvbiAtIGRvbid0IHdvcnJ5IGFib3V0IFswLDFdIG9yIFswLDEwMF0gb3IgWzAsMzYwXVxuICAgIC8vIEp1c3QgcmV0dXJuIGFuIG9iamVjdCBhbmQgbGV0IHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBoYW5kbGUgdGhhdC5cbiAgICAvLyBUaGlzIHdheSB0aGUgcmVzdWx0IHdpbGwgYmUgdGhlIHNhbWUgd2hldGhlciB0aGUgdGlueWNvbG9yIGlzIGluaXRpYWxpemVkIHdpdGggc3RyaW5nIG9yIG9iamVjdC5cbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0Y2hbMV0sIGc6IG1hdGNoWzJdLCBiOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCBsOiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHN2YS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgaDogbWF0Y2hbMV0sIHM6IG1hdGNoWzJdLCB2OiBtYXRjaFszXSwgYTogbWF0Y2hbNF0gfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhOiBjb252ZXJ0SGV4VG9EZWNpbWFsKG1hdGNoWzFdKSxcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzRdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4OFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4My5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdICsgJycgKyBtYXRjaFsyXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10gKyAnJyArIG1hdGNoWzNdKSxcbiAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV0NBRzJQYXJtcyhwYXJtcykge1xuICAgIC8vIHJldHVybiB2YWxpZCBXQ0FHMiBwYXJtcyBmb3IgaXNSZWFkYWJsZS5cbiAgICAvLyBJZiBpbnB1dCBwYXJtcyBhcmUgaW52YWxpZCwgcmV0dXJuIHtcImxldmVsXCI6XCJBQVwiLCBcInNpemVcIjpcInNtYWxsXCJ9XG4gICAgdmFyIGxldmVsLCBzaXplO1xuICAgIHBhcm1zID0gcGFybXMgfHwge1wibGV2ZWxcIjpcIkFBXCIsIFwic2l6ZVwiOlwic21hbGxcIn07XG4gICAgbGV2ZWwgPSAocGFybXMubGV2ZWwgfHwgXCJBQVwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIHNpemUgPSAocGFybXMuc2l6ZSB8fCBcInNtYWxsXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxldmVsICE9PSBcIkFBXCIgJiYgbGV2ZWwgIT09IFwiQUFBXCIpIHtcbiAgICAgICAgbGV2ZWwgPSBcIkFBXCI7XG4gICAgfVxuICAgIGlmIChzaXplICE9PSBcInNtYWxsXCIgJiYgc2l6ZSAhPT0gXCJsYXJnZVwiKSB7XG4gICAgICAgIHNpemUgPSBcInNtYWxsXCI7XG4gICAgfVxuICAgIHJldHVybiB7XCJsZXZlbFwiOmxldmVsLCBcInNpemVcIjpzaXplfTtcbn1cblxuLy8gTm9kZTogRXhwb3J0IGZ1bmN0aW9uXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdGlueWNvbG9yO1xufVxuLy8gQU1EL3JlcXVpcmVqczogRGVmaW5lIHRoZSBtb2R1bGVcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7cmV0dXJuIHRpbnljb2xvcjt9KTtcbn1cbi8vIEJyb3dzZXI6IEV4cG9zZSB0byB3aW5kb3dcbmVsc2Uge1xuICAgIHdpbmRvdy50aW55Y29sb3IgPSB0aW55Y29sb3I7XG59XG5cbn0pKCk7XG4iLCIvKlxuICogVG9hc3RyXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1XG4gKiBBdXRob3JzOiBKb2huIFBhcGEsIEhhbnMgRmrDpGxsZW1hcmssIGFuZCBUaW0gRmVycmVsbC5cbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBVc2UsIHJlcHJvZHVjdGlvbiwgZGlzdHJpYnV0aW9uLCBhbmQgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29kZSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmRcbiAqIGNvbmRpdGlvbnMgb2YgdGhlIE1JVCBsaWNlbnNlLCBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiBBUklBIFN1cHBvcnQ6IEdyZXRhIEtyYWZzaWdcbiAqXG4gKiBQcm9qZWN0OiBodHRwczovL2dpdGh1Yi5jb20vQ29kZVNldmVuL3RvYXN0clxuICovXG4vKiBnbG9iYWwgZGVmaW5lICovXG47IChmdW5jdGlvbiAoZGVmaW5lKSB7XG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZ1bmN0aW9uICgkKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICRjb250YWluZXI7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG4gICAgICAgICAgICB2YXIgdG9hc3RJZCA9IDA7XG4gICAgICAgICAgICB2YXIgdG9hc3RUeXBlID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGluZm86ICdpbmZvJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgd2FybmluZzogJ3dhcm5pbmcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdG9hc3RyID0ge1xuICAgICAgICAgICAgICAgIGNsZWFyOiBjbGVhcixcbiAgICAgICAgICAgICAgICByZW1vdmU6IHJlbW92ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgZ2V0Q29udGFpbmVyOiBnZXRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgaW5mbzogaW5mbyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcyLjEuMicsXG4gICAgICAgICAgICAgICAgd2FybmluZzogd2FybmluZ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHByZXZpb3VzVG9hc3Q7XG5cbiAgICAgICAgICAgIHJldHVybiB0b2FzdHI7XG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldENvbnRhaW5lcihvcHRpb25zLCBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IGdldE9wdGlvbnMoKTsgfVxuICAgICAgICAgICAgICAgICRjb250YWluZXIgPSAkKCcjJyArIG9wdGlvbnMuY29udGFpbmVySWQpO1xuICAgICAgICAgICAgICAgIGlmICgkY29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaW5mbyhtZXNzYWdlLCB0aXRsZSwgb3B0aW9uc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvYXN0VHlwZS5pbmZvLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IGdldE9wdGlvbnMoKS5pY29uQ2xhc3Nlcy5pbmZvLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MobWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiBnZXRPcHRpb25zKCkuaWNvbkNsYXNzZXMuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc092ZXJyaWRlOiBvcHRpb25zT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHRpdGxlLCBvcHRpb25zT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9hc3RUeXBlLndhcm5pbmcsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLndhcm5pbmcsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNPdmVycmlkZTogb3B0aW9uc092ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXIoJHRvYXN0RWxlbWVudCwgY2xlYXJPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyKSB7IGdldENvbnRhaW5lcihvcHRpb25zKTsgfVxuICAgICAgICAgICAgICAgIGlmICghY2xlYXJUb2FzdCgkdG9hc3RFbGVtZW50LCBvcHRpb25zLCBjbGVhck9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCR0b2FzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoISRjb250YWluZXIpIHsgZ2V0Q29udGFpbmVyKG9wdGlvbnMpOyB9XG4gICAgICAgICAgICAgICAgaWYgKCR0b2FzdEVsZW1lbnQgJiYgJCgnOmZvY3VzJywgJHRvYXN0RWxlbWVudCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkY29udGFpbmVyLmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICRjb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBmdW5jdGlvbnNcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXJDb250YWluZXIgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9hc3RzVG9DbGVhciA9ICRjb250YWluZXIuY2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdG9hc3RzVG9DbGVhci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRvYXN0KCQodG9hc3RzVG9DbGVhcltpXSksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXJUb2FzdCAoJHRvYXN0RWxlbWVudCwgb3B0aW9ucywgY2xlYXJPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcmNlID0gY2xlYXJPcHRpb25zICYmIGNsZWFyT3B0aW9ucy5mb3JjZSA/IGNsZWFyT3B0aW9ucy5mb3JjZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICgkdG9hc3RFbGVtZW50ICYmIChmb3JjZSB8fCAkKCc6Zm9jdXMnLCAkdG9hc3RFbGVtZW50KS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnRbb3B0aW9ucy5oaWRlTWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5oaWRlRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuaGlkZUVhc2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVDb250YWluZXIob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICRjb250YWluZXIgPSAkKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCBvcHRpb25zLmNvbnRhaW5lcklkKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3Mob3B0aW9ucy5wb3NpdGlvbkNsYXNzKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyb2xlJywgJ2FsZXJ0Jyk7XG5cbiAgICAgICAgICAgICAgICAkY29udGFpbmVyLmFwcGVuZFRvKCQob3B0aW9ucy50YXJnZXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFwVG9EaXNtaXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0b2FzdENsYXNzOiAndG9hc3QnLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJJZDogJ3RvYXN0LWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgICAgICBzaG93TWV0aG9kOiAnZmFkZUluJywgLy9mYWRlSW4sIHNsaWRlRG93biwgYW5kIHNob3cgYXJlIGJ1aWx0IGludG8galF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIHNob3dEdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgICAgICAgICBzaG93RWFzaW5nOiAnc3dpbmcnLCAvL3N3aW5nIGFuZCBsaW5lYXIgYXJlIGJ1aWx0IGludG8galF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIG9uU2hvd246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZU1ldGhvZDogJ2ZhZGVPdXQnLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRHVyYXRpb246IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFYXNpbmc6ICdzd2luZycsXG4gICAgICAgICAgICAgICAgICAgIG9uSGlkZGVuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlTWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VEdXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlRWFzaW5nOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFRpbWVPdXQ6IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ3RvYXN0LWVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm86ICd0b2FzdC1pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICd0b2FzdC1zdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmc6ICd0b2FzdC13YXJuaW5nJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6ICd0b2FzdC1pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25DbGFzczogJ3RvYXN0LXRvcC1yaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVPdXQ6IDUwMDAsIC8vIFNldCB0aW1lT3V0IGFuZCBleHRlbmRlZFRpbWVPdXQgdG8gMCB0byBtYWtlIGl0IHN0aWNreVxuICAgICAgICAgICAgICAgICAgICB0aXRsZUNsYXNzOiAndG9hc3QtdGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlQ2xhc3M6ICd0b2FzdC1tZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlSHRtbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ2JvZHknLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUh0bWw6ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIj4mdGltZXM7PC9idXR0b24+JyxcbiAgICAgICAgICAgICAgICAgICAgbmV3ZXN0T25Ub3A6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREdXBsaWNhdGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXI6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGlzaChhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbm90aWZ5KG1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIHZhciBpY29uQ2xhc3MgPSBtYXAuaWNvbkNsYXNzIHx8IG9wdGlvbnMuaWNvbkNsYXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobWFwLm9wdGlvbnNPdmVycmlkZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZChvcHRpb25zLCBtYXAub3B0aW9uc092ZXJyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzID0gbWFwLm9wdGlvbnNPdmVycmlkZS5pY29uQ2xhc3MgfHwgaWNvbkNsYXNzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRFeGl0KG9wdGlvbnMsIG1hcCkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICB0b2FzdElkKys7XG5cbiAgICAgICAgICAgICAgICAkY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciAkdG9hc3RFbGVtZW50ID0gJCgnPGRpdi8+Jyk7XG4gICAgICAgICAgICAgICAgdmFyICR0aXRsZUVsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgJG1lc3NhZ2VFbGVtZW50ID0gJCgnPGRpdi8+Jyk7XG4gICAgICAgICAgICAgICAgdmFyICRwcm9ncmVzc0VsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgJGNsb3NlRWxlbWVudCA9ICQob3B0aW9ucy5jbG9zZUh0bWwpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc0JhciA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxJZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWF4SGlkZVRpbWU6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9hc3RJZDogdG9hc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG1hcFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBwZXJzb25hbGl6ZVRvYXN0KCk7XG5cbiAgICAgICAgICAgICAgICBkaXNwbGF5VG9hc3QoKTtcblxuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgcHVibGlzaChyZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1ZyAmJiBjb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHRvYXN0RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmcoc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBlcnNvbmFsaXplVG9hc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEljb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRDbG9zZUJ1dHRvbigpO1xuICAgICAgICAgICAgICAgICAgICBzZXRQcm9ncmVzc0JhcigpO1xuICAgICAgICAgICAgICAgICAgICBzZXRTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50cygpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5ob3ZlcihzdGlja0Fyb3VuZCwgZGVsYXllZEhpZGVUb2FzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5vbmNsaWNrICYmIG9wdGlvbnMudGFwVG9EaXNtaXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmNsaWNrKGhpZGVUb2FzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbG9zZUJ1dHRvbiAmJiAkY2xvc2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkY2xvc2VFbGVtZW50LmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5jYW5jZWxCdWJibGUgIT09IHVuZGVmaW5lZCAmJiBldmVudC5jYW5jZWxCdWJibGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRvYXN0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jbGljayhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRvYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRpc3BsYXlUb2FzdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5oaWRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudFtvcHRpb25zLnNob3dNZXRob2RdKFxuICAgICAgICAgICAgICAgICAgICAgICAge2R1cmF0aW9uOiBvcHRpb25zLnNob3dEdXJhdGlvbiwgZWFzaW5nOiBvcHRpb25zLnNob3dFYXNpbmcsIGNvbXBsZXRlOiBvcHRpb25zLm9uU2hvd259XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZU91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRUaW1lb3V0KGhpZGVUb2FzdCwgb3B0aW9ucy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lID0gcGFyc2VGbG9hdChvcHRpb25zLnRpbWVPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuaGlkZUV0YSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcm9ncmVzc0Jhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh1cGRhdGVQcm9ncmVzcywgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0SWNvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5pY29uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuYWRkQ2xhc3Mob3B0aW9ucy50b2FzdENsYXNzKS5hZGRDbGFzcyhpY29uQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0U2VxdWVuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5ld2VzdE9uVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLnByZXBlbmQoJHRvYXN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLmFwcGVuZCgkdG9hc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFRpdGxlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGl0bGVFbGVtZW50LmFwcGVuZCghb3B0aW9ucy5lc2NhcGVIdG1sID8gbWFwLnRpdGxlIDogZXNjYXBlSHRtbChtYXAudGl0bGUpKS5hZGRDbGFzcyhvcHRpb25zLnRpdGxlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5hcHBlbmQoJHRpdGxlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRNZXNzYWdlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRtZXNzYWdlRWxlbWVudC5hcHBlbmQoIW9wdGlvbnMuZXNjYXBlSHRtbCA/IG1hcC5tZXNzYWdlIDogZXNjYXBlSHRtbChtYXAubWVzc2FnZSkpLmFkZENsYXNzKG9wdGlvbnMubWVzc2FnZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuYXBwZW5kKCRtZXNzYWdlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRDbG9zZUJ1dHRvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjbG9zZUVsZW1lbnQuYWRkQ2xhc3MoJ3RvYXN0LWNsb3NlLWJ1dHRvbicpLmF0dHIoJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnByZXBlbmQoJGNsb3NlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRQcm9ncmVzc0JhcigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJvZ3Jlc3NCYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRwcm9ncmVzc0VsZW1lbnQuYWRkQ2xhc3MoJ3RvYXN0LXByb2dyZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnByZXBlbmQoJHByb2dyZXNzRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG91bGRFeGl0KG9wdGlvbnMsIG1hcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50RHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5tZXNzYWdlID09PSBwcmV2aW91c1RvYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVG9hc3QgPSBtYXAubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGlkZVRvYXN0KG92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBvdmVycmlkZSAmJiBvcHRpb25zLmNsb3NlTWV0aG9kICE9PSBmYWxzZSA/IG9wdGlvbnMuY2xvc2VNZXRob2QgOiBvcHRpb25zLmhpZGVNZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG92ZXJyaWRlICYmIG9wdGlvbnMuY2xvc2VEdXJhdGlvbiAhPT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jbG9zZUR1cmF0aW9uIDogb3B0aW9ucy5oaWRlRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBlYXNpbmcgPSBvdmVycmlkZSAmJiBvcHRpb25zLmNsb3NlRWFzaW5nICE9PSBmYWxzZSA/IG9wdGlvbnMuY2xvc2VFYXNpbmcgOiBvcHRpb25zLmhpZGVFYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKCc6Zm9jdXMnLCAkdG9hc3RFbGVtZW50KS5sZW5ndGggJiYgIW92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHByb2dyZXNzQmFyLmludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRvYXN0RWxlbWVudFttZXRob2RdKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUb2FzdCgkdG9hc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbkhpZGRlbiAmJiByZXNwb25zZS5zdGF0ZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkhpZGRlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0ZSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2gocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWxheWVkSGlkZVRvYXN0KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lT3V0ID4gMCB8fCBvcHRpb25zLmV4dGVuZGVkVGltZU91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRUaW1lb3V0KGhpZGVUb2FzdCwgb3B0aW9ucy5leHRlbmRlZFRpbWVPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMuZXh0ZW5kZWRUaW1lT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQmFyLmhpZGVFdGEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3RpY2tBcm91bmQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpbnRlcnZhbElkKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuaGlkZUV0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuc3RvcCh0cnVlLCB0cnVlKVtvcHRpb25zLnNob3dNZXRob2RdKFxuICAgICAgICAgICAgICAgICAgICAgICAge2R1cmF0aW9uOiBvcHRpb25zLnNob3dEdXJhdGlvbiwgZWFzaW5nOiBvcHRpb25zLnNob3dFYXNpbmd9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50YWdlID0gKChwcm9ncmVzc0Jhci5oaWRlRXRhIC0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSkgLyBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZSkgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgICRwcm9ncmVzc0VsZW1lbnQud2lkdGgocGVyY2VudGFnZSArICclJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZ2V0RGVmYXVsdHMoKSwgdG9hc3RyLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVUb2FzdCgkdG9hc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyKSB7ICRjb250YWluZXIgPSBnZXRDb250YWluZXIoKTsgfVxuICAgICAgICAgICAgICAgIGlmICgkdG9hc3RFbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoJGNvbnRhaW5lci5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAkY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RvYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KSgpO1xuICAgIH0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZGVwcywgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgeyAvL05vZGVcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy50b2FzdHIgPSBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xuICAgIH1cbn0pKTtcbiIsInZhciB0ZW1wbGF0ZVN5c3RlbSA9IHJlcXVpcmUoJy4uL3NyYy9qcy9iaW5kaW5ncy9jaG9vc2UtdGVtcGxhdGUuanMnKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbihldmVudCkge1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImFycmF5XCIsIFwiPCEtLSBrbyBmb3JlYWNoOiAkZGF0YSAtLT48IS0tIGtvIGJsb2NrOiAkZGF0YSAtLT48IS0tIC9rbyAtLT48IS0tIC9rbyAtLT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYmxvY2stc2hvd1wiLCBcIjwhLS0ga28gYmxvY2s6ICRkYXRhLCBzY3JvbGxJbnRvVmlldzogJHJvb3Quc2VsZWN0ZWRCbG9jaygpID09PSAkZGF0YSAtLT48IS0tIC9rbyAtLT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYmxvY2std3lzaXd5Z1wiLCBcIjxkaXYgY2xhc3M9XFx4MjJlZGl0YWJsZSBibG9ja1xceDIyIGRhdGEtZHJvcC1jb250ZW50PVxceDIyRHJvcCBoZXJlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyAnZGF0YS1kcm9wLWNvbnRlbnQnOiAkcm9vdC50KCdEcm9wIGhlcmUnKSB9LCBjbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0QmxvY2sob2JqKTsgcmV0dXJuIHRydWUgfSwgY2xpY2tCdWJibGU6IGZhbHNlLCBjc3M6IHsgc2VsZWN0ZWQ6ICRyb290LnNlbGVjdGVkQmxvY2soKSA9PT0gJGRhdGEgfSwgc2Nyb2xsSW50b1ZpZXc6ICRyb290LnNlbGVjdGVkQmxvY2soKSA9PT0gJGRhdGFcXHgyMj4gIDxkaXYgY2xhc3M9XFx4MjJtby1ibG9ja3NlbGVjdGlvbmhlbHBlclxceDIyPjwvZGl2PiAgPGRpdiBjbGFzcz1cXHgyMnRvb2xzXFx4MjIgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkaW5kZXggIT0gJ3VuZGVmaW5lZCcgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJEcmFnIHRoaXMgaGFuZGxlIHRvIG1vdmUgdGhlIGJsb2NrXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnRHJhZyB0aGlzIGhhbmRsZSB0byBtb3ZlIHRoZSBibG9jaycpIH1cXHgyMiBjbGFzcz1cXHgyMnRvb2wgaGFuZGxlXFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1zb3J0XFx4MjI+PC9pPjwvZGl2PiAgICA8IS0tIGtvIGlmOiAkaW5kZXgoKSA+IDAgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJNb3ZlIHRoaXMgYmxvY2sgdXBzaWRlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnTW92ZSB0aGlzIGJsb2NrIHVwc2lkZScpIH1cXHgyMiBjbGFzcz1cXHgyMnRvb2wgbW92ZXVwXFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1zb3J0LWFzY1xceDIyIGRhdGEtYmluZD0nY2xpY2s6ICRyb290Lm1vdmVCbG9jay5iaW5kKCRlbGVtZW50LCAkaW5kZXgsICRwYXJlbnQsIHRydWUpJz48L2k+PC9kaXY+ICAgIDwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiAkaW5kZXgoKSA8ICRwYXJlbnQuYmxvY2tzKCkubGVuZ3RoIC0xIC0tPiAgICA8ZGl2IHRpdGxlPVxceDIyTW92ZSB0aGlzIGJsb2NrIGRvd25zaWRlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnTW92ZSB0aGlzIGJsb2NrIGRvd25zaWRlJykgfVxceDIyIGNsYXNzPVxceDIydG9vbCBtb3ZlZG93blxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtc29ydC1kZXNjXFx4MjIgZGF0YS1iaW5kPSdjbGljazogJHJvb3QubW92ZUJsb2NrLmJpbmQoJGVsZW1lbnQsICRpbmRleCwgJHBhcmVudCwgZmFsc2UpJz48L2k+PC9kaXY+ICAgIDwhLS0gL2tvIC0tPiAgICA8ZGl2IHRpdGxlPVxceDIyRGVsZXRlIGJsb2NrXFx4MjIgY2xhc3M9XFx4MjJ0b29sIGRlbGV0ZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0RlbGV0ZSBibG9jaycpIH0sIGNsaWNrOiAkcm9vdC5yZW1vdmVCbG9jay5iaW5kKCRlbGVtZW50LCAkcmF3RGF0YSwgJHBhcmVudClcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXRyYXNoLW9cXHgyMj48L2k+PC9kaXY+ICAgIDxkaXYgdGl0bGU9XFx4MjJEdXBsaWNhdGUgYmxvY2tcXHgyMiBjbGFzcz1cXHgyMnRvb2wgY2xvbmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdEdXBsaWNhdGUgYmxvY2snKSB9LCBjbGljazogJHJvb3QuZHVwbGljYXRlQmxvY2suYmluZCgkZWxlbWVudCwgJGluZGV4LCAkcGFyZW50KVxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtZmlsZXMtb1xceDIyPjwvaT48L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkZGF0YS5fbmV4dFZhcmlhbnQgIT0gJ3VuZGVmaW5lZCcgLS0+PGRpdiB0aXRsZT1cXHgyMlN3aXRjaCBibG9jayB2YXJpYW50XFx4MjIgY2xhc3M9XFx4MjJ0b29sIHZhcmlhbnRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTd2l0Y2ggYmxvY2sgdmFyaWFudCcpIH0sIGNsaWNrOiAkZGF0YS5fbmV4dFZhcmlhbnRcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLW1hZ2ljXFx4MjI+PC9pPjwvZGl2PjwhLS0gL2tvIC0tPiAgPC9kaXY+ICA8IS0tIGtvIGJsb2NrOiAkZGF0YSAtLT48IS0tIC9rbyAtLT48L2Rpdj5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYmxvY2tzLXNob3dcIiwgXCI8IS0tIGtvIHRlbXBsYXRlOiB7IG5hbWU6ICdibG9jay1zaG93JywgZm9yZWFjaDogYmxvY2tzIH0gLS0+PCEtLSAva28gLS0+XCIpO1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImJsb2Nrcy13eXNpd3lnXCIsIFwiPGRpdiBjbGFzcz1cXHgyMnNvcnRhYmxlLWJsb2Nrcy1lZGl0XFx4MjIgZGF0YS1kcm9wLWNvbnRlbnQ9XFx4MjJEcm9wIGhlcmVcXHgyMiBkYXRhLWVtcHR5LWNvbnRlbnQ9XFx4MjJEcm9wIGhlcmUgYmxvY2tzIGZyb20gdGhlIEJsb2NrcyB0YWJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7ICdkYXRhLWRyb3AtY29udGVudCc6ICRyb290LnQoJ0Ryb3AgaGVyZScpLCAnZGF0YS1lbXB0eS1jb250ZW50JzogJHJvb3QudCgnRHJvcCBoZXJlIGJsb2NrcyBmcm9tIHRoZSAmcXVvdDtCbG9ja3MmcXVvdDsgdGFiJykgfSwgY3NzOiB7ICdlbXB0eSc6IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoYmxvY2tzKS5sZW5ndGggPT0gMCB9LCBleHRzb3J0YWJsZTogeyBjb25uZWN0Q2xhc3M6ICdzb3J0YWJsZS1ibG9ja3MtZWRpdCcsIHRlbXBsYXRlOiAnYmxvY2std3lzaXd5ZycsIGRhdGE6IGJsb2NrcywgZHJhZ2dpbmc6ICRyb290LmRyYWdnaW5nLCBiZWZvcmVNb3ZlOiAkcm9vdC5zdGFydE11bHRpcGxlLCBhZnRlck1vdmU6ICRyb290LnN0b3BNdWx0aXBsZSwgb3B0aW9uczogeyBoYW5kbGU6ICcuaGFuZGxlJywgcGxhY2Vob2xkZXI6ICRyb290LnBsYWNlaG9sZGVySGVscGVyIH0gfVxceDIyPjwvZGl2PlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJjdXN0b21zdHlsZVwiLCBcIjxkaXYgY2xhc3M9XFx4MjJjdXN0b21TdHlsZUhlbHBcXHgyMiBkYXRhLWJpbmQ9XFx4MjJodG1sOiAkcm9vdC50KCdDdXN0b21pemVkIGJsb2NrLjx1bD48bGk+SW4gdGhpcyBzdGF0dXMgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIHdpbGwgYmUgc3BlY2lmaWMgdG8gdGhlIGN1cnJlbnQgYmxvY2sgKGluc3RlYWQgb2YgYmVpbmcgZ2xvYmFsIHRvIGFsbCBibG9ja3MgaW4gdGhlIHNhbWUgc2VjdGlvbik8L2xpPjxsaT5BIDxzcGFuIGNsYXNzPSZxdW90O2N1c3RvbVN0eWxlZCZxdW90Oz48c3Bhbj4mcXVvdDtzbWFsbCBjdWJlJnF1b3Q7IDwvc3Bhbj48L3NwYW4+IGljb24gYmVzaWRlIHRoZSBwcm9wZXJ0eSB3aWxsIG1hcmsgdGhlIGN1c3RvbWl6YXRpb24uIEJ5IGNsaWNraW5nIHRoaXMgaWNvbiB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSByZXZlcnRlZCB0byB0aGUgdmFsdWUgZGVmaW5lZCBmb3IgdGhlIHNlY3Rpb24uPC9saT48L3VsPicpXFx4MjI+Q3VzdG9taXplZCBibG9jay48dWw+PGxpPkluIHRoaXMgc3RhdHVzIGNoYW5nZXMgdG8gcHJvcGVydGllcyB3aWxsIGJlIHNwZWNpZmljIHRvIHRoZSBjdXJyZW50IGJsb2NrIChpbnN0ZWFkIG9mIGJlaW5nIGdsb2JhbCB0byBhbGwgYmxvY2tzIGluIHRoZSBzYW1lIHNlY3Rpb24pPC9saT48bGk+QSA8c3BhbiBjbGFzcz1cXHgyMmN1c3RvbVN0eWxlZFxceDIyPjxzcGFuPlxceDIyc21hbGwgY3ViZVxceDIyIDwvc3Bhbj48L3NwYW4+IGljb24gYmVzaWRlIHRoZSBwcm9wZXJ0eSB3aWxsIG1hcmsgdGhlIGN1c3RvbWl6YXRpb24uIEJ5IGNsaWNraW5nIHRoaXMgaWNvbiB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSByZXZlcnRlZCB0byB0aGUgdmFsdWUgZGVmaW5lZCBmb3IgdGhlIHNlY3Rpb24uPC9saT48L3VsPjwvZGl2PlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJlbXB0eVwiLCBcIlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJlcnJvclwiLCBcIls8ZGl2IHN0eWxlPVxceDIyYmFja2dyb3VuZC1jb2xvcjogI2ZmZjBmMFxceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6IGtvLnRvSlMoJGRhdGEpXFx4MjI+PC9kaXY+XVwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJnYWxsZXJ5LWltYWdlc1wiLCBcIjxkaXYgZGF0YS1iaW5kPVxceDIyZm9yZWFjaDogaXRlbXMuY3VycmVudFBhZ2VEYXRhXFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIyZHJhZ2dhYmxlLWl0ZW1cXHgyMiBkYXRhLWJpbmQ9XFx4MjJpZjogdHlwZW9mIHRodW1ibmFpbFVybCAhPSAndW5kZWZpbmVkJ1xceDIyPiAgICA8ZGl2IGNsYXNzPVxceDIyZHJhZ2dhYmxlIGltYWdlXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmFkZEltYWdlLCBleHRkcmFnZ2FibGU6IHsgZGF0YTogJGRhdGEsIGRyb3BDb250YWluZXI6ICcjbWFpbi13eXNpd3lnLWFyZWEnLCBkcmFnZ2luZzogJHJvb3QuZHJhZ2dpbmdJbWFnZSwgJ29wdGlvbnMnOiB7ICdhcHBlbmRUbyc6ICcjcGFnZScgfSB9LCBzdHlsZTogeyBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwoXFxcXCcnICsgdGh1bWJuYWlsVXJsICsgJ1xcXFwnKScgfVxceDIyPiAgICAgIDxpbWcgdGl0bGU9XFx4MjJEcmFnIHRoaXMgaW1hZ2UgYW5kIGRyb3AgaXQgb24gYW55IHRlbXBsYXRlIGltYWdlIHBsYWNlaG9sZGVyXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBibG9jaztcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge30sIGF0dHI6IHsgc3JjOiB0aHVtYm5haWxVcmwsICd0aXRsZSc6ICRyb290LnQoJ0RyYWcgdGhpcyBpbWFnZSBhbmQgZHJvcCBpdCBvbiBhbnkgdGVtcGxhdGUgaW1hZ2UgcGxhY2Vob2xkZXInKSB9XFx4MjIvPiAgICA8L2Rpdj4gIDwvZGl2PjwvZGl2PjwhLS0ga28gaWY6IGl0ZW1zLnBhZ2VDb3VudCgpID4gMSAtLT48ZGl2IGNsYXNzPVxceDIyZ2FsbGVyeVBhZ2VyXFx4MjIgZGF0YS1iaW5kPVxceDIyYnV0dG9uc2V0OiB7fVxceDIyPiAgPGEgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiBpdGVtcy5tb3ZlRmlyc3QsIGJ1dHRvbjogeyBkaXNhYmxlZDogaXRlbXMuY3VycmVudFBhZ2UoKSA9PSAxLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZmFzdC1iYWNrd2FyZCcgfSwgdGV4dDogZmFsc2UgfVxceDIyPkZpcnN0PC9hPiAgPGEgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiBpdGVtcy5tb3ZlUHJldmlvdXMsIGJ1dHRvbjogeyBkaXNhYmxlZDogaXRlbXMuY3VycmVudFBhZ2UoKSA9PSAxLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtYmFja3dhcmQnIH0sIHRleHQ6IGZhbHNlIH1cXHgyMj5QcmV2aW91czwvYT4gIDxzcGFuIGRhdGEtYmluZD1cXHgyMmJ1dHRvbjogeyBkaXNhYmxlZDogdHJ1ZSwgdGV4dDogdHJ1ZSwgbGFiZWw6ICcgJytpdGVtcy5jdXJyZW50UGFnZSgpKycgZGkgJytpdGVtcy5wYWdlQ291bnQoKSsnICcgfVxceDIyPiBYIGRpIFkgPC9zcGFuPiAgPGEgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiBpdGVtcy5tb3ZlTmV4dCwgYnV0dG9uOiB7IGRpc2FibGVkOiBpdGVtcy5jdXJyZW50UGFnZSgpID09IGl0ZW1zLnBhZ2VDb3VudCgpLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZm9yd2FyZCcgfSwgdGV4dDogZmFsc2UgfVxceDIyPk5leHQ8L2E+ICA8YSBocmVmPVxceDIyamF2YXNjcmlwdDp2b2lkKDApXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6IGl0ZW1zLm1vdmVMYXN0LCBidXR0b246IHsgZGlzYWJsZWQ6IGl0ZW1zLmN1cnJlbnRQYWdlKCkgPT0gaXRlbXMucGFnZUNvdW50KCksIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mYXN0LWZvcndhcmQnIH0sIHRleHQ6IGZhbHNlIH1cXHgyMj5MYXN0PC9hPjwvZGl2PjwhLS0gL2tvIC0tPlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJpbWctd3lzaXd5Z1wiLCBcIjx0YWJsZSB0YWJmb2N1cz1cXHgyMjBcXHgyMiBjZWxsc3BhY2luZz1cXHgyMjBcXHgyMiBjZWxscGFkZGluZz1cXHgyMjBcXHgyMiBkYXRhLWRyb3AtY29udGVudD1cXHgyMkRyb3AgaGVyZVxceDIyIGRhdGEtYmluZD1cXHgyMnN0eWxlOiBfc3R5bGViaW5kLCBjbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0SXRlbShfaXRlbSwgX2RhdGEpOyByZXR1cm4gdHJ1ZTsgfSwgY2xpY2tCdWJibGU6IGZhbHNlLCBmdWRyb3BwYWJsZTogeyBhY3RpdmVDbGFzczogJ3VpLXN0YXRlLWhpZ2hsaWdodCcsIGhvdmVyQ2xhc3M6ICd1aS1zdGF0ZS1kcmFnaG92ZXInIH0sIGRyb3BwYWJsZTogeyBvcHRpb25zOiB7IGFjY2VwdDogJy5pbWFnZScsIGFjdGl2ZUNsYXNzOiAndWktc3RhdGUtaGlnaGxpZ2h0JywgaG92ZXJDbGFzczogJ3VpLXN0YXRlLWRyYWdob3ZlcicgfSwgZGF0YTogX3NyYywgZHJhZ2dlZDogJHJvb3QuZmlsZVRvSW1hZ2UgfSwgY3NzOiB7IHNlbGVjdGVkaXRlbTogJHJvb3QuaXNTZWxlY3RlZEl0ZW0oX2l0ZW0pIH0sIHNjcm9sbEludG9WaWV3OiAkcm9vdC5pc1NlbGVjdGVkSXRlbShfaXRlbSksIGF0dHI6IHsgJ2RhdGEtZHJvcC1jb250ZW50JzogJHJvb3QudCgnRHJvcCBoZXJlJyksIHdpZHRoOiBfd2lkdGgsIGhlaWdodDogX2hlaWdodCwgYWxpZ246IF9hbGlnbiB9XFx4MjIgIGNsYXNzPVxceDIyaW1nLXd5c2l3eWcgc2VsZWN0YWJsZS1pbWdcXHgyMiBzdHlsZT1cXHgyMmRpc3BsYXk6IHRhYmxlO1xceDIyPjx0cj48dGQgY2xhc3M9XFx4MjJ1cGxvYWR6b25lXFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIybW8taW1nc2VsZWN0aW9uaGVscGVyXFx4MjI+PC9kaXY+ICA8ZGl2IGNsYXNzPVxceDIybW8tdXBsb2Fkem9uZVxceDIyPjwvZGl2PiAgPGRpdiBjbGFzcz1cXHgyMmltZy1zaXplXFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogX3NpemVcXHgyMj5zaXplPC9kaXY+ICA8ZGl2IGNsYXNzPVxceDIybWlkdG9vbHNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj4gICAgPCEtLSBrbyBpZjogX3NyYygpICE9ICcnIC0tPiAgICA8ZGl2IHRpdGxlPVxceDIyUmVtb3ZlIGltYWdlXFx4MjIgY2xhc3M9XFx4MjJ0b29sIGRlbGV0ZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1JlbW92ZSBpbWFnZScpIH0sIGNsaWNrOiBfc3JjLmJpbmQoX3NyYywgJycpLCBjbGlja0J1YmJsZTogZmFsc2VcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXRyYXNoLW9cXHgyMj48L2k+PC9kaXY+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC5lZGl0SW1hZ2UgIT09ICd1bmRlZmluZWQnIC0tPiAgICA8ZGl2IHRpdGxlPVxceDIyT3BlbiB0aGUgaW1hZ2UgZWRpdGluZyB0b29sXFx4MjIgY2xhc3M9XFx4MjJ0b29sIGVkaXRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdPcGVuIHRoZSBpbWFnZSBlZGl0aW5nIHRvb2wnKSB9LCBjbGljazogJHJvb3QuZWRpdEltYWdlLmJpbmQoJGVsZW1lbnQsIF9zcmMpLCBjbGlja0J1YmJsZTogZmFsc2VcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXBlbmNpbFxceDIyPjwvaT48L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiBfc3JjKCkgPT0gJycgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJVcGxvYWQgYSBuZXcgaW1hZ2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdVcGxvYWQgYSBuZXcgaW1hZ2UnKSB9XFx4MjIgY2xhc3M9XFx4MjJ0b29sIHVwbG9hZFxceDIyIHN0eWxlPVxceDIycG9zaXRpb246IHJlbGF0aXZlOyBvdmVyZmxvdzogaGlkZGVuO1xceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtdXBsb2FkXFx4MjI+PC9pPiAgICAgIDxpbnB1dCBjbGFzcz1cXHgyMmZpbGV1cGxvYWQgbm9maWxlXFx4MjIgdHlwZT1cXHgyMmZpbGVcXHgyMiBuYW1lPVxceDIyZmlsZXNbXVxceDIyIGRhdGEtYmluZD1cXHgyMmZpbGV1cGxvYWQ6IHsgZGF0YTogX3NyYywgb25lcnJvcjogJHJvb3Qubm90aWZpZXIuZXJyb3IsIG9uZmlsZTogJHJvb3QubG9hZEltYWdlLCBjYW52YXNQcmV2aWV3OiB0cnVlIH1cXHgyMiBzdHlsZT1cXHgyMnotaW5kZXg6IDIwOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgbWluLXdpZHRoOiAxMDAlOyBtaW4taGVpZ2h0OiAxMDAlOyBmb250LXNpemU6IDk5OXB4OyB0ZXh0LWFsaWduOiByaWdodDsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTApOyBvcGFjaXR5OiAwOyBvdXRsaW5lOiBub25lOyBjdXJzb3I6IGluaGVyaXQ7IGRpc3BsYXk6IGJsb2NrXFx4MjI+ICAgIDwvZGl2PiAgICA8IS0tIC9rbyAtLT4gIDwvZGl2PiAgPCEtLSBrbyB0ZW1wbGF0ZTogX3RlbXBsYXRlIC0tPjwhLS0gL2tvIC0tPiAgPCEtLSBrbyBpZjogX3NyYygpID09ICcnIC0tPiAgICA8IS0tICAgIDxpbWcgc3R5bGU9XFx4MjJkaXNwbGF5OiBibG9jaztcXHgyMiBjbGFzcz1cXHgyMmltZ3BsYWNlaG9sZGVyXFx4MjIgd2lkdGg9XFx4MjIyMDBcXHgyMiBzcmM9XFx4MjJcXHgyMiBhbHQ9XFx4MjJJbnNlcnQgYW4gaW1hZ2UgaGVyZVxceDIyIGRhdGEtYmluZD1cXHgyMnd5c2l3eWdTcmM6IHsgc3JjOiBfc3JjLnByZWxvYWRlZCwgcGxhY2Vob2xkZXI6IF9wbGFjZWhvbGRlcnNyYywgd2lkdGg6IF93aWR0aCwgaGVpZ2h0OiBfaGVpZ2h0LCBtZXRob2Q6IF9tZXRob2QgfVxceDIyIC8+ICAgIC0tPiAgICA8c3BhbiBjbGFzcz1cXHgyMmZpbGV1cGxvYWR0ZXh0XFx4MjIgc3R5bGU9XFx4MjJ0ZXh0LWFsaWduOiBjZW50ZXI7IGRpc3BsYXk6IC1tcy1mbGV4Ym94OyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBmbGV4LWFsaWduOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyOyBwYWRkaW5nOiAxZW07IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwO1xceDIyPjxzcGFuIGNsYXNzPVxceDIydGV4dE1pZGRsZVxceDIyIHN0eWxlPVxceDIyIHRleHQtc2hhZG93OiAxcHggMXB4IDAgI0ZGRkZGRiwgMCAwIDEwcHggI0ZGRkZGRjsgZm9udC13ZWlnaHQ6IGJvbGQ7XFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnRHJvcCBhbiBpbWFnZSBoZXJlJylcXHgyMj5Ecm9wIGFuIGltYWdlIGhlcmU8L3NwYW4+PC9zcGFuPiAgPCEtLSAva28gLS0+ICA8IS0tIGtvIGlmOiBfc3JjKCkgIT0gJycgLS0+ICA8IS0tICAgIDxpbWcgc3R5bGU9XFx4MjJkaXNwbGF5OiBibG9jaztcXHgyMiB3aWR0aD1cXHgyMjIwMFxceDIyIHNyYz1cXHgyMlxceDIyIGRhdGEtYmluZD1cXHgyMnByZWxvYWRlcjogX3NyYywgd3lzaXd5Z1NyYzogeyBzcmM6IF9zcmMucHJlbG9hZGVkLCBwbGFjZWhvbGRlcjogX3BsYWNlaG9sZGVyc3JjLCB3aWR0aDogX3dpZHRoLCBoZWlnaHQ6IF9oZWlnaHQsIG1ldGhvZDogX21ldGhvZCB9XFx4MjIgLz4gICAgLS0+ICA8IS0tIC9rbyAtLT4gIDwhLS0gcHVsc2FudGUgcGVyIGxhIGNhbmNlbGxhemlvbmUgLS0+ICA8ZGl2IHRpdGxlPVxceDIyRHJvcCBhbiBpbWFnZSBoZXJlIG9yIGNsaWNrIHRoZSB1cGxvYWQgYnV0dG9uXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnRHJvcCBhbiBpbWFnZSBoZXJlIG9yIGNsaWNrIHRoZSB1cGxvYWQgYnV0dG9uJykgfSwgdG9vbHRpcHM6IHt9XFx4MjIgY2xhc3M9XFx4MjJ3b3Jrem9uZVxceDIyIHN0eWxlPVxceDIycG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBoaWRkZW47XFx4MjI+ICAgIDwhLS0ga28gaWY6IF9zcmMucHJlbG9hZGVkICYmIF9zcmMoKSAhPSBfc3JjLnByZWxvYWRlZCgpIC0tPlBSRUxPQURJTkcuLi4uPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6IF9zcmMoKSAhPSAnJyAtLT4gICAgICA8aW5wdXQgY2xhc3M9XFx4MjJmaWxldXBsb2FkIHdpdGhmaWxlXFx4MjIgdHlwZT1cXHgyMmZpbGVcXHgyMiBuYW1lPVxceDIyZmlsZXNbXVxceDIyIGRhdGEtYmluZD1cXHgyMmZpbGV1cGxvYWQ6IHsgZGF0YTogX3NyYywgb25lcnJvcjogJHJvb3Qubm90aWZpZXIuZXJyb3IsIG9uZmlsZTogJHJvb3QuZ2FsbGVyeVJlY2VudC51bnNoaWZ0LmJpbmQoJHJvb3QuZ2FsbGVyeVJlY2VudCksIGNhbnZhc1ByZXZpZXc6IHRydWUgfVxceDIyIHN0eWxlPVxceDIyei1pbmRleDogLTIwOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgbWluLXdpZHRoOiAxMDAlOyBtaW4taGVpZ2h0OiAxMDAlOyBmb250LXppZTogOTk5cHg7IHRleHQtYWxpZ246IHJpZ2h0OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9MCk7IG9wYWNpdHk6IDA7IG91dGxpbmU6IG5vbmU7IGN1cnNvcjogaW5oZXJpdDsgZGlzcGxheTogYmxvY2tcXHgyMj4gICAgPCEtLSAva28gLS0+ICAgIDxkaXYgY2xhc3M9XFx4MjJwcm9ncmVzc1xceDIyIHN0eWxlPVxceDIyb3BhY2l0eTogLjU7IHdpZHRoOiA4MCU7IG1hcmdpbi1sZWZ0OiAxMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAzMCU7IGhlaWdodDogMjBweDsgYm9yZGVyOiAycHggc29saWQgYmxhY2s7XFx4MjI+ICAgICAgPGRpdiBjbGFzcz1cXHgyMnByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItc3VjY2Vzc1xceDIyIHN0eWxlPVxceDIyaGVpZ2h0OiAyMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgXFx4MjI+PC9kaXY+ICAgIDwvZGl2PiAgPC9kaXY+PC90YWJsZT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwibWFpblwiLCBcIjxkaXYgaWQ9XFx4MjJwYWdlXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBub25lO1xceDIyIGRhdGEtYmluZD1cXHgyMnZpc2libGU6IHRydWUsIGNzczogeyB3aXRoVG9vbGJveDogJHJvb3Quc2hvd1Rvb2xib3gsIHdpdGhQcmV2aWV3RnJhbWU6IHNob3dQcmV2aWV3RnJhbWUgfVxceDIyPiAgPGRpdiBpZD1cXHgyMm1haW4tZWRpdC1hcmVhXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6IGZ1bmN0aW9uKG9iaiwgZXZ0KSB7ICRyb290LnNlbGVjdEJsb2NrKG51bGwpOyByZXR1cm4gdHJ1ZTsgfSwgY2xpY2tCdWJibGU6IGZhbHNlXFx4MjI+ICAgIDwhLS0ga28gd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiAnd3lzaXd5ZycsIHRlbXBsYXRlTW9kZUZhbGxiYWNrOiAnc2hvdycgfSAtLT4gICAgPGRpdiBpZD1cXHgyMm1haW4td3lzaXd5Zy1hcmVhXFx4MjIgZGF0YS1iaW5kPVxceDIyd3lzaXd5Z1Njcm9sbGZpeDogdHJ1ZSwgc2Nyb2xsYWJsZTogdHJ1ZSwgZnVkcm9wcGFibGU6IHsgYWN0aXZlOiBkcmFnZ2luZ0ltYWdlIH0sIGNzczogeyBpc2RyYWdnaW5nOiBkcmFnZ2luZywgaXNkcmFnZ2luZ2ltZzogZHJhZ2dpbmdJbWFnZSB9LCBibG9jazogY29udGVudFxceDIyPjwvZGl2PiAgICA8IS0tIC9rbyAtLT4gIDwvZGl2PiAgPGRpdiBpZD1cXHgyMnRvb2xiYXJcXHgyMiBjbGFzcz1cXHgyMm1vXFx4MjIgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC51bmRvICE9ICd1bmRlZmluZWQnIC0tPiAgICA8c3BhbiBkYXRhLWJpbmQ9XFx4MjJidXR0b25zZXQ6IHsgfVxceDIyIGNsYXNzPVxceDIybGVmdEJ1dHRvbnNcXHgyMj4gICAgPGEgdGl0bGU9XFx4MjJVbmRvIGxhc3Qgb3BlcmF0aW9uXFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1VuZG8gbGFzdCBvcGVyYXRpb24nKSB9LCBjbGljazogJHJvb3QudW5kby5leGVjdXRlLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LnVuZG8uZW5hYmxlZCgpLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtcmVwbHknIH0sIGxhYmVsOiAkcm9vdC51bmRvLm5hbWUsIHRleHQ6IHRydWUgfVxceDIyPlVORE88L2E+ICAgIDxhIHRpdGxlPVxceDIyUmVkbyBsYXN0IG9wZXJhdGlvblxceDIyIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdSZWRvIGxhc3Qgb3BlcmF0aW9uJykgfSwgY2xpY2s6ICRyb290LnJlZG8uZXhlY3V0ZSwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgZGlzYWJsZWQ6ICEkcm9vdC5yZWRvLmVuYWJsZWQoKSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLXNoYXJlJyB9LCBsYWJlbDogJHJvb3QucmVkby5uYW1lLCB0ZXh0OiB0cnVlIH1cXHgyMj5SRURPPC9hPiAgICA8L3NwYW4+ICAgIDwhLS0ga28gaWY6ICRyb290LmRlYnVnIC0tPiAgICA8YSBocmVmPVxceDIyamF2YXNjcmlwdDp2b2lkKDApXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LnVuZG9SZXNldCwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgZGlzYWJsZWQ6ICEkcm9vdC51bmRvLmVuYWJsZWQoKSAmJiAhJHJvb3QucmVkby5lbmFibGVkKCksIGxhYmVsOiAncmVzZXQnLCB0ZXh0OiB0cnVlIH1cXHgyMj5SRVNFVDwvYT4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0gL2tvIC0tPiAgICA8c3Bhbj4gICAgPGlucHV0IGlkPVxceDIyc2hvd0dhbGxlcnlcXHgyMiB0eXBlPVxceDIyY2hlY2tib3hcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjaGVja2VkOiAkcm9vdC5zaG93R2FsbGVyeSwgYnV0dG9uOiB7IHJlZnJlc2hPbjogJHJvb3Quc2hvd0dhbGxlcnksICAgICBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtcGljdHVyZS1vJywgc2Vjb25kYXJ5OiBudWxsIH0sIHRleHQ6IHRydWUsIGxhYmVsOiAkcm9vdC50KCdHYWxsZXJ5JykgfVxceDIyPjxsYWJlbCB0aXRsZT1cXHgyMlNob3cgaW1hZ2UgZ2FsbGVyeVxceDIyIGZvcj1cXHgyMnNob3dHYWxsZXJ5XFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU2hvdyBpbWFnZSBnYWxsZXJ5JykgfVxceDIyPnNob3cgZ2FsbGVyeTwvbGFiZWw+PC9pbnB1dD4gICAgPC9zcGFuPiAgICA8IS0tIENSRUFUSU9OIE5BTUUgLS0+ICAgIDwhLS0ga28gaWY6ICRyb290LnRpdGxlTW9kZSgpID09ICdlZGl0JyB8fCAkcm9vdC50aXRsZU1vZGUoKSA9PSAnc2F2aW5nJyAtLT4gICAgPGZvcm0gY2xhc3M9XFx4MjJjcmVhdGlvbi1uYW1lXFx4MjIgZGF0YS1iaW5kPVxceDIyc3VibWl0OiBzYXZlRWRpdENyZWF0aW9uTmFtZSwgc3VibWl0QnViYmxlOiBmYWxzZVxceDIyPiAgICAgIDxpbnB1dCB0eXBlPVxceDIydGV4dFxceDIyIGRhdGEtYmluZD1cXHgyMnZhbHVlOiAkcm9vdC5tZXRhZGF0YS5uYW1lLCBkaXNhYmxlOiAkcm9vdC50aXRsZU1vZGUoKSA9PSAnc2F2aW5nJywgaGFzRm9jdXM6ICRyb290LnRpdGxlTW9kZSgpID09ICdlZGl0J1xceDIyLz4gICAgICA8YnV0dG9uIHR5cGU9XFx4MjJidXR0b25cXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogY2FuY2VsRWRpdENyZWF0aW9uTmFtZSwgY2xpY2tCdWJibGU6IGZhbHNlLCBkaXNhYmxlOiAkcm9vdC50aXRsZU1vZGUoKSA9PSAnc2F2aW5nJywgICAgICBidXR0b246IHsgcmVmcmVzaE9uOiAkcm9vdC5zaG93UHJldmlld0ZyYW1lLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtdGltZXMnLCBzZWNvbmRhcnk6IG51bGwgfSwgdGV4dDogZmFsc2UsIGxhYmVsOiAkcm9vdC50KCdlZGl0LXRpdGxlLWNhbmNlbCcpIH1cXHgyMj5jYW5jZWw8L2J1dHRvbj4gICAgICA8YnV0dG9uIHR5cGU9XFx4MjJzdWJtaXRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJkaXNhYmxlOiAkcm9vdC50aXRsZU1vZGUoKSA9PSAnc2F2aW5nJywgICAgICAgIGJ1dHRvbjogeyByZWZyZXNoT246ICRyb290LnNob3dQcmV2aWV3RnJhbWUsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1jaGVjay1jaXJjbGUnLCBzZWNvbmRhcnk6IG51bGwgfSwgdGV4dDogZmFsc2UsIGxhYmVsOiAkcm9vdC50KCdlZGl0LXRpdGxlLXNhdmUnKSB9XFx4MjI+c2F2ZTwvYnV0dG9uPiAgICA8L2Zvcm0+ICAgIDwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiAkcm9vdC50aXRsZU1vZGUoKSA9PSAnc2hvdycgLS0+ICAgIDxkaXYgY2xhc3M9XFx4MjJjcmVhdGlvbi1uYW1lXFx4MjI+ICAgICAgPHAgY2xhc3M9XFx4MjJ1aS1idXR0b25cXHgyMiBkYXRhLWJpbmQ9XFx4MjJldmVudDogeyBkYmxjbGljazogZW5hYmxlRWRpdENyZWF0aW9uTmFtZSB9LCBkYmxjbGlja0J1YmJsZTogZmFsc2UsICAgICAgICBhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdlZGl0LXRpdGxlLWRvdWJsZS1jbGljaycpIH1cXHgyMj4gICAgICAgIDxzcGFuIGNsYXNzPVxceDIydWktYnV0dG9uLXRleHRcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC5jcmVhdGlvbk5hbWVcXHgyMj48L3NwYW4+ICAgICAgPC9wPiAgICA8L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDxpbnB1dCBpZD1cXHgyMnByZXZpZXdGcmFtZVRvZ2dsZVxceDIyIHR5cGU9XFx4MjJjaGVja2JveFxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LnNob3dQcmV2aWV3RnJhbWUsIGJ1dHRvbjogeyByZWZyZXNoT246ICRyb290LnNob3dQcmV2aWV3RnJhbWUsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS10YWJsZXQnLCBzZWNvbmRhcnk6IG51bGwgfSwgdGV4dDogZmFsc2UsIGxhYmVsOiAkcm9vdC50KCdQcmV2aWV3JykgfVxceDIyPjxsYWJlbCB0aXRsZT1cXHgyMlNob3cgbGl2ZSBwcmV2aWV3XFx4MjIgZm9yPVxceDIycHJldmlld0ZyYW1lVG9nZ2xlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU2hvdyBsaXZlIHByZXZpZXcnKSB9XFx4MjI+UFJFVklFVzwvbGFiZWw+PC9pbnB1dD4gICAgPCEtLSBrbyBpZjogJHJvb3QuZGVidWcgLS0+ICAgIDxhIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuZXhwb3J0LCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBsYWJlbDogJ2V4cG9ydCcsIHRleHQ6IHRydWUgfVxceDIyPkVYUE9SVDwvYT4gICAgPGlucHV0IHR5cGU9XFx4MjJjaGVja2JveFxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LmRlYnVnXFx4MjIgLz4gZGVidWcgICAgPGEgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiAkcm9vdC5sb2FkRGVmYXVsdEJsb2NrcywgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLXVwbG9hZCcgfSwgbGFiZWw6ICdEZWZhdWx0JywgdGV4dDogdHJ1ZSB9XFx4MjI+TE9BRCBCTE9DS1M8L2E+ICAgIFs8YSBpZD1cXHgyMnN1YnNjcmlwdGlvbnNDb3VudFxceDIyIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZpZXdNb2RlbC5sb29wU3Vic2NyaXB0aW9uc0NvdW50KClcXHgyMj5zdWJzPC9hPl0gICAgPCEtLSAva28gLS0+ICAgIDxzcGFuIGRhdGEtYmluZD1cXHgyMnZpc2libGU6IGZhbHNlXFx4MjI+ICAgIDxpbnB1dCB0eXBlPVxceDIyY2hlY2tib3hcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjaGVja2VkOiAkcm9vdC5zaG93VG9vbGJveFxceDIyIC8+IHRvb2xib3ggICAgPC9zcGFuPiAgICA8ZGl2IGNsYXNzPVxceDIycmlnaHRCdXR0b25zXFx4MjI+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC5zYXZlICE9PSAndW5kZWZpbmVkJyAtLT4gICAgPGEgdGl0bGU9XFx4MjJTYXZlIHRlbXBsYXRlXFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1NhdmUgdGVtcGxhdGUnKSB9LCBjbGljazogJHJvb3Quc2F2ZS5leGVjdXRlLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LnNhdmUuZW5hYmxlZCgpLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtY2xvdWQtdXBsb2FkJyB9LCBsYWJlbDogJHJvb3QudCgkcm9vdC5zYXZlLm5hbWUpLCB0ZXh0OiB0cnVlIH1cXHgyMj5TQUxWQTwvYT4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC50ZXN0ICE9PSAndW5kZWZpbmVkJyAtLT4gICAgPGEgdGl0bGU9XFx4MjJTaG93IHByZXZpZXcgYW5kIHNlbmQgdGVzdFxceDIyIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTaG93IHByZXZpZXcgYW5kIHNlbmQgdGVzdCcpIH0sIGNsaWNrOiAkcm9vdC50ZXN0LmV4ZWN1dGUsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGRpc2FibGVkOiAhJHJvb3QudGVzdC5lbmFibGVkKCksIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1wYXBlci1wbGFuZScgfSwgbGFiZWw6ICRyb290LnQoJHJvb3QudGVzdC5uYW1lKSwgdGV4dDogdHJ1ZSB9XFx4MjI+VEVTVDwvYT4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC5kb3dubG9hZCAhPT0gJ3VuZGVmaW5lZCcgLS0+ICAgIDxmb3JtIGlkPVxceDIyZG93bmxvYWRGb3JtXFx4MjIgYWN0aW9uPVxceDIyI1xceDIyIG1ldGhvZD1cXHgyMlBPU1RcXHgyMj4gICAgPGlucHV0IHR5cGU9XFx4MjJoaWRkZW5cXHgyMiBuYW1lPVxceDIyYWN0aW9uXFx4MjIgdmFsdWU9XFx4MjJkb3dubG9hZFxceDIyIC8+ICAgIDxpbnB1dCB0eXBlPVxceDIyaGlkZGVuXFx4MjIgbmFtZT1cXHgyMmZpbGVuYW1lXFx4MjIgdmFsdWU9XFx4MjJlbWFpbC5odG1sXFx4MjIgaWQ9XFx4MjJkb3dubG9hZEh0bWxGaWxlbmFtZVxceDIyIC8+ICAgIDxpbnB1dCB0eXBlPVxceDIyaGlkZGVuXFx4MjIgbmFtZT1cXHgyMmh0bWxcXHgyMiBpZD1cXHgyMmRvd25sb2FkSHRtbFRleHRhcmVhXFx4MjIgLz4gICAgPGEgdGl0bGU9XFx4MjJEb3dubG9hZCB0ZW1wbGF0ZVxceDIyIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdEb3dubG9hZCB0ZW1wbGF0ZScpIH0sIGNsaWNrOiAkcm9vdC5kb3dubG9hZC5leGVjdXRlLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LmRvd25sb2FkLmVuYWJsZWQoKSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLWRvd25sb2FkJyB9LCBsYWJlbDogJHJvb3QudCgkcm9vdC5kb3dubG9hZC5uYW1lKSwgdGV4dDogdHJ1ZSB9XFx4MjI+RE9XTkxPQUQ8L2E+ICAgIDwvZm9ybT4gICAgPCEtLSAva28gLS0+ICAgIDwvZGl2PiAgPC9kaXY+ICA8IS0tIGtvIGlmOiAkcm9vdC5zaG93VG9vbGJveCAtLT4gIDxkaXYgaWQ9XFx4MjJtYWluLXRvb2xib3hcXHgyMiBjbGFzcz1cXHgyMm1vXFx4MjIgZGF0YS1iaW5kPVxceDIyc2Nyb2xsYWJsZTogdHJ1ZSwgd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiAnZWRpdCcgfVxceDIyPiAgICA8ZGl2IGRhdGEtYmluZD1cXHgyMnRlbXBsYXRlOiB7IG5hbWU6ICd0b29sYm94JyB9XFx4MjI+PC9kaXY+ICA8L2Rpdj4gIDwhLS0gL2tvIC0tPiAgICA8ZGl2IGlkPVxceDIybWFpbi1wcmV2aWV3XFx4MjIgY2xhc3M9XFx4MjJtb1xceDIyIGRhdGEtYmluZD1cXHgyMnNjcm9sbGFibGU6IHRydWUsIGlmOiAkcm9vdC5zaG93UHJldmlld0ZyYW1lXFx4MjI+ICAgIDxkaXYgaWQ9XFx4MjJwcmV2aWV3LXRvb2xiYXJcXHgyMj4gICAgICA8ZGl2IGRhdGEtYmluZD1cXHgyMnZpc2libGU6ICRyb290LnNob3dQcmV2aWV3RnJhbWUsIGJ1dHRvbnNldDogeyB9XFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBpbmxpbmUtYmxvY2tcXHgyMj4gICAgICAgIDxpbnB1dCBpZD1cXHgyMnByZXZpZXdMYXJnZVxceDIyIHR5cGU9XFx4MjJyYWRpb1xceDIyIG5hbWU9XFx4MjJwcmV2aWV3TW9kZVxceDIyIHZhbHVlPVxceDIybGFyZ2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjaGVja2VkOiAkcm9vdC5wcmV2aWV3TW9kZSwgYnV0dG9uOiB7IHRleHQ6IGZhbHNlLCBsYWJlbDogJ2xhcmdlJywgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLWRlc2t0b3AnIH0gfVxceDIyIC8+ICAgICAgICA8bGFiZWwgZm9yPVxceDIycHJldmlld0xhcmdlXFx4MjIgdGl0bGU9XFx4MjJMYXJnZSBzY3JlZW5cXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdMYXJnZSBzY3JlZW4nKSB9XFx4MjI+TGFyZ2Ugc2NyZWVuPC9sYWJlbD4gICAgICAgIDxpbnB1dCBpZD1cXHgyMnByZXZpZXdEZXNrdG9wXFx4MjIgdHlwZT1cXHgyMnJhZGlvXFx4MjIgbmFtZT1cXHgyMnByZXZpZXdNb2RlXFx4MjIgdmFsdWU9XFx4MjJkZXNrdG9wXFx4MjIgZGF0YS1iaW5kPVxceDIyY2hlY2tlZDogJHJvb3QucHJldmlld01vZGUsIGJ1dHRvbjogeyB0ZXh0OiBmYWxzZSwgbGFiZWw6ICdkZXNrdG9wJywgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZ3IGZhLXRhYmxldCcgfSB9XFx4MjIgLz4gICAgICAgIDxsYWJlbCBmb3I9XFx4MjJwcmV2aWV3RGVza3RvcFxceDIyIHRpdGxlPVxceDIyVGFibGV0XFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnVGFibGV0JykgfVxceDIyPlRhYmxldDwvbGFiZWw+ICAgICAgICA8aW5wdXQgaWQ9XFx4MjJwcmV2aWV3TW9iaWxlXFx4MjIgdHlwZT1cXHgyMnJhZGlvXFx4MjIgbmFtZT1cXHgyMnByZXZpZXdNb2RlXFx4MjIgdmFsdWU9XFx4MjJtb2JpbGVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjaGVja2VkOiAkcm9vdC5wcmV2aWV3TW9kZSwgYnV0dG9uOiB7IHRleHQ6IGZhbHNlLCBsYWJlbDogJ21vYmlsZScsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1tb2JpbGUnIH0gfVxceDIyIC8+ICAgICAgICA8bGFiZWwgZm9yPVxceDIycHJldmlld01vYmlsZVxceDIyIHRpdGxlPVxceDIyU21hcnRwaG9uZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1NtYXJ0cGhvbmUnKSB9XFx4MjI+U21hcnRwaG9uZTwvbGFiZWw+ICAgICAgPC9kaXY+ICAgIDwvZGl2PiAgICA8ZGl2IGlkPVxceDIyZnJhbWUtY29udGFpbmVyXFx4MjIgZGF0YS1iaW5kPVxceDIyY3NzOiB7IGRlc2t0b3A6ICRyb290LnByZXZpZXdNb2RlKCkgPT0gJ2Rlc2t0b3AnLCBtb2JpbGU6ICRyb290LnByZXZpZXdNb2RlKCkgPT0gJ21vYmlsZScsIGxhcmdlOiAkcm9vdC5wcmV2aWV3TW9kZSgpID09ICdsYXJnZScgfVxceDIyPiAgICAgIDxpZnJhbWUgZGF0YS1iaW5kPVxceDIyYmluZElmcmFtZTogJGRhdGFcXHgyMj48L2lmcmFtZT4gICAgPC9kaXY+ICA8L2Rpdj4gIDxkaXYgY2xhc3M9XFx4MjJtb1xceDIyIGlkPVxceDIybW8tYm9keVxceDIyPjwvZGl2PiAgPCEtLSBUT0RPIFJFTU9WRSBNRSAgPGRpdiBpZD1cXHgyMmluY29tcGF0aWJsZS1icm93c2VyXFx4MjIgdGl0bGU9XFx4MjJVbnN1cHBvcnRlZCBicm93c2VyXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBub25lXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnVXN1cHBvcnRlZCBicm93c2VyJykgfSwgaHRtbDogJzxwPllvdXIgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLjwvcD48cD5Vc2UgYSBkaWZmZXJlbnQgYnJvd3NlciBvciB0cnkgdXBkYXJpbmcgeW91ciBicm93c2VyLjwvcD48cD5TdXBwb3J0ZWQgYnJvd3NlcnM6IDx1bD48bGk+SW50ZXJuZXQgRXhwbG9yZXIgJmd0Oz0gMTA8L2xpPjxsaT5Hb29nbGUgQ2hyb21lICZndDs9IDMwPC9saT48bGk+QXBwbGUgU2FmYXJpICZndDs9IDU8L2xpPjxsaT5Nb3ppbGxhIEZpcmVmaXggJmd0Oz0gMjA8L2xpPjwvdWw+PC9wPidcXHgyMj4gICAgVW5zdXBwb3J0ZWQgYnJvd3NlciAgPC9kaXY+ICAtLT4gIDxkaXYgaWQ9XFx4MjJpbmNvbXBhdGlibGUtdGVtcGxhdGVcXHgyMiB0aXRsZT1cXHgyMlNhdmVkIG1vZGVsIGlzIG9ic29sZXRlXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBub25lXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU2F2ZWQgbW9kZWwgaXMgb2Jzb2xldGUnKSB9LCBodG1sOiAkcm9vdC50KCc8cD5UaGUgc2F2ZWQgbW9kZWwgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIGEgcHJldmlvdXMsIG5vbiBjb21wbGV0ZWx5IGNvbXBhdGlibGUgdmVyc2lvbiwgb2YgdGhlIHRlbXBsYXRlPC9wPjxwPlNvbWUgY29udGVudCBvciBzdHlsZSBpbiB0aGUgbW9kZWwgPGI+Q09VTEQgQkUgTE9TVDwvYj4gaWYgeW91IHdpbGwgPGI+c2F2ZTwvYj48L3A+PHA+Q29udGFjdCB1cyBmb3IgbW9yZSBpbmZvcm1hdGlvbnMhPC9wPicpXFx4MjI+ICAgIEluY29tcGF0aWJsZSB0ZW1wbGF0ZSAgPC9kaXY+ICA8ZGl2IGlkPVxceDIyZmFrZS1pbWFnZS1lZGl0b3JcXHgyMiB0aXRsZT1cXHgyMkZha2UgaW1hZ2UgZWRpdG9yXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBub25lXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnRmFrZSBpbWFnZSBlZGl0b3InKSB9LCBodG1sOiAkcm9vdC50KCc8cD5GYWtlIGltYWdlIGVkaXRvcjwvcD4nKVxceDIyPiAgICA8cD5GYWtlIGltYWdlIGVkaXRvcjwvcD4gIDwvZGl2PjwvZGl2PjwhLS0ga28gaWY6ICRyb290LmxvZ29QYXRoIC0tPjxkaXYgaWQ9XFx4MjJsb2FkaW5nXFx4MjIgY2xhc3M9XFx4MjJsb2FkaW5nXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBibG9jazsgd2lkdGg6IDMwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IGhlaWdodDogMzJweDsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6MDsgYm90dG9tOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgIG1hcmdpbjogYXV0bztcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHN0eWxlOiAncG9zaXRpb246IGFic29sdXRlOyB0b3A6IDVweDsgbGVmdDogNnB4OyB6LWluZGV4OiAxNTA7J30sIGNzczogeyBsb2FkaW5nOiBmYWxzZSB9XFx4MjI+ICA8YSBocmVmPVxceDIyL1xceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgaHJlZjogJHJvb3QubG9nb1VybCwgYWx0OiAkcm9vdC5sb2dvQWx0IH1cXHgyMj48aW1nIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgc3JjOiAkcm9vdC5sb2dvUGF0aCB9XFx4MjIgd2lkdGg9XFx4MjIzMlxceDIyIGhlaWdodD1cXHgyMjMyXFx4MjIgYWx0PVxceDIybW9zYWljb1xceDIyIGJvcmRlcj1cXHgyMjBcXHgyMiAvPjwvYT4gIDxkaXYgc3R5bGU9XFx4MjJvcGFjaXR5OiAwXFx4MjIgZGF0YS1iaW5kPVxceDIydmlzaWJsZTogZmFsc2VcXHgyMj5PcHBwcy4uLiAhITwvZGl2PjwvZGl2PjwhLS0gL2tvIC0tPlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJ0b29sYm94XCIsIFwiPGRpdiBpZD1cXHgyMnRvb2x0YWJzXFx4MjIgY2xhc3M9XFx4MjJ0YWJzX2hvcml6b250YWwgYnV0dG9uX2NvbG9yXFx4MjIgZGF0YS1iaW5kPVxceDIydGFiczogeyBhY3RpdmU6ICRyb290LnNlbGVjdGVkVG9vbCB9XFx4MjI+ICA8dWw+ICAgIDxsaSBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj48YSB0aXRsZT1cXHgyMkJsb2NrcyByZWFkeSB0byBiZSBhZGRlZCB0byB0aGUgdGVtcGxhdGVcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGhyZWY9XFx4MjIjdG9vbGJsb2Nrc1xceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0Jsb2NrcyByZWFkeSB0byBiZSBhZGRlZCB0byB0aGUgdGVtcGxhdGUnKSB9XFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1jdWJlc1xceDIyPjwvaT4gPHNwYW4gZGF0YS1iaW5kPVxceDIyaHRtbDogJHJvb3QudCgnQmxvY2tzJylcXHgyMj5CbG9ja3M8L3NwYW4+PC9hPjwvbGk+ICAgIDxsaSBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj48YSB0aXRsZT1cXHgyMkVkaXQgY29udGVudCBvcHRpb25zXFx4MjIgaHJlZj1cXHgyMiN0b29sY29udGVudHNcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0VkaXQgY29udGVudCBvcHRpb25zJykgfVxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtcGVuY2lsXFx4MjI+PC9pPiA8c3BhbiBkYXRhLWJpbmQ9XFx4MjJodG1sOiAkcm9vdC50KCdDb250ZW50JylcXHgyMj5Db250ZW50PC9zcGFuPjwvYT48L2xpPiAgICA8bGkgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+PGEgdGl0bGU9XFx4MjJFZGl0IHN0eWxlIG9wdGlvbnNcXHgyMiBocmVmPVxceDIyI3Rvb2xzdHlsZXNcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0VkaXQgc3R5bGUgb3B0aW9ucycpIH1cXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXBhaW50LWJydXNoXFx4MjI+PC9pPiA8c3BhbiBkYXRhLWJpbmQ9XFx4MjJodG1sOiAkcm9vdC50KCdTdHlsZScpXFx4MjI+U3R5bGU8L3NwYW4+PC9hPjwvbGk+ICA8L3VsPiAgPGRpdiBpZD1cXHgyMnRvb2xibG9ja3NcXHgyMiBkYXRhLWJpbmQ9XFx4MjJzY3JvbGxhYmxlOiB0cnVlXFx4MjI+ICAgIDxkaXYgY2xhc3M9XFx4MjJibG9jay1saXN0XFx4MjIgZGF0YS1iaW5kPVxceDIyZm9yZWFjaDogYmxvY2tEZWZzXFx4MjIgc3R5bGU9XFx4MjJ0ZXh0LWFsaWduOiBjZW50ZXJcXHgyMj4gICAgICA8ZGl2IGNsYXNzPVxceDIyZHJhZ2dhYmxlLWl0ZW1cXHgyMiBkYXRhLWJpbmQ9XFx4MjJ3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6ICdzaG93JyB9XFx4MjI+ICAgICAgICA8ZGl2IGNsYXNzPVxceDIyYmxvY2tcXHgyMiBkYXRhLWJpbmQ9XFx4MjJleHRkcmFnZ2FibGU6IHsgY29ubmVjdENsYXNzOiAnc29ydGFibGUtYmxvY2tzLWVkaXQnLCBkYXRhOiAkZGF0YSwgZHJvcENvbnRhaW5lcjogJyNtYWluLXd5c2l3eWctYXJlYScsIGRyYWdnaW5nOiAkcm9vdC5kcmFnZ2luZywgJ29wdGlvbnMnOiB7IGhhbmRsZTogJy5oYW5kbGUnLCBkaXN0YW5jZTogMTAsICdhcHBlbmRUbyc6ICcjcGFnZScgfSB9LCBjbGljazogJHJvb3QuYWRkQmxvY2tcXHgyMiBzdHlsZT1cXHgyMnBvc2l0aW9uOiByZWxhdGl2ZTtcXHgyMj4gICAgICAgICAgPGRpdiB0aXRsZT1cXHgyMkNsaWNrIG9yIGRyYWcgdG8gYWRkIHRoaXMgYmxvY2sgdG8gdGhlIHRlbXBsYXRlXFx4MjIgY2xhc3M9XFx4MjJoYW5kbGVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdDbGljayBvciBkcmFnIHRvIGFkZCB0aGlzIGJsb2NrIHRvIHRoZSB0ZW1wbGF0ZScpIH0sIHRvb2x0aXBzOiB7fVxceDIyPjwvZGl2PiAgICAgICAgICA8aW1nIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgYWx0OiAkcm9vdC50KCdCbG9jayBfX25hbWVfXycsIHsgbmFtZToga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0eXBlKSB9KSwgc3JjOiAkcm9vdC50ZW1wbGF0ZVBhdGgoJ2VkcmVzLycra28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0eXBlKSsnLnBuZycpIH1cXHgyMiBhbHQ9XFx4MjJCbG9jayBfX25hbWVfX1xceDIyIC8+ICAgICAgICA8L2Rpdj4gICAgICAgIDxhIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBjbGFzcz1cXHgyMmFkZGJsb2NrYnV0dG9uXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmFkZEJsb2NrLCBidXR0b246IHsgbGFiZWw6ICRyb290LnQoJ0FkZCcpIH1cXHgyMj5BZGQ8L2E+ICAgICAgPC9kaXY+ICAgIDwvZGl2PiAgPC9kaXY+ICA8ZGl2IGlkPVxceDIydG9vbGNvbnRlbnRzXFx4MjIgZGF0YS1iaW5kPVxceDIyc2Nyb2xsYWJsZTogdHJ1ZVxceDIyPiAgICA8IS0tIGtvIGlmOiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgIT09IG51bGwgLS0+ICAgIDxkaXYgZGF0YS1iaW5kPVxceDIyYmxvY2s6ICRyb290LnNlbGVjdGVkQmxvY2tcXHgyMj48L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6ICRyb290LnNlbGVjdGVkQmxvY2soKSA9PSBudWxsIC0tPiAgICA8ZGl2IGNsYXNzPVxceDIybm9TZWxlY3RlZEJsb2NrXFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnQnkgY2xpY2tpbmcgb24gbWVzc2FnZSBwYXJ0cyB5b3Ugd2lsbCBzZWxlY3QgYSBibG9jayBhbmQgY29udGVudCBvcHRpb25zLCBpZiBhbnksIHdpbGwgc2hvdyBoZXJlJylcXHgyMj5CeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBjb250ZW50IG9wdGlvbnMsIGlmIGFueSwgd2lsbCBzaG93IGhlcmU8L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gYmxvY2s6IGNvbnRlbnQgLS0+PCEtLSAva28gLS0+ICA8L2Rpdj4gICAgPGRpdiBpZD1cXHgyMnRvb2xzdHlsZXNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJzY3JvbGxhYmxlOiB0cnVlLCB3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6ICdzdHlsZXInIH1cXHgyMj4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRyb290LmNvbnRlbnQoKS50aGVtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mICRyb290LmNvbnRlbnQoKS50aGVtZSgpLnNjaGVtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgJHJvb3QuY29udGVudCgpLnRoZW1lKCkuc2NoZW1lKCkgPT09ICdjdXN0b20nIC0tPiAgICAgIDwhLS0ga28gaWY6ICRyb290LnNlbGVjdGVkQmxvY2soKSAhPT0gbnVsbCAtLT4gICAgICA8ZGl2IGRhdGEtYmluZD1cXHgyMmJsb2NrOiAkcm9vdC5zZWxlY3RlZEJsb2NrLCBjc3M6IHsgd29ya0xvY2FsOiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkuY3VzdG9tU3R5bGUsIHdvcmtHbG9iYWw6IHR5cGVvZiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkuY3VzdG9tU3R5bGUgPT09ICd1bmRlZmluZWQnIHx8ICEkcm9vdC5zZWxlY3RlZEJsb2NrKCkuY3VzdG9tU3R5bGUoKSB9XFx4MjI+PC9kaXY+ICAgICAgPCEtLSAva28gLS0+ICAgICAgPCEtLSBrbyBpZjogJHJvb3Quc2VsZWN0ZWRCbG9jaygpID09IG51bGwgLS0+ICAgICAgPGRpdiBjbGFzcz1cXHgyMm5vU2VsZWN0ZWRCbG9ja1xceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6ICRyb290LnQoJ0J5IGNsaWNraW5nIG9uIG1lc3NhZ2UgcGFydHMgeW91IHdpbGwgc2VsZWN0IGEgYmxvY2sgYW5kIHN0eWxlIG9wdGlvbnMsIGlmIGF2YWlsYWJsZSwgd2lsbCBzaG93IGhlcmUnKVxceDIyPkJ5IGNsaWNraW5nIG9uIG1lc3NhZ2UgcGFydHMgeW91IHdpbGwgc2VsZWN0IGEgYmxvY2sgYW5kIHN0eWxlIG9wdGlvbnMsIGlmIGF2YWlsYWJsZSwgd2lsbCBzaG93IGhlcmU8L2Rpdj4gICAgICA8IS0tIC9rbyAtLT4gICAgICA8ZGl2IGNsYXNzPVxceDIyd29ya0dsb2JhbENvbnRlbnRcXHgyMj4gICAgICA8IS0tIGtvIGJsb2NrOiBjb250ZW50IC0tPjwhLS0gL2tvIC0tPiAgICAgIDwvZGl2PiAgICA8IS0tIC9rbyAtLT4gIDwvZGl2PjwvZGl2PiAgICAgICAgPGRpdiBpZD1cXHgyMnRvb2xpbWFnZXNcXHgyMiBjbGFzcz1cXHgyMnNsaWRlYmFyXFx4MjIgZGF0YS1iaW5kPVxceDIyc2Nyb2xsYWJsZTogdHJ1ZSwgY3NzOiB7IGhpZGRlbjogJHJvb3Quc2hvd0dhbGxlcnkoKSA9PT0gZmFsc2UgfVxceDIyPiAgPGRpdiBjbGFzcz1cXHgyMmNsb3NlXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LnNob3dHYWxsZXJ5LmJpbmQoJGVsZW1lbnQsIGZhbHNlKTtcXHgyMj5YPC9kaXY+ICA8c3BhbiBjbGFzcz1cXHgyMnBhbmUtdGl0bGVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdHYWxsZXJ5OicpXFx4MjI+R2FsbGVyeTo8L3NwYW4+ICA8ZGl2IGRhdGEtZHJvcC1jb250ZW50PVxceDIyRHJvcCBoZXJlXFx4MjIgY2xhc3M9XFx4MjJpbWctZHJvcHpvbmUgcGFuZSB1cGxvYWR6b25lXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyAnZGF0YS1kcm9wLWNvbnRlbnQnOiAkcm9vdC50KCdEcm9wIGhlcmUnKSB9LCBmdWRyb3BwYWJsZTogeyBhY3RpdmVDbGFzczogJ3VpLXN0YXRlLWhpZ2hsaWdodCcsIGhvdmVyQ2xhc3M6ICd1aS1zdGF0ZS1kcmFnaG92ZXInIH1cXHgyMj4gIDxkaXYgY2xhc3M9XFx4MjJtby11cGxvYWR6b25lXFx4MjIgc3R5bGU9XFx4MjJwb3NpdGlvbjogcmVsYXRpdmU7IHBhZGRpbmc6IDJlbTsgYm9yZGVyOiAycHggZG90dGVkICM4MDgwODBcXHgyMj4gICAgIDxpbnB1dCBjbGFzcz1cXHgyMmZpbGV1cGxvYWRcXHgyMiB0eXBlPVxceDIyZmlsZVxceDIyIG11bHRpcGxlIG5hbWU9XFx4MjJmaWxlc1tdXFx4MjIgZGF0YS1iaW5kPVxceDIyZmlsZXVwbG9hZDogeyBvbmVycm9yOiAkcm9vdC5ub3RpZmllci5lcnJvciwgb25maWxlOiAkcm9vdC5sb2FkSW1hZ2UgfVxceDIyIHN0eWxlPVxceDIyei1pbmRleDogMTA7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBtaW4td2lkdGg6IDEwMCU7IG1pbi1oZWlnaHQ6IDEwMCU7IGZvbnQtemllOiA5OTlweDsgdGV4dC1hbGlnbjogcmlnaHQ7IGZpbHRlcjogYWxwaGEob3BhY2l0eT0wKTsgb3BhY2l0eTogMDsgb3V0bGluZTogbm9uZTsgY3Vyc29yOiBpbmhlcml0OyBkaXNwbGF5OiBibG9ja1xceDIyPiAgICAgPHNwYW4gZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnQ2xpY2sgb3IgZHJhZyBmaWxlcyBoZXJlJylcXHgyMj5DbGljayBvciBkcmFnIGZpbGVzIGhlcmU8L3NwYW4+ICAgICA8ZGl2IGNsYXNzPVxceDIyd29ya3pvbmVcXHgyMiBzdHlsZT1cXHgyMnBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuO1xceDIyPiAgICAgICA8ZGl2IGNsYXNzPVxceDIycHJvZ3Jlc3NcXHgyMiBzdHlsZT1cXHgyMm9wYWNpdHk6IC41OyB3aWR0aDogODAlOyBtYXJnaW4tbGVmdDogMTAlOyBwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogMzAlOyBoZWlnaHQ6IDIwcHg7IGJvcmRlcjogMnB4IHNvbGlkIGJsYWNrO1xceDIyPiAgICAgICAgIDxkaXYgY2xhc3M9XFx4MjJwcm9ncmVzcy1iYXIgcHJvZ3Jlc3MtYmFyLXN1Y2Nlc3NcXHgyMiBzdHlsZT1cXHgyMmhlaWdodDogMjBweDsgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IFxceDIyPjwvZGl2PiAgICAgICA8L2Rpdj4gICAgIDwvZGl2PiAgPC9kaXY+ICA8L2Rpdj4gIDwhLS0ga28gaWY6ICRyb290LnNob3dHYWxsZXJ5KCkgLS0+ICA8ZGl2IGlkPVxceDIydG9vbGltYWdlc3RhYlxceDIyIGNsYXNzPVxceDIydGFic19ob3Jpem9udGFsXFx4MjIgZGF0YS1iaW5kPVxceDIydGFiczogeyBhY3RpdmU6ICRyb290LnNlbGVjdGVkSW1hZ2VUYWIgfVxceDIyPiAgICA8dWw+ICAgICAgPGxpIGRhdGEtYmluZD1cXHgyMnRvb2x0aXBzOiB7fVxceDIyPjxhIHRpdGxlPVxceDIyU2Vzc2lvbiBpbWFnZXNcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGhyZWY9XFx4MjIjdG9vbGltYWdlc3JlY2VudFxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1Nlc3Npb24gaW1hZ2VzJykgfSwgdGV4dDogJHJvb3QudCgnUmVjZW50cycpXFx4MjI+UmVjZW50czwvYT48L2xpPiAgICAgIDxsaSBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj48YSB0aXRsZT1cXHgyMlJlbW90ZSBnYWxsZXJ5XFx4MjIgZGF0YS1sb2NhbD1cXHgyMnRydWVcXHgyMiBocmVmPVxceDIyI3Rvb2xpbWFnZXNnYWxsZXJ5XFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnUmVtb3RlIGdhbGxlcnknKSB9LCB0ZXh0OiAkcm9vdC50KCdHYWxsZXJ5JylcXHgyMj5HYWxsZXJ5PC9hPjwvbGk+ICAgIDwvdWw+ICAgIDxkaXYgaWQ9XFx4MjJ0b29saW1hZ2VzcmVjZW50XFx4MjI+ICAgICAgPCEtLSBrbyBpZjogZ2FsbGVyeVJlY2VudCgpLmxlbmd0aCA9PSAwIC0tPjxkaXYgY2xhc3M9XFx4MjJnYWxsZXJ5RW1wdHlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdObyBpbWFnZXMgdXBsb2FkZWQsIHlldCcpXFx4MjI+Tm8gaW1hZ2VzIHVwbG9hZGVkLCB5ZXQ8L2Rpdj48IS0tIC9rbyAtLT4gICAgICA8IS0tIGtvIHRlbXBsYXRlOiB7bmFtZTogJ2dhbGxlcnktaW1hZ2VzJywgZGF0YTogeyBpdGVtczogZ2FsbGVyeVJlY2VudCB9IH0gLS0+IyByZWNlbnQgZ2FsbGVyeSAjPCEtLSAva28gLS0+ICAgIDwvZGl2PiAgICA8ZGl2IGlkPVxceDIydG9vbGltYWdlc2dhbGxlcnlcXHgyMiBzdHlsZT1cXHgyMnRleHQtYWxpZ246IGNlbnRlclxceDIyPiAgICA8IS0tIGtvIGlmOiAkcm9vdC5nYWxsZXJ5TG9hZGVkKCkgPT09IGZhbHNlIC0tPjxhIGNsYXNzPVxceDIybG9hZGJ1dHRvblxceDIyIHRpdGxlPVxceDIyU2hvdyBpbWFnZXMgZnJvbSB0aGUgZ2FsbGVyeVxceDIyIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5JykgfSwgY2xpY2s6ICRyb290LmxvYWRHYWxsZXJ5LCBidXR0b246IHsgZGlzYWJsZWQ6ICRyb290LmdhbGxlcnlMb2FkZWQsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1waWN0dXJlLW8nIH0sIGxhYmVsOiAkcm9vdC5nYWxsZXJ5TG9hZGVkKCkgPT0gJ2xvYWRpbmcnID8gJHJvb3QudCgnTG9hZGluZy4uLicpIDogJHJvb3QudCgnTG9hZCBnYWxsZXJ5JyksIHRleHQ6IHRydWUgfVxceDIyPiMgbG9hZCBnYWxseSAjPC9hPjwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiAkcm9vdC5nYWxsZXJ5TG9hZGVkKCkgPT09ICdsb2FkaW5nJyAtLT48ZGl2IGNsYXNzPVxceDIyZ2FsbGVyeUVtcHR5XFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnTG9hZGluZyBnYWxsZXJ5Li4uJylcXHgyMj5Mb2FkaW5nIGdhbGxlcnkuLi48L2Rpdj48IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogJHJvb3QuZ2FsbGVyeUxvYWRlZCgpID09PSAwIC0tPjxkaXYgY2xhc3M9XFx4MjJnYWxsZXJ5RW1wdHlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdUaGUgZ2FsbGVyeSBpcyBlbXB0eScpXFx4MjI+VGhlIGdhbGxlcnkgaXMgZW1wdHk8L2Rpdj48IS0tIC9rbyAtLT4gICAgPCEtLSBrbyB0ZW1wbGF0ZToge25hbWU6ICdnYWxsZXJ5LWltYWdlcycsIGRhdGE6IHsgaXRlbXM6IGdhbGxlcnlSZW1vdGUgfSB9IC0tPiMgcmVtb3RlIGdhbGxlcnkgIzwhLS0gL2tvIC0tPiAgICA8L2Rpdj4gIDwvZGl2PiAgPCEtLSAva28gLS0+PC9kaXY+PGRpdiBpZD1cXHgyMnRvb2xkZWJ1Z1xceDIyIGNsYXNzPVxceDIyc2xpZGViYXJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjc3M6IHsgaGlkZGVuOiAkcm9vdC5kZWJ1ZygpID09PSBmYWxzZSB9XFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIyY2xvc2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuZGVidWcuYmluZCgkZWxlbWVudCwgZmFsc2UpO1xceDIyPlg8L2Rpdj4gICAgPCEtLSBrbyBpZjogJHJvb3QuZGVidWcgLS0+ICBDb250ZW50OiAgPHByZSBkYXRhLWJpbmQ9J3RleHQ6IGtvLnRvSlNPTihjb250ZW50LCBudWxsLCAyKScgc3R5bGU9XFx4MjJvdmVyZmxvdzogYXV0bzsgaGVpZ2h0OiAyMCVcXHgyMj48L3ByZT4gIEJsb2NrRGVmczogIDxwcmUgZGF0YS1iaW5kPSd0ZXh0OiBrby50b0pTT04oYmxvY2tEZWZzLCBudWxsLCAyKScgc3R5bGU9XFx4MjJvdmVyZmxvdzogYXV0bzsgaGVpZ2h0OiAyMCVcXHgyMj48L3ByZT4gIDwhLS0gL2tvIC0tPiAgPGEgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiAkcm9vdC5leHBvcnRIVE1MdG9UZXh0YXJlYS5iaW5kKCRlbGVtZW50LCAnI291dHB1dGh0bWwnKTsgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgdGV4dDogdHJ1ZSwgbGFiZWw6J0dlbmVyYXRlJyB9XFx4MjI+T3V0cHV0PC9hPiAgPGEgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dm9pZCgwKVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiAkcm9vdC5leHBvcnRKU09OdG9UZXh0YXJlYS5iaW5kKCRlbGVtZW50LCAnI291dHB1dGh0bWwnKTsgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgdGV4dDogdHJ1ZSwgbGFiZWw6J0V4cG9ydCcgfVxceDIyPkV4cG9ydDwvYT4gIDxhIGhyZWY9XFx4MjJqYXZhc2NyaXB0OnZvaWQoMClcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuaW1wb3J0SlNPTmZyb21UZXh0YXJlYS5iaW5kKCRlbGVtZW50LCAnI291dHB1dGh0bWwnKTsgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgdGV4dDogdHJ1ZSwgbGFiZWw6J0ltcG9ydCcgfVxceDIyPkltcG9ydDwvYT4gIDx0ZXh0YXJlYSBpZD1cXHgyMm91dHB1dGh0bWxcXHgyMiByb3dzPVxceDIyMTBcXHgyMiBzdHlsZT1cXHgyMndpZHRoOiAxMDAlO1xceDIyPjwvdGV4dGFyZWE+PC9kaXY+PGRpdiBpZD1cXHgyMnRvb2x0aGVtZVxceDIyIGNsYXNzPVxceDIydWktd2lkZ2V0IHNsaWRlYmFyXFx4MjIgZGF0YS1iaW5kPVxceDIyY3NzOiB7IGhpZGRlbjogJHJvb3Quc2hvd1RoZW1lKCkgPT09IGZhbHNlIH1cXHgyMj4gIDxkaXYgY2xhc3M9XFx4MjJjbG9zZVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiAkcm9vdC5zaG93VGhlbWUuYmluZCgkZWxlbWVudCwgZmFsc2UpO1xceDIyPlg8L2Rpdj4gICAgPCEtLSBrbyB3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6ICdzdHlsZXInIH0gLS0+ICAgIDwhLS0ga28gaWY6ICRyb290LnNob3dUaGVtZSAtLT4gICAgICA8IS0tIGtvIGJsb2NrOiAkcm9vdC5jb250ZW50KCkudGhlbWUgLS0+PCEtLSAva28gLS0+ICAgIDwhLS0gL2tvIC0tPiAgPCEtLSAva28gLS0+PC9kaXY+XCIpO1xufSk7XG4iLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbnZhciByb290ID0gcmVxdWlyZSgnbG9kYXNoLl9yb290Jyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgcmV0dXJuICEhYXJyYXkubGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCk7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIHdyYXBwZXIgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgTmFOYCBpcyBmb3VuZCBpbiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIGBOYU5gLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAwIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChvdGhlciAhPT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgfVxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgfVxuICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCB3ZWFrIG1hcCBjb25zdHJ1Y3RvcnMsXG4gIC8vIGFuZCBQaGFudG9tSlMgMS45IHdoaWNoIHJldHVybnMgJ2Z1bmN0aW9uJyBmb3IgYE5vZGVMaXN0YCBpbnN0YW5jZXMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTmF0aXZlKF8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZURpZmZlcmVuY2U7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGFcbiAqIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKSB0aGF0IGFmZmVjdHNcbiAqIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIGluY29ycmVjdGx5IG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCB3ZWFrIG1hcCBjb25zdHJ1Y3RvcnMsXG4gIC8vIGFuZCBQaGFudG9tSlMgMS45IHdoaWNoIHJldHVybnMgJ2Z1bmN0aW9uJyBmb3IgYE5vZGVMaXN0YCBpbnN0YW5jZXMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xudmFyIG9iamVjdFR5cGVzID0ge1xuICAnZnVuY3Rpb24nOiB0cnVlLFxuICAnb2JqZWN0JzogdHJ1ZVxufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IChvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSlcbiAgPyBleHBvcnRzXG4gIDogdW5kZWZpbmVkO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IChvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSlcbiAgPyBtb2R1bGVcbiAgOiB1bmRlZmluZWQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IGNoZWNrR2xvYmFsKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHdpbmRvd2AuICovXG52YXIgZnJlZVdpbmRvdyA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG5cbi8qKiBEZXRlY3QgYHRoaXNgIGFzIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHRoaXNHbG9iYWwgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2YgdGhpc10gJiYgdGhpcyk7XG5cbi8qKlxuICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBUaGUgYHRoaXNgIHZhbHVlIGlzIHVzZWQgaWYgaXQncyB0aGUgZ2xvYmFsIG9iamVjdCB0byBhdm9pZCBHcmVhc2Vtb25rZXknc1xuICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fFxuICAoKGZyZWVXaW5kb3cgIT09ICh0aGlzR2xvYmFsICYmIHRoaXNHbG9iYWwud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHxcbiAgICBmcmVlU2VsZiB8fCB0aGlzR2xvYmFsIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBnbG9iYWwgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyBgdmFsdWVgIGlmIGl0J3MgYSBnbG9iYWwgb2JqZWN0LCBlbHNlIGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tHbG9iYWwodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5PYmplY3QgPT09IE9iamVjdCkgPyB2YWx1ZSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YC4gKi9cbnZhciBvYmplY3RUeXBlcyA9IHtcbiAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgJ29iamVjdCc6IHRydWVcbn07XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSAob2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUpXG4gID8gZXhwb3J0c1xuICA6IHVuZGVmaW5lZDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSAob2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUpXG4gID8gbW9kdWxlXG4gIDogdW5kZWZpbmVkO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSBjaGVja0dsb2JhbChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGB3aW5kb3dgLiAqL1xudmFyIGZyZWVXaW5kb3cgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuXG4vKiogRGV0ZWN0IGB0aGlzYCBhcyB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciB0aGlzR2xvYmFsID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHRoaXNdICYmIHRoaXMpO1xuXG4vKipcbiAqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gKlxuICogVGhlIGB0aGlzYCB2YWx1ZSBpcyB1c2VkIGlmIGl0J3MgdGhlIGdsb2JhbCBvYmplY3QgdG8gYXZvaWQgR3JlYXNlbW9ua2V5J3NcbiAqIHJlc3RyaWN0ZWQgYHdpbmRvd2Agb2JqZWN0LCBvdGhlcndpc2UgdGhlIGB3aW5kb3dgIG9iamVjdCBpcyB1c2VkLlxuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHxcbiAgKChmcmVlV2luZG93ICE9PSAodGhpc0dsb2JhbCAmJiB0aGlzR2xvYmFsLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8XG4gICAgZnJlZVNlbGYgfHwgdGhpc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgYHZhbHVlYCBpZiBpdCdzIGEgZ2xvYmFsIG9iamVjdCwgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgdmFyIGRhdGEsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFJlZmxlY3QgPSByb290LlJlZmxlY3QsXG4gICAgZW51bWVyYXRlID0gUmVmbGVjdCA/IFJlZmxlY3QuZW51bWVyYXRlIDogdW5kZWZpbmVkLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHNraXAgdGhlIGNvbnN0cnVjdG9yXG4gKiBwcm9wZXJ0eSBvZiBwcm90b3R5cGVzIG9yIHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIG9iamVjdCA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogT2JqZWN0KG9iamVjdCk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBGYWxsYmFjayBmb3IgSUUgPCA5IHdpdGggZXM2LXNoaW0uXG5pZiAoZW51bWVyYXRlICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgJ3ZhbHVlT2YnOiAxIH0sICd2YWx1ZU9mJykpIHtcbiAgYmFzZUtleXNJbiA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkoZW51bWVyYXRlKG9iamVjdCkpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhXG4gKiBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MikgdGhhdCBhZmZlY3RzXG4gKiBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGluZGV4IGtleXMgZm9yIGBvYmplY3RgIHZhbHVlcyBvZiBhcnJheXMsXG4gKiBgYXJndW1lbnRzYCBvYmplY3RzLCBhbmQgc3RyaW5ncywgb3RoZXJ3aXNlIGBudWxsYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fG51bGx9IFJldHVybnMgaW5kZXgga2V5cywgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGluZGV4S2V5cyhvYmplY3QpIHtcbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiB1bmRlZmluZWQ7XG4gIGlmIChpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzU3RyaW5nKG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgaW5jb3JyZWN0bHkgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIHdlYWsgbWFwIGNvbnN0cnVjdG9ycyxcbiAgLy8gYW5kIFBoYW50b21KUyAxLjkgd2hpY2ggcmV0dXJucyAnZnVuY3Rpb24nIGZvciBgTm9kZUxpc3RgIGluc3RhbmNlcy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICBwcm9wcyA9IGJhc2VLZXlzSW4ob2JqZWN0KSxcbiAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgaW5kZXhlcyA9IGluZGV4S2V5cyhvYmplY3QpLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWluZGV4ZXMsXG4gICAgICByZXN1bHQgPSBpbmRleGVzIHx8IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICBpZiAoIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkgJiZcbiAgICAgICAgIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbnZhciBiYXNlRGlmZmVyZW5jZSA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWRpZmZlcmVuY2UnKSxcbiAgICBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWZsYXR0ZW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCdsb2Rhc2gua2V5c2luJyksXG4gICAgcmVzdCA9IHJlcXVpcmUoJ2xvZGFzaC5yZXN0Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcHJvcHMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShwcm9wcywgZnVuY3Rpb24ocmVzdWx0LCBrZXkpIHtcbiAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGBbW1Byb3RvdHlwZV1dYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgYFtbUHJvdG90eXBlXV1gLlxuICovXG5mdW5jdGlvbiBnZXRQcm90b3R5cGUodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZUdldFByb3RvdHlwZShPYmplY3QodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRTeW1ib2xzKG9iamVjdCkge1xuICAvLyBDb2VyY2UgYG9iamVjdGAgdG8gYW4gb2JqZWN0IHRvIGF2b2lkIG5vbi1vYmplY3QgZXJyb3JzIGluIFY4LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0MyBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE9iamVjdChvYmplY3QpKTtcbn1cblxuLy8gRmFsbGJhY2sgZm9yIElFIDwgMTEuXG5pZiAoIWdldE93blByb3BlcnR5U3ltYm9scykge1xuICBnZXRTeW1ib2xzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9sIHByb3BlcnRpZXNcbiAqIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gZ2V0U3ltYm9scyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0IGFyZVxuICogbm90IG9taXR0ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcm9wc10gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIG9taXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2InOiAnMicgfVxuICovXG52YXIgb21pdCA9IHJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvcHMgPSBhcnJheU1hcChiYXNlRmxhdHRlbihwcm9wcywgMSksIHRvS2V5KTtcbiAgcmV0dXJuIGJhc2VQaWNrKG9iamVjdCwgYmFzZURpZmZlcmVuY2UoZ2V0QWxsS2V5c0luKG9iamVjdCksIHByb3BzKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0O1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICogYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gKlxuICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogdG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGFydCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFycmF5KTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcnJheSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJyYXkpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICBpbmRleCA9IC0xO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IGFycmF5O1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIHdlYWsgbWFwIGNvbnN0cnVjdG9ycyxcbiAgLy8gYW5kIFBoYW50b21KUyAxLjkgd2hpY2ggcmV0dXJucyAnZnVuY3Rpb24nIGZvciBgTm9kZUxpc3RgIGluc3RhbmNlcy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSBpc0Z1bmN0aW9uKHZhbHVlLnZhbHVlT2YpID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXN0O1xuIiwiZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xuXG5leHBvcnRzLmhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZVxuICAgIH1cbiAgICBlbHNlIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudXB0aW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG5leHBvcnRzLmZyZWVtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLnRvdGFsbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Jyb3dzZXInIH07XG5cbmV4cG9ydHMucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcbj0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge30gfTtcblxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnYnJvd3NlcicgfTtcblxuZXhwb3J0cy50bXBkaXIgPSBleHBvcnRzLnRtcERpciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy90bXAnO1xufTtcblxuZXhwb3J0cy5FT0wgPSAnXFxuJztcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdCBkb24ndCBicmVhayB0aGluZ3MuXG52YXIgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBjYWNoZWRTZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9zcGVha2luZ3VybCcpO1xuIiwiKGZ1bmN0aW9uIChyb290LCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBnZXRTbHVnXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBpbnB1dCBpbnB1dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R8c3RyaW5nfSBvcHRzIGNvbmZpZyBvYmplY3Qgb3Igc2VwYXJhdG9yIHN0cmluZy9jaGFyXG4gICAgICogQGFwaSAgICBwdWJsaWNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICBzbHVnZ2lmaWVkIHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBnZXRTbHVnID0gZnVuY3Rpb24gZ2V0U2x1ZyhpbnB1dCwgb3B0cykge1xuXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnLSc7XG4gICAgICAgIHZhciB1cmljQ2hhcnMgPSBbJzsnLCAnPycsICc6JywgJ0AnLCAnJicsICc9JywgJysnLCAnJCcsICcsJywgJy8nXTtcbiAgICAgICAgdmFyIHVyaWNOb1NsYXNoQ2hhcnMgPSBbJzsnLCAnPycsICc6JywgJ0AnLCAnJicsICc9JywgJysnLCAnJCcsICcsJ107XG4gICAgICAgIHZhciBtYXJrQ2hhcnMgPSBbJy4nLCAnIScsICd+JywgJyonLCAnXFwnJywgJygnLCAnKSddO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBkaWF0cmljU3RyaW5nID0gJyc7XG4gICAgICAgIHZhciBjb252ZXJ0U3ltYm9scyA9IHRydWU7XG4gICAgICAgIHZhciBjdXN0b21SZXBsYWNlbWVudHMgPSB7fTtcbiAgICAgICAgdmFyIG1haW50YWluQ2FzZTtcbiAgICAgICAgdmFyIHRpdGxlQ2FzZTtcbiAgICAgICAgdmFyIHRydW5jYXRlO1xuICAgICAgICB2YXIgdXJpY0ZsYWc7XG4gICAgICAgIHZhciB1cmljTm9TbGFzaEZsYWc7XG4gICAgICAgIHZhciBtYXJrRmxhZztcbiAgICAgICAgdmFyIHN5bWJvbDtcbiAgICAgICAgdmFyIGxhbmdDaGFyO1xuICAgICAgICB2YXIgbHVja3k7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgY2g7XG4gICAgICAgIHZhciBsO1xuICAgICAgICB2YXIgbGFzdENoYXJXYXNTeW1ib2w7XG4gICAgICAgIHZhciBsYXN0Q2hhcldhc0RpYXRyaWM7XG4gICAgICAgIHZhciBhbGxvd2VkQ2hhcnM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJNYXBcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjaGFyTWFwID0ge1xuXG4gICAgICAgICAgICAvLyBsYXRpblxuICAgICAgICAgICAgJ8OAJzogJ0EnLFxuICAgICAgICAgICAgJ8OBJzogJ0EnLFxuICAgICAgICAgICAgJ8OCJzogJ0EnLFxuICAgICAgICAgICAgJ8ODJzogJ0EnLFxuICAgICAgICAgICAgJ8OEJzogJ0FlJyxcbiAgICAgICAgICAgICfDhSc6ICdBJyxcbiAgICAgICAgICAgICfDhic6ICdBRScsXG4gICAgICAgICAgICAnw4cnOiAnQycsXG4gICAgICAgICAgICAnw4gnOiAnRScsXG4gICAgICAgICAgICAnw4knOiAnRScsXG4gICAgICAgICAgICAnw4onOiAnRScsXG4gICAgICAgICAgICAnw4snOiAnRScsXG4gICAgICAgICAgICAnw4wnOiAnSScsXG4gICAgICAgICAgICAnw40nOiAnSScsXG4gICAgICAgICAgICAnw44nOiAnSScsXG4gICAgICAgICAgICAnw48nOiAnSScsXG4gICAgICAgICAgICAnw5AnOiAnRCcsXG4gICAgICAgICAgICAnw5EnOiAnTicsXG4gICAgICAgICAgICAnw5InOiAnTycsXG4gICAgICAgICAgICAnw5MnOiAnTycsXG4gICAgICAgICAgICAnw5QnOiAnTycsXG4gICAgICAgICAgICAnw5UnOiAnTycsXG4gICAgICAgICAgICAnw5YnOiAnT2UnLFxuICAgICAgICAgICAgJ8WQJzogJ08nLFxuICAgICAgICAgICAgJ8OYJzogJ08nLFxuICAgICAgICAgICAgJ8OZJzogJ1UnLFxuICAgICAgICAgICAgJ8OaJzogJ1UnLFxuICAgICAgICAgICAgJ8ObJzogJ1UnLFxuICAgICAgICAgICAgJ8OcJzogJ1VlJyxcbiAgICAgICAgICAgICfFsCc6ICdVJyxcbiAgICAgICAgICAgICfDnSc6ICdZJyxcbiAgICAgICAgICAgICfDnic6ICdUSCcsXG4gICAgICAgICAgICAnw58nOiAnc3MnLFxuICAgICAgICAgICAgJ8OgJzogJ2EnLFxuICAgICAgICAgICAgJ8OhJzogJ2EnLFxuICAgICAgICAgICAgJ8OiJzogJ2EnLFxuICAgICAgICAgICAgJ8OjJzogJ2EnLFxuICAgICAgICAgICAgJ8OkJzogJ2FlJyxcbiAgICAgICAgICAgICfDpSc6ICdhJyxcbiAgICAgICAgICAgICfDpic6ICdhZScsXG4gICAgICAgICAgICAnw6cnOiAnYycsXG4gICAgICAgICAgICAnw6gnOiAnZScsXG4gICAgICAgICAgICAnw6knOiAnZScsXG4gICAgICAgICAgICAnw6onOiAnZScsXG4gICAgICAgICAgICAnw6snOiAnZScsXG4gICAgICAgICAgICAnw6wnOiAnaScsXG4gICAgICAgICAgICAnw60nOiAnaScsXG4gICAgICAgICAgICAnw64nOiAnaScsXG4gICAgICAgICAgICAnw68nOiAnaScsXG4gICAgICAgICAgICAnw7AnOiAnZCcsXG4gICAgICAgICAgICAnw7EnOiAnbicsXG4gICAgICAgICAgICAnw7InOiAnbycsXG4gICAgICAgICAgICAnw7MnOiAnbycsXG4gICAgICAgICAgICAnw7QnOiAnbycsXG4gICAgICAgICAgICAnw7UnOiAnbycsXG4gICAgICAgICAgICAnw7YnOiAnb2UnLFxuICAgICAgICAgICAgJ8WRJzogJ28nLFxuICAgICAgICAgICAgJ8O4JzogJ28nLFxuICAgICAgICAgICAgJ8O5JzogJ3UnLFxuICAgICAgICAgICAgJ8O6JzogJ3UnLFxuICAgICAgICAgICAgJ8O7JzogJ3UnLFxuICAgICAgICAgICAgJ8O8JzogJ3VlJyxcbiAgICAgICAgICAgICfFsSc6ICd1JyxcbiAgICAgICAgICAgICfDvSc6ICd5JyxcbiAgICAgICAgICAgICfDvic6ICd0aCcsXG4gICAgICAgICAgICAnw78nOiAneScsXG4gICAgICAgICAgICAn4bqeJzogJ1NTJyxcblxuICAgICAgICAgICAgLy8gbGFuZ3VhZ2Ugc3BlY2lmaWNcblxuICAgICAgICAgICAgLy8gQXJhYmljXG4gICAgICAgICAgICAn2KcnOiAnYScsXG4gICAgICAgICAgICAn2KMnOiAnYScsXG4gICAgICAgICAgICAn2KUnOiAnaScsXG4gICAgICAgICAgICAn2KInOiAnYWEnLFxuICAgICAgICAgICAgJ9ikJzogJ3UnLFxuICAgICAgICAgICAgJ9imJzogJ2UnLFxuICAgICAgICAgICAgJ9ihJzogJ2EnLFxuICAgICAgICAgICAgJ9ioJzogJ2InLFxuICAgICAgICAgICAgJ9iqJzogJ3QnLFxuICAgICAgICAgICAgJ9irJzogJ3RoJyxcbiAgICAgICAgICAgICfYrCc6ICdqJyxcbiAgICAgICAgICAgICfYrSc6ICdoJyxcbiAgICAgICAgICAgICfYric6ICdraCcsXG4gICAgICAgICAgICAn2K8nOiAnZCcsXG4gICAgICAgICAgICAn2LAnOiAndGgnLFxuICAgICAgICAgICAgJ9ixJzogJ3InLFxuICAgICAgICAgICAgJ9iyJzogJ3onLFxuICAgICAgICAgICAgJ9izJzogJ3MnLFxuICAgICAgICAgICAgJ9i0JzogJ3NoJyxcbiAgICAgICAgICAgICfYtSc6ICdzJyxcbiAgICAgICAgICAgICfYtic6ICdkaCcsXG4gICAgICAgICAgICAn2LcnOiAndCcsXG4gICAgICAgICAgICAn2LgnOiAneicsXG4gICAgICAgICAgICAn2LknOiAnYScsXG4gICAgICAgICAgICAn2LonOiAnZ2gnLFxuICAgICAgICAgICAgJ9mBJzogJ2YnLFxuICAgICAgICAgICAgJ9mCJzogJ3EnLFxuICAgICAgICAgICAgJ9mDJzogJ2snLFxuICAgICAgICAgICAgJ9mEJzogJ2wnLFxuICAgICAgICAgICAgJ9mFJzogJ20nLFxuICAgICAgICAgICAgJ9mGJzogJ24nLFxuICAgICAgICAgICAgJ9mHJzogJ2gnLFxuICAgICAgICAgICAgJ9mIJzogJ3cnLFxuICAgICAgICAgICAgJ9mKJzogJ3knLFxuICAgICAgICAgICAgJ9mJJzogJ2EnLFxuICAgICAgICAgICAgJ9ipJzogJ2gnLFxuICAgICAgICAgICAgJ++7uyc6ICdsYScsXG4gICAgICAgICAgICAn77u3JzogJ2xhYScsXG4gICAgICAgICAgICAn77u5JzogJ2xhaScsXG4gICAgICAgICAgICAn77u1JzogJ2xhYScsXG5cbiAgICAgICAgICAgIC8vIEFyYWJpYyBkaWFjdHJpY3NcbiAgICAgICAgICAgICfZjic6ICdhJyxcbiAgICAgICAgICAgICfZiyc6ICdhbicsXG4gICAgICAgICAgICAn2ZAnOiAnZScsXG4gICAgICAgICAgICAn2Y0nOiAnZW4nLFxuICAgICAgICAgICAgJ9mPJzogJ3UnLFxuICAgICAgICAgICAgJ9mMJzogJ29uJyxcbiAgICAgICAgICAgICfZkic6ICcnLFxuXG4gICAgICAgICAgICAvLyBBcmFiaWMgbnVtYmVyc1xuICAgICAgICAgICAgJ9mgJzogJzAnLFxuICAgICAgICAgICAgJ9mhJzogJzEnLFxuICAgICAgICAgICAgJ9miJzogJzInLFxuICAgICAgICAgICAgJ9mjJzogJzMnLFxuICAgICAgICAgICAgJ9mkJzogJzQnLFxuICAgICAgICAgICAgJ9mlJzogJzUnLFxuICAgICAgICAgICAgJ9mmJzogJzYnLFxuICAgICAgICAgICAgJ9mnJzogJzcnLFxuICAgICAgICAgICAgJ9moJzogJzgnLFxuICAgICAgICAgICAgJ9mpJzogJzknLFxuXG4gICAgICAgICAgICAvLyBCdXJtZXNlIGNvbnNvbmFudHNcbiAgICAgICAgICAgICfhgIAnOiAnaycsXG4gICAgICAgICAgICAn4YCBJzogJ2toJyxcbiAgICAgICAgICAgICfhgIInOiAnZycsXG4gICAgICAgICAgICAn4YCDJzogJ2dhJyxcbiAgICAgICAgICAgICfhgIQnOiAnbmcnLFxuICAgICAgICAgICAgJ+GAhSc6ICdzJyxcbiAgICAgICAgICAgICfhgIYnOiAnc2EnLFxuICAgICAgICAgICAgJ+GAhyc6ICd6JyxcbiAgICAgICAgICAgICfhgIXhgLsnOiAnemEnLFxuICAgICAgICAgICAgJ+GAiic6ICdueScsXG4gICAgICAgICAgICAn4YCLJzogJ3QnLFxuICAgICAgICAgICAgJ+GAjCc6ICd0YScsXG4gICAgICAgICAgICAn4YCNJzogJ2QnLFxuICAgICAgICAgICAgJ+GAjic6ICdkYScsXG4gICAgICAgICAgICAn4YCPJzogJ25hJyxcbiAgICAgICAgICAgICfhgJAnOiAndCcsXG4gICAgICAgICAgICAn4YCRJzogJ3RhJyxcbiAgICAgICAgICAgICfhgJInOiAnZCcsXG4gICAgICAgICAgICAn4YCTJzogJ2RhJyxcbiAgICAgICAgICAgICfhgJQnOiAnbicsXG4gICAgICAgICAgICAn4YCVJzogJ3AnLFxuICAgICAgICAgICAgJ+GAlic6ICdwYScsXG4gICAgICAgICAgICAn4YCXJzogJ2InLFxuICAgICAgICAgICAgJ+GAmCc6ICdiYScsXG4gICAgICAgICAgICAn4YCZJzogJ20nLFxuICAgICAgICAgICAgJ+GAmic6ICd5JyxcbiAgICAgICAgICAgICfhgJsnOiAneWEnLFxuICAgICAgICAgICAgJ+GAnCc6ICdsJyxcbiAgICAgICAgICAgICfhgJ0nOiAndycsXG4gICAgICAgICAgICAn4YCeJzogJ3RoJyxcbiAgICAgICAgICAgICfhgJ8nOiAnaCcsXG4gICAgICAgICAgICAn4YCgJzogJ2xhJyxcbiAgICAgICAgICAgICfhgKEnOiAnYScsXG4gICAgICAgICAgICAvLyBjb25zb25hbnQgY2hhcmFjdGVyIGNvbWJvc1xuICAgICAgICAgICAgJ+GAvCc6ICd5JyxcbiAgICAgICAgICAgICfhgLsnOiAneWEnLFxuICAgICAgICAgICAgJ+GAvSc6ICd3JyxcbiAgICAgICAgICAgICfhgLzhgL0nOiAneXcnLFxuICAgICAgICAgICAgJ+GAu+GAvSc6ICd5d2EnLFxuICAgICAgICAgICAgJ+GAvic6ICdoJyxcbiAgICAgICAgICAgIC8vIGluZGVwZW5kZW50IHZvd2Vsc1xuICAgICAgICAgICAgJ+GApyc6ICdlJyxcbiAgICAgICAgICAgICfhgY8nOiAnLWUnLFxuICAgICAgICAgICAgJ+GAoyc6ICdpJyxcbiAgICAgICAgICAgICfhgKQnOiAnLWknLFxuICAgICAgICAgICAgJ+GAiSc6ICd1JyxcbiAgICAgICAgICAgICfhgKYnOiAnLXUnLFxuICAgICAgICAgICAgJ+GAqSc6ICdhdycsXG4gICAgICAgICAgICAn4YCe4YC84YCx4YCsJzogJ2F3JyxcbiAgICAgICAgICAgICfhgKonOiAnYXcnLFxuICAgICAgICAgICAgLy8gbnVtYmVyc1xuICAgICAgICAgICAgJ+GBgCc6ICcwJyxcbiAgICAgICAgICAgICfhgYEnOiAnMScsXG4gICAgICAgICAgICAn4YGCJzogJzInLFxuICAgICAgICAgICAgJ+GBgyc6ICczJyxcbiAgICAgICAgICAgICfhgYQnOiAnNCcsXG4gICAgICAgICAgICAn4YGFJzogJzUnLFxuICAgICAgICAgICAgJ+GBhic6ICc2JyxcbiAgICAgICAgICAgICfhgYcnOiAnNycsXG4gICAgICAgICAgICAn4YGIJzogJzgnLFxuICAgICAgICAgICAgJ+GBiSc6ICc5JyxcbiAgICAgICAgICAgIC8vIHZpcmFtYSBhbmQgdG9uZSBtYXJrcyB3aGljaCBhcmUgc2lsZW50IGluIHRyYW5zbGl0ZXJhdGlvblxuICAgICAgICAgICAgJ+GAuSc6ICcnLFxuICAgICAgICAgICAgJ+GAtyc6ICcnLFxuICAgICAgICAgICAgJ+GAuCc6ICcnLFxuXG4gICAgICAgICAgICAvLyBDemVjaFxuICAgICAgICAgICAgJ8SNJzogJ2MnLFxuICAgICAgICAgICAgJ8SPJzogJ2QnLFxuICAgICAgICAgICAgJ8SbJzogJ2UnLFxuICAgICAgICAgICAgJ8WIJzogJ24nLFxuICAgICAgICAgICAgJ8WZJzogJ3InLFxuICAgICAgICAgICAgJ8WhJzogJ3MnLFxuICAgICAgICAgICAgJ8WlJzogJ3QnLFxuICAgICAgICAgICAgJ8WvJzogJ3UnLFxuICAgICAgICAgICAgJ8W+JzogJ3onLFxuICAgICAgICAgICAgJ8SMJzogJ0MnLFxuICAgICAgICAgICAgJ8SOJzogJ0QnLFxuICAgICAgICAgICAgJ8SaJzogJ0UnLFxuICAgICAgICAgICAgJ8WHJzogJ04nLFxuICAgICAgICAgICAgJ8WYJzogJ1InLFxuICAgICAgICAgICAgJ8WgJzogJ1MnLFxuICAgICAgICAgICAgJ8WkJzogJ1QnLFxuICAgICAgICAgICAgJ8WuJzogJ1UnLFxuICAgICAgICAgICAgJ8W9JzogJ1onLFxuXG4gICAgICAgICAgICAvLyBEaGl2ZWhpXG4gICAgICAgICAgICAn3oAnOiAnaCcsXG4gICAgICAgICAgICAn3oEnOiAnc2gnLFxuICAgICAgICAgICAgJ96CJzogJ24nLFxuICAgICAgICAgICAgJ96DJzogJ3InLFxuICAgICAgICAgICAgJ96EJzogJ2InLFxuICAgICAgICAgICAgJ96FJzogJ2xoJyxcbiAgICAgICAgICAgICfehic6ICdrJyxcbiAgICAgICAgICAgICfehyc6ICdhJyxcbiAgICAgICAgICAgICfeiCc6ICd2JyxcbiAgICAgICAgICAgICfeiSc6ICdtJyxcbiAgICAgICAgICAgICfeiic6ICdmJyxcbiAgICAgICAgICAgICfeiyc6ICdkaCcsXG4gICAgICAgICAgICAn3ownOiAndGgnLFxuICAgICAgICAgICAgJ96NJzogJ2wnLFxuICAgICAgICAgICAgJ96OJzogJ2cnLFxuICAgICAgICAgICAgJ96PJzogJ2duJyxcbiAgICAgICAgICAgICfekCc6ICdzJyxcbiAgICAgICAgICAgICfekSc6ICdkJyxcbiAgICAgICAgICAgICfekic6ICd6JyxcbiAgICAgICAgICAgICfekyc6ICd0JyxcbiAgICAgICAgICAgICfelCc6ICd5JyxcbiAgICAgICAgICAgICfelSc6ICdwJyxcbiAgICAgICAgICAgICfelic6ICdqJyxcbiAgICAgICAgICAgICfelyc6ICdjaCcsXG4gICAgICAgICAgICAn3pgnOiAndHQnLFxuICAgICAgICAgICAgJ96ZJzogJ2hoJyxcbiAgICAgICAgICAgICfemic6ICdraCcsXG4gICAgICAgICAgICAn3psnOiAndGgnLFxuICAgICAgICAgICAgJ96cJzogJ3onLFxuICAgICAgICAgICAgJ96dJzogJ3NoJyxcbiAgICAgICAgICAgICfenic6ICdzJyxcbiAgICAgICAgICAgICfenyc6ICdkJyxcbiAgICAgICAgICAgICfeoCc6ICd0JyxcbiAgICAgICAgICAgICfeoSc6ICd6JyxcbiAgICAgICAgICAgICfeoic6ICdhJyxcbiAgICAgICAgICAgICfeoyc6ICdnaCcsXG4gICAgICAgICAgICAn3qQnOiAncScsXG4gICAgICAgICAgICAn3qUnOiAndycsXG4gICAgICAgICAgICAn3qYnOiAnYScsXG4gICAgICAgICAgICAn3qcnOiAnYWEnLFxuICAgICAgICAgICAgJ96oJzogJ2knLFxuICAgICAgICAgICAgJ96pJzogJ2VlJyxcbiAgICAgICAgICAgICfeqic6ICd1JyxcbiAgICAgICAgICAgICfeqyc6ICdvbycsXG4gICAgICAgICAgICAn3qwnOiAnZScsXG4gICAgICAgICAgICAn3q0nOiAnZXknLFxuICAgICAgICAgICAgJ96uJzogJ28nLFxuICAgICAgICAgICAgJ96vJzogJ29hJyxcbiAgICAgICAgICAgICfesCc6ICcnLFxuXG4gICAgICAgICAgICAvLyBHcmVla1xuICAgICAgICAgICAgJ86xJzogJ2EnLFxuICAgICAgICAgICAgJ86yJzogJ3YnLFxuICAgICAgICAgICAgJ86zJzogJ2cnLFxuICAgICAgICAgICAgJ860JzogJ2QnLFxuICAgICAgICAgICAgJ861JzogJ2UnLFxuICAgICAgICAgICAgJ862JzogJ3onLFxuICAgICAgICAgICAgJ863JzogJ2knLFxuICAgICAgICAgICAgJ864JzogJ3RoJyxcbiAgICAgICAgICAgICfOuSc6ICdpJyxcbiAgICAgICAgICAgICfOuic6ICdrJyxcbiAgICAgICAgICAgICfOuyc6ICdsJyxcbiAgICAgICAgICAgICfOvCc6ICdtJyxcbiAgICAgICAgICAgICfOvSc6ICduJyxcbiAgICAgICAgICAgICfOvic6ICdrcycsXG4gICAgICAgICAgICAnzr8nOiAnbycsXG4gICAgICAgICAgICAnz4AnOiAncCcsXG4gICAgICAgICAgICAnz4EnOiAncicsXG4gICAgICAgICAgICAnz4MnOiAncycsXG4gICAgICAgICAgICAnz4QnOiAndCcsXG4gICAgICAgICAgICAnz4UnOiAneScsXG4gICAgICAgICAgICAnz4YnOiAnZicsXG4gICAgICAgICAgICAnz4cnOiAneCcsXG4gICAgICAgICAgICAnz4gnOiAncHMnLFxuICAgICAgICAgICAgJ8+JJzogJ28nLFxuICAgICAgICAgICAgJ86sJzogJ2EnLFxuICAgICAgICAgICAgJ86tJzogJ2UnLFxuICAgICAgICAgICAgJ86vJzogJ2knLFxuICAgICAgICAgICAgJ8+MJzogJ28nLFxuICAgICAgICAgICAgJ8+NJzogJ3knLFxuICAgICAgICAgICAgJ86uJzogJ2knLFxuICAgICAgICAgICAgJ8+OJzogJ28nLFxuICAgICAgICAgICAgJ8+CJzogJ3MnLFxuICAgICAgICAgICAgJ8+KJzogJ2knLFxuICAgICAgICAgICAgJ86wJzogJ3knLFxuICAgICAgICAgICAgJ8+LJzogJ3knLFxuICAgICAgICAgICAgJ86QJzogJ2knLFxuICAgICAgICAgICAgJ86RJzogJ0EnLFxuICAgICAgICAgICAgJ86SJzogJ0InLFxuICAgICAgICAgICAgJ86TJzogJ0cnLFxuICAgICAgICAgICAgJ86UJzogJ0QnLFxuICAgICAgICAgICAgJ86VJzogJ0UnLFxuICAgICAgICAgICAgJ86WJzogJ1onLFxuICAgICAgICAgICAgJ86XJzogJ0knLFxuICAgICAgICAgICAgJ86YJzogJ1RIJyxcbiAgICAgICAgICAgICfOmSc6ICdJJyxcbiAgICAgICAgICAgICfOmic6ICdLJyxcbiAgICAgICAgICAgICfOmyc6ICdMJyxcbiAgICAgICAgICAgICfOnCc6ICdNJyxcbiAgICAgICAgICAgICfOnSc6ICdOJyxcbiAgICAgICAgICAgICfOnic6ICdLUycsXG4gICAgICAgICAgICAnzp8nOiAnTycsXG4gICAgICAgICAgICAnzqAnOiAnUCcsXG4gICAgICAgICAgICAnzqEnOiAnUicsXG4gICAgICAgICAgICAnzqMnOiAnUycsXG4gICAgICAgICAgICAnzqQnOiAnVCcsXG4gICAgICAgICAgICAnzqUnOiAnWScsXG4gICAgICAgICAgICAnzqYnOiAnRicsXG4gICAgICAgICAgICAnzqcnOiAnWCcsXG4gICAgICAgICAgICAnzqgnOiAnUFMnLFxuICAgICAgICAgICAgJ86pJzogJ1cnLFxuICAgICAgICAgICAgJ86GJzogJ0EnLFxuICAgICAgICAgICAgJ86IJzogJ0UnLFxuICAgICAgICAgICAgJ86KJzogJ0knLFxuICAgICAgICAgICAgJ86MJzogJ08nLFxuICAgICAgICAgICAgJ86OJzogJ1knLFxuICAgICAgICAgICAgJ86JJzogJ0knLFxuICAgICAgICAgICAgJ86PJzogJ08nLFxuICAgICAgICAgICAgJ86qJzogJ0knLFxuICAgICAgICAgICAgJ86rJzogJ1knLFxuXG4gICAgICAgICAgICAvLyBMYXR2aWFuXG4gICAgICAgICAgICAnxIEnOiAnYScsXG4gICAgICAgICAgICAvLyAnxI0nOiAnYycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgJ8STJzogJ2UnLFxuICAgICAgICAgICAgJ8SjJzogJ2cnLFxuICAgICAgICAgICAgJ8SrJzogJ2knLFxuICAgICAgICAgICAgJ8S3JzogJ2snLFxuICAgICAgICAgICAgJ8S8JzogJ2wnLFxuICAgICAgICAgICAgJ8WGJzogJ24nLFxuICAgICAgICAgICAgLy8gJ8WhJzogJ3MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAgICfFqyc6ICd1JyxcbiAgICAgICAgICAgIC8vICfFvic6ICd6JywgLy8gZHVwbGljYXRlXG4gICAgICAgICAgICAnxIAnOiAnQScsXG4gICAgICAgICAgICAvLyAnxIwnOiAnQycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgJ8SSJzogJ0UnLFxuICAgICAgICAgICAgJ8SiJzogJ0cnLFxuICAgICAgICAgICAgJ8SqJzogJ0knLFxuICAgICAgICAgICAgJ8S2JzogJ2snLFxuICAgICAgICAgICAgJ8S7JzogJ0wnLFxuICAgICAgICAgICAgJ8WFJzogJ04nLFxuICAgICAgICAgICAgLy8gJ8WgJzogJ1MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAgICfFqic6ICdVJyxcbiAgICAgICAgICAgIC8vICfFvSc6ICdaJywgLy8gZHVwbGljYXRlXG5cbiAgICAgICAgICAgIC8vIE1hY2Vkb25pYW5cbiAgICAgICAgICAgICfQjCc6ICdLaicsXG4gICAgICAgICAgICAn0ZwnOiAna2onLFxuICAgICAgICAgICAgJ9CJJzogJ0xqJyxcbiAgICAgICAgICAgICfRmSc6ICdsaicsXG4gICAgICAgICAgICAn0IonOiAnTmonLFxuICAgICAgICAgICAgJ9GaJzogJ25qJyxcbiAgICAgICAgICAgICfQotGBJzogJ1RzJyxcbiAgICAgICAgICAgICfRgtGBJzogJ3RzJyxcblxuICAgICAgICAgICAgLy8gUG9saXNoXG4gICAgICAgICAgICAnxIUnOiAnYScsXG4gICAgICAgICAgICAnxIcnOiAnYycsXG4gICAgICAgICAgICAnxJknOiAnZScsXG4gICAgICAgICAgICAnxYInOiAnbCcsXG4gICAgICAgICAgICAnxYQnOiAnbicsXG4gICAgICAgICAgICAvLyAnw7MnOiAnbycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgJ8WbJzogJ3MnLFxuICAgICAgICAgICAgJ8W6JzogJ3onLFxuICAgICAgICAgICAgJ8W8JzogJ3onLFxuICAgICAgICAgICAgJ8SEJzogJ0EnLFxuICAgICAgICAgICAgJ8SGJzogJ0MnLFxuICAgICAgICAgICAgJ8SYJzogJ0UnLFxuICAgICAgICAgICAgJ8WBJzogJ0wnLFxuICAgICAgICAgICAgJ8WDJzogJ04nLFxuICAgICAgICAgICAgJ8WaJzogJ1MnLFxuICAgICAgICAgICAgJ8W5JzogJ1onLFxuICAgICAgICAgICAgJ8W7JzogJ1onLFxuXG4gICAgICAgICAgICAvLyBVa3JhbmlhblxuICAgICAgICAgICAgJ9CEJzogJ1llJyxcbiAgICAgICAgICAgICfQhic6ICdJJyxcbiAgICAgICAgICAgICfQhyc6ICdZaScsXG4gICAgICAgICAgICAn0pAnOiAnRycsXG4gICAgICAgICAgICAn0ZQnOiAneWUnLFxuICAgICAgICAgICAgJ9GWJzogJ2knLFxuICAgICAgICAgICAgJ9GXJzogJ3lpJyxcbiAgICAgICAgICAgICfSkSc6ICdnJyxcblxuICAgICAgICAgICAgLy8gUm9tYW5pYW5cbiAgICAgICAgICAgICfEgyc6ICdhJyxcbiAgICAgICAgICAgICfEgic6ICdBJyxcbiAgICAgICAgICAgICfImSc6ICdzJyxcbiAgICAgICAgICAgICfImCc6ICdTJyxcbiAgICAgICAgICAgIC8vICfFnyc6ICdzJywgLy8gZHVwbGljYXRlXG4gICAgICAgICAgICAvLyAnxZ4nOiAnUycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgJ8ibJzogJ3QnLFxuICAgICAgICAgICAgJ8iaJzogJ1QnLFxuICAgICAgICAgICAgJ8WjJzogJ3QnLFxuICAgICAgICAgICAgJ8WiJzogJ1QnLFxuXG4gICAgICAgICAgICAvLyBSdXNzaWFuIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvbWFuaXphdGlvbl9vZl9SdXNzaWFuXG4gICAgICAgICAgICAvLyBJQ0FPXG5cbiAgICAgICAgICAgICfQsCc6ICdhJyxcbiAgICAgICAgICAgICfQsSc6ICdiJyxcbiAgICAgICAgICAgICfQsic6ICd2JyxcbiAgICAgICAgICAgICfQsyc6ICdnJyxcbiAgICAgICAgICAgICfQtCc6ICdkJyxcbiAgICAgICAgICAgICfQtSc6ICdlJyxcbiAgICAgICAgICAgICfRkSc6ICd5bycsXG4gICAgICAgICAgICAn0LYnOiAnemgnLFxuICAgICAgICAgICAgJ9C3JzogJ3onLFxuICAgICAgICAgICAgJ9C4JzogJ2knLFxuICAgICAgICAgICAgJ9C5JzogJ2knLFxuICAgICAgICAgICAgJ9C6JzogJ2snLFxuICAgICAgICAgICAgJ9C7JzogJ2wnLFxuICAgICAgICAgICAgJ9C8JzogJ20nLFxuICAgICAgICAgICAgJ9C9JzogJ24nLFxuICAgICAgICAgICAgJ9C+JzogJ28nLFxuICAgICAgICAgICAgJ9C/JzogJ3AnLFxuICAgICAgICAgICAgJ9GAJzogJ3InLFxuICAgICAgICAgICAgJ9GBJzogJ3MnLFxuICAgICAgICAgICAgJ9GCJzogJ3QnLFxuICAgICAgICAgICAgJ9GDJzogJ3UnLFxuICAgICAgICAgICAgJ9GEJzogJ2YnLFxuICAgICAgICAgICAgJ9GFJzogJ2toJyxcbiAgICAgICAgICAgICfRhic6ICdjJyxcbiAgICAgICAgICAgICfRhyc6ICdjaCcsXG4gICAgICAgICAgICAn0YgnOiAnc2gnLFxuICAgICAgICAgICAgJ9GJJzogJ3NoJyxcbiAgICAgICAgICAgICfRiic6ICcnLFxuICAgICAgICAgICAgJ9GLJzogJ3knLFxuICAgICAgICAgICAgJ9GMJzogJycsXG4gICAgICAgICAgICAn0Y0nOiAnZScsXG4gICAgICAgICAgICAn0Y4nOiAneXUnLFxuICAgICAgICAgICAgJ9GPJzogJ3lhJyxcbiAgICAgICAgICAgICfQkCc6ICdBJyxcbiAgICAgICAgICAgICfQkSc6ICdCJyxcbiAgICAgICAgICAgICfQkic6ICdWJyxcbiAgICAgICAgICAgICfQkyc6ICdHJyxcbiAgICAgICAgICAgICfQlCc6ICdEJyxcbiAgICAgICAgICAgICfQlSc6ICdFJyxcbiAgICAgICAgICAgICfQgSc6ICdZbycsXG4gICAgICAgICAgICAn0JYnOiAnWmgnLFxuICAgICAgICAgICAgJ9CXJzogJ1onLFxuICAgICAgICAgICAgJ9CYJzogJ0knLFxuICAgICAgICAgICAgJ9CZJzogJ0knLFxuICAgICAgICAgICAgJ9CaJzogJ0snLFxuICAgICAgICAgICAgJ9CbJzogJ0wnLFxuICAgICAgICAgICAgJ9CcJzogJ00nLFxuICAgICAgICAgICAgJ9CdJzogJ04nLFxuICAgICAgICAgICAgJ9CeJzogJ08nLFxuICAgICAgICAgICAgJ9CfJzogJ1AnLFxuICAgICAgICAgICAgJ9CgJzogJ1InLFxuICAgICAgICAgICAgJ9ChJzogJ1MnLFxuICAgICAgICAgICAgJ9CiJzogJ1QnLFxuICAgICAgICAgICAgJ9CjJzogJ1UnLFxuICAgICAgICAgICAgJ9CkJzogJ0YnLFxuICAgICAgICAgICAgJ9ClJzogJ0toJyxcbiAgICAgICAgICAgICfQpic6ICdDJyxcbiAgICAgICAgICAgICfQpyc6ICdDaCcsXG4gICAgICAgICAgICAn0KgnOiAnU2gnLFxuICAgICAgICAgICAgJ9CpJzogJ1NoJyxcbiAgICAgICAgICAgICfQqic6ICcnLFxuICAgICAgICAgICAgJ9CrJzogJ1knLFxuICAgICAgICAgICAgJ9CsJzogJycsXG4gICAgICAgICAgICAn0K0nOiAnRScsXG4gICAgICAgICAgICAn0K4nOiAnWXUnLFxuICAgICAgICAgICAgJ9CvJzogJ1lhJyxcblxuICAgICAgICAgICAgLy8gU2VyYmlhblxuICAgICAgICAgICAgJ9GSJzogJ2RqJyxcbiAgICAgICAgICAgICfRmCc6ICdqJyxcbiAgICAgICAgICAgIC8vICfRmSc6ICdsaicsICAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAgIC8vICfRmic6ICduaicsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgJ9GbJzogJ2MnLFxuICAgICAgICAgICAgJ9GfJzogJ2R6JyxcbiAgICAgICAgICAgICfQgic6ICdEaicsXG4gICAgICAgICAgICAn0IgnOiAnaicsXG4gICAgICAgICAgICAvLyAn0IknOiAnTGonLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAgIC8vICfQiic6ICdOaicsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgJ9CLJzogJ0MnLFxuICAgICAgICAgICAgJ9CPJzogJ0R6JyxcblxuICAgICAgICAgICAgLy8gU2xvdmFrXG4gICAgICAgICAgICAnxL4nOiAnbCcsXG4gICAgICAgICAgICAnxLonOiAnbCcsXG4gICAgICAgICAgICAnxZUnOiAncicsXG4gICAgICAgICAgICAnxL0nOiAnTCcsXG4gICAgICAgICAgICAnxLknOiAnTCcsXG4gICAgICAgICAgICAnxZQnOiAnUicsXG5cbiAgICAgICAgICAgIC8vIFR1cmtpc2hcbiAgICAgICAgICAgICfFnyc6ICdzJyxcbiAgICAgICAgICAgICfFnic6ICdTJyxcbiAgICAgICAgICAgICfEsSc6ICdpJyxcbiAgICAgICAgICAgICfEsCc6ICdJJyxcbiAgICAgICAgICAgIC8vICfDpyc6ICdjJywgLy8gZHVwbGljYXRlXG4gICAgICAgICAgICAvLyAnw4cnOiAnQycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgLy8gJ8O8JzogJ3UnLCAvLyBkdXBsaWNhdGUsIHNlZSBsYW5nQ2hhck1hcFxuICAgICAgICAgICAgLy8gJ8OcJzogJ1UnLCAvLyBkdXBsaWNhdGUsIHNlZSBsYW5nQ2hhck1hcFxuICAgICAgICAgICAgLy8gJ8O2JzogJ28nLCAvLyBkdXBsaWNhdGUsIHNlZSBsYW5nQ2hhck1hcFxuICAgICAgICAgICAgLy8gJ8OWJzogJ08nLCAvLyBkdXBsaWNhdGUsIHNlZSBsYW5nQ2hhck1hcFxuICAgICAgICAgICAgJ8SfJzogJ2cnLFxuICAgICAgICAgICAgJ8SeJzogJ0cnLFxuXG4gICAgICAgICAgICAvLyBWaWV0bmFtZXNlXG4gICAgICAgICAgICAn4bqjJzogJ2EnLFxuICAgICAgICAgICAgJ+G6oic6ICdBJyxcbiAgICAgICAgICAgICfhurMnOiAnYScsXG4gICAgICAgICAgICAn4bqyJzogJ0EnLFxuICAgICAgICAgICAgJ+G6qSc6ICdhJyxcbiAgICAgICAgICAgICfhuqgnOiAnQScsXG4gICAgICAgICAgICAnxJEnOiAnZCcsXG4gICAgICAgICAgICAnxJAnOiAnRCcsXG4gICAgICAgICAgICAn4bq5JzogJ2UnLFxuICAgICAgICAgICAgJ+G6uCc6ICdFJyxcbiAgICAgICAgICAgICfhur0nOiAnZScsXG4gICAgICAgICAgICAn4bq8JzogJ0UnLFxuICAgICAgICAgICAgJ+G6uyc6ICdlJyxcbiAgICAgICAgICAgICfhuronOiAnRScsXG4gICAgICAgICAgICAn4bq/JzogJ2UnLFxuICAgICAgICAgICAgJ+G6vic6ICdFJyxcbiAgICAgICAgICAgICfhu4EnOiAnZScsXG4gICAgICAgICAgICAn4buAJzogJ0UnLFxuICAgICAgICAgICAgJ+G7hyc6ICdlJyxcbiAgICAgICAgICAgICfhu4YnOiAnRScsXG4gICAgICAgICAgICAn4buFJzogJ2UnLFxuICAgICAgICAgICAgJ+G7hCc6ICdFJyxcbiAgICAgICAgICAgICfhu4MnOiAnZScsXG4gICAgICAgICAgICAn4buCJzogJ0UnLFxuICAgICAgICAgICAgJ+G7jSc6ICdvJyxcbiAgICAgICAgICAgICfhu4wnOiAnbycsXG4gICAgICAgICAgICAn4buRJzogJ28nLFxuICAgICAgICAgICAgJ+G7kCc6ICdPJyxcbiAgICAgICAgICAgICfhu5MnOiAnbycsXG4gICAgICAgICAgICAn4buSJzogJ08nLFxuICAgICAgICAgICAgJ+G7lSc6ICdvJyxcbiAgICAgICAgICAgICfhu5QnOiAnTycsXG4gICAgICAgICAgICAn4buZJzogJ28nLFxuICAgICAgICAgICAgJ+G7mCc6ICdPJyxcbiAgICAgICAgICAgICfhu5cnOiAnbycsXG4gICAgICAgICAgICAn4buWJzogJ08nLFxuICAgICAgICAgICAgJ8ahJzogJ28nLFxuICAgICAgICAgICAgJ8agJzogJ08nLFxuICAgICAgICAgICAgJ+G7myc6ICdvJyxcbiAgICAgICAgICAgICfhu5onOiAnTycsXG4gICAgICAgICAgICAn4budJzogJ28nLFxuICAgICAgICAgICAgJ+G7nCc6ICdPJyxcbiAgICAgICAgICAgICfhu6MnOiAnbycsXG4gICAgICAgICAgICAn4buiJzogJ08nLFxuICAgICAgICAgICAgJ+G7oSc6ICdvJyxcbiAgICAgICAgICAgICfhu6AnOiAnTycsXG4gICAgICAgICAgICAn4bueJzogJ28nLFxuICAgICAgICAgICAgJ+G7nyc6ICdvJyxcbiAgICAgICAgICAgICfhu4snOiAnaScsXG4gICAgICAgICAgICAn4buKJzogJ0knLFxuICAgICAgICAgICAgJ8SpJzogJ2knLFxuICAgICAgICAgICAgJ8SoJzogJ0knLFxuICAgICAgICAgICAgJ+G7iSc6ICdpJyxcbiAgICAgICAgICAgICfhu4gnOiAnaScsXG4gICAgICAgICAgICAn4bunJzogJ3UnLFxuICAgICAgICAgICAgJ+G7pic6ICdVJyxcbiAgICAgICAgICAgICfhu6UnOiAndScsXG4gICAgICAgICAgICAn4bukJzogJ1UnLFxuICAgICAgICAgICAgJ8WpJzogJ3UnLFxuICAgICAgICAgICAgJ8WoJzogJ1UnLFxuICAgICAgICAgICAgJ8awJzogJ3UnLFxuICAgICAgICAgICAgJ8avJzogJ1UnLFxuICAgICAgICAgICAgJ+G7qSc6ICd1JyxcbiAgICAgICAgICAgICfhu6gnOiAnVScsXG4gICAgICAgICAgICAn4burJzogJ3UnLFxuICAgICAgICAgICAgJ+G7qic6ICdVJyxcbiAgICAgICAgICAgICfhu7EnOiAndScsXG4gICAgICAgICAgICAn4buwJzogJ1UnLFxuICAgICAgICAgICAgJ+G7ryc6ICd1JyxcbiAgICAgICAgICAgICfhu64nOiAnVScsXG4gICAgICAgICAgICAn4butJzogJ3UnLFxuICAgICAgICAgICAgJ+G7rCc6ICfGsCcsXG4gICAgICAgICAgICAn4bu3JzogJ3knLFxuICAgICAgICAgICAgJ+G7tic6ICd5JyxcbiAgICAgICAgICAgICfhu7MnOiAneScsXG4gICAgICAgICAgICAn4buyJzogJ1knLFxuICAgICAgICAgICAgJ+G7tSc6ICd5JyxcbiAgICAgICAgICAgICfhu7QnOiAnWScsXG4gICAgICAgICAgICAn4bu5JzogJ3knLFxuICAgICAgICAgICAgJ+G7uCc6ICdZJyxcbiAgICAgICAgICAgICfhuqEnOiAnYScsXG4gICAgICAgICAgICAn4bqgJzogJ0EnLFxuICAgICAgICAgICAgJ+G6pSc6ICdhJyxcbiAgICAgICAgICAgICfhuqQnOiAnQScsXG4gICAgICAgICAgICAn4bqnJzogJ2EnLFxuICAgICAgICAgICAgJ+G6pic6ICdBJyxcbiAgICAgICAgICAgICfhuq0nOiAnYScsXG4gICAgICAgICAgICAn4bqsJzogJ0EnLFxuICAgICAgICAgICAgJ+G6qyc6ICdhJyxcbiAgICAgICAgICAgICfhuqonOiAnQScsXG4gICAgICAgICAgICAvLyAnxIMnOiAnYScsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgLy8gJ8SCJzogJ0EnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAgICfhuq8nOiAnYScsXG4gICAgICAgICAgICAn4bquJzogJ0EnLFxuICAgICAgICAgICAgJ+G6sSc6ICdhJyxcbiAgICAgICAgICAgICfhurAnOiAnQScsXG4gICAgICAgICAgICAn4bq3JzogJ2EnLFxuICAgICAgICAgICAgJ+G6tic6ICdBJyxcbiAgICAgICAgICAgICfhurUnOiAnYScsXG4gICAgICAgICAgICAn4bq0JzogJ0EnLFxuXG4gICAgICAgICAgICAvLyBzeW1ib2xzXG4gICAgICAgICAgICAn4oCcJzogJ1wiJyxcbiAgICAgICAgICAgICfigJ0nOiAnXCInLFxuICAgICAgICAgICAgJ+KAmCc6ICdcXCcnLFxuICAgICAgICAgICAgJ+KAmSc6ICdcXCcnLFxuICAgICAgICAgICAgJ+KIgic6ICdkJyxcbiAgICAgICAgICAgICfGkic6ICdmJyxcbiAgICAgICAgICAgICfihKInOiAnKFRNKScsXG4gICAgICAgICAgICAnwqknOiAnKEMpJyxcbiAgICAgICAgICAgICfFkyc6ICdvZScsXG4gICAgICAgICAgICAnxZInOiAnT0UnLFxuICAgICAgICAgICAgJ8KuJzogJyhSKScsXG4gICAgICAgICAgICAn4oCgJzogJysnLFxuICAgICAgICAgICAgJ+KEoCc6ICcoU00pJyxcbiAgICAgICAgICAgICfigKYnOiAnLi4uJyxcbiAgICAgICAgICAgICfLmic6ICdvJyxcbiAgICAgICAgICAgICfCuic6ICdvJyxcbiAgICAgICAgICAgICfCqic6ICdhJyxcbiAgICAgICAgICAgICfigKInOiAnKicsXG4gICAgICAgICAgICAn4YGKJzogJywnLFxuICAgICAgICAgICAgJ+GBiyc6ICcuJyxcblxuICAgICAgICAgICAgLy8gY3VycmVuY3lcbiAgICAgICAgICAgICckJzogJ1VTRCcsXG4gICAgICAgICAgICAn4oKsJzogJ0VVUicsXG4gICAgICAgICAgICAn4oKiJzogJ0JSTicsXG4gICAgICAgICAgICAn4oKjJzogJ0ZSRicsXG4gICAgICAgICAgICAnwqMnOiAnR0JQJyxcbiAgICAgICAgICAgICfigqQnOiAnSVRMJyxcbiAgICAgICAgICAgICfigqYnOiAnTkdOJyxcbiAgICAgICAgICAgICfigqcnOiAnRVNQJyxcbiAgICAgICAgICAgICfigqknOiAnS1JXJyxcbiAgICAgICAgICAgICfigqonOiAnSUxTJyxcbiAgICAgICAgICAgICfigqsnOiAnVk5EJyxcbiAgICAgICAgICAgICfigq0nOiAnTEFLJyxcbiAgICAgICAgICAgICfigq4nOiAnTU5UJyxcbiAgICAgICAgICAgICfigq8nOiAnR1JEJyxcbiAgICAgICAgICAgICfigrEnOiAnQVJTJyxcbiAgICAgICAgICAgICfigrInOiAnUFlHJyxcbiAgICAgICAgICAgICfigrMnOiAnQVJBJyxcbiAgICAgICAgICAgICfigrQnOiAnVUFIJyxcbiAgICAgICAgICAgICfigrUnOiAnR0hTJyxcbiAgICAgICAgICAgICfCoic6ICdjZW50JyxcbiAgICAgICAgICAgICfCpSc6ICdDTlknLFxuICAgICAgICAgICAgJ+WFgyc6ICdDTlknLFxuICAgICAgICAgICAgJ+WGhic6ICdZRU4nLFxuICAgICAgICAgICAgJ++3vCc6ICdJUlInLFxuICAgICAgICAgICAgJ+KCoCc6ICdFV0UnLFxuICAgICAgICAgICAgJ+C4vyc6ICdUSEInLFxuICAgICAgICAgICAgJ+KCqCc6ICdJTlInLFxuICAgICAgICAgICAgJ+KCuSc6ICdJTlInLFxuICAgICAgICAgICAgJ+KCsCc6ICdQRidcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzcGVjaWFsIGxvb2sgYWhlYWQgY2hhcmFjdGVyIGFycmF5XG4gICAgICAgICAqIFRoZXNlIGNoYXJhY3RlcnMgZm9ybSB3aXRoIGNvbnNvbmFudHMgdG8gYmVjb21lICdzaW5nbGUnL2NvbnNvbmFudCBjb21ib1xuICAgICAgICAgKiBAdHlwZSBbQXJyYXldXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgbG9va0FoZWFkQ2hhckFycmF5ID0gW1xuICAgICAgICAgICAgLy8gYnVybWVzZVxuICAgICAgICAgICAgJ+GAuicsXG5cbiAgICAgICAgICAgIC8vIERoaXZlaGlcbiAgICAgICAgICAgICfesCdcbiAgICAgICAgXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGlhdHJpY01hcCBmb3IgbGFuZ3VhZ2VzIHdoZXJlIHRyYW5zbGl0ZXJhdGlvbiBjaGFuZ2VzIGVudGlyZWx5IGFzIG1vcmUgZGlhdHJpY3MgYXJlIGFkZGVkXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZGlhdHJpY01hcCA9IHtcbiAgICAgICAgICAgIC8vIEJ1cm1lc2VcbiAgICAgICAgICAgIC8vIGRlcGVuZGVudCB2b3dlbHNcbiAgICAgICAgICAgICfhgKwnOiAnYScsXG4gICAgICAgICAgICAn4YCrJzogJ2EnLFxuICAgICAgICAgICAgJ+GAsSc6ICdlJyxcbiAgICAgICAgICAgICfhgLInOiAnZScsXG4gICAgICAgICAgICAn4YCtJzogJ2knLFxuICAgICAgICAgICAgJ+GAric6ICdpJyxcbiAgICAgICAgICAgICfhgK3hgK8nOiAnbycsXG4gICAgICAgICAgICAn4YCvJzogJ3UnLFxuICAgICAgICAgICAgJ+GAsCc6ICd1JyxcbiAgICAgICAgICAgICfhgLHhgKvhgIThgLonOiAnYXVuZycsXG4gICAgICAgICAgICAn4YCx4YCsJzogJ2F3JyxcbiAgICAgICAgICAgICfhgLHhgKzhgLonOiAnYXcnLFxuICAgICAgICAgICAgJ+GAseGAqyc6ICdhdycsXG4gICAgICAgICAgICAn4YCx4YCr4YC6JzogJ2F3JyxcbiAgICAgICAgICAgICfhgLonOiAn4YC6JywgLy8gdGhpcyBpcyBzcGVjaWFsIGNhc2UgYnV0IHRoZSBjaGFyYWN0ZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gbGF0aW4gaW4gdGhlIGNvZGVcbiAgICAgICAgICAgICfhgIDhgLonOiAnZXQnLFxuICAgICAgICAgICAgJ+GAreGAr+GAgOGAuic6ICdhaWsnLFxuICAgICAgICAgICAgJ+GAseGArOGAgOGAuic6ICdhdWsnLFxuICAgICAgICAgICAgJ+GAhOGAuic6ICdpbicsXG4gICAgICAgICAgICAn4YCt4YCv4YCE4YC6JzogJ2FpbmcnLFxuICAgICAgICAgICAgJ+GAseGArOGAhOGAuic6ICdhdW5nJyxcbiAgICAgICAgICAgICfhgIXhgLonOiAnaXQnLFxuICAgICAgICAgICAgJ+GAiuGAuic6ICdpJyxcbiAgICAgICAgICAgICfhgJDhgLonOiAnYXQnLFxuICAgICAgICAgICAgJ+GAreGAkOGAuic6ICdlaWsnLFxuICAgICAgICAgICAgJ+GAr+GAkOGAuic6ICdvaycsXG4gICAgICAgICAgICAn4YC94YCQ4YC6JzogJ3V0JyxcbiAgICAgICAgICAgICfhgLHhgJDhgLonOiAnaXQnLFxuICAgICAgICAgICAgJ+GAkuGAuic6ICdkJyxcbiAgICAgICAgICAgICfhgK3hgK/hgJLhgLonOiAnb2snLFxuICAgICAgICAgICAgJ+GAr+GAkuGAuic6ICdhaXQnLFxuICAgICAgICAgICAgJ+GAlOGAuic6ICdhbicsXG4gICAgICAgICAgICAn4YCs4YCU4YC6JzogJ2FuJyxcbiAgICAgICAgICAgICfhgK3hgJThgLonOiAnZWluJyxcbiAgICAgICAgICAgICfhgK/hgJThgLonOiAnb24nLFxuICAgICAgICAgICAgJ+GAveGAlOGAuic6ICd1bicsXG4gICAgICAgICAgICAn4YCV4YC6JzogJ2F0JyxcbiAgICAgICAgICAgICfhgK3hgJXhgLonOiAnZWlrJyxcbiAgICAgICAgICAgICfhgK/hgJXhgLonOiAnb2snLFxuICAgICAgICAgICAgJ+GAveGAleGAuic6ICd1dCcsXG4gICAgICAgICAgICAn4YCU4YC64YCv4YCV4YC6JzogJ251YicsXG4gICAgICAgICAgICAn4YCZ4YC6JzogJ2FuJyxcbiAgICAgICAgICAgICfhgK3hgJnhgLonOiAnZWluJyxcbiAgICAgICAgICAgICfhgK/hgJnhgLonOiAnb24nLFxuICAgICAgICAgICAgJ+GAveGAmeGAuic6ICd1bicsXG4gICAgICAgICAgICAn4YCa4YC6JzogJ2UnLFxuICAgICAgICAgICAgJ+GAreGAr+GAnOGAuic6ICdvbCcsXG4gICAgICAgICAgICAn4YCJ4YC6JzogJ2luJyxcbiAgICAgICAgICAgICfhgLYnOiAnYW4nLFxuICAgICAgICAgICAgJ+GAreGAtic6ICdlaW4nLFxuICAgICAgICAgICAgJ+GAr+GAtic6ICdvbicsXG5cbiAgICAgICAgICAgIC8vIERoaXZlaGlcbiAgICAgICAgICAgICfept6H3rAnOiAnYWgnLFxuICAgICAgICAgICAgJ96m3oHesCc6ICdhaCcsXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxhbmdDaGFyTWFwIGxhbmd1YWdlIHNwZWNpZmljIGNoYXJhY3RlcnMgdHJhbnNsYXRpb25zXG4gICAgICAgICAqIEB0eXBlICAge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBsYW5nQ2hhck1hcCA9IHtcblxuICAgICAgICAgICAgJ2VuJzoge30sIC8vIGRlZmF1bHQgbGFuZ3VhZ2VcblxuICAgICAgICAgICAgJ2F6JzogeyAvLyBBemVyYmFpamFuaVxuICAgICAgICAgICAgICAgICfDpyc6ICdjJyxcbiAgICAgICAgICAgICAgICAnyZknOiAnZScsXG4gICAgICAgICAgICAgICAgJ8SfJzogJ2cnLFxuICAgICAgICAgICAgICAgICfEsSc6ICdpJyxcbiAgICAgICAgICAgICAgICAnw7YnOiAnbycsXG4gICAgICAgICAgICAgICAgJ8WfJzogJ3MnLFxuICAgICAgICAgICAgICAgICfDvCc6ICd1JyxcbiAgICAgICAgICAgICAgICAnw4cnOiAnQycsXG4gICAgICAgICAgICAgICAgJ8aPJzogJ0UnLFxuICAgICAgICAgICAgICAgICfEnic6ICdHJyxcbiAgICAgICAgICAgICAgICAnxLAnOiAnSScsXG4gICAgICAgICAgICAgICAgJ8OWJzogJ08nLFxuICAgICAgICAgICAgICAgICfFnic6ICdTJyxcbiAgICAgICAgICAgICAgICAnw5wnOiAnVSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdjcyc6IHsgLy8gQ3plY2hcbiAgICAgICAgICAgICAgICAnxI0nOiAnYycsXG4gICAgICAgICAgICAgICAgJ8SPJzogJ2QnLFxuICAgICAgICAgICAgICAgICfEmyc6ICdlJyxcbiAgICAgICAgICAgICAgICAnxYgnOiAnbicsXG4gICAgICAgICAgICAgICAgJ8WZJzogJ3InLFxuICAgICAgICAgICAgICAgICfFoSc6ICdzJyxcbiAgICAgICAgICAgICAgICAnxaUnOiAndCcsXG4gICAgICAgICAgICAgICAgJ8WvJzogJ3UnLFxuICAgICAgICAgICAgICAgICfFvic6ICd6JyxcbiAgICAgICAgICAgICAgICAnxIwnOiAnQycsXG4gICAgICAgICAgICAgICAgJ8SOJzogJ0QnLFxuICAgICAgICAgICAgICAgICfEmic6ICdFJyxcbiAgICAgICAgICAgICAgICAnxYcnOiAnTicsXG4gICAgICAgICAgICAgICAgJ8WYJzogJ1InLFxuICAgICAgICAgICAgICAgICfFoCc6ICdTJyxcbiAgICAgICAgICAgICAgICAnxaQnOiAnVCcsXG4gICAgICAgICAgICAgICAgJ8WuJzogJ1UnLFxuICAgICAgICAgICAgICAgICfFvSc6ICdaJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ2ZpJzogeyAvLyBGaW5uaXNoXG4gICAgICAgICAgICAgICAgLy8gJ8OlJzogJ2EnLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgICAgICAvLyAnw4UnOiAnQScsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgICAgICAgICfDpCc6ICdhJywgLy8gb2tcbiAgICAgICAgICAgICAgICAnw4QnOiAnQScsIC8vIG9rXG4gICAgICAgICAgICAgICAgJ8O2JzogJ28nLCAvLyBva1xuICAgICAgICAgICAgICAgICfDlic6ICdPJyAvLyBva1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ2h1JzogeyAvLyBIdW5nYXJpYW5cbiAgICAgICAgICAgICAgICAnw6QnOiAnYScsIC8vIG9rXG4gICAgICAgICAgICAgICAgJ8OEJzogJ0EnLCAvLyBva1xuICAgICAgICAgICAgICAgIC8vICfDoSc6ICdhJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgICAgICAgLy8gJ8OBJzogJ0EnLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgICAgICAnw7YnOiAnbycsIC8vIG9rXG4gICAgICAgICAgICAgICAgJ8OWJzogJ08nLCAvLyBva1xuICAgICAgICAgICAgICAgIC8vICfFkSc6ICdvJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgICAgICAgLy8gJ8WQJzogJ08nLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICAgICAgICAnw7wnOiAndScsXG4gICAgICAgICAgICAgICAgJ8OcJzogJ1UnLFxuICAgICAgICAgICAgICAgICfFsSc6ICd1JyxcbiAgICAgICAgICAgICAgICAnxbAnOiAnVSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdsdCc6IHsgLy8gTGl0aHVhbmlhblxuICAgICAgICAgICAgICAgICfEhSc6ICdhJyxcbiAgICAgICAgICAgICAgICAnxI0nOiAnYycsXG4gICAgICAgICAgICAgICAgJ8SZJzogJ2UnLFxuICAgICAgICAgICAgICAgICfElyc6ICdlJyxcbiAgICAgICAgICAgICAgICAnxK8nOiAnaScsXG4gICAgICAgICAgICAgICAgJ8WhJzogJ3MnLFxuICAgICAgICAgICAgICAgICfFsyc6ICd1JyxcbiAgICAgICAgICAgICAgICAnxasnOiAndScsXG4gICAgICAgICAgICAgICAgJ8W+JzogJ3onLFxuICAgICAgICAgICAgICAgICfEhCc6ICdBJyxcbiAgICAgICAgICAgICAgICAnxIwnOiAnQycsXG4gICAgICAgICAgICAgICAgJ8SYJzogJ0UnLFxuICAgICAgICAgICAgICAgICfElic6ICdFJyxcbiAgICAgICAgICAgICAgICAnxK4nOiAnSScsXG4gICAgICAgICAgICAgICAgJ8WgJzogJ1MnLFxuICAgICAgICAgICAgICAgICfFsic6ICdVJyxcbiAgICAgICAgICAgICAgICAnxaonOiAnVSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdsdic6IHsgLy8gTGF0dmlhblxuICAgICAgICAgICAgICAgICfEgSc6ICdhJyxcbiAgICAgICAgICAgICAgICAnxI0nOiAnYycsXG4gICAgICAgICAgICAgICAgJ8STJzogJ2UnLFxuICAgICAgICAgICAgICAgICfEoyc6ICdnJyxcbiAgICAgICAgICAgICAgICAnxKsnOiAnaScsXG4gICAgICAgICAgICAgICAgJ8S3JzogJ2snLFxuICAgICAgICAgICAgICAgICfEvCc6ICdsJyxcbiAgICAgICAgICAgICAgICAnxYYnOiAnbicsXG4gICAgICAgICAgICAgICAgJ8WhJzogJ3MnLFxuICAgICAgICAgICAgICAgICfFqyc6ICd1JyxcbiAgICAgICAgICAgICAgICAnxb4nOiAneicsXG4gICAgICAgICAgICAgICAgJ8SAJzogJ0EnLFxuICAgICAgICAgICAgICAgICfEjCc6ICdDJyxcbiAgICAgICAgICAgICAgICAnxJInOiAnRScsXG4gICAgICAgICAgICAgICAgJ8SiJzogJ0cnLFxuICAgICAgICAgICAgICAgICfEqic6ICdpJyxcbiAgICAgICAgICAgICAgICAnxLYnOiAnaycsXG4gICAgICAgICAgICAgICAgJ8S7JzogJ0wnLFxuICAgICAgICAgICAgICAgICfFhSc6ICdOJyxcbiAgICAgICAgICAgICAgICAnxaAnOiAnUycsXG4gICAgICAgICAgICAgICAgJ8WqJzogJ3UnLFxuICAgICAgICAgICAgICAgICfFvSc6ICdaJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ3BsJzogeyAvLyBQb2xpc2hcbiAgICAgICAgICAgICAgICAnxIUnOiAnYScsXG4gICAgICAgICAgICAgICAgJ8SHJzogJ2MnLFxuICAgICAgICAgICAgICAgICfEmSc6ICdlJyxcbiAgICAgICAgICAgICAgICAnxYInOiAnbCcsXG4gICAgICAgICAgICAgICAgJ8WEJzogJ24nLFxuICAgICAgICAgICAgICAgICfDsyc6ICdvJyxcbiAgICAgICAgICAgICAgICAnxZsnOiAncycsXG4gICAgICAgICAgICAgICAgJ8W6JzogJ3onLFxuICAgICAgICAgICAgICAgICfFvCc6ICd6JyxcbiAgICAgICAgICAgICAgICAnxIQnOiAnQScsXG4gICAgICAgICAgICAgICAgJ8SGJzogJ0MnLFxuICAgICAgICAgICAgICAgICfEmCc6ICdlJyxcbiAgICAgICAgICAgICAgICAnxYEnOiAnTCcsXG4gICAgICAgICAgICAgICAgJ8WDJzogJ04nLFxuICAgICAgICAgICAgICAgICfDkyc6ICdPJyxcbiAgICAgICAgICAgICAgICAnxZonOiAnUycsXG4gICAgICAgICAgICAgICAgJ8W5JzogJ1onLFxuICAgICAgICAgICAgICAgICfFuyc6ICdaJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ3NrJzogeyAvLyBTbG92YWtcbiAgICAgICAgICAgICAgICAnw6QnOiAnYScsXG4gICAgICAgICAgICAgICAgJ8OEJzogJ0EnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnc3InOiB7IC8vIFNlcmJpYW5cbiAgICAgICAgICAgICAgICAn0ZknOiAnbGonLFxuICAgICAgICAgICAgICAgICfRmic6ICduaicsXG4gICAgICAgICAgICAgICAgJ9CJJzogJ0xqJyxcbiAgICAgICAgICAgICAgICAn0IonOiAnTmonLFxuICAgICAgICAgICAgICAgICfEkSc6ICdkaicsXG4gICAgICAgICAgICAgICAgJ8SQJzogJ0RqJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ3RyJzogeyAvLyBUdXJraXNoXG4gICAgICAgICAgICAgICAgJ8OcJzogJ1UnLFxuICAgICAgICAgICAgICAgICfDlic6ICdPJyxcbiAgICAgICAgICAgICAgICAnw7wnOiAndScsXG4gICAgICAgICAgICAgICAgJ8O2JzogJ28nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN5bWJvbE1hcCBsYW5ndWFnZSBzcGVjaWZpYyBzeW1ib2wgdHJhbnNsYXRpb25zXG4gICAgICAgICAqIHRyYW5zbGF0aW9ucyBtdXN0IGJlIHRyYW5zbGl0ZXJhdGVkIGFscmVhZHlcbiAgICAgICAgICogQHR5cGUgICB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHN5bWJvbE1hcCA9IHtcblxuICAgICAgICAgICAgJ2FyJzoge1xuICAgICAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAnbGEtbmloYXlhJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2hvYicsXG4gICAgICAgICAgICAgICAgJyYnOiAnd2EnLFxuICAgICAgICAgICAgICAgICd8JzogJ2F3JyxcbiAgICAgICAgICAgICAgICAnPCc6ICdhcWFsLW1lbicsXG4gICAgICAgICAgICAgICAgJz4nOiAnYWtiYXItbWVuJyxcbiAgICAgICAgICAgICAgICAn4oiRJzogJ21ham1vdScsXG4gICAgICAgICAgICAgICAgJ8KkJzogJ29tbGEnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnYXonOiB7fSxcblxuICAgICAgICAgICAgJ2NhJzoge1xuICAgICAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAnaW5maW5pdCcsXG4gICAgICAgICAgICAgICAgJ+KZpSc6ICdhbW9yJyxcbiAgICAgICAgICAgICAgICAnJic6ICdpJyxcbiAgICAgICAgICAgICAgICAnfCc6ICdvJyxcbiAgICAgICAgICAgICAgICAnPCc6ICdtZW55cyBxdWUnLFxuICAgICAgICAgICAgICAgICc+JzogJ21lcyBxdWUnLFxuICAgICAgICAgICAgICAgICfiiJEnOiAnc3VtYSBkZWxzJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAnbW9uZWRhJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ2N6Jzoge1xuICAgICAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAnbmVrb25lY25vJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2xhc2thJyxcbiAgICAgICAgICAgICAgICAnJic6ICdhJyxcbiAgICAgICAgICAgICAgICAnfCc6ICduZWJvJyxcbiAgICAgICAgICAgICAgICAnPCc6ICdtZW5lIGpha28nLFxuICAgICAgICAgICAgICAgICc+JzogJ3ZpY2UgamFrbycsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdzb3VjZXQnLFxuICAgICAgICAgICAgICAgICfCpCc6ICdtZW5hJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ2RlJzoge1xuICAgICAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAndW5lbmRsaWNoJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ0xpZWJlJyxcbiAgICAgICAgICAgICAgICAnJic6ICd1bmQnLFxuICAgICAgICAgICAgICAgICd8JzogJ29kZXInLFxuICAgICAgICAgICAgICAgICc8JzogJ2tsZWluZXIgYWxzJyxcbiAgICAgICAgICAgICAgICAnPic6ICdncm9lc3NlciBhbHMnLFxuICAgICAgICAgICAgICAgICfiiJEnOiAnU3VtbWUgdm9uJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAnV2FlaHJ1bmcnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnZHYnOiB7XG4gICAgICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAgICAgJ+KInic6ICdrb2x1bnVsYWEnLFxuICAgICAgICAgICAgICAgICfimaUnOiAnbG9hYmknLFxuICAgICAgICAgICAgICAgICcmJzogJ2FhaScsXG4gICAgICAgICAgICAgICAgJ3wnOiAnbm9vbmVlJyxcbiAgICAgICAgICAgICAgICAnPCc6ICdhaCB2dXJlIGt1ZGEnLFxuICAgICAgICAgICAgICAgICc+JzogJ2FoIHZ1cmUgYm9kdScsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdqdW11bGEnLFxuICAgICAgICAgICAgICAgICfCpCc6ICdmYWlzYWEnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnZW4nOiB7XG4gICAgICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAgICAgJ+KInic6ICdpbmZpbml0eScsXG4gICAgICAgICAgICAgICAgJ+KZpSc6ICdsb3ZlJyxcbiAgICAgICAgICAgICAgICAnJic6ICdhbmQnLFxuICAgICAgICAgICAgICAgICd8JzogJ29yJyxcbiAgICAgICAgICAgICAgICAnPCc6ICdsZXNzIHRoYW4nLFxuICAgICAgICAgICAgICAgICc+JzogJ2dyZWF0ZXIgdGhhbicsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdzdW0nLFxuICAgICAgICAgICAgICAgICfCpCc6ICdjdXJyZW5jeSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdlcyc6IHtcbiAgICAgICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICAgICAn4oieJzogJ2luZmluaXRvJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2Ftb3InLFxuICAgICAgICAgICAgICAgICcmJzogJ3knLFxuICAgICAgICAgICAgICAgICd8JzogJ3UnLFxuICAgICAgICAgICAgICAgICc8JzogJ21lbm9zIHF1ZScsXG4gICAgICAgICAgICAgICAgJz4nOiAnbWFzIHF1ZScsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdzdW1hIGRlIGxvcycsXG4gICAgICAgICAgICAgICAgJ8KkJzogJ21vbmVkYSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdmcic6IHtcbiAgICAgICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICAgICAn4oieJzogJ2luZmluaW1lbnQnLFxuICAgICAgICAgICAgICAgICfimaUnOiAnQW1vdXInLFxuICAgICAgICAgICAgICAgICcmJzogJ2V0JyxcbiAgICAgICAgICAgICAgICAnfCc6ICdvdScsXG4gICAgICAgICAgICAgICAgJzwnOiAnbW9pbnMgcXVlJyxcbiAgICAgICAgICAgICAgICAnPic6ICdzdXBlcmlldXJlIGEnLFxuICAgICAgICAgICAgICAgICfiiJEnOiAnc29tbWUgZGVzJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAnbW9ubmFpZSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdncic6IHt9LFxuXG4gICAgICAgICAgICAnaHUnOiB7XG4gICAgICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAgICAgJ+KInic6ICd2ZWd0ZWxlbicsXG4gICAgICAgICAgICAgICAgJ+KZpSc6ICdzemVyZWxlbScsXG4gICAgICAgICAgICAgICAgJyYnOiAnZXMnLFxuICAgICAgICAgICAgICAgICd8JzogJ3ZhZ3knLFxuICAgICAgICAgICAgICAgICc8JzogJ2tpc2ViYiBtaW50JyxcbiAgICAgICAgICAgICAgICAnPic6ICduYWd5b2JiIG1pbnQnLFxuICAgICAgICAgICAgICAgICfiiJEnOiAnc3p1bW1hJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAncGVuem5lbSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdpdCc6IHtcbiAgICAgICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICAgICAn4oieJzogJ2luZmluaXRvJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2Ftb3JlJyxcbiAgICAgICAgICAgICAgICAnJic6ICdlJyxcbiAgICAgICAgICAgICAgICAnfCc6ICdvJyxcbiAgICAgICAgICAgICAgICAnPCc6ICdtaW5vcmUgZGknLFxuICAgICAgICAgICAgICAgICc+JzogJ21hZ2dpb3JlIGRpJyxcbiAgICAgICAgICAgICAgICAn4oiRJzogJ3NvbW1hJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAnbW9uZXRhJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ2x0Jzoge30sXG5cbiAgICAgICAgICAgICdsdic6IHtcbiAgICAgICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICAgICAn4oieJzogJ2JlemdhbGliYScsXG4gICAgICAgICAgICAgICAgJ+KZpSc6ICdtaWxlc3RpYmEnLFxuICAgICAgICAgICAgICAgICcmJzogJ3VuJyxcbiAgICAgICAgICAgICAgICAnfCc6ICd2YWknLFxuICAgICAgICAgICAgICAgICc8JzogJ21hemFrIG5la2EnLFxuICAgICAgICAgICAgICAgICc+JzogJ2xpZWxha3MgbmVrYScsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdzdW1tYScsXG4gICAgICAgICAgICAgICAgJ8KkJzogJ3ZhbHV0YSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdteSc6IHtcbiAgICAgICAgICAgICAgICAn4oiGJzogJ2t3YWhraHlhZXQnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAnYXNhb25hc21lJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2FraHlhaXQnLFxuICAgICAgICAgICAgICAgICcmJzogJ25oaW4nLFxuICAgICAgICAgICAgICAgICd8JzogJ3RobycsXG4gICAgICAgICAgICAgICAgJzwnOiAnbmdldGhhdycsXG4gICAgICAgICAgICAgICAgJz4nOiAna3lpdGhhdycsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdwYXVuZ2xkJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAnbmd3ZWt5ZSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdtayc6IHt9LFxuXG4gICAgICAgICAgICAnbmwnOiB7XG4gICAgICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAgICAgJ+KInic6ICdvbmVpbmRpZycsXG4gICAgICAgICAgICAgICAgJ+KZpSc6ICdsaWVmZGUnLFxuICAgICAgICAgICAgICAgICcmJzogJ2VuJyxcbiAgICAgICAgICAgICAgICAnfCc6ICdvZicsXG4gICAgICAgICAgICAgICAgJzwnOiAna2xlaW5lciBkYW4nLFxuICAgICAgICAgICAgICAgICc+JzogJ2dyb3RlciBkYW4nLFxuICAgICAgICAgICAgICAgICfiiJEnOiAnc29tJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAndmFsdXRhJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ3BsJzoge1xuICAgICAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAnbmllc2tvbmN6b25vc2MnLFxuICAgICAgICAgICAgICAgICfimaUnOiAnbWlsb3NjJyxcbiAgICAgICAgICAgICAgICAnJic6ICdpJyxcbiAgICAgICAgICAgICAgICAnfCc6ICdsdWInLFxuICAgICAgICAgICAgICAgICc8JzogJ21uaWVqc3plIG5peicsXG4gICAgICAgICAgICAgICAgJz4nOiAnd2lla3N6ZSBuaXonLFxuICAgICAgICAgICAgICAgICfiiJEnOiAnc3VtYScsXG4gICAgICAgICAgICAgICAgJ8KkJzogJ3dhbHV0YSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICdwdCc6IHtcbiAgICAgICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICAgICAn4oieJzogJ2luZmluaXRvJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2Ftb3InLFxuICAgICAgICAgICAgICAgICcmJzogJ2UnLFxuICAgICAgICAgICAgICAgICd8JzogJ291JyxcbiAgICAgICAgICAgICAgICAnPCc6ICdtZW5vciBxdWUnLFxuICAgICAgICAgICAgICAgICc+JzogJ21haW9yIHF1ZScsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdzb21hJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAnbW9lZGEnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAncm8nOiB7XG4gICAgICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAgICAgJ+KInic6ICdpbmZpbml0JyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2RyYWdvc3RlJyxcbiAgICAgICAgICAgICAgICAnJic6ICdzaScsXG4gICAgICAgICAgICAgICAgJ3wnOiAnc2F1JyxcbiAgICAgICAgICAgICAgICAnPCc6ICdtYWkgbWljIGNhJyxcbiAgICAgICAgICAgICAgICAnPic6ICdtYWkgbWFyZSBjYScsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdzdW1hJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAndmFsdXRhJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ3J1Jzoge1xuICAgICAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAnYmVza29uZWNobm8nLFxuICAgICAgICAgICAgICAgICfimaUnOiAnbHVib3YnLFxuICAgICAgICAgICAgICAgICcmJzogJ2knLFxuICAgICAgICAgICAgICAgICd8JzogJ2lsaScsXG4gICAgICAgICAgICAgICAgJzwnOiAnbWVuc2hlJyxcbiAgICAgICAgICAgICAgICAnPic6ICdib2xzaGUnLFxuICAgICAgICAgICAgICAgICfiiJEnOiAnc3VtbWEnLFxuICAgICAgICAgICAgICAgICfCpCc6ICd2YWxqdXRhJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgJ3NrJzoge1xuICAgICAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAnbmVrb25lY25vJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2xhc2thJyxcbiAgICAgICAgICAgICAgICAnJic6ICdhJyxcbiAgICAgICAgICAgICAgICAnfCc6ICdhbGVibycsXG4gICAgICAgICAgICAgICAgJzwnOiAnbWVuZWogYWtvJyxcbiAgICAgICAgICAgICAgICAnPic6ICd2aWFjIGFrbycsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICdzdWNldCcsXG4gICAgICAgICAgICAgICAgJ8KkJzogJ21lbmEnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnc3InOiB7fSxcblxuICAgICAgICAgICAgJ3RyJzoge1xuICAgICAgICAgICAgICAgICfiiIYnOiAnZGVsdGEnLFxuICAgICAgICAgICAgICAgICfiiJ4nOiAnc29uc3V6bHVrJyxcbiAgICAgICAgICAgICAgICAn4pmlJzogJ2FzaycsXG4gICAgICAgICAgICAgICAgJyYnOiAndmUnLFxuICAgICAgICAgICAgICAgICd8JzogJ3ZleWEnLFxuICAgICAgICAgICAgICAgICc8JzogJ2t1Y3VrdHVyJyxcbiAgICAgICAgICAgICAgICAnPic6ICdidXl1a3R1cicsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICd0b3BsYW0nLFxuICAgICAgICAgICAgICAgICfCpCc6ICdwYXJhIGJpcmltaSdcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICd1ayc6IHtcbiAgICAgICAgICAgICAgICAn4oiGJzogJ2RlbHRhJyxcbiAgICAgICAgICAgICAgICAn4oieJzogJ2JlemtpbmVjaG5pc3QnLFxuICAgICAgICAgICAgICAgICfimaUnOiAnbHVib3YnLFxuICAgICAgICAgICAgICAgICcmJzogJ2knLFxuICAgICAgICAgICAgICAgICd8JzogJ2FibycsXG4gICAgICAgICAgICAgICAgJzwnOiAnbWVuc2hlJyxcbiAgICAgICAgICAgICAgICAnPic6ICdiaWxzaGUnLFxuICAgICAgICAgICAgICAgICfiiJEnOiAnc3VtYScsXG4gICAgICAgICAgICAgICAgJ8KkJzogJ3ZhbGp1dGEnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAndm4nOiB7XG4gICAgICAgICAgICAgICAgJ+KIhic6ICdkZWx0YScsXG4gICAgICAgICAgICAgICAgJ+KInic6ICd2byBjdWMnLFxuICAgICAgICAgICAgICAgICfimaUnOiAneWV1JyxcbiAgICAgICAgICAgICAgICAnJic6ICd2YScsXG4gICAgICAgICAgICAgICAgJ3wnOiAnaG9hYycsXG4gICAgICAgICAgICAgICAgJzwnOiAnbmhvIGhvbicsXG4gICAgICAgICAgICAgICAgJz4nOiAnbG9uIGhvbicsXG4gICAgICAgICAgICAgICAgJ+KIkSc6ICd0b25nJyxcbiAgICAgICAgICAgICAgICAnwqQnOiAndGllbiB0ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gb3B0cztcbiAgICAgICAgfVxuXG4gICAgICAgIHN5bWJvbCA9IHN5bWJvbE1hcC5lbjtcbiAgICAgICAgbGFuZ0NoYXIgPSBsYW5nQ2hhck1hcC5lbjtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIG1haW50YWluQ2FzZSA9IG9wdHMubWFpbnRhaW5DYXNlIHx8IGZhbHNlO1xuICAgICAgICAgICAgY3VzdG9tUmVwbGFjZW1lbnRzID0gKG9wdHMuY3VzdG9tICYmIHR5cGVvZiBvcHRzLmN1c3RvbSA9PT0gJ29iamVjdCcpID8gb3B0cy5jdXN0b20gOiBjdXN0b21SZXBsYWNlbWVudHM7XG4gICAgICAgICAgICB0cnVuY2F0ZSA9ICgrb3B0cy50cnVuY2F0ZSA+IDEgJiYgb3B0cy50cnVuY2F0ZSkgfHwgZmFsc2U7XG4gICAgICAgICAgICB1cmljRmxhZyA9IG9wdHMudXJpYyB8fCBmYWxzZTtcbiAgICAgICAgICAgIHVyaWNOb1NsYXNoRmxhZyA9IG9wdHMudXJpY05vU2xhc2ggfHwgZmFsc2U7XG4gICAgICAgICAgICBtYXJrRmxhZyA9IG9wdHMubWFyayB8fCBmYWxzZTtcbiAgICAgICAgICAgIGNvbnZlcnRTeW1ib2xzID0gKG9wdHMuc3ltYm9scyA9PT0gZmFsc2UgfHwgb3B0cy5sYW5nID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBvcHRzLnNlcGFyYXRvciB8fCBzZXBhcmF0b3I7XG5cbiAgICAgICAgICAgIGlmICh1cmljRmxhZykge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRDaGFycyArPSB1cmljQ2hhcnMuam9pbignJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1cmljTm9TbGFzaEZsYWcpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2hhcnMgKz0gdXJpY05vU2xhc2hDaGFycy5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hcmtGbGFnKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZENoYXJzICs9IG1hcmtDaGFycy5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3ltYm9sID0gKG9wdHMubGFuZyAmJiBzeW1ib2xNYXBbb3B0cy5sYW5nXSAmJiBjb252ZXJ0U3ltYm9scykgP1xuICAgICAgICAgICAgICAgIHN5bWJvbE1hcFtvcHRzLmxhbmddIDogKGNvbnZlcnRTeW1ib2xzID8gc3ltYm9sTWFwLmVuIDoge30pO1xuXG4gICAgICAgICAgICBsYW5nQ2hhciA9IChvcHRzLmxhbmcgJiYgbGFuZ0NoYXJNYXBbb3B0cy5sYW5nXSkgP1xuICAgICAgICAgICAgICAgIGxhbmdDaGFyTWFwW29wdHMubGFuZ10gOlxuICAgICAgICAgICAgICAgIG9wdHMubGFuZyA9PT0gZmFsc2UgfHwgb3B0cy5sYW5nID09PSB0cnVlID8ge30gOiBsYW5nQ2hhck1hcC5lbjtcblxuICAgICAgICAgICAgLy8gaWYgdGl0bGVDYXNlIGNvbmZpZyBpcyBhbiBBcnJheSwgcmV3cml0ZSB0byBvYmplY3QgZm9ybWF0XG4gICAgICAgICAgICBpZiAob3B0cy50aXRsZUNhc2UgJiYgdHlwZW9mIG9wdHMudGl0bGVDYXNlLmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBBcnJheS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRzLnRpdGxlQ2FzZSkpIHtcblxuICAgICAgICAgICAgICAgIG9wdHMudGl0bGVDYXNlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tUmVwbGFjZW1lbnRzW3YgKyBcIlwiXSA9IHYgKyBcIlwiO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGl0bGVDYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGl0bGVDYXNlID0gISFvcHRzLnRpdGxlQ2FzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgY3VzdG9tIGNvbmZpZyBpcyBhbiBBcnJheSwgcmV3cml0ZSB0byBvYmplY3QgZm9ybWF0XG4gICAgICAgICAgICBpZiAob3B0cy5jdXN0b20gJiYgdHlwZW9mIG9wdHMuY3VzdG9tLmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBBcnJheS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRzLmN1c3RvbSkpIHtcblxuICAgICAgICAgICAgICAgIG9wdHMuY3VzdG9tLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tUmVwbGFjZW1lbnRzW3YgKyBcIlwiXSA9IHYgKyBcIlwiO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjdXN0b20gcmVwbGFjZW1lbnRzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjdXN0b21SZXBsYWNlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblxuICAgICAgICAgICAgICAgIHZhciByO1xuXG4gICAgICAgICAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgZXNjYXBlQ2hhcnModikgKyAnXFxcXGInLCAnZ2knKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByID0gbmV3IFJlZ0V4cChlc2NhcGVDaGFycyh2KSwgJ2dpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKHIsIGN1c3RvbVJlcGxhY2VtZW50c1t2XSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYWRkIGFsbCBjdXN0b20gcmVwbGFjZW1lbnQgdG8gYWxsb3dlZCBjaGFybGlzdFxuICAgICAgICAgICAgZm9yIChjaCBpbiBjdXN0b21SZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkQ2hhcnMgKz0gY2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGFsbG93ZWRDaGFycyArPSBzZXBhcmF0b3I7XG5cbiAgICAgICAgLy8gZXNjYXBlIGFsbCBuZWNlc3NhcnkgY2hhcnNcbiAgICAgICAgYWxsb3dlZENoYXJzID0gZXNjYXBlQ2hhcnMoYWxsb3dlZENoYXJzKTtcblxuICAgICAgICAvLyB0cmltIHdoaXRlc3BhY2VzXG4gICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvKF5cXHMrfFxccyskKS9nLCAnJyk7XG5cbiAgICAgICAgbGFzdENoYXJXYXNTeW1ib2wgPSBmYWxzZTtcbiAgICAgICAgbGFzdENoYXJXYXNEaWF0cmljID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgICAgICBjaCA9IGlucHV0W2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNSZXBsYWNlZEN1c3RvbUNoYXIoY2gsIGN1c3RvbVJlcGxhY2VtZW50cykpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjb252ZXJ0IGEgYWxyZWFkeSBjb252ZXJ0ZWQgY2hhclxuICAgICAgICAgICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhbmdDaGFyW2NoXSkge1xuICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgbGFuZ3VhZ2Ugc3BlY2lmaWMgZGlhY3RyaWNzIGNoYXJzIGNvbnZlcnNpb25cbiAgICAgICAgICAgICAgICBjaCA9IGxhc3RDaGFyV2FzU3ltYm9sICYmIGxhbmdDaGFyW2NoXS5tYXRjaCgvW0EtWmEtejAtOV0vKSA/ICcgJyArIGxhbmdDaGFyW2NoXSA6IGxhbmdDaGFyW2NoXTtcblxuICAgICAgICAgICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoIGluIGNoYXJNYXApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgdHJhbnNsaXRlcmF0aW9uIGNoYW5nZXMgZW50aXJlbHkgd2hlbiBzb21lIHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgYWRkZWRcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBsICYmIGxvb2tBaGVhZENoYXJBcnJheS5pbmRleE9mKGlucHV0W2kgKyAxXSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaWF0cmljU3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBjaCA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdENoYXJXYXNEaWF0cmljID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gZGlhdHJpY01hcFtkaWF0cmljU3RyaW5nXSArIGNoYXJNYXBbY2hdO1xuICAgICAgICAgICAgICAgICAgICBkaWF0cmljU3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBkaWFjdHJpY3MgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBsYXN0Q2hhcldhc1N5bWJvbCAmJiBjaGFyTWFwW2NoXS5tYXRjaCgvW0EtWmEtejAtOV0vKSA/ICcgJyArIGNoYXJNYXBbY2hdIDogY2hhck1hcFtjaF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGFzdENoYXJXYXNTeW1ib2wgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc0RpYXRyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgaWYgKGNoIGluIGRpYXRyaWNNYXApIHtcbiAgICAgICAgICAgICAgICBkaWF0cmljU3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIGNoID0gJyc7XG4gICAgICAgICAgICAgICAgLy8gZW5kIG9mIHN0cmluZywgcHV0IHRoZSB3aG9sZSBtZWFuaW5nZnVsIHdvcmRcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBkaWF0cmljTWFwW2RpYXRyaWNTdHJpbmddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc0RpYXRyaWMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHN5bWJvbCBjaGFyc1xuICAgICAgICAgICAgICAgIHN5bWJvbFtjaF0gJiYgISh1cmljRmxhZyAmJiB1cmljQ2hhcnMuam9pbignJylcbiAgICAgICAgICAgICAgICAgICAgLmluZGV4T2YoY2gpICE9PSAtMSkgJiYgISh1cmljTm9TbGFzaEZsYWcgJiYgdXJpY05vU2xhc2hDaGFycy5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICAvLy5pbmRleE9mKGNoKSAhPT0gLTEpICYmICEobWFya0ZsYWcgJiYgbWFya0NoYXJzLmpvaW4oJycpXG4gICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKGNoKSAhPT0gLTEpKSB7XG5cbiAgICAgICAgICAgICAgICBjaCA9IGxhc3RDaGFyV2FzU3ltYm9sIHx8IHJlc3VsdC5zdWJzdHIoLTEpLm1hdGNoKC9bQS1aYS16MC05XS8pID8gc2VwYXJhdG9yICsgc3ltYm9sW2NoXSA6IHN5bWJvbFtjaF07XG4gICAgICAgICAgICAgICAgY2ggKz0gaW5wdXRbaSArIDFdICE9PSB2b2lkIDAgJiYgaW5wdXRbaSArIDFdLm1hdGNoKC9bQS1aYS16MC05XS8pID8gc2VwYXJhdG9yIDogJyc7XG5cbiAgICAgICAgICAgICAgICBsYXN0Q2hhcldhc1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hhcldhc0RpYXRyaWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBkaWF0cmljTWFwW2RpYXRyaWNTdHJpbmddICsgY2g7XG4gICAgICAgICAgICAgICAgICAgIGRpYXRyaWNTdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJXYXNEaWF0cmljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0Q2hhcldhc1N5bWJvbCAmJiAoL1tBLVphLXowLTldLy50ZXN0KGNoKSB8fCByZXN1bHQuc3Vic3RyKC0xKS5tYXRjaCgvQS1aYS16MC05XS8pKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGxhdGluIGNoYXJzXG4gICAgICAgICAgICAgICAgICAgIGNoID0gJyAnICsgY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBhbGxvd2VkIGNoYXJzXG4gICAgICAgICAgICByZXN1bHQgKz0gY2gucmVwbGFjZShuZXcgUmVnRXhwKCdbXlxcXFx3XFxcXHMnICsgYWxsb3dlZENoYXJzICsgJ18tXScsICdnJyksIHNlcGFyYXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGl0bGVDYXNlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvKFxcdykoXFxTKikvZywgZnVuY3Rpb24gKF8sIGksIHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IGkudG9VcHBlckNhc2UoKSArIChyICE9PSBudWxsID8gciA6IFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmtleXMoY3VzdG9tUmVwbGFjZW1lbnRzKS5pbmRleE9mKGoudG9Mb3dlckNhc2UoKSkgPCAwKSA/IGogOiBqLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsaW1pbmF0ZSBkdXBsaWNhdGUgc2VwYXJhdG9yc1xuICAgICAgICAvLyBhZGQgc2VwYXJhdG9yXG4gICAgICAgIC8vIHRyaW0gc2VwYXJhdG9ycyBmcm9tIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xccysvZywgc2VwYXJhdG9yKVxuICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXCcgKyBzZXBhcmF0b3IgKyAnKycsICdnJyksIHNlcGFyYXRvcilcbiAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJyheXFxcXCcgKyBzZXBhcmF0b3IgKyAnK3xcXFxcJyArIHNlcGFyYXRvciArICcrJCknLCAnZycpLCAnJyk7XG5cbiAgICAgICAgaWYgKHRydW5jYXRlICYmIHJlc3VsdC5sZW5ndGggPiB0cnVuY2F0ZSkge1xuXG4gICAgICAgICAgICBsdWNreSA9IHJlc3VsdC5jaGFyQXQodHJ1bmNhdGUpID09PSBzZXBhcmF0b3I7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgdHJ1bmNhdGUpO1xuXG4gICAgICAgICAgICBpZiAoIWx1Y2t5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWFpbnRhaW5DYXNlICYmICF0aXRsZUNhc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlU2x1ZyBjdXJyaWVkKG9wdHMpKGlucHV0KVxuICAgICAqIEBwYXJhbSAgIHtvYmplY3R8c3RyaW5nfSBvcHRzIGNvbmZpZyBvYmplY3Qgb3IgaW5wdXQgc3RyaW5nXG4gICAgICogQHJldHVybiAge0Z1bmN0aW9ufSBmdW5jdGlvbiBnZXRTbHVnV2l0aENvbmZpZygpXG4gICAgICoqL1xuICAgIHZhciBjcmVhdGVTbHVnID0gZnVuY3Rpb24gY3JlYXRlU2x1ZyhvcHRzKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldFNsdWdXaXRoQ29uZmlnXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9IGlucHV0IHN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJuICB7c3RyaW5nfSBzbHVnIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldFNsdWdXaXRoQ29uZmlnKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2x1ZyhpbnB1dCwgb3B0cyk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGVzY2FwZSBDaGFyc1xuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9IGlucHV0IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBlc2NhcGVDaGFycyA9IGZ1bmN0aW9uIGVzY2FwZUNoYXJzKGlucHV0KSB7XG5cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1stXFxcXF4kKis/LigpfFtcXF17fVxcL10vZywgJ1xcXFwkJicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiB0aGUgY2hhciBpcyBhbiBhbHJlYWR5IGNvbnZlcnRlZCBjaGFyIGZyb20gY3VzdG9tIGxpc3RcbiAgICAgKiBAcGFyYW0gICB7Y2hhcn0gY2ggY2hhcmFjdGVyIHRvIGNoZWNrXG4gICAgICogQHBhcmFtICAge29iamVjdH0gY3VzdG9tUmVwbGFjZW1lbnRzIGN1c3RvbSB0cmFuc2xhdGlvbiBtYXBcbiAgICAgKi9cbiAgICB2YXIgaXNSZXBsYWNlZEN1c3RvbUNoYXIgPSBmdW5jdGlvbiAoY2gsIGN1c3RvbVJlcGxhY2VtZW50cykge1xuXG4gICAgICAgIGZvciAodmFyIGMgaW4gY3VzdG9tUmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tUmVwbGFjZW1lbnRzW2NdID09PSBjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXG4gICAgICAgIC8vIGV4cG9ydCBmdW5jdGlvbnMgZm9yIHVzZSBpbiBOb2RlXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZ2V0U2x1ZztcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuY3JlYXRlU2x1ZyA9IGNyZWF0ZVNsdWc7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcblxuICAgICAgICAvLyBleHBvcnQgZnVuY3Rpb24gZm9yIHVzZSBpbiBBTURcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2x1ZztcbiAgICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGRvbid0IG92ZXJ3cml0ZSBnbG9iYWwgaWYgZXhpc3RzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm9vdC5nZXRTbHVnIHx8IHJvb3QuY3JlYXRlU2x1Zykge1xuICAgICAgICAgICAgICAgIHRocm93ICdzcGVha2luZ3VybDogZ2xvYmFscyBleGlzdHMgLyhnZXRTbHVnfGNyZWF0ZVNsdWcpLyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QuZ2V0U2x1ZyA9IGdldFNsdWc7XG4gICAgICAgICAgICAgICAgcm9vdC5jcmVhdGVTbHVnID0gY3JlYXRlU2x1ZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgIH1cbn0pKHRoaXMpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNCeXRlTGVuZ3RoO1xuXG52YXIgX2Fzc2VydFN0cmluZyA9IHJlcXVpcmUoJy4vdXRpbC9hc3NlcnRTdHJpbmcnKTtcblxudmFyIF9hc3NlcnRTdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzZXJ0U3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXG5mdW5jdGlvbiBpc0J5dGVMZW5ndGgoc3RyLCBvcHRpb25zKSB7XG4gICgwLCBfYXNzZXJ0U3RyaW5nMi5kZWZhdWx0KShzdHIpO1xuICB2YXIgbWluID0gdm9pZCAwO1xuICB2YXIgbWF4ID0gdm9pZCAwO1xuICBpZiAoKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRpb25zKSkgPT09ICdvYmplY3QnKSB7XG4gICAgbWluID0gb3B0aW9ucy5taW4gfHwgMDtcbiAgICBtYXggPSBvcHRpb25zLm1heDtcbiAgfSBlbHNlIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaXNCeXRlTGVuZ3RoKHN0ciwgbWluIFssIG1heF0pXG4gICAgbWluID0gYXJndW1lbnRzWzFdO1xuICAgIG1heCA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgbGVuID0gZW5jb2RlVVJJKHN0cikuc3BsaXQoLyUuLnwuLykubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGxlbiA+PSBtaW4gJiYgKHR5cGVvZiBtYXggPT09ICd1bmRlZmluZWQnIHx8IGxlbiA8PSBtYXgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFbWFpbDtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSByZXF1aXJlKCcuL3V0aWwvYXNzZXJ0U3RyaW5nJyk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydFN0cmluZyk7XG5cbnZhciBfbWVyZ2UgPSByZXF1aXJlKCcuL3V0aWwvbWVyZ2UnKTtcblxudmFyIF9tZXJnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXJnZSk7XG5cbnZhciBfaXNCeXRlTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0J5dGVMZW5ndGgnKTtcblxudmFyIF9pc0J5dGVMZW5ndGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNCeXRlTGVuZ3RoKTtcblxudmFyIF9pc0ZRRE4gPSByZXF1aXJlKCcuL2lzRlFETicpO1xuXG52YXIgX2lzRlFETjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0ZRRE4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdF9lbWFpbF9vcHRpb25zID0ge1xuICBhbGxvd19kaXNwbGF5X25hbWU6IGZhbHNlLFxuICBhbGxvd191dGY4X2xvY2FsX3BhcnQ6IHRydWUsXG4gIHJlcXVpcmVfdGxkOiB0cnVlXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG52YXIgZGlzcGxheU5hbWUgPSAvXlthLXpcXGQhI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9flxcLlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFwuXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXFxzXSo8KC4rKT4kL2k7XG52YXIgZW1haWxVc2VyUGFydCA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XSskL2k7XG52YXIgcXVvdGVkRW1haWxVc2VyID0gL14oW1xcc1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2VdfChcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXSkpKiQvaTtcbnZhciBlbWFpbFVzZXJVdGY4UGFydCA9IC9eW2EtelxcZCEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSskL2k7XG52YXIgcXVvdGVkRW1haWxVc2VyVXRmOCA9IC9eKFtcXHNcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdlXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXXwoXFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3ZlxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSokL2k7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbi8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5mdW5jdGlvbiBpc0VtYWlsKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZW1haWxfb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMuYWxsb3dfZGlzcGxheV9uYW1lKSB7XG4gICAgdmFyIGRpc3BsYXlfZW1haWwgPSBzdHIubWF0Y2goZGlzcGxheU5hbWUpO1xuICAgIGlmIChkaXNwbGF5X2VtYWlsKSB7XG4gICAgICBzdHIgPSBkaXNwbGF5X2VtYWlsWzFdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnQCcpO1xuICB2YXIgZG9tYWluID0gcGFydHMucG9wKCk7XG4gIHZhciB1c2VyID0gcGFydHMuam9pbignQCcpO1xuXG4gIHZhciBsb3dlcl9kb21haW4gPSBkb21haW4udG9Mb3dlckNhc2UoKTtcbiAgaWYgKGxvd2VyX2RvbWFpbiA9PT0gJ2dtYWlsLmNvbScgfHwgbG93ZXJfZG9tYWluID09PSAnZ29vZ2xlbWFpbC5jb20nKSB7XG4gICAgdXNlciA9IHVzZXIucmVwbGFjZSgvXFwuL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzQnl0ZUxlbmd0aDIuZGVmYXVsdCkodXNlciwgeyBtYXg6IDY0IH0pIHx8ICEoMCwgX2lzQnl0ZUxlbmd0aDIuZGVmYXVsdCkoZG9tYWluLCB7IG1heDogMjU2IH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzRlFETjIuZGVmYXVsdCkoZG9tYWluLCB7IHJlcXVpcmVfdGxkOiBvcHRpb25zLnJlcXVpcmVfdGxkIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHVzZXJbMF0gPT09ICdcIicpIHtcbiAgICB1c2VyID0gdXNlci5zbGljZSgxLCB1c2VyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IHF1b3RlZEVtYWlsVXNlclV0ZjgudGVzdCh1c2VyKSA6IHF1b3RlZEVtYWlsVXNlci50ZXN0KHVzZXIpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm4gPSBvcHRpb25zLmFsbG93X3V0ZjhfbG9jYWxfcGFydCA/IGVtYWlsVXNlclV0ZjhQYXJ0IDogZW1haWxVc2VyUGFydDtcblxuICB2YXIgdXNlcl9wYXJ0cyA9IHVzZXIuc3BsaXQoJy4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1c2VyX3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwYXR0ZXJuLnRlc3QodXNlcl9wYXJ0c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRkRRTjtcblxudmFyIF9hc3NlcnRTdHJpbmcgPSByZXF1aXJlKCcuL3V0aWwvYXNzZXJ0U3RyaW5nJyk7XG5cbnZhciBfYXNzZXJ0U3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydFN0cmluZyk7XG5cbnZhciBfbWVyZ2UgPSByZXF1aXJlKCcuL3V0aWwvbWVyZ2UnKTtcblxudmFyIF9tZXJnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXJnZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0X2ZxZG5fb3B0aW9ucyA9IHtcbiAgcmVxdWlyZV90bGQ6IHRydWUsXG4gIGFsbG93X3VuZGVyc2NvcmVzOiBmYWxzZSxcbiAgYWxsb3dfdHJhaWxpbmdfZG90OiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNGRFFOKHN0ciwgb3B0aW9ucykge1xuICAoMCwgX2Fzc2VydFN0cmluZzIuZGVmYXVsdCkoc3RyKTtcbiAgb3B0aW9ucyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKG9wdGlvbnMsIGRlZmF1bHRfZnFkbl9vcHRpb25zKTtcblxuICAvKiBSZW1vdmUgdGhlIG9wdGlvbmFsIHRyYWlsaW5nIGRvdCBiZWZvcmUgY2hlY2tpbmcgdmFsaWRpdHkgKi9cbiAgaWYgKG9wdGlvbnMuYWxsb3dfdHJhaWxpbmdfZG90ICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcuJykge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICB9XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLicpO1xuICBpZiAob3B0aW9ucy5yZXF1aXJlX3RsZCkge1xuICAgIHZhciB0bGQgPSBwYXJ0cy5wb3AoKTtcbiAgICBpZiAoIXBhcnRzLmxlbmd0aCB8fCAhL14oW2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9fHhuW2EtejAtOS1dezIsfSkkL2kudGVzdCh0bGQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIHBhcnQsIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dfdW5kZXJzY29yZXMpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL18vZywgJycpO1xuICAgIH1cbiAgICBpZiAoIS9eW2EtelxcdTAwYTEtXFx1ZmZmZjAtOS1dKyQvaS50ZXN0KHBhcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgvW1xcdWZmMDEtXFx1ZmY1ZV0vLnRlc3QocGFydCkpIHtcbiAgICAgIC8vIGRpc2FsbG93IGZ1bGwtd2lkdGggY2hhcnNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcnRbMF0gPT09ICctJyB8fCBwYXJ0W3BhcnQubGVuZ3RoIC0gMV0gPT09ICctJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydFN0cmluZztcbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgbGlicmFyeSAodmFsaWRhdG9yLmpzKSB2YWxpZGF0ZXMgc3RyaW5ncyBvbmx5Jyk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1lcmdlO1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGRlZmF1bHRzID0gYXJndW1lbnRzWzFdO1xuXG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmpba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCdcblxudmFyIGdldFNsdWcgPSByZXF1aXJlKCdzcGVha2luZ3VybCcpXG5cbi8vIHRha2UgY2FyZSBvZiBzbHVnZ2luZyBldmVyeXRoaW5nIEJVVCB0aGUgZmlsZSBleHRlbnNpb25cbi8vIGtlZXBpbmcgdGhpcyBmaWxlIGFzIG1pbmltYWwgYXMgcG9zc2libGUgLT4gdXNlZCBpbiBmcm9udC1lbmTigKZcbmZ1bmN0aW9uIHNsdWdGaWxlbmFtZShuYW1lKSB7XG4gIHZhciBmaWxlTmFtZSAgPSBuYW1lXG4gIHZhciBleHQgICAgICAgPSAvXFwuWzAtOWEtel0rJC8uZXhlYyhuYW1lKVswXVxuICBmaWxlTmFtZSAgICAgID0gZmlsZU5hbWUucmVwbGFjZShleHQsICcnKVxuICBmaWxlTmFtZSAgICAgID0gZ2V0U2x1ZyhmaWxlTmFtZSkgKyBleHRcbiAgcmV0dXJuIGZpbGVOYW1lXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2x1Z0ZpbGVuYW1lXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlICovXG4vKiBnbG9iYWwgWE1MSHR0cFJlcXVlc3Q6IGZhbHNlICovXG5cbnZhciB1cmwgICAgID0gcmVxdWlyZSgndXJsJyk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG5cbnZhciB0ZW1wbGF0ZUxvYWRlciA9IHJlcXVpcmUoJy4vdGVtcGxhdGUtbG9hZGVyLmpzJyk7XG5cbnJlcXVpcmUoXCIuL2tvLWJpbmRpbmdzLmpzXCIpO1xudmFyIHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIgPSByZXF1aXJlKFwiLi90aW1lZC1jYWxsLmpzXCIpLnRpbWVkQ2FsbDtcblxudmFyIGFkZFVuZG9TdGFja0V4dGVuc2lvbk1ha2VyID0gcmVxdWlyZShcIi4vdW5kb21hbmFnZXIvdW5kb21haW4uanNcIik7XG52YXIgY29sb3JQbHVnaW4gPSByZXF1aXJlKFwiLi9leHQvY29sb3IuanNcIik7XG52YXIgaW5saW5lclBsdWdpbiA9IHJlcXVpcmUoXCIuL2V4dC9pbmxpbmVyLmpzXCIpO1xuXG52YXIgbG9jYWxTdG9yYWdlTG9hZGVyID0gcmVxdWlyZShcIi4vZXh0L2xvY2Fsc3RvcmFnZS5qc1wiKTtcblxuaWYgKHR5cGVvZiBrbyA9PSAndW5kZWZpbmVkJykgdGhyb3cgXCJDYW5ub3QgZmluZCBrbm9ja291dC5qcyBsaWJyYXJ5IVwiO1xuaWYgKHR5cGVvZiAkID09ICd1bmRlZmluZWQnKSB0aHJvdyBcIkNhbm5vdCBmaW5kIGpxdWVyeSBsaWJyYXJ5IVwiO1xuXG5pZiAoZmFsc2UpIHtcblxuZnVuY3Rpb24gX2Nhbm9uaWNhbGl6ZSh1cmwpIHtcbiAgdmFyIGRpdiA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IFwiPGE+PC9hPlwiO1xuICBkaXYuZmlyc3RDaGlsZC5ocmVmID0gdXJsOyAvLyBFbnN1cmVzIHRoYXQgdGhlIGhyZWYgaXMgcHJvcGVybHkgZXNjYXBlZFxuICBkaXYuaW5uZXJIVE1MID0gZGl2LmlubmVySFRNTDsgLy8gUnVuIHRoZSBjdXJyZW50IGlubmVySFRNTCBiYWNrIHRocm91Z2ggdGhlIHBhcnNlclxuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQuaHJlZjtcbn1cblxudmFyIGFwcGx5QmluZGluZ09wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCBrbykge1xuICAvLyBwdXNoIFwiY29udmVydGVkVXJsXCIgbWV0aG9kIHRvIHRoZSB3eXNpd3lnU3JjIGJpbmRpbmdcbiAga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMuY29udmVydGVkVXJsID0gZnVuY3Rpb24oc3JjLCBtZXRob2QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaW1nUHJvY2Vzc29yQmFja2VuZCA9IG9wdGlvbnMuaW1nUHJvY2Vzc29yQmFja2VuZCA/IG9wdGlvbnMuaW1nUHJvY2Vzc29yQmFja2VuZCA6ICcuL3VwbG9hZCc7XG4gICAgdmFyIGJhY2tFbmRNYXRjaCA9IGltZ1Byb2Nlc3NvckJhY2tlbmQubWF0Y2goL14oaHR0cHM/OlxcL1xcL1teXFwvXSpcXC8pLiokLyk7XG4gICAgdmFyIHNyY01hdGNoID0gc3JjLm1hdGNoKC9eKGh0dHBzPzpcXC9cXC9bXlxcL10qXFwvKS4qJC8pO1xuICAgIGlmIChiYWNrRW5kTWF0Y2ggPT09IG51bGwgfHwgKHNyY01hdGNoICE9PSBudWxsICYmIGJhY2tFbmRNYXRjaFsxXSA9PSBzcmNNYXRjaFsxXSkpIHtcbiAgICAgIHJldHVybiBpbWdQcm9jZXNzb3JCYWNrZW5kICsgXCI/c3JjPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNyYykgKyBcIiZtZXRob2Q9XCIgKyBlbmNvZGVVUklDb21wb25lbnQobWV0aG9kKSArIFwiJnBhcmFtcz1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh3aWR0aCArIFwiLFwiICsgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJDYW5ub3QgYXBwbHkgYmFja2VuZCBpbWFnZSByZXNpemluZyB0byBub24tbG9jYWwgcmVzb3VyY2VzIFwiLCBzcmMsIG1ldGhvZCwgd2lkdGgsIGhlaWdodCwgYmFja0VuZE1hdGNoLCBzcmNNYXRjaCk7XG4gICAgICByZXR1cm4gc3JjICsgXCI/bWV0aG9kPVwiICsgbWV0aG9kICsgXCImd2lkdGg9XCIgKyB3aWR0aCArIChoZWlnaHQgIT09IG51bGwgPyBcIiZoZWlnaHQ9XCIgKyBoZWlnaHQgOiAnJyk7XG4gICAgfVxuICB9O1xuXG4gIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLnBsYWNlaG9sZGVyVXJsID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdGV4dCkge1xuICAgIHJldHVybiBvcHRpb25zLmltZ1Byb2Nlc3NvckJhY2tlbmQgKyBcIj9tZXRob2Q9XCIgKyAncGxhY2Vob2xkZXInICsgXCImcGFyYW1zPVwiICsgd2lkdGggKyBlbmNvZGVVUklDb21wb25lbnQoXCIsXCIpICsgaGVpZ2h0O1xuICB9O1xuXG4gIC8vIHB1c2hlcyBjdXN0b20gdGlueW1jZSBjb25maWd1cmF0aW9ucyBmcm9tIG9wdGlvbnMgdG8gdGhlIGJpbmRpbmdcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW55bWNlQ29uZmlnKVxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLnN0YW5kYXJkT3B0aW9ucyA9IG9wdGlvbnMudGlueW1jZUNvbmZpZztcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW55bWNlQ29uZmlnRnVsbClcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5mdWxsT3B0aW9ucyA9IG9wdGlvbnMudGlueW1jZUNvbmZpZ0Z1bGw7XG59O1xuXG59XG5cbnZhciBzdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRlbXBsYXRlRmlsZSwgdGVtcGxhdGVNZXRhZGF0YSwganNvcmpzb24sIGN1c3RvbUV4dGVuc2lvbnMpIHtcblxuICB0ZW1wbGF0ZUxvYWRlci5maXhQYWdlRXZlbnRzKCk7XG5cbiAgdmFyIGZpbGVVcGxvYWRNZXNzYWdlc0V4dGVuc2lvbiA9IGZ1bmN0aW9uKHZtKSB7XG4gICAgdmFyIGZpbGV1cGxvYWRDb25maWcgPSB7XG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICB1bmtub3duRXJyb3I6IHZtLnQoJ1Vua25vd24gZXJyb3InKSxcbiAgICAgICAgdXBsb2FkZWRCeXRlczogdm0udCgnVXBsb2FkZWQgYnl0ZXMgZXhjZWVkIGZpbGUgc2l6ZScpLFxuICAgICAgICBtYXhOdW1iZXJPZkZpbGVzOiB2bS50KCdNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZCcpLFxuICAgICAgICBhY2NlcHRGaWxlVHlwZXM6IHZtLnQoJ0ZpbGUgdHlwZSBub3QgYWxsb3dlZCcpLFxuICAgICAgICBtYXhGaWxlU2l6ZTogdm0udCgnRmlsZSBpcyB0b28gbGFyZ2UnKSxcbiAgICAgICAgbWluRmlsZVNpemU6IHZtLnQoJ0ZpbGUgaXMgdG9vIHNtYWxsJyksXG4gICAgICAgIHBvc3RfbWF4X3NpemU6IHZtLnQoJ1RoZSB1cGxvYWRlZCBmaWxlIGV4Y2VlZHMgdGhlIHBvc3RfbWF4X3NpemUgZGlyZWN0aXZlIGluIHBocC5pbmknKSxcbiAgICAgICAgbWF4X2ZpbGVfc2l6ZTogdm0udCgnRmlsZSBpcyB0b28gYmlnJyksXG4gICAgICAgIG1pbl9maWxlX3NpemU6IHZtLnQoJ0ZpbGUgaXMgdG9vIHNtYWxsJyksXG4gICAgICAgIGFjY2VwdF9maWxlX3R5cGVzOiB2bS50KCdGaWxldHlwZSBub3QgYWxsb3dlZCcpLFxuICAgICAgICBtYXhfbnVtYmVyX29mX2ZpbGVzOiB2bS50KCdNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZCcpLFxuICAgICAgICBtYXhfd2lkdGg6IHZtLnQoJ0ltYWdlIGV4Y2VlZHMgbWF4aW11bSB3aWR0aCcpLFxuICAgICAgICBtaW5fd2lkdGg6IHZtLnQoJ0ltYWdlIHJlcXVpcmVzIGEgbWluaW11bSB3aWR0aCcpLFxuICAgICAgICBtYXhfaGVpZ2h0OiB2bS50KCdJbWFnZSBleGNlZWRzIG1heGltdW0gaGVpZ2h0JyksXG4gICAgICAgIG1pbl9oZWlnaHQ6IHZtLnQoJ0ltYWdlIHJlcXVpcmVzIGEgbWluaW11bSBoZWlnaHQnKSxcbiAgICAgICAgYWJvcnQ6IHZtLnQoJ0ZpbGUgdXBsb2FkIGFib3J0ZWQnKSxcbiAgICAgICAgaW1hZ2VfcmVzaXplOiB2bS50KCdGYWlsZWQgdG8gcmVzaXplIGltYWdlJyksXG4gICAgICAgIGdlbmVyaWM6IHZtLnQoJ1VuZXhwZWN0ZWQgdXBsb2FkIGVycm9yJylcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIGZpbGVVcGxvYWQgb3B0aW9ucy5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbGV1cGxvYWRDb25maWcpXG4gICAgICBmaWxldXBsb2FkQ29uZmlnID0gJC5leHRlbmQodHJ1ZSwgZmlsZXVwbG9hZENvbmZpZywgb3B0aW9ucy5maWxldXBsb2FkQ29uZmlnKTtcblxuICAgIGtvLmJpbmRpbmdIYW5kbGVyc1snZmlsZXVwbG9hZCddLmV4dGVuZE9wdGlvbnMgPSBmaWxldXBsb2FkQ29uZmlnO1xuXG4gIH07XG5cbiAgdmFyIHNpbXBsZVRyYW5zbGF0aW9uUGx1Z2luID0gZnVuY3Rpb24odm0pIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0cmluZ3MpIHtcbiAgICAgIHZtLnQgPSBmdW5jdGlvbihrZXksIG9ialBhcmFtKSB7XG4gICAgICAgIHZhciByZXMgPSBvcHRpb25zLnN0cmluZ3Nba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJNaXNzaW5nIHRyYW5zbGF0aW9uIHN0cmluZyBmb3JcIixrZXksXCI6IHVzaW5nIGRlZmF1bHQgc3RyaW5nXCIpO1xuICAgICAgICAgIHJlcyA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm0udHQocmVzLCBvYmpQYXJhbSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBzaW1wbGVUcmFuc2xhdGlvblBsdWdpbiBtdXN0IGJlIGJlZm9yZSB0aGUgdW5kb1N0YWNrIHRvIHRyYW5zbGF0ZSB1bmRvL3JlZG8gbGFiZWxzXG4gIHZhciBleHRlbnNpb25zID0gW3NpbXBsZVRyYW5zbGF0aW9uUGx1Z2luLCBhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlcihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKSwgY29sb3JQbHVnaW4sIGlubGluZXJQbHVnaW5dO1xuICBpZiAodHlwZW9mIGN1c3RvbUV4dGVuc2lvbnMgIT09ICd1bmRlZmluZWQnKVxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY3VzdG9tRXh0ZW5zaW9ucy5sZW5ndGg7IGsrKykgZXh0ZW5zaW9ucy5wdXNoKGN1c3RvbUV4dGVuc2lvbnNba10pO1xuICBleHRlbnNpb25zLnB1c2goZmlsZVVwbG9hZE1lc3NhZ2VzRXh0ZW5zaW9uKTtcblxuICB2YXIgZ2FsbGVyeVVybCA9IG9wdGlvbnMuZmlsZXVwbG9hZENvbmZpZyA/IG9wdGlvbnMuZmlsZXVwbG9hZENvbmZpZy51cmwgOiAnL3VwbG9hZC8nO1xuICBhcHBseUJpbmRpbmdPcHRpb25zKG9wdGlvbnMsIGtvKTtcblxuICAvLyBUT0RPIHdoYXQgYWJvdXQgYXBwZW5kaW5nIHRvIGFub3RoZXIgZWxlbWVudD9cbiAgJChcIjwhLS0ga28gdGVtcGxhdGU6ICdtYWluJyAtLT48IS0tIC9rbyAtLT5cIikuYXBwZW5kVG8oZ2xvYmFsLmRvY3VtZW50LmJvZHkpO1xuXG4gIC8vIHRlbXBsYXRlRmlsZSBtYXkgb3ZlcnJpZGUgdGhlIHRlbXBsYXRlIHBhdGggaW4gdGVtcGxhdGVNZXRhZGF0YVxuICBpZiAodHlwZW9mIHRlbXBsYXRlRmlsZSA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGVtcGxhdGVNZXRhZGF0YSAhPSAndW5kZWZpbmVkJykge1xuICAgIHRlbXBsYXRlRmlsZSA9IHRlbXBsYXRlTWV0YWRhdGEudGVtcGxhdGU7XG4gIH1cbiAgLy8gVE9ETyBjYW5vbmljYWxpemUgdGVtcGxhdGVGaWxlIHRvIGFic29sdXRlIG9yIHJlbGF0aXZlIGRlcGVuZGluZyBvbiBcInJlbGF0aXZlVXJsc0V4Y2VwdGlvblwiIHBsdWdpblxuXG4gIHRlbXBsYXRlTG9hZGVyLmxvYWQocGVyZm9ybWFuY2VBd2FyZUNhbGxlciwgdGVtcGxhdGVGaWxlLCB0ZW1wbGF0ZU1ldGFkYXRhLCBqc29yanNvbiwgZXh0ZW5zaW9ucywgZ2FsbGVyeVVybCk7XG5cbn07XG5cbmlmIChmYWxzZSkge1xuXG52YXIgaW5pdEZyb21Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbihvcHRpb25zLCBoYXNoX2tleSwgY3VzdG9tRXh0ZW5zaW9ucykge1xuICB0cnkge1xuICAgIHZhciBsc0RhdGEgPSBsb2NhbFN0b3JhZ2VMb2FkZXIoaGFzaF9rZXksIG9wdGlvbnMuZW1haWxQcm9jZXNzb3JCYWNrZW5kKTtcbiAgICB2YXIgZXh0ZW5zaW9ucyA9IHR5cGVvZiBjdXN0b21FeHRlbnNpb25zICE9PSAndW5kZWZpbmVkJyA/IGN1c3RvbUV4dGVuc2lvbnMgOiBbXTtcbiAgICBleHRlbnNpb25zLnB1c2gobHNEYXRhLmV4dGVuc2lvbik7XG4gICAgdmFyIHRlbXBsYXRlID0gX2Nhbm9uaWNhbGl6ZShsc0RhdGEubWV0YWRhdGEudGVtcGxhdGUpO1xuICAgIHN0YXJ0KG9wdGlvbnMsIHRlbXBsYXRlLCBsc0RhdGEubWV0YWRhdGEsIGxzRGF0YS5tb2RlbCwgZXh0ZW5zaW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVE9ETyBub3QgZm91bmQgXCIsIGhhc2hfa2V5LCBlKTtcbiAgfVxufTtcblxudmFyIGluaXQgPSBmdW5jdGlvbihvcHRpb25zLCBjdXN0b21FeHRlbnNpb25zKSB7XG5cbiAgdmFyIGhhc2ggPSBnbG9iYWwubG9jYXRpb24uaGFzaCA/IGdsb2JhbC5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiI1wiKVsxXSA6IHVuZGVmaW5lZDtcblxuICAvLyBMb2FkaW5nIGZyb20gY29uZmlndXJlZCB0ZW1wbGF0ZSBvciBjb25maWd1cmVkIG1ldGFkYXRhXG4gIGlmIChvcHRpb25zICYmIChvcHRpb25zLnRlbXBsYXRlIHx8IG9wdGlvbnMuZGF0YSkpIHtcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2Uob3B0aW9ucy5kYXRhKTtcbiAgICAgIHN0YXJ0KG9wdGlvbnMsIHVuZGVmaW5lZCwgZGF0YS5tZXRhZGF0YSwgZGF0YS5jb250ZW50LCBjdXN0b21FeHRlbnNpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQob3B0aW9ucywgb3B0aW9ucy50ZW1wbGF0ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGN1c3RvbUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvLyBMb2FkaW5nIGZyb20gTG9jYWxTdG9yYWdlIChpZiB1cmwgaGFzaCBoYXMgYSA3Y2hhcnMga2V5KVxuICB9IGVsc2UgaWYgKGhhc2ggJiYgaGFzaC5sZW5ndGggPT0gNykge1xuICAgIGluaXRGcm9tTG9jYWxTdG9yYWdlKG9wdGlvbnMsIGhhc2gsIGN1c3RvbUV4dGVuc2lvbnMpO1xuICAgIC8vIExvYWRpbmcgZnJvbSB0ZW1wbGF0ZSB1cmwgYXMgaGFzaCAoaWYgaGFzaCBpcyBub3QgYSB2YWxpZCBsb2NhbHN0b3JhZ2Uga2V5KVxuICB9IGVsc2UgaWYgKGhhc2gpIHtcbiAgICBzdGFydChvcHRpb25zLCBfY2Fub25pY2FsaXplKGhhc2gpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY3VzdG9tRXh0ZW5zaW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxufVxuXG5pZiAodHJ1ZSkge1xuXG4vLy8vLy9cbi8vIEJBRFNFTkRFUiBTUEVDSUZJQ1xuLy8vLy8vXG5cbi8vIGRvbid0IHJlcGxhY2UgbW9zYWljbyBjb2RlIGZvciBiZXR0ZXIgbWVyZ2luZ1xuXG4vLyBLZWVwIGFuIGVtcHR5IGZ1bmN0aW9uIGZvciBub3QgYnJlYWtpbmcgc3RhcnQgZnVuY3Rpb25cbi8vIEV2ZW50IGlzIGFwcGx5QmluZGluZ09wdGlvbnMgY2FuIGJlIHN1cmNoYXJnZWQsXG4vLyBpdCdzIGJldHRlciB0byByZW1vdmUgdGhpcyBub3QgbmVjZXNzYXJ5IHBpZWNlIG9mIGNvZGVcbnZhciBhcHBseUJpbmRpbmdPcHRpb25zID0gJC5ub29wXG5cbi8vIEZMT1c6XG4vLyA9PiBpbml0XG4vLyA9PiBzdGFydFxuLy8gaW4gLi90ZW1wbGF0ZS1sb2FkZXIuanNcbi8vID0+IHRlbXBsYXRlTG9hZGVyOiBBamF4IGRhdGFzXG4vLyA9PiB0ZW1wbGF0ZUNvbXBpbGVyOlxuLy8gICAgLT4gSW5pdGlhbGl6ZSB2aWV3bW9kZWwgKC4vdmlld21vZGVsLmpzKVxuLy8gICAgLT4gQWRkIHNlcnZlciBkYXRhc1xuLy8gICAgLT4gYXBwbHkgcGx1Z2lucyAoc2VydmVyLXN0b3JhZ2UsIHNldEVkaXRvckljb24gKyBtb3NhaWNvIGRlZmluZWQpXG5cbnZhciBiYWRzZW5kZXJFeHQgPSByZXF1aXJlKCcuL2V4dC9iYWRzZW5kZXItZXh0ZW5zaW9ucycpXG5cbnZhciBpbml0ID0gZnVuY3Rpb24ob3B0cywgY3VzdG9tRXh0ZW5zaW9ucykge1xuICBjb25zb2xlLmluZm8oJ0JBRFNFTkRFUiDigJMgaW5pdCcpXG4gIGNvbnNvbGUubG9nKG9wdHMpXG4gIHZhciBoYXNEYXRhcyA9IG9wdHMgJiYgb3B0cy5tZXRhZGF0YSAmJiBvcHRzLmRhdGFcbiAgLy8gZWRpdG9yLmphZGUgc2NyaXB0IG5lZWQgYSByZXR1cm4gdmFsdWVcbiAgaWYgKCFoYXNEYXRhcykgcmV0dXJuIGZhbHNlO1xuXG4gIGJhZHNlbmRlckV4dC5leHRlbmRWaWV3TW9kZWwob3B0cywgY3VzdG9tRXh0ZW5zaW9ucylcbiAgYmFkc2VuZGVyRXh0LmV4dGVuZEtub2Nrb3V0KG9wdHMpXG5cbiAgc3RhcnQob3B0cywgdm9pZCgwKSwgb3B0cy5tZXRhZGF0YSwgb3B0cy5kYXRhLCBjdXN0b21FeHRlbnNpb25zKVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0NvbXBhdGlibGU6IHRlbXBsYXRlTG9hZGVyLmlzQ29tcGF0aWJsZSxcbiAgaW5pdDogaW5pdCxcbiAgc3RhcnQ6IHN0YXJ0XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuLy8gQHNlZSBhbHNvIHNjcmlwdC10ZW1wbGF0ZS5qcyBwdXNoVGVtcGxhdGVcbnZhciBhZGRTY3JpcHRUZW1wbGF0ZSA9IGZ1bmN0aW9uKGRvYywgdGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZU1hcmt1cCkge1xuICB2YXIgc2NyaXB0VGFnID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHRUYWcuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvaHRtbCcpO1xuICBzY3JpcHRUYWcuc2V0QXR0cmlidXRlKCdpZCcsIHRlbXBsYXRlTmFtZSk7XG4gIHNjcmlwdFRhZy50ZXh0ID0gdGVtcGxhdGVNYXJrdXA7XG4gIGRvYy5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG4gIHJldHVybiBzY3JpcHRUYWc7XG4gIC8vICQoJzxzY3JpcHQgdHlwZT1cInRleHQvaHRtbFwiPjwvc2MnICsgJ3JpcHQ+JykudGV4dCh0ZW1wbGF0ZU1hcmt1cCkuYXR0cignaWQnLCB0ZW1wbGF0ZU5hbWUpLmFwcGVuZFRvKCQoJ2JvZHknKSk7XG59O1xuXG4vLyB1c2VkIGZvciBsaXZlIHByZXZpZXcgaW4gaWZyYW1lLlxua28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUgPSB7XG4gIC8vIHRwbCB3aWxsIGJlIG92ZXJyaWRlbiB3aXRoIHRoZSBzdHJ1Y3R1cmUgcGFyc2VkIGJ5IHRoZSBpbnB1dCB0ZW1wbGF0ZS5cbiAgdHBsOiBcIjwhRE9DVFlQRSBodG1sPlxcclxcbjxodG1sPlxcclxcbjxoZWFkPlxcclxcbjwvaGVhZD5cXHJcXG48Ym9keT48ZGl2IGRhdGEtYmluZD1cXFwiYmxvY2s6IGNvbnRlbnRcXFwiPjwvZGl2PjwvYm9keT5cXHJcXG48L2h0bWw+XFxyXFxuXCIsXG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBiaW5kSWZyYW1lKGxvY2FsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaWZyYW1lID0gZWxlbWVudC5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGlmcmFtZS5vcGVuKCk7XG4gICAgICAgIGlmcmFtZS53cml0ZShrby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZS50cGwpO1xuICAgICAgICBpZnJhbWUuY2xvc2UoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpZnJhbWVkb2MgPSBpZnJhbWUuYm9keTtcbiAgICAgICAgICBpZiAoaWZyYW1lZG9jKSB7XG4gICAgICAgICAgICAvLyBzY3JpcHRzIGhhdmUgdG8gYmUgZHVwbGljYXRlZCAobWF5YmUgdGhpcyBpcyBub3QgbmVlZGVkIGFueW1vcmUgc2luY2UgdXNpbmcgc3RyaW5nLXRlbXBsYXRlcylcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZXMgPSBlbGVtZW50LmNvbnRlbnRXaW5kb3cucGFyZW50LmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZXNbaV0uZ2V0QXR0cmlidXRlKCd0eXBlJykgPT0gJ3RleHQvaHRtbCcgJiYgdGVtcGxhdGVzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICAgICAgICAgIGFkZFNjcmlwdFRlbXBsYXRlKGlmcmFtZSwgdGVtcGxhdGVzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSwgdGVtcGxhdGVzW2ldLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGh0bWwgPSBpZnJhbWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJIVE1MXCIpO1xuXG4gICAgICAgICAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBrby5jbGVhbk5vZGUoaHRtbFswXSB8fCBpZnJhbWVkb2MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGtvLmFwcGx5QmluZGluZ3ModmFsdWVBY2Nlc3NvcigpLCBodG1sWzBdIHx8IGlmcmFtZWRvYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm8gaWZyYW1lZG9jXCIsIGxvY2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yIHJlYWRpbmcgaWZyYW1lLmJvZHlcIiwgZSwgbG9jYWwpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciByZWFkaW5nIGlmcmFtZSBjb250ZW50RG9jdW1lbnRcIiwgZSwgbG9jYWwpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgICAvLyBpZ25vcmVkXG4gICAgICB9XG4gICAgfVxuICAgIGJpbmRJZnJhbWUoXCJmaXJzdCBjYWxsXCIpO1xuICAgIC8vIG9sZGVyIGJyb3dzZXJzIG5lZWRlZCB0aGlzXG4gICAgLy8ga28udXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXIoZWxlbWVudCwgJ2xvYWQnLCBiaW5kSWZyYW1lKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgZ2xvYmFsOmZhbHNlICovXG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3dpdGhQcm9wZXJ0aWVzJ10gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgLy8gTWFrZSBhIG1vZGlmaWVkIGJpbmRpbmcgY29udGV4dCwgd2l0aCBhIGV4dHJhIHByb3BlcnRpZXMsIGFuZCBhcHBseSBpdCB0byBkZXNjZW5kYW50IGVsZW1lbnRzXG4gICAgdmFyIGNoaWxkQmluZGluZ0NvbnRleHQgPSBiaW5kaW5nQ29udGV4dC5jcmVhdGVDaGlsZENvbnRleHQoXG4gICAgICBiaW5kaW5nQ29udGV4dC4kcmF3RGF0YSxcbiAgICAgIG51bGwsIC8vIE9wdGlvbmFsbHksIHBhc3MgYSBzdHJpbmcgaGVyZSBhcyBhbiBhbGlhcyBmb3IgdGhlIGRhdGEgaXRlbSBpbiBkZXNjZW5kYW50IGNvbnRleHRzXG4gICAgICBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgIGtvLnV0aWxzLmV4dGVuZChjb250ZXh0LCB2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgfVxuICAgICk7XG4gICAga28uYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHMoY2hpbGRCaW5kaW5nQ29udGV4dCwgZWxlbWVudCk7XG5cbiAgICAvLyBBbHNvIHRlbGwgS08gKm5vdCogdG8gYmluZCB0aGUgZGVzY2VuZGFudHMgaXRzZWxmLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGJvdW5kIHR3aWNlXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3dpdGhQcm9wZXJ0aWVzJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2xvZyddID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGNvbnNvbGUubG9nKFwibG9nXCIsIHZhbHVlQWNjZXNzb3IoKSk7XG4gIH1cbn07XG5cblxua28uYmluZGluZ0hhbmRsZXJzWydibG9jayddID0ge1xuXG4gIHRlbXBsYXRlRXhpc3RzOiBmdW5jdGlvbihpZCkge1xuICAgIHZhciBlbCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKGVsKSByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBfY2hvb3NlVGVtcGxhdGU6IGZ1bmN0aW9uKGlzQXJyYXksIHByZWZpeCwgYWN0aW9uLCBmYWxsYmFjaykge1xuICAgIHZhciBpZCA9IHByZWZpeCArICctJyArIGFjdGlvbjtcbiAgICBpZiAoa28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLnRlbXBsYXRlRXhpc3RzKGlkKSkgcmV0dXJuIGlkO1xuICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IG51bGwpIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX2Nob29zZVRlbXBsYXRlKGlzQXJyYXksIHByZWZpeCwgZmFsbGJhY2spO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGZhbGxCYWNrSWQgPSBpc0FycmF5ID8gJ2FycmF5JyA6ICdvYmplY3QtJyArIGFjdGlvbjtcbiAgICAgIGlmIChrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10udGVtcGxhdGVFeGlzdHMoZmFsbEJhY2tJZCkpIHJldHVybiBmYWxsQmFja0lkO1xuICAgICAgZWxzZSB0aHJvdyBcImNhbm5vdCBmaW5kIHRlbXBsYXRlIGZvciBcIiArIGlkICsgXCIvXCIgKyBmYWxsQmFja0lkO1xuICAgIH1cbiAgfSxcblxuICAvLyBjb21wdXRlIGRpc3BsYXlNb2RlIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZU1vZGUgc2V0IHVzaW5nIFwid2l0aFByb3BlcnRpZXNcIiBiaW5kaW5nLlxuICBfZGlzcGxheU1vZGU6IGZ1bmN0aW9uKHVud3JhcHBlZCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgcHJlZml4ID0gdHlwZW9mIHVud3JhcHBlZC50eXBlICE9ICd1bmRlZmluZWQnID8ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh1bndyYXBwZWQudHlwZSkgOiAnbm90YWJsb2NrLScgKyB0eXBlb2YodW53cmFwcGVkKTtcbiAgICB2YXIgaXNBcnJheSA9IHR5cGVvZiB1bndyYXBwZWQuc3BsaWNlICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgdGVtcGxhdGVNb2RlID0gYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID8gYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlIDogJ3Nob3cnO1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX2Nob29zZVRlbXBsYXRlKGlzQXJyYXksIHByZWZpeCwgdGVtcGxhdGVNb2RlLCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGVGYWxsYmFjayk7XG4gIH0sXG5cbiAgX21ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3I6IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVBY2Nlc3NvcigpLFxuICAgICAgICB1bndyYXBwZWRWYWx1ZSA9IGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKHZhbHVlKTsgLy8gVW53cmFwIHdpdGhvdXQgc2V0dGluZyBhIGRlcGVuZGVuY3kgaGVyZVxuXG4gICAgICAvLyBJZiB1bndyYXBwZWRWYWx1ZS5kYXRhIGlzIHRoZSBhcnJheSwgcHJlc2VydmUgYWxsIHJlbGV2YW50IG9wdGlvbnMgYW5kIHVud3JhcCBhZ2FpbiB2YWx1ZSBzbyB3ZSBnZXQgdXBkYXRlc1xuICAgICAgdmFyIG1vZGVsVmFsdWU7XG4gICAgICB2YXIgdGVtcGxhdGU7XG5cbiAgICAgIGlmICgoIXVud3JhcHBlZFZhbHVlKSB8fCAodHlwZW9mIHVud3JhcHBlZFZhbHVlLmRhdGEgIT0gJ29iamVjdCcgJiYgdHlwZW9mIHVud3JhcHBlZFZhbHVlLmRhdGEgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgbW9kZWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWxWYWx1ZSA9IHVud3JhcHBlZFZhbHVlLmRhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgdW53cmFwcGVkVmFsdWUudGVtcGxhdGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVQYXJhbSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodW53cmFwcGVkVmFsdWUudGVtcGxhdGUpO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZU1vZGUgPSBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPyBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgOiAnc2hvdyc7XG4gICAgICAgICAgdGVtcGxhdGUgPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX2Nob29zZVRlbXBsYXRlKGZhbHNlLCB0ZW1wbGF0ZVBhcmFtLCB0ZW1wbGF0ZU1vZGUsIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZUZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdW53cmFwcGVkTW9kZWxWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobW9kZWxWYWx1ZSk7XG4gICAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHVud3JhcHBlZE1vZGVsVmFsdWUpKSBjb25zb2xlLmxvZyhcImRvdWJsZU9ic2VydmFibGVcIiwgdW53cmFwcGVkTW9kZWxWYWx1ZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTk9URSBJRTggdXNlZCB0byBicmVhayBoZXJlLCBidXQgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBhbnltb3JlLCBzbyBtYXliZSB0aGlzIGlzIG5vdCBuZWVkZWQuXG4gICAgICAgIGlmIChtb2RlbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9ICdlbXB0eSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0ga28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLl9kaXNwbGF5TW9kZSh1bndyYXBwZWRNb2RlbFZhbHVlLCBiaW5kaW5nQ29udGV4dCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSwgdW53cmFwcGVkTW9kZWxWYWx1ZSwgYmluZGluZ0NvbnRleHRbJyRkYXRhJ10sIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbmFtZSc6IHRlbXBsYXRlLFxuICAgICAgICAnZGF0YSc6IG1vZGVsVmFsdWUsXG4gICAgICAgICd0ZW1wbGF0ZUVuZ2luZSc6IGtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lLmluc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG4gIH0sXG5cbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWVBY2Nlc3NvcigpID09PSAndW5kZWZpbmVkJykgY29uc29sZS5sb2coXCJmb3VuZCBhIG51bGwgYmxvY2s6IGNoZWNrIGVuZGluZyBjb21tYXMgaW4gYXJyYXlzIGRlZnMgaW4gSUVcIik7XG4gICAgdmFyIG5ld1ZhbHVlQWNjZXNzb3IgPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX21ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciwgYmluZGluZ0NvbnRleHQpO1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3RlbXBsYXRlJ11bJ2luaXQnXShlbGVtZW50LCBuZXdWYWx1ZUFjY2Vzc29yKTtcbiAgfSxcbiAgJ3VwZGF0ZSc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIG5ld1ZhbHVlQWNjZXNzb3IgPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10uX21ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciwgYmluZGluZ0NvbnRleHQpO1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3RlbXBsYXRlJ11bJ3VwZGF0ZSddKGVsZW1lbnQsIG5ld1ZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfVxufTtcbmtvLmV4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzWydibG9jayddID0gZmFsc2U7IC8vIENhbid0IHJld3JpdGUgY29udHJvbCBmbG93IGJpbmRpbmdzXG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWydibG9jayddID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gc2NyaXB0IHRlbXBsYXRlIGlzIHRoZSBvbmUgcHJvdmlkZWQgYnkgS08gYW5kIGRlYWxzIHdpdGggdGVtcGFsdGVzIGRlZmluZWQgYXMgPHNjcmlwdCB0eXBlPXRleHQvaHRtbC5cbi8vIHN0cmluZyB0ZW1wbGF0ZSBkZWZpbmVzIHRoZW0gaW4gbWVtb3J5IGFuZCBhdm9pZHMgcG9sbHV0aW5nIHRoZSBIVE1MOiBzZWVtcyB0byB3b3JrIGJldHRlciBpbiBNb3NhaWNvLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3RyaW5nLXRlbXBsYXRlLmpzJyk7XG4vLyBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc2NyaXB0LXRlbXBsYXRlLmpzJyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlICovXG5cbnJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvZXZvbC1jb2xvcnBpY2tlci9qcy9ldm9sLmNvbG9ycGlja2VyLm1pbi5qc1wiKTtcblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIga29qcXVpID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvanF1aSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna29qcXVpJ10gOiBudWxsKTtcblxuXG52YXIgQ29sb3JQaWNrZXIgPSBmdW5jdGlvbigpIHtcbiAga29qcXVpLkJpbmRpbmdIYW5kbGVyLmNhbGwodGhpcywgJ2NvbG9ycGlja2VyJyk7XG59O1xuQ29sb3JQaWNrZXIucHJvdG90eXBlID0ga29qcXVpLnV0aWxzLmNyZWF0ZU9iamVjdChrb2pxdWkuQmluZGluZ0hhbmRsZXIucHJvdG90eXBlKTtcbkNvbG9yUGlja2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbG9yUGlja2VyO1xuXG5Db2xvclBpY2tlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKSB7XG4gIHZhciB2YSA9IHZhbHVlQWNjZXNzb3IoKTtcbiAgdmFyIHZhbHVlID0gdmEuY29sb3I7XG5cbiAgLy8gSW4gb3JkZXIgdG8gaGF2ZSBhIGNvcnJlY3QgZGVwZW5kZW5jeSB0cmFja2luZyBpbiBcImlmU3Vic1wiIHdlIGhhdmUgdG8gZW5zdXJlIHdlIHVzZSBhIHNpbmdsZSBjb21wdXRlciBmb3IgZWFjaCBlZGl0YWJsZVxuICAvLyBwcm9wZXJ0eS4gR2l2ZW4gdGhpcyBiaW5kaW5nIG5lZWRzIDIgb2YgdGhlbSwgd2UgY3JlYXRlIGEgY29tcHV0ZWQgc28gdG8gXCJwcm94eVwiIHRoZSBkZXBlbmRlbmNpZXMuXG4gIHZhciBuZXdETyA9IGtvLmNvbXB1dGVkKHtcbiAgICByZWFkOiB2YWx1ZSxcbiAgICB3cml0ZTogdmFsdWUsXG4gICAgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50XG4gIH0pO1xuICB2YXIgbmV3VkEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3RE87XG4gIH07XG5cbiAga28uYmluZGluZ0hhbmRsZXJzLnZhbHVlLmluaXQoZWxlbWVudCwgbmV3VkEsIGFsbEJpbmRpbmdzKTtcblxuICB2YXIgY2hhbmdlUHJvcGFnYXRvciA9IGZ1bmN0aW9uKGV2ZW50LCBjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgIT09ICd1bmRlZmluZWQnKSBuZXdETyhjb2xvcik7XG4gIH07XG4gICQoZWxlbWVudCkub24oJ2NoYW5nZS5jb2xvcicsIGNoYW5nZVByb3BhZ2F0b3IpO1xuXG4gIGtvLmNvbXB1dGVkKHtcbiAgICByZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHQgPSB7XG4gICAgICAgIGNvbG9yOiBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKG5ld0RPKSxcbiAgICAgICAgc2hvd09uOiAnYnV0dG9uJ1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdmEpXG4gICAgICAgIGlmIChwcm9wICE9PSAnY29sb3InICYmIHZhLmhhc093blByb3BlcnR5KHByb3ApKSBvcHRbcHJvcF0gPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhW3Byb3BdKTtcbiAgICAgICQoZWxlbWVudCkuY29sb3JwaWNrZXIob3B0KTtcbiAgICB9LFxuICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuICB9KTtcblxuICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICQoZWxlbWVudCkub2ZmKCdjaGFuZ2UuY29sb3InLCBjaGFuZ2VQcm9wYWdhdG9yKTtcbiAgICAkKGVsZW1lbnQpLmNvbG9ycGlja2VyKCdkZXN0cm95Jyk7XG4gIH0pO1xuXG59O1xua29qcXVpLnV0aWxzLnJlZ2lzdGVyKENvbG9yUGlja2VyKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG5cbi8qIGh0dHBzOi8vZ2l0aHViLmNvbS9rbm9ja291dC9rbm9ja291dC9pc3N1ZXMvMTE3MSAqL1xua28uYmluZGluZ0hhbmRsZXJzLmNzc1RleHQgPSB7XG4gICd1cGRhdGUnOiBmdW5jdGlvbihub2RlLCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuICAgIHZhciB0ZXh0ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIHRyeSB7XG4gICAgICBub2RlLmlubmVyVGV4dCA9IHRleHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFub2RlLnN0eWxlU2hlZXQpIG5vZGUuaW5uZXJIVE1MID0gXCJhe31cIjtcbiAgICAgIG5vZGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gdGV4dDtcbiAgICB9XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xuXG4vKiBrbm9ja291dCBkcm9wcGFibGUsIHdpdGggc2ltcGxpZmllZCBVTUQgKi9cbjsoZnVuY3Rpb24oZmFjdG9yeSkge1xuICBmYWN0b3J5KGtvLCAkKTtcbn0pKGZ1bmN0aW9uKGtvLCAkKSB7XG4gIHZhciBJVEVNS0VZID0gXCJrb19zb3J0SXRlbVwiLFxuICAgIElOREVYS0VZID0gXCJrb19zb3VyY2VJbmRleFwiLFxuICAgIExJU1RLRVkgPSBcImtvX3NvcnRMaXN0XCIsXG4gICAgUEFSRU5US0VZID0gXCJrb19wYXJlbnRMaXN0XCIsXG4gICAgRFJBR0tFWSA9IFwia29fZHJhZ0l0ZW1cIixcbiAgICB1bndyYXAgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlLFxuICAgIGRhdGFHZXQgPSBrby51dGlscy5kb21EYXRhLmdldCxcbiAgICBkYXRhU2V0ID0ga28udXRpbHMuZG9tRGF0YS5zZXQ7XG5cbiAga28uYmluZGluZ0hhbmRsZXJzLmRyb3BwYWJsZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpLFxuICAgICAgICB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSB8fCB7fSxcbiAgICAgICAgZHJvcHBhYmxlID0ge30sXG4gICAgICAgIGRyb3BBY3R1YWw7XG5cbiAgICAgICQuZXh0ZW5kKHRydWUsIGRyb3BwYWJsZSwga28uYmluZGluZ0hhbmRsZXJzLmRyb3BwYWJsZSk7XG4gICAgICBpZiAodmFsdWUuZGF0YSkge1xuICAgICAgICBpZiAodmFsdWUub3B0aW9ucyAmJiBkcm9wcGFibGUub3B0aW9ucykge1xuICAgICAgICAgIGtvLnV0aWxzLmV4dGVuZChkcm9wcGFibGUub3B0aW9ucywgdmFsdWUub3B0aW9ucyk7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlLm9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAga28udXRpbHMuZXh0ZW5kKGRyb3BwYWJsZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJvcHBhYmxlLmRhdGEgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgZHJvcEFjdHVhbCA9IGRyb3BwYWJsZS5vcHRpb25zLmRyb3A7XG5cbiAgICAgICRlbGVtZW50LmRyb3BwYWJsZShrby51dGlscy5leHRlbmQoZHJvcHBhYmxlLm9wdGlvbnMsIHtcbiAgICAgICAgZHJvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cbiAgICAgICAgICB2YXIgZWwgPSB1aS5kcmFnZ2FibGVbMF0sXG4gICAgICAgICAgICBpdGVtID0gZGF0YUdldChlbCwgSVRFTUtFWSkgfHwgZGF0YUdldChlbCwgRFJBR0tFWSk7XG5cbiAgICAgICAgICBpZiAoaXRlbSkge1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5jbG9uZSkge1xuICAgICAgICAgICAgICBpdGVtID0gaXRlbS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJvcHBhYmxlLmRyYWdnZWQpIHtcbiAgICAgICAgICAgICAgaXRlbSA9IGRyb3BwYWJsZS5kcmFnZ2VkLmNhbGwodGhpcywgaXRlbSwgZXZlbnQsIHVpKSB8fCBpdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJvcHBhYmxlLmRhdGEpIHtcbiAgICAgICAgICAgICAgZHJvcHBhYmxlLmRhdGEoaXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZHJvcEFjdHVhbCkge1xuICAgICAgICAgICAgZHJvcEFjdHVhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vaGFuZGxlIGVuYWJsaW5nL2Rpc2FibGluZ1xuICAgICAgaWYgKGRyb3BwYWJsZS5pc0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrby5jb21wdXRlZCh7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkZWxlbWVudC5kcm9wcGFibGUoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShkcm9wcGFibGUuaXNFbmFibGVkKSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuXG4gICAgfSxcbiAgICB0YXJnZXRJbmRleDogbnVsbCxcbiAgICBhZnRlck1vdmU6IG51bGwsXG4gICAgYmVmb3JlTW92ZTogbnVsbCxcbiAgICBvcHRpb25zOiB7fVxuICB9O1xufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuLyogdXRpbGl0eSBmb3IgdG9nZXRoZXJqcyAqL1xua28uYmluZGluZ0hhbmRsZXJzLmZvY3VzYWJsZSA9IHtcbiAgJ2ZvY3VzJzogZnVuY3Rpb24oKSB7fSxcbiAgJ2JsdXInOiBmdW5jdGlvbigpIHt9LFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgJChlbGVtZW50KS5vZmYoXCJmb2N1c2luXCIsIGtvLmJpbmRpbmdIYW5kbGVycy5mb2N1c2FibGUuZm9jdXMpO1xuICAgICAgJChlbGVtZW50KS5vZmYoXCJmb2N1c291dFwiLCBrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlLmJsdXIpO1xuICAgIH0pO1xuXG4gICAgJChlbGVtZW50KS5vbihcImZvY3VzaW5cIiwga28uYmluZGluZ0hhbmRsZXJzLmZvY3VzYWJsZS5mb2N1cyk7XG4gICAgJChlbGVtZW50KS5vbihcImZvY3Vzb3V0XCIsIGtvLmJpbmRpbmdIYW5kbGVycy5mb2N1c2FibGUuYmx1cik7XG5cbiAgfVxufTtcblxua28uYmluZGluZ0hhbmRsZXJzLnNjcm9sbGFibGUgPSB7XG4gICdzY3JvbGwnOiBmdW5jdGlvbigpIHt9LFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgJChlbGVtZW50KS5vZmYoXCJzY3JvbGxcIiwga28uYmluZGluZ0hhbmRsZXJzLnNjcm9sbGFibGUuc2Nyb2xsKTtcbiAgICB9KTtcblxuICAgICQoZWxlbWVudCkub24oXCJzY3JvbGxcIiwga28uYmluZGluZ0hhbmRsZXJzLnNjcm9sbGFibGUuc2Nyb2xsKTtcblxuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcblxua28uZXh0ZW5kZXJzLnBhZ2luZyA9IGZ1bmN0aW9uKHRhcmdldCwgcGFnZVNpemUpIHtcbiAgdmFyIF9wYWdlU2l6ZSA9IGtvLm9ic2VydmFibGUocGFnZVNpemUgfHwgMTApLFxuICAgIC8vIGRlZmF1bHQgcGFnZVNpemUgdG8gMTBcbiAgICBfY3VycmVudFBhZ2UgPSBrby5vYnNlcnZhYmxlKDEpOyAvLyBkZWZhdWx0IGN1cnJlbnQgcGFnZSB0byAxXG4gIHRhcmdldC5wYWdlU2l6ZSA9IGtvLmNvbXB1dGVkKHtcbiAgICByZWFkOiBfcGFnZVNpemUsXG4gICAgd3JpdGU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPiAwKSB7XG4gICAgICAgIF9wYWdlU2l6ZShuZXdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcGFnZVNpemUoMTApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdGFyZ2V0LmN1cnJlbnRQYWdlID0ga28uY29tcHV0ZWQoe1xuICAgIHJlYWQ6IF9jdXJyZW50UGFnZSxcbiAgICB3cml0ZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSA+IHRhcmdldC5wYWdlQ291bnQoKSkge1xuICAgICAgICBfY3VycmVudFBhZ2UodGFyZ2V0LnBhZ2VDb3VudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgPD0gMCkge1xuICAgICAgICBfY3VycmVudFBhZ2UoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfY3VycmVudFBhZ2UobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdGFyZ2V0LnBhZ2VDb3VudCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGFyZ2V0KCkubGVuZ3RoIC8gdGFyZ2V0LnBhZ2VTaXplKCkpIHx8IDE7XG4gIH0pO1xuXG4gIHRhcmdldC5jdXJyZW50UGFnZURhdGEgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFnZVNpemUgPSBfcGFnZVNpemUoKSxcbiAgICAgIHBhZ2VJbmRleCA9IF9jdXJyZW50UGFnZSgpLFxuICAgICAgc3RhcnRJbmRleCA9IHBhZ2VTaXplICogKHBhZ2VJbmRleCAtIDEpLFxuICAgICAgZW5kSW5kZXggPSBwYWdlU2l6ZSAqIHBhZ2VJbmRleDtcblxuICAgIHJldHVybiB0YXJnZXQoKS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIH0pO1xuXG4gIHRhcmdldC5tb3ZlRmlyc3QgPSBmdW5jdGlvbigpIHtcbiAgICB0YXJnZXQuY3VycmVudFBhZ2UoMSk7XG4gIH07XG4gIHRhcmdldC5tb3ZlUHJldmlvdXMgPSBmdW5jdGlvbigpIHtcbiAgICB0YXJnZXQuY3VycmVudFBhZ2UodGFyZ2V0LmN1cnJlbnRQYWdlKCkgLSAxKTtcbiAgfTtcbiAgdGFyZ2V0Lm1vdmVOZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGFyZ2V0LmN1cnJlbnRQYWdlKHRhcmdldC5jdXJyZW50UGFnZSgpICsgMSk7XG4gIH07XG4gIHRhcmdldC5tb3ZlTGFzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRhcmdldC5jdXJyZW50UGFnZSh0YXJnZXQucGFnZUNvdW50KCkpO1xuICB9O1xuXG4gIHJldHVybiB0YXJnZXQ7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBnbG9iYWw6IHRydWUgKi9cblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgc29ydGFibGUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J11bJ3VpJ11bJ3NvcnRhYmxlJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXVsndWknXVsnc29ydGFibGUnXSA6IG51bGwpO1xudmFyIGRyYWdnYWJsZSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXVsndWknXVsnZHJhZ2dhYmxlJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXVsndWknXVsnZHJhZ2dhYmxlJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5yZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2tub2Nrb3V0LXNvcnRhYmxlL2J1aWxkL2tub2Nrb3V0LXNvcnRhYmxlLm1pbi5qc1wiKTtcblxuaWYgKHR5cGVvZiBzb3J0YWJsZSA9PSAndW5kZWZpbmVkJykgdGhyb3cgXCJDYW5ub3QgZmluZCBqcXVlcnktdWkgc29ydGFibGUgd2lkZ2V0IGRlcGVuZGVuY3khXCI7XG5pZiAodHlwZW9mIGRyYWdnYWJsZSA9PSAndW5kZWZpbmVkJykgdGhyb3cgXCJDYW5ub3QgZmluZCBqcXVlcnktdWkgc29ydGFibGUgd2lkZ2V0IGRlcGVuZGVuY3khXCI7XG5cbnZhciBpc0RyYWdnaW5nSGVscGVyID0gZnVuY3Rpb24od3JpdGFibGUsIGUpIHtcbiAgaWYgKHdyaXRhYmxlKCkpIHtcbiAgICBpZiAoZS50eXBlID09IHdyaXRhYmxlKCkgKyAnc3RvcCcpIHdyaXRhYmxlKGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZS50eXBlID09ICdkcmFnc3RhcnQnIHx8IGUudHlwZSA9PSAnc29ydHN0YXJ0Jykgd3JpdGFibGUoZS50eXBlLnN1YnN0cmluZygwLCA0KSk7XG4gIH1cbn07XG5cbnZhciBtYWtlRXh0ZW5kZWRWYWx1ZUFjY2Vzc29yID0gZnVuY3Rpb24odmFsdWVBY2Nlc3Nvcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1vZGVsVmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCksXG4gICAgICB1bndyYXBwZWRWYWx1ZSA9IGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKG1vZGVsVmFsdWUpOyAvLyBVbndyYXAgd2l0aG91dCBzZXR0aW5nIGEgZGVwZW5kZW5jeSBoZXJlXG5cbiAgICBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKG1vZGVsVmFsdWUpO1xuXG4gICAgaWYgKG1vZGVsVmFsdWUub3B0aW9ucyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgbW9kZWxWYWx1ZS5vcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIG9yaWdTdGFydCA9IG1vZGVsVmFsdWUub3B0aW9ucy5zdGFydDtcbiAgICBtb2RlbFZhbHVlLm9wdGlvbnMuc3RhcnQgPSBmdW5jdGlvbihlLCB1aSkge1xuICAgICAgaWYgKHR5cGVvZiBtb2RlbFZhbHVlLmRyYWdnaW5nICE9ICd1bmRlZmluZWQnICYmIGtvLmlzV3JpdGFibGVPYnNlcnZhYmxlKG1vZGVsVmFsdWUuZHJhZ2dpbmcpKSBpc0RyYWdnaW5nSGVscGVyKG1vZGVsVmFsdWUuZHJhZ2dpbmcsIGUpO1xuICAgICAgaWYgKHR5cGVvZiBtb2RlbFZhbHVlLmRyb3BDb250YWluZXIgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kZWxWYWx1ZS5zY3JvbGxJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZm9vID0gJChtb2RlbFZhbHVlLmRyb3BDb250YWluZXIpLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICQobW9kZWxWYWx1ZS5kcm9wQ29udGFpbmVyKS5zY3JvbGxUb3AoZm9vICsgbW9kZWxWYWx1ZS5hZGRpbmcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9yaWdTdGFydCAhPSAndW5kZWZpbmVkJykgcmV0dXJuIG9yaWdTdGFydChlLCB1aSk7XG4gICAgfTtcbiAgICB2YXIgb3JpZ1N0b3AgPSBtb2RlbFZhbHVlLm9wdGlvbnMuc3RvcDtcbiAgICBtb2RlbFZhbHVlLm9wdGlvbnMuc3RvcCA9IGZ1bmN0aW9uKGUsIHVpKSB7XG4gICAgICBpZiAodHlwZW9mIG1vZGVsVmFsdWUuZHJhZ2dpbmcgIT0gJ3VuZGVmaW5lZCcgJiYga28uaXNXcml0YWJsZU9ic2VydmFibGUobW9kZWxWYWx1ZS5kcmFnZ2luZykpIGlzRHJhZ2dpbmdIZWxwZXIobW9kZWxWYWx1ZS5kcmFnZ2luZywgZSk7XG4gICAgICBpZiAodHlwZW9mIG1vZGVsVmFsdWUuZHJvcENvbnRhaW5lciAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBnbG9iYWwuY2xlYXJJbnRlcnZhbChtb2RlbFZhbHVlLnNjcm9sbEludGVydmFsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3JpZ1N0b3AgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBvcmlnU3RvcChlLCB1aSk7XG4gICAgfTtcbiAgICB2YXIgb3JpZ0RyYWcgPSBtb2RlbFZhbHVlLm9wdGlvbnMuZHJhZztcbiAgICBtb2RlbFZhbHVlLm9wdGlvbnMuZHJhZyA9IGZ1bmN0aW9uKGUsIHVpKSB7XG4gICAgICBpZiAodHlwZW9mIG1vZGVsVmFsdWUuZHJvcENvbnRhaW5lciAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdG9wID0gZS5wYWdlWSAtICQobW9kZWxWYWx1ZS5kcm9wQ29udGFpbmVyKS5vZmZzZXQoKS50b3A7XG4gICAgICAgIHZhciBib3R0b20gPSB0b3AgLSAkKG1vZGVsVmFsdWUuZHJvcENvbnRhaW5lcikuaGVpZ2h0KCk7XG4gICAgICAgIC8vIEhhbmRsZSBzY3JvbGxpbmcgc3BlZWQgZGVwZW5kaW5nIG9uIGRpc3RhbmNlIGZyb20gYm9yZGVyLlxuICAgICAgICBpZiAodG9wIDwgLTIwKSB7XG4gICAgICAgICAgbW9kZWxWYWx1ZS5hZGRpbmcgPSAtMjA7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCI8PDxcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wIDwgMCkge1xuICAgICAgICAgIG1vZGVsVmFsdWUuYWRkaW5nID0gLTEwO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiPDxcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wIDwgMTApIHtcbiAgICAgICAgICBtb2RlbFZhbHVlLmFkZGluZyA9IC01O1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiPFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b20gPiAyMCkge1xuICAgICAgICAgIG1vZGVsVmFsdWUuYWRkaW5nID0gMjA7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCI+Pj5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tID4gMCkge1xuICAgICAgICAgIG1vZGVsVmFsdWUuYWRkaW5nID0gMTA7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCI+PlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b20gPiAtMTApIHtcbiAgICAgICAgICBtb2RlbFZhbHVlLmFkZGluZyA9IDU7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCI+XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsVmFsdWUuYWRkaW5nID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcmlnRHJhZyAhPSAndW5kZWZpbmVkJykgcmV0dXJuIG9yaWdEcmFnKGUsIHVpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG1vZGVsVmFsdWU7XG4gIH07XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnMuZXh0c29ydGFibGUgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpIHtcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnNvcnRhYmxlLmluaXQoZWxlbWVudCwgbWFrZUV4dGVuZGVkVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGUudXBkYXRlKGVsZW1lbnQsIG1ha2VFeHRlbmRlZFZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpO1xuICB9XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnMuZXh0ZHJhZ2dhYmxlID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy5kcmFnZ2FibGUuaW5pdChlbGVtZW50LCBtYWtlRXh0ZW5kZWRWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IpLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy5kcmFnZ2FibGUudXBkYXRlKGVsZW1lbnQsIG1ha2VFeHRlbmRlZFZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UsIEltYWdlOiBmYWxzZSAqL1xuXG4vLyBUaGlzIG1vZHVsZSBkZXBlbmRzIG9uIHRob3NlIGZpbGVzLCBidXQgaXQgZG9lc24ndCBoYXZlIGEgZGlyZWN0IGRlcGVuZGVuY3ksIHNvIHdlIGRvbid0IHJlcXVpcmUgdGhlbSBoZXJlLlxuXG4vL3JlcXVpcmUoXCJibHVlaW1wLWNhbnZhcy10by1ibG9iXCIpO1xuLy9yZXF1aXJlKFwianF1ZXJ5LWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5pZnJhbWUtdHJhbnNwb3J0LmpzXCIpO1xuLy9yZXF1aXJlKFwianF1ZXJ5LWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5maWxldXBsb2FkLmpzXCIpO1xuLy9yZXF1aXJlKFwianF1ZXJ5LWZpbGUtdXBsb2FkL2pzL2pxdWVyeS5maWxldXBsb2FkLXByb2Nlc3MuanNcIik7XG4vL3JlcXVpcmUoXCJqcXVlcnktZmlsZS11cGxvYWQvanMvanF1ZXJ5LmZpbGV1cGxvYWQtaW1hZ2UuanNcIik7XG4vL3JlcXVpcmUoXCJqcXVlcnktZmlsZS11cGxvYWQvanMvanF1ZXJ5LmZpbGV1cGxvYWQtdmFsaWRhdGUuanNcIik7XG5cbnZhciAkICAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG4vLyBleHBlcmltZW50YWwgaW1hZ2UgcHJlbG9hZGluZy5cbmtvLmJpbmRpbmdIYW5kbGVyc1sncHJlbG9hZGVyJ10gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5wcmVsb2FkZWQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlLnByZWxvYWRlZCA9IGtvLm9ic2VydmFibGUoXCJcIik7XG5cbiAgICAgIHZhciBwcmVsb2FkZXIgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgIT0gdmFsdWUucHJlbG9hZGVkKCkpIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhbHVlLnByZWxvYWRlZChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFsdWUucHJlbG9hZGVkKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gbmV3VmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLnByZWxvYWRlZChuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YWx1ZS5zdWJzY3JpYmUocHJlbG9hZGVyKTtcbiAgICAgIHByZWxvYWRlcih2YWx1ZSgpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFRPRE8gd2UgZG9uJ3QgdXNlIGFkdmF0dHIgYW5kIGFkdnN0eWxlLCBtYXliZSB3ZSBzaG91bGQgc2ltcGx5IHJlbW92ZSB0aGlzIGNvZGUuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2FkdmF0dHInXSA9IHtcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpIHx8IHt9KTtcbiAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHZhbHVlLCBmdW5jdGlvbihhdHRyTmFtZSwgYXR0clZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHZhciBhdHRyVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgIGlmIChrby5pc1dyaXRlYWJsZU9ic2VydmFibGUoYXR0clZhbHVlQWNjZXNzb3IpKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGF0dHJWYWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICBhdHRyVmFsdWVBY2Nlc3NvcihhdHRyVmFsdWUpO1xuICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBZHZBdHRyIGZvdW5kIGEgdmFsdWUgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHRcIiwgYXR0ck5hbWUsIG9sZFZhbHVlLCBhdHRyVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpIHtcbiAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfHwge307XG4gICAga28udXRpbHMub2JqZWN0Rm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oYXR0ck5hbWUsIGF0dHJWYWx1ZSkge1xuICAgICAgYXR0clZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShhdHRyVmFsdWUpO1xuICAgICAgLy8gVG8gY292ZXIgY2FzZXMgbGlrZSBcImF0dHI6IHsgY2hlY2tlZDpzb21lUHJvcCB9XCIsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgZW50aXJlbHlcbiAgICAgIC8vIHdoZW4gc29tZVByb3AgaXMgYSBcIm5vIHZhbHVlXCItbGlrZSB2YWx1ZSAoc3RyaWN0bHkgbnVsbCwgZmFsc2UsIG9yIHVuZGVmaW5lZClcbiAgICAgIC8vIChiZWNhdXNlIHRoZSBhYnNlbmNlIG9mIHRoZSBcImNoZWNrZWRcIiBhdHRyIGlzIGhvdyB0byBtYXJrIGFuIGVsZW1lbnQgYXMgbm90IGNoZWNrZWQsIGV0Yy4pXG4gICAgICB2YXIgdG9SZW1vdmUgPSAoYXR0clZhbHVlID09PSBmYWxzZSkgfHwgKGF0dHJWYWx1ZSA9PT0gbnVsbCkgfHwgKGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgIGlmICh0b1JlbW92ZSkgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuICB9XG59O1xua28uYmluZGluZ0hhbmRsZXJzWydhZHZzdHlsZSddID0ge1xuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkgfHwge30pO1xuICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZUFjY2Vzc29yKSB7XG4gICAgICB2YXIgc3R5bGVWYWx1ZTtcbiAgICAgIGlmIChzdHlsZU5hbWUubWF0Y2goL1B4JC8pKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlTmFtZS5zdWJzdHIoMCwgc3R5bGVOYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICBzdHlsZVZhbHVlID0gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZS5tYXRjaCgvcHgkLykpIHtcbiAgICAgICAgICBzdHlsZVZhbHVlID0gc3R5bGVWYWx1ZS5yZXBsYWNlKC9weCQvLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBZHZTdHlsZSBiaW5kaW5nIGZvdW5kIGFuIHVuZXhwZWN0ZWQgZGVmYXVsdCB2YWx1ZVwiLCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZVZhbHVlID0gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoa28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHN0eWxlVmFsdWVBY2Nlc3NvcikpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gc3R5bGVWYWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPSBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgc3R5bGVWYWx1ZUFjY2Vzc29yKHN0eWxlVmFsdWUpO1xuICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBZHZTdHlsZSBmb3VuZCBhIHZhbHVlIGRpZmZlcmVudCBmcm9tIHRoZSBkZWZhdWx0XCIsIHN0eWxlTmFtZSwgb2xkVmFsdWUsIHN0eWxlVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpIHx8IHt9KTtcbiAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHZhbHVlLCBmdW5jdGlvbihzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgIHN0eWxlVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHN0eWxlVmFsdWUpO1xuXG4gICAgICBpZiAoc3R5bGVWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgc3R5bGVWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3R5bGVWYWx1ZSA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZU5hbWUubWF0Y2goL1B4JC8pKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlTmFtZS5zdWJzdHIoMCwgc3R5bGVOYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICBzdHlsZVZhbHVlID0gc3R5bGVWYWx1ZSArIFwicHhcIjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gVXRpbGl0eSB0byBsb2cgaW5pemlhbGl6YXRpb24gYW5kIGRpc3Bvc2FsIG9mIERPTSBlbGVtZW50cy5cbmtvLmJpbmRpbmdIYW5kbGVyc1snZG9tbG9nJ10gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICBjb25zb2xlLmxvZyhcImluaXRpYWxpemVkXCIsIGVsZW1lbnQpO1xuICAgIGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soZWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImRpc3Bvc2VkXCIsIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2Z1ZHJvcHBhYmxlJ10gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICB2YXIgb3B0ID0gdmFsdWVBY2Nlc3NvcigpIHx8IHt9O1xuICAgIHZhciB0aW1lb3V0c09iaiA9IHt9O1xuXG4gICAgdmFyIG92ZXIgPSBmdW5jdGlvbih0aW1lb3V0cywgZHJvcFpvbmVUaW1lb3V0LCBlbGVtZW50LCBjbGFzc05hbWUsIG9ic2VydmFibGUsIGV2ZW50KSB7XG5cbiAgICAgIGlmICghdGltZW91dHNbZHJvcFpvbmVUaW1lb3V0XSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKG9ic2VydmFibGUpICYmICFvYnNlcnZhYmxlKCkpIHtcbiAgICAgICAgICBvYnNlcnZhYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbG9iYWwuY2xlYXJUaW1lb3V0KHRpbWVvdXRzW2Ryb3Bab25lVGltZW91dF0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lb3V0c1tkcm9wWm9uZVRpbWVvdXRdID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZShvYnNlcnZhYmxlKSAmJiBvYnNlcnZhYmxlKCkpIHtcbiAgICAgICAgICBvYnNlcnZhYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gJ2RyYWdsZWF2ZScpIHN0b3AoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBVc2luZyAxMDAgaXQgZG9lbnMndCB3b3JrIGZpbmUgb24gTGludXggKGNob21lL2ZpcmVmb3gpLCB1c2luZyAyMDAgc3RpbGwgc2hvd3MgaXNzdWVzIG9uIHNsb3cgTGludXggYm94ZXNcbiAgICAgICAgdGltZW91dHNbZHJvcFpvbmVUaW1lb3V0XSA9IGdsb2JhbC5zZXRUaW1lb3V0KHN0b3AsIDUwMCk7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgaWYgKG9wdC5hY3RpdmUgfHwgb3B0LmFjdGl2ZUNsYXNzKSB7XG4gICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihnbG9iYWwsICdkcmFnb3ZlcicsIG92ZXIuYmluZCh1bmRlZmluZWQsIHRpbWVvdXRzT2JqLCAnYWN0aXZlVGltZW91dCcsIGVsZW1lbnQsIG9wdC5hY3RpdmVDbGFzcywgb3B0LmFjdGl2ZSkpO1xuICAgIH1cbiAgICBpZiAob3B0LmhvdmVyQ2xhc3MpIHtcbiAgICAgIC8vIGRyYWdlbnRlciBhbmQgZHJhZ2xlYXZlIGFyZSBub3QgcmVxdWlyZWQgYnV0IHRoZXkgc3BlZWR1cCBmZWVkYmFjayB3aGVuIHVzZWQuXG4gICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCAnZHJhZ292ZXIgZHJhZ2VudGVyIGRyYWdsZWF2ZScsIG92ZXIuYmluZCh1bmRlZmluZWQsIHRpbWVvdXRzT2JqLCAnaG92ZXJUaW1lb3V0JywgZWxlbWVudCwgb3B0LmhvdmVyQ2xhc3MsIHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgfVxufTtcblxua28uYmluZGluZ0hhbmRsZXJzWydmaWxldXBsb2FkJ10gPSB7XG4gIGV4dGVuZE9wdGlvbnM6IHt9LFxuICAvLyByZW1vdGVGaWxlUHJlcHJvY2Vzc29yIG1ldGhvZCBoYXMgYmVlbiBzZXQgaW4gYXBwLmpzXG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICAvLyBUT0RPIGRvbW5vZGVkaXNwb3NhbCBkb2Vzbid0IHdvcmsgd2hlbiB0aGUgdXBsb2FkIGlzIGRvbmUgYnkgXCJjbGlja2luZ1wiXG4gICAgLy8gUHJvYmFibHkganF1ZXJ5LWZpbGV1cGxvYWQgbW92ZXMgdGhlIERPTSBzb21ld2hlcmUgZWxzZSBzbyB0aGF0IEtPIGRvZXNuJ3RcbiAgICAvLyBkZXRlY3QgdGhlIHJlbW92YWwgYW55bW9yZS5cbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgJChlbGVtZW50KS5maWxldXBsb2FkKCdkZXN0cm95Jyk7XG4gICAgfSk7XG5cbiAgICAvLyBpZiB3ZSBsZWF2ZSB0aGUgdGl0bGUgdGhlIG5hdGl2ZSBjb250cm9sIHdpbGwgc2hvdyB1cyBhIHRvb2x0aXAgd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBJbiBXZWJLaXQgdGhlIHJpZ2h0IHdheSB0byByZW1vdmUgaXQgaXMgbGVhdmluZyBhIFwid2hpdGVzcGFjZVwiLlxuICAgIC8vIEluIEdlY2tvIHdlIGhhdmUgdG8gc2V0IGl0IGVtcHR5LlxuICAgIGlmIChnbG9iYWwud2Via2l0VVJMKVxuICAgICAgJChlbGVtZW50KS5hdHRyKCd0aXRsZScsICcgJyk7XG4gICAgZWxzZVxuICAgICAgJChlbGVtZW50KS5hdHRyKCd0aXRsZScsICcnKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZhbHVlQWNjZXNzb3IoKSB8fCB7fTtcblxuICAgIHZhciAkZnUgPSAkKGVsZW1lbnQpO1xuICAgIHZhciAkcGFyZW50ID0gJGZ1LnBhcmVudHMoJy51cGxvYWR6b25lJyk7XG5cbiAgICB2YXIgZGF0YVZhbHVlID0gb3B0aW9ucy5kYXRhO1xuICAgIG9wdGlvbnMuZGF0YSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBjYW52YXNQcmV2aWV3ID0gb3B0aW9ucy5jYW52YXNQcmV2aWV3O1xuXG4gICAgLy8gVE9ETyByZW1vdmUgaGFyZGNvZGVkIHVybFxuICAgIGtvLnV0aWxzLmV4dGVuZChvcHRpb25zLCB7XG4gICAgICB1cmw6ICcvdXBsb2FkLycsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgZHJvcFpvbmU6ICRwYXJlbnQuZmluZCgnLm1vLXVwbG9hZHpvbmUnKVswXSxcbiAgICAgIGF1dG9VcGxvYWQ6IHRydWUsXG4gICAgICBhY2NlcHRGaWxlVHlwZXM6IC8oXFwufFxcLykoZ2lmfGpwZT9nfHBuZykkL2ksXG4gICAgICBtYXhGaWxlU2l6ZTogMTAyNCAqIDEwMjQsXG4gICAgICAvLyBFbmFibGUgaW1hZ2UgcmVzaXppbmcsIGV4Y2VwdCBmb3IgQW5kcm9pZCBhbmQgT3BlcmEsXG4gICAgICAvLyB3aGljaCBhY3R1YWxseSBzdXBwb3J0IGltYWdlIHJlc2l6aW5nLCBidXQgZmFpbCB0b1xuICAgICAgLy8gc2VuZCBCbG9iIG9iamVjdHMgdmlhIFhIUiByZXF1ZXN0czpcbiAgICAgIGRpc2FibGVJbWFnZVJlc2l6ZTogL0FuZHJvaWQoPyEuKkNocm9tZSl8T3BlcmEvLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpLFxuICAgICAgcHJldmlld01heFdpZHRoOiAyMDAsXG4gICAgICBwcmV2aWV3TWF4SGVpZ2h0OiAyMDAsXG4gICAgICBwcmV2aWV3Q3JvcDogZmFsc2UsXG4gICAgICByZXBsYWNlRmlsZUlucHV0OiBmYWxzZSwgLy8gcmVwbGFjZUZpbGVJbnB1dCB0cnVlIGJyZWFrcyBhZnRlciB1cGxvYWRpbmcgdXNpbmcgXCJpbnB1dFwiICh1c2luZyBtb3VzZSBjbGljIGluc3RlYWQgb2YgZHJvcHBpbmcpXG5cbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIC8vIGNsaWVudCBzaWRlXG4gICAgICAgIHVua25vd25FcnJvcjogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICB1cGxvYWRlZEJ5dGVzOiAnVXBsb2FkZWQgYnl0ZXMgZXhjZWVkIGZpbGUgc2l6ZScsXG4gICAgICAgIG1heE51bWJlck9mRmlsZXM6ICdNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZCcsXG4gICAgICAgIGFjY2VwdEZpbGVUeXBlczogJ0ZpbGUgdHlwZSBub3QgYWxsb3dlZCcsXG4gICAgICAgIG1heEZpbGVTaXplOiAnRmlsZSBpcyB0b28gbGFyZ2UnLFxuICAgICAgICBtaW5GaWxlU2l6ZTogJ0ZpbGUgaXMgdG9vIHNtYWxsJyxcbiAgICAgICAgLy8gc2VydmVyIHNpZGVcbiAgICAgICAgcG9zdF9tYXhfc2l6ZTogJ1RoZSB1cGxvYWRlZCBmaWxlIGV4Y2VlZHMgdGhlIHBvc3RfbWF4X3NpemUgZGlyZWN0aXZlIGluIHBocC5pbmknLFxuICAgICAgICBtYXhfZmlsZV9zaXplOiAnRmlsZSBpcyB0b28gYmlnJyxcbiAgICAgICAgbWluX2ZpbGVfc2l6ZTogJ0ZpbGUgaXMgdG9vIHNtYWxsJyxcbiAgICAgICAgYWNjZXB0X2ZpbGVfdHlwZXM6ICdGaWxldHlwZSBub3QgYWxsb3dlZCcsXG4gICAgICAgIG1heF9udW1iZXJfb2ZfZmlsZXM6ICdNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZCcsXG4gICAgICAgIG1heF93aWR0aDogJ0ltYWdlIGV4Y2VlZHMgbWF4aW11bSB3aWR0aCcsXG4gICAgICAgIG1pbl93aWR0aDogJ0ltYWdlIHJlcXVpcmVzIGEgbWluaW11bSB3aWR0aCcsXG4gICAgICAgIG1heF9oZWlnaHQ6ICdJbWFnZSBleGNlZWRzIG1heGltdW0gaGVpZ2h0JyxcbiAgICAgICAgbWluX2hlaWdodDogJ0ltYWdlIHJlcXVpcmVzIGEgbWluaW11bSBoZWlnaHQnLFxuICAgICAgICBhYm9ydDogJ0ZpbGUgdXBsb2FkIGFib3J0ZWQnLFxuICAgICAgICBpbWFnZV9yZXNpemU6ICdGYWlsZWQgdG8gcmVzaXplIGltYWdlJyxcbiAgICAgICAgZ2VuZXJpYzogJ1VuZXhwZWN0ZWQgdXBsb2FkIGVycm9yJ1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAga28udXRpbHMuZXh0ZW5kKG9wdGlvbnMsIGtvLmJpbmRpbmdIYW5kbGVyc1snZmlsZXVwbG9hZCddLmV4dGVuZE9wdGlvbnMpO1xuXG4gICAgdmFyIHdvcmtpbmcgPSAwO1xuICAgIHZhciBmaXJzdFdvcmtlZCA9ICcnO1xuXG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXdvcmtpbmcgPT09IDApIHtcbiAgICAgICAgaWYgKGRhdGFWYWx1ZSkge1xuICAgICAgICAgIGRhdGFWYWx1ZShmaXJzdFdvcmtlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RXb3JrZWQgPSAnJztcbiAgICAgICAgaWYgKGNhbnZhc1ByZXZpZXcpIHtcbiAgICAgICAgICAkcGFyZW50LmZpbmQoJ2ltZycpLnNob3coKTtcbiAgICAgICAgICAkcGFyZW50LmZpbmQoJ2NhbnZhcycpLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoXCJ1cGxvYWRpbmdcIik7XG4gICAgICAgICRwYXJlbnQuZmluZCgnLnByb2dyZXNzLWJhcicpLmNzcygnd2lkdGgnLCAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zbGF0ZWRNZXNzYWdlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1lc3NhZ2VzID09ICdvYmplY3QnICYmIG9wdGlvbnMubWVzc2FnZXMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXihbXiBdKykoLiopJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWVzc2FnZXNbbWF0Y2hbMV1dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZXNbbWF0Y2hbMV1dICsgbWF0Y2hbMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgJGZ1LmZpbGV1cGxvYWQob3B0aW9ucyk7XG5cbiAgICB2YXIgZXZlbnRzID0gWydmaWxldXBsb2FkYWRkJywgJ2ZpbGV1cGxvYWRwcm9jZXNzYWx3YXlzJywgJ2ZpbGV1cGxvYWRwcm9ncmVzc2FsbCcsICdmaWxldXBsb2FkZG9uZScsICdmaWxldXBsb2FkZmFpbCddO1xuICAgIHZhciBldmVudEhhbmRsZXIgPSBmdW5jdGlvbihlLCBkYXRhKSB7XG4gICAgICBpZiAoZS50eXBlID09ICdmaWxldXBsb2FkYWRkJykge1xuICAgICAgICB3b3JraW5nKys7XG4gICAgICB9XG4gICAgICBpZiAoZS50eXBlID09ICdmaWxldXBsb2FkZmFpbCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJmaWxldXBsb2FkZmFpbFwiLCBlLCBkYXRhKTtcbiAgICAgICAgaWYgKG9wdGlvbnMub25lcnJvcikge1xuICAgICAgICAgIGlmIChkYXRhLmVycm9yVGhyb3duID09PSAnJyAmJiBkYXRhLnRleHRTdGF0dXMgPT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgb3B0aW9ucy5vbmVycm9yKHRyYW5zbGF0ZWRNZXNzYWdlKCdnZW5lcmljJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uZXJyb3IodHJhbnNsYXRlZE1lc3NhZ2UoJ2dlbmVyaWMgKCcgKyBkYXRhLmVycm9yVGhyb3duICsgJyknKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT0gJ2ZpbGV1cGxvYWRkb25lJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEucmVzdWx0LmZpbGVzWzBdLnVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmZpbGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5yZXN1bHQuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZGF0YS5yZXN1bHQuZmlsZXNbaV0gPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2ZpbGV1cGxvYWQnXS5yZW1vdGVGaWxlUHJlcHJvY2Vzc29yKGRhdGEucmVzdWx0LmZpbGVzW2ldKTtcbiAgICAgICAgICAgICAgb3B0aW9ucy5vbmZpbGUoZGF0YS5yZXN1bHQuZmlsZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaXJzdFdvcmtlZCA9PT0gJycpIGZpcnN0V29ya2VkID0gZGF0YS5yZXN1bHQuZmlsZXNbMF0udXJsO1xuXG4gICAgICAgICAgaWYgKGNhbnZhc1ByZXZpZXcpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBjbGVhbnVwO1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBjbGVhbnVwO1xuICAgICAgICAgICAgaW1nLnNyYyA9IGRhdGEucmVzdWx0LmZpbGVzWzBdLnVybDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YS5yZXN1bHQuZmlsZXNbMF0uZXJyb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJyZW1vdGUgZXJyb3JcIiwgZSwgZGF0YSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub25lcnJvcikge1xuICAgICAgICAgICAgb3B0aW9ucy5vbmVycm9yKHRyYW5zbGF0ZWRNZXNzYWdlKGRhdGEucmVzdWx0LmZpbGVzWzBdLmVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInVuZXhwZWN0ZWQgZXJyb3JcIiwgZSwgZGF0YSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub25lcnJvcikge1xuICAgICAgICAgICAgb3B0aW9ucy5vbmVycm9yKHRyYW5zbGF0ZWRNZXNzYWdlKCdnZW5lcmljIChVbmV4cGVjdGVkIEVycm9yIHJldHJpZXZpbmcgdXBsb2FkZWQgZmlsZSknKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSA9PSAnZmlsZXVwbG9hZHByb2Nlc3NhbHdheXMnKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgZmlsZSA9IGRhdGEuZmlsZXNbaW5kZXhdO1xuICAgICAgICBpZiAoZmlsZS5wcmV2aWV3ICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNhbnZhcyB3ZSBoYWQgbXVsdGlwbGUgdXBsb2FkZWQgZmlsZXNcbiAgICAgICAgICBpZiAoJHBhcmVudC5maW5kKCdjYW52YXMnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjYW52YXNQcmV2aWV3KSB7XG4gICAgICAgICAgICAgIHZhciBlbCA9ICQoZmlsZS5wcmV2aWV3KS5jc3MoJ3dpZHRoJywgJzEwMCUnKTsgLy8gLmNzcygncG9zaXRpb24nLCAnYWJzb2x1dGUnKS5jc3MoJ2xlZnQnLCAnMCcpO1xuICAgICAgICAgICAgICAkcGFyZW50LmZpbmQoJ2ltZycpLmhpZGUoKTtcbiAgICAgICAgICAgICAgJHBhcmVudC5wcmVwZW5kKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRwYXJlbnQuYWRkQ2xhc3MoXCJ1cGxvYWRpbmdcIik7XG4gICAgICAgICAgICAkcGFyZW50LmZpbmQoJy5wcm9ncmVzcy1iYXInKS5jc3MoJ3dpZHRoJywgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlLmVycm9yKSB7XG4gICAgICAgICAgLy8gRmlsZSB0eXBlIG5vdCBhbGxvd2VkXG4gICAgICAgICAgLy8gRmlsZSBpcyB0b28gbGFyZ2VcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmVycm9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uZXJyb3IodHJhbnNsYXRlZE1lc3NhZ2UoZmlsZS5lcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT0gJ2ZpbGV1cGxvYWRwcm9ncmVzc2FsbCcpIHtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gcGFyc2VJbnQoZGF0YS5sb2FkZWQgLyBkYXRhLnRvdGFsICogMTAwLCAxMCk7XG4gICAgICAgICRwYXJlbnQuZmluZCgnLnByb2dyZXNzLWJhcicpLmNzcygnd2lkdGgnLCBwcm9ncmVzcyArICclJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gZXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnRzW2ldO1xuICAgICAgJGZ1Lm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKCEkLnN1cHBvcnQuZmlsZUlucHV0KSB7XG4gICAgICAkZnUucHJvcCgnZGlzYWJsZWQnLCB0cnVlKS5wYXJlbnQoKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2lmU3VicyddID0ge1xuICAvLyBjbG9uZU5vZGVzIGZyb20ga28udXRpbHMuY2xvbmVOb2RlcyAobWlzc2luZyBpbiBtaW5pbWl6ZWQgS08pXG4gIGNsb25lTm9kZXM6IGZ1bmN0aW9uKG5vZGVzQXJyYXksIHNob3VsZENsZWFuTm9kZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IG5vZGVzQXJyYXkubGVuZ3RoLCBuZXdOb2Rlc0FycmF5ID0gW107IGkgPCBqOyBpKyspIHtcbiAgICAgIHZhciBjbG9uZWROb2RlID0gbm9kZXNBcnJheVtpXS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBuZXdOb2Rlc0FycmF5LnB1c2goc2hvdWxkQ2xlYW5Ob2RlcyA/IGtvLmNsZWFuTm9kZShjbG9uZWROb2RlKSA6IGNsb25lZE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZXNBcnJheTtcbiAgfSxcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciBkaWREaXNwbGF5T25MYXN0VXBkYXRlLFxuICAgICAgc2F2ZWROb2RlcyxcbiAgICAgIHZhbHVlQWNjID0gdmFsdWVBY2Nlc3NvcigpO1xuICAgIGlmICh0eXBlb2YgdmFsdWVBY2MuZGF0YS5zdWJzQ291bnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBrby5leHRlbmRlcnNbJ3N1YnNjcmlwdGlvbnNDb3VudCddKHZhbHVlQWNjLmRhdGEpO1xuICAgICAgLy8gTk9URSBJIGNhbid0IHNpbXBseSBsaXN0ZW4gb24gXCJ0aHJlc2hvbGRzXCIgYmVjYXVzZSBtdWx0aXBsZSBiaW5kaW5ncyB0byB0aGUgc2FtZSBvYnNlcnZhYmxlIGNvdWxkIHVzZSBkaWZmZXJlbnQgdGhyZXNob2xkcy5cbiAgICB9XG4gICAga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YVZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkuZGF0YS5zdWJzQ291bnQpLFxuICAgICAgICBpc0ZpcnN0UmVuZGVyID0gIXNhdmVkTm9kZXMsXG4gICAgICAgIHNob3VsZERpc3BsYXksIG5lZWRzUmVmcmVzaCwgZ3V0dGVyO1xuXG4gICAgICBndXR0ZXIgPSAtKHR5cGVvZiB2YWx1ZUFjY2Vzc29yKCkuZ3V0dGVyICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlQWNjZXNzb3IoKS5ndXR0ZXIgOiAxKTtcbiAgICAgIHNob3VsZERpc3BsYXkgPSBkYXRhVmFsdWUgKyAoZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSA/IGd1dHRlciA6IDApID49IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2MudGhyZXNob2xkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVBY2Nlc3NvcigpLm5vdCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWVBY2Nlc3NvcigpLm5vdCkge1xuICAgICAgICBzaG91bGREaXNwbGF5ID0gIXNob3VsZERpc3BsYXk7XG4gICAgICB9XG4gICAgICBuZWVkc1JlZnJlc2ggPSBpc0ZpcnN0UmVuZGVyIHx8IChzaG91bGREaXNwbGF5ICE9PSBkaWREaXNwbGF5T25MYXN0VXBkYXRlKTtcblxuICAgICAgaWYgKG5lZWRzUmVmcmVzaCkge1xuICAgICAgICAvLyBTYXZlIGEgY29weSBvZiB0aGUgaW5uZXIgbm9kZXMgb24gdGhlIGluaXRpYWwgdXBkYXRlLCBidXQgb25seSBpZiB3ZSBoYXZlIGRlcGVuZGVuY2llcy5cbiAgICAgICAgaWYgKGlzRmlyc3RSZW5kZXIgJiYga28uY29tcHV0ZWRDb250ZXh0LmdldERlcGVuZGVuY2llc0NvdW50KCkpIHtcbiAgICAgICAgICBzYXZlZE5vZGVzID0ga28uYmluZGluZ0hhbmRsZXJzWydpZlN1YnMnXS5jbG9uZU5vZGVzKGtvLnZpcnR1YWxFbGVtZW50cy5jaGlsZE5vZGVzKGVsZW1lbnQpLCB0cnVlIC8qIHNob3VsZENsZWFuTm9kZXMgKi8gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGREaXNwbGF5KSB7XG4gICAgICAgICAgaWYgKCFpc0ZpcnN0UmVuZGVyKSB7XG4gICAgICAgICAgICBrby52aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuKGVsZW1lbnQsIGtvLmJpbmRpbmdIYW5kbGVyc1snaWZTdWJzJ10uY2xvbmVOb2RlcyhzYXZlZE5vZGVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtvLmFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKGJpbmRpbmdDb250ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrby52aXJ0dWFsRWxlbWVudHMuZW1wdHlOb2RlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSA9IHNob3VsZERpc3BsYXk7XG4gICAgICB9XG4gICAgfSwgbnVsbCwge1xuICAgICAgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICdjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyc6IHRydWVcbiAgICB9O1xuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snaWZTdWJzJ10gPSB0cnVlO1xuXG4vLyBrby5pc1dyaXRhYmxlT2JzZXJ2YWJsZSAod2l0aG91dCBcImVcIikgaGFzIGJlZW4gaW50cm9kdWNlZCBpbiAzLjIuMCwgdGhhdCBpcyBhbHNvIG91ciBtaW4gcmVxdWlyZW1lbnQuXG4vLyBtaW5pbWl6ZWQga25vY2tvdXQgXCJvYmZ1c2NhdGVcIiB0aGUgYmVmb3JlU3Vic2NyaXB0aW9uQWRkIGFuZCBhZnRlclN1YnNjcmlwdGlvblJlbW92ZSBtZXRob2RzIHRoYXQgd2UgaGFjayBoZXJlLlxuLy8gc28gd2UgaGF2ZSB0byBleHBsaWNpdGx5IGtub3cgdGhhdC5cbnZhciBiZWZvcmVTdWJzY3JpcHRpb25Qcm9wO1xudmFyIGFmdGVyU3Vic2NyaXB0aW9uUHJvcDtcbmlmICh0eXBlb2Yga28uREVCVUcgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBrby5pc1dyaXRhYmxlT2JzZXJ2YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmVmb3JlU3Vic2NyaXB0aW9uUHJvcCA9ICdiZWZvcmVTdWJzY3JpcHRpb25BZGQnO1xuICBhZnRlclN1YnNjcmlwdGlvblByb3AgPSAnYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUnO1xufSBlbHNlIGlmIChrby52ZXJzaW9uID09IFwiMy4yLjBcIikge1xuICBiZWZvcmVTdWJzY3JpcHRpb25Qcm9wID0gJ3ZhJztcbiAgYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wID0gJ25iJztcbn0gZWxzZSBpZiAoa28udmVyc2lvbiA9PSBcIjMuMy4wXCIpIHtcbiAgYmVmb3JlU3Vic2NyaXB0aW9uUHJvcCA9ICdqYSc7XG4gIGFmdGVyU3Vic2NyaXB0aW9uUHJvcCA9ICd1YSc7XG59IGVsc2UgaWYgKGtvLnZlcnNpb24gPT0gXCIzLjQuMFwiKSB7XG4gIGJlZm9yZVN1YnNjcmlwdGlvblByb3AgPSAnc2EnO1xuICBhZnRlclN1YnNjcmlwdGlvblByb3AgPSAnSWEnO1xufVxuZWxzZSB0aHJvdyBcIlVuc3VwcG9ydGVkIG1pbmltaXplZCBLbm9ja291dCB2ZXJzaW9uIFwiICsga28udmVyc2lvbiArIFwiIChzdXBwb3J0ZWQgREVCVUcgb3IgbWluaW1pemVkIDMuMi4wIC4uLiAzLjQuMClcIjtcblxuLy8gaW50ZXJuYWxseSB1c2VkIGJ5IGlmc3VicyBiaW5kaW5nLlxuLy8gV0FSTklORyB0aGlzIGJyZWFrIHdoZW4gdXNlZCB3aXRoIHB1cmVDb21wdXRlZCBvciBkZWZlcnJlZEV2YWx1YXRlZFxua28uZXh0ZW5kZXJzWydzdWJzY3JpcHRpb25zQ291bnQnXSA9IGZ1bmN0aW9uKHRhcmdldCwgbDEsIGwyKSB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0LnN1YnNDb3VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0YXJnZXQuc3Vic0NvdW50ID0ga28ub2JzZXJ2YWJsZSh0YXJnZXQuZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkpLmV4dGVuZCh7XG4gICAgICBub3RpZnk6ICdhbHdheXMnXG4gICAgfSk7XG4gICAgdmFyIHVuZGVybHlpbmdCZWZvcmVTdWJzY3JpcHRpb25BZGRGdW5jdGlvbiA9IHRhcmdldFtiZWZvcmVTdWJzY3JpcHRpb25Qcm9wXTtcbiAgICB2YXIgdW5kZXJseWluZ0FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlRnVuY3Rpb24gPSB0YXJnZXRbYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wXTtcbiAgICB0YXJnZXRbYmVmb3JlU3Vic2NyaXB0aW9uUHJvcF0gPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgaWYgKHVuZGVybHlpbmdCZWZvcmVTdWJzY3JpcHRpb25BZGRGdW5jdGlvbikgdW5kZXJseWluZ0JlZm9yZVN1YnNjcmlwdGlvbkFkZEZ1bmN0aW9uLmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICB2YXIgYyA9IHRhcmdldC5nZXRTdWJzY3JpcHRpb25zQ291bnQoKSArIDE7XG4gICAgICBpZiAodHlwZW9mIGwxID09PSAndW5kZWZpbmVkJyB8fCBjID09IGwxIHx8IHR5cGVvZiBsMiA9PT0gJ3VuZGVmaW5lZCcgfHwgYyA9PSBsMikgdGFyZ2V0LnN1YnNDb3VudChjKTtcbiAgICB9O1xuICAgIHRhcmdldFthZnRlclN1YnNjcmlwdGlvblByb3BdID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmICh1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbikgdW5kZXJseWluZ0FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlRnVuY3Rpb24uY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgIHZhciBjID0gdGFyZ2V0LmdldFN1YnNjcmlwdGlvbnNDb3VudCgpO1xuICAgICAgaWYgKHR5cGVvZiBsMSA9PT0gJ3VuZGVmaW5lZCcgfHwgYyA9PSBsMSB8fCB0eXBlb2YgbDIgPT09ICd1bmRlZmluZWQnIHx8IGMgPT0gbDIpIHRhcmdldC5zdWJzQ291bnQoYyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhcImFscmVhZHkgYXBwbGllZCBzdWJzY3JpcHRpb25Db3VudCB0byBvYnNlcnZhYmxlXCIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBPdmVycmlkZXMgbmF0aXZlIGpRdWVyeSBzcGlubmVyIHRvIGF2b2lkIHZhbGlkYXRpb24gb2YgdGhlIFwic3RlcFwiLlxuLy8gV2Ugd2FudHMgdG8gdXNlIHRoZSBzdGVwIGJ1dCBhbHNvIHdhbnRzIHRvIGxlYXZlIHRoZSB1c2VyIHRoZSBhYmlsaXR5IHRvIHNlbGVjdCBzcGVjaWZpYyB2YWx1ZXMuXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBzcGlubmVyID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddWyd1aSddWydzcGlubmVyJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXVsndWknXVsnc3Bpbm5lciddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG5pZiAodHlwZW9mIHNwaW5uZXIgPT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiQ2Fubm90IGZpbmQganF1ZXJ5LXVpIHNwaW5uZXIgd2lkZ2V0IGRlcGVuZGVuY3khXCI7XG5cbiQud2lkZ2V0KFwidWkuc3Bpbm5lclwiLCBzcGlubmVyLCB7XG4gIF9hZGp1c3RWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgYWRqID0gdGhpcy5fc3VwZXIodmFsdWUpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAvLyBmaXggcHJlY2lzaW9uIGZyb20gYmFkIEpTIGZsb2F0aW5nIHBvaW50IG1hdGhcbiAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZCh0aGlzLl9wcmVjaXNpb24oKSkpO1xuXG4gICAgLy8gY2xhbXAgdGhlIHZhbHVlXG4gICAgaWYgKG9wdGlvbnMubWF4ICE9PSBudWxsICYmIHZhbHVlID4gb3B0aW9ucy5tYXgpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm1heDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWluICE9PSBudWxsICYmIHZhbHVlIDwgb3B0aW9ucy5taW4pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm1pbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE92ZXJyaWRlcyBuYXRpdmUgalF1ZXJ5IHRhYnMgdG8gbWFrZSB0YWJzIHdvcmtpbmcgYWxzbyB3aGVuIHVzaW5nIGEgYmFzZSB0YWdcbi8vIGluIG9yZGVyIHRvIGF2b2lkIGNvbmZsaWN0cyB5b3UgaGF2ZSB0byBhZGQgYSBkYXRhLWxvY2FsPVwidHJ1ZVwiIGF0dHJpYnV0ZSB0byB5b3VyIHRhYiBsaW5rcy5cblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciB0YWJzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddWyd1aSddWyd0YWJzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXVsndWknXVsndGFicyddIDogbnVsbCk7XG5cbmlmICh0eXBlb2YgdGFicyA9PSAndW5kZWZpbmVkJykgdGhyb3cgXCJDYW5ub3QgZmluZCBqcXVlcnktdWkgdGFicyB3aWRnZXQgZGVwZW5kZW5jeSFcIjtcblxuJC53aWRnZXQoXCJ1aS50YWJzXCIsIHRhYnMsIHtcbiAgX2lzTG9jYWw6IGZ1bmN0aW9uKCBhbmNob3IgKSB7XG4gICAgaWYgKGFuY2hvci5nZXRBdHRyaWJ1dGUoJ2RhdGEtbG9jYWwnKSA9PSBcInRydWVcIikgcmV0dXJuIHRydWU7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG4gIH1cbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBnbG9iYWw6IGZhbHNlICovXG5cbmZ1bmN0aW9uIHB1c2hUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUsIHRlbXBsYXRlVGV4dCkge1xuICB2YXIgc2NyaXB0VGFnID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHRUYWcuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvaHRtbCcpO1xuICBzY3JpcHRUYWcuc2V0QXR0cmlidXRlKCdpZCcsIHRlbXBsYXRlTmFtZSk7XG4gIHNjcmlwdFRhZy50ZXh0ID0gdGVtcGxhdGVUZXh0O1xuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRUYWcpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUpIHtcbiAgdmFyIGVsID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBsYXRlTmFtZSk7XG4gIGlmIChlbCkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7fVxuXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZUNvbnRlbnQoaWQpIHtcbiAgdmFyIGVsID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgaWYgKGVsKSByZXR1cm4gZWwuaW5uZXJIVE1MO1xuICBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBpbml0LFxuICBhZGRUZW1wbGF0ZTogcHVzaFRlbXBsYXRlLFxuICByZW1vdmVUZW1wbGF0ZTogcmVtb3ZlVGVtcGxhdGUsXG4gIGdldFRlbXBsYXRlQ29udGVudDogZ2V0VGVtcGxhdGVDb250ZW50XG59OyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UgKi9cblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xudmFyIHRpbnltY2UgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndGlueW1jZSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndGlueW1jZSddIDogbnVsbCk7XG5cbnZhciB0aW1lb3V0O1xuXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgdGltZW91dCA9IHVuZGVmaW5lZDtcblxuICBpZiAodHlwZW9mIHRpbnltY2UuYWN0aXZlRWRpdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLnZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQHNlZSBGbG9hdFBhbmVsLmpzIGZ1bmN0aW9uIHJlcG9zaXRpb25QYW5lbChwYW5lbClcbiAgICAvLyBGaXJzdCBjb25kaXRpb24gZ3JvdXAgaXMgZm9yIFRpbnltY2UgNC4wLzQuMVxuICAgIC8vIFNlY29uZCBjb25kaXRpb24gZ3JvdXAgaXMgZm9yIFRpbnltY2UgNC4yLzQuMyB3aGVyZSBcIi5fcHJvcGVydHlcIiBhcmUgbm93IGF2YWlsYWJsZSBhcyBcIi5zdGF0ZS5nZXQoJ3Byb3BlcnR5JylcIi5cbiAgICBpZiAoKHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5fdmlzaWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuX3Zpc2libGUgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuX2ZpeGVkKSB8fCBcbiAgICAgICAgKHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5zdGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuc3RhdGUuZ2V0KCd2aXNpYmxlJykgJiYgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuc3RhdGUuZ2V0KCdmaXhlZCcpKSkge1xuICAgICAgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwuZml4ZWQoZmFsc2UpO1xuICAgIH1cblxuICAgIHRpbnltY2UuYWN0aXZlRWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgLy8gRG9uJ3QgZm9yY2UgdGlueW1jZSB0byBiZSB2aXNpYmxlIG9uIHNjcm9sbHNcbiAgICAvLyBJZiBzZXR0ZWVkLCBUaGlzIHdpbGwgc2hvdyB0aGUgdGlueW1jZSBjb250cm9scyBldmVudCB3aGVuIG5vbiBhcmUgc2VsZWN0ZWRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZGVub3VnaC9tb3NhaWNvL2lzc3Vlcy83I2lzc3VlY29tbWVudC0yMzY4NTMzMDVcbiAgICAvLyB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC52aXNpYmxlKHRydWUpO1xuICAgIGlmICh0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5sYXlvdXRSZWN0KCkueSA8PSA0MClcbiAgICAgIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLm1vdmVCeSgwLCA0MCAtIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLmxheW91dFJlY3QoKS55KTtcblxuICB9XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1Njcm9sbGZpeCA9IHtcbiAgJ3Njcm9sbCc6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRpbWVvdXQpIGdsb2JhbC5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0KHJlbmRlciwgNTApO1xuICB9LFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgJChlbGVtZW50KS5vZmYoXCJzY3JvbGxcIiwga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTY3JvbGxmaXguc2Nyb2xsKTtcbiAgICB9KTtcblxuICAgICQoZWxlbWVudCkub24oXCJzY3JvbGxcIiwga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTY3JvbGxmaXguc2Nyb2xsKTtcblxuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbnZhciBfc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbigkZWxlbWVudCwgYWxpZ25Ub3AsIHNjcm9sbFBhcmVudCwgbW92ZUJ5KSB7XG4gIHZhciBjdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xuICB2YXIgbmV3U2Nyb2xsVG9wID0gY3VycmVudFNjcm9sbFRvcCAtIG1vdmVCeSAtIChhbGlnblRvcCA/IDIwIDogLTIwKTtcbiAgLy8gaWZyYW1lIHNjcm9sbHMgdGhlIHdpbmRvdyBhbmQgYW5pbWF0aW9uIGlzIG5vdCBzdXBwb3J0ZWRcbiAgdmFyIGFuaW1hdGUgPSB0eXBlb2Ygc2Nyb2xsUGFyZW50WzBdLm5vZGVUeXBlICE9PSAndW5kZWZpbmVkJztcbiAgaWYgKGFuaW1hdGUpIHtcbiAgICB2YXIgYWN0aW9uID0ge1xuICAgICAgJ3Njcm9sbFRvcCc6IFwiXCIgKyBNYXRoLnJvdW5kKG5ld1Njcm9sbFRvcCkgKyBcInB4XCJcbiAgICB9O1xuICAgIHZhciB0aW1lID0gTWF0aC5yb3VuZChNYXRoLmFicyhuZXdTY3JvbGxUb3AgLSBjdXJyZW50U2Nyb2xsVG9wKSk7XG4gICAgc2Nyb2xsUGFyZW50LnN0b3AoKS5hbmltYXRlKGFjdGlvbiwgdGltZSk7XG4gIH0gZWxzZSB7XG4gICAgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcChuZXdTY3JvbGxUb3ApO1xuICB9XG4gIC8vIG5hdGl2ZSBzY3JvbGxJbnRvVmlldyBpcyBub3Qgd2VsbCBzdXBwb3J0ZWQgYW5kIGRvZXNuJ3Qgd29yayBmaW5lLlxuICAvLyBlbGVtZW50LnNjcm9sbEludG9WaWV3KGFsaWduVG9wKTtcbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxJbnRvVmlldyA9IHtcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIHNlbGVjdGVkID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIGlmICghc2VsZWN0ZWQpIHJldHVybjtcbiAgICB0cnkge1xuXG4gICAgICB3aGlsZSAoZWxlbWVudC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBlbGVtZW50IGlzIGEgY29tbWVudCwgbW92ZSB0byB0aGUgbmV4dCBzaWJsaW5nLi4uXG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDgpIHtcbiAgICAgICAgdmFyIHNjcm9sbFBhcmVudCA9ICQoZWxlbWVudCkuc2Nyb2xsUGFyZW50KCk7XG5cbiAgICAgICAgdmFyIHBhcmVudFRvcDtcbiAgICAgICAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZmFsc2U7XG4gICAgICAgIGlmIChzY3JvbGxQYXJlbnRbMF0ubm9kZVR5cGUgPT0gOSkge1xuICAgICAgICAgIC8vIHNjcm9sbHBhcmVudCBpcyBkb2N1bWVudCwgcmVwbGFjaW5nIHdpdGggYm9keS4uLlxuICAgICAgICAgIHNjcm9sbFBhcmVudCA9ICQoc2Nyb2xsUGFyZW50WzBdLmRlZmF1bHRWaWV3KTtcbiAgICAgICAgICBwYXJlbnRUb3AgPSAwO1xuICAgICAgICAgIHJlbGF0aXZlT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUb3AgPSBzY3JvbGxQYXJlbnQub2Zmc2V0KCkudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudEhlaWdodCA9IHNjcm9sbFBhcmVudC5oZWlnaHQoKTtcbiAgICAgICAgdmFyIHBhcmVudFNjcm9sbCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcbiAgICAgICAgdmFyIHBhcmVudEJvdHRvbSA9IHBhcmVudFRvcCArIHBhcmVudEhlaWdodDtcblxuICAgICAgICAvLyBzY3JvbGxQYXJlbnQgaXMgdGhlIGRvY3VtZW50LlxuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICB2YXIgZWxUb3AgPSAkZWxlbWVudC5vZmZzZXQoKS50b3A7XG4gICAgICAgIC8vIHdoZW4gd2UgYXJlIGluIFwiaWZyYW1lXCIgd2l0aCBzY3JvbGxiYXIgZXZlcnl0aGlqbmcgY2hhbmdlcy5cbiAgICAgICAgaWYgKHJlbGF0aXZlT2Zmc2V0KSBlbFRvcCA9IGVsVG9wIC0gcGFyZW50U2Nyb2xsO1xuICAgICAgICB2YXIgZWxIZWlnaHQgPSAkZWxlbWVudC5oZWlnaHQoKTtcbiAgICAgICAgdmFyIGVsQm90dG9tID0gZWxUb3AgKyBlbEhlaWdodDtcbiAgICAgICAgaWYgKGVsVG9wID4gcGFyZW50VG9wICYmIGVsVG9wICsgZWxIZWlnaHQgPCBwYXJlbnRCb3R0b20pIHtcbiAgICAgICAgICAvLyBib3RoIGJvcmRlcnMgYXJlIHZpc2libGUgPT4gZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgIH0gZWxzZSBpZiAoZWxIZWlnaHQgPCBwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgYmxvY2sgaXMgc21hbGxlciB0aGFuIHRoZSB2aWV3UG9ydFxuICAgICAgICAgIGlmIChlbFRvcCA8IHBhcmVudFRvcCkgX3Njcm9sbEludG9WaWV3KGVsZW1lbnQsIHRydWUsIHNjcm9sbFBhcmVudCwgcGFyZW50VG9wIC0gZWxUb3ApO1xuICAgICAgICAgIC8vIC0+IGlmIHRoZSB1cHBlciBib3JkZXIgaXMgaGlnaGVyIHRoYW4gdGhlIHRvcCwgdGhlbiBJIG1vdmUgaXQgdG8gdGhlIHRvcC5cbiAgICAgICAgICBpZiAoZWxCb3R0b20gPiBwYXJlbnRCb3R0b20pIF9zY3JvbGxJbnRvVmlldyhlbGVtZW50LCBmYWxzZSwgc2Nyb2xsUGFyZW50LCBwYXJlbnRCb3R0b20gLSBlbEJvdHRvbSk7XG4gICAgICAgICAgLy8gLT4gaWYgdGhlIGJvdHRvbSBib3JkZXIgaXMgbG93ZXIgdGhhbiB0aGUgYm90dG9tIHRoZW4gSSBtb3ZlIGl0IHRvIHRoZSBib3R0b20uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGJsb2NrIGlzIGxhcmdlciB0aGFuIHRoZSB2aWV3UG9ydCB3ZSBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgICAgICAgLy8gLT4gaWYgdGhlIHVwcGVyIGJvcmRlciBpcyBoaWdoZXIgdGhhbiB0aGUgdG9wIGFuZCB0aGUgbG93ZXIgaXMgaGlnaGVyIHRoYW4gdGhlIGJvdHRvbSBJIG1vdmUgdGhlIGxvd2VyIGl0IHRvIHRoZSBib3R0b20uXG4gICAgICAgICAgaWYgKGVsVG9wIDwgcGFyZW50VG9wICYmIGVsQm90dG9tIDwgcGFyZW50Qm90dG9tKSBfc2Nyb2xsSW50b1ZpZXcoZWxlbWVudCwgZmFsc2UsIHNjcm9sbFBhcmVudCwgcGFyZW50Qm90dG9tIC0gZWxCb3R0b20pO1xuICAgICAgICAgIC8vIC0+IGlmIHRoZSBib3R0b20gYm9yZGVyIGlsIGxvd2VyIHRoYW4gYm90dG9tIGFuZCB0aGUgdXBwZXIgaXMgbG93ZXIgdGhhbiB0aGUgdG9wIEkgbW92ZSB0aGUgdXBwZXIgYm9yZGVyIHRvIHRoZSB2aWV3cG9ydCB0b3BcbiAgICAgICAgICBpZiAoZWxUb3AgPiBwYXJlbnRUb3AgJiYgZWxCb3R0b20gPiBwYXJlbnRCb3R0b20pIF9zY3JvbGxJbnRvVmlldyhlbGVtZW50LCB0cnVlLCBzY3JvbGxQYXJlbnQsIHBhcmVudFRvcCAtIGVsVG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcodHJ1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coXCJUT0RPIGV4Y2VwdGlvbiBzY3JvbGxpbmcgaW50byB2aWV3XCIsIGUpO1xuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3Njcm9sbEludG9WaWV3J10gPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBvcmlnVGVtcGxhdGVTeXN0ZW0gPSByZXF1aXJlKFwiLi9zY3JpcHQtdGVtcGxhdGUuanNcIik7XG5cbnZhciB0ZW1wbGF0ZXMgPSB7fTtcblxuLy9kZWZpbmUgYSB0ZW1wbGF0ZSBzb3VyY2UgdGhhdCBzaW1wbHkgdHJlYXRzIHRoZSB0ZW1wbGF0ZSBuYW1lIGFzIGl0cyBjb250ZW50XG5rby50ZW1wbGF0ZVNvdXJjZXMuc3RyaW5nVGVtcGxhdGUgPSBmdW5jdGlvbih0ZW1wbGF0ZU5hbWUsIHRlbXBsYXRlKSB7XG4gIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIHRoaXMuX2RhdGEgPSB7fTtcbn07XG5cbmtvLnV0aWxzLmV4dGVuZChrby50ZW1wbGF0ZVNvdXJjZXMuc3RyaW5nVGVtcGxhdGUucHJvdG90eXBlLCB7XG4gIGRhdGE6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcImRhdGFcIiwga2V5LCB2YWx1ZSwgdGhpcy50ZW1wbGF0ZU5hbWUpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YVtrZXldO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGFba2V5XSA9IHZhbHVlO1xuICB9LFxuICB0ZXh0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwidGV4dFwiLCB2YWx1ZSwgdGhpcy50ZW1wbGF0ZU5hbWUpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlO1xuICAgIH1cbiAgICB0aGlzLnRlbXBsYXRlID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5cbi8vbW9kaWZ5IGFuIGV4aXN0aW5nIHRlbXBsYXRlRW5naW5lIHRvIHdvcmsgd2l0aCBzdHJpbmcgdGVtcGxhdGVzXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdUZW1wbGF0ZUVuZ2luZSh0ZW1wbGF0ZUVuZ2luZSkge1xuICB2YXIgb3JpZyA9IHRlbXBsYXRlRW5naW5lLm1ha2VUZW1wbGF0ZVNvdXJjZTtcbiAgdGVtcGxhdGVFbmdpbmUubWFrZVRlbXBsYXRlU291cmNlID0gZnVuY3Rpb24odGVtcGxhdGVOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZXNbdGVtcGxhdGVOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcga28udGVtcGxhdGVTb3VyY2VzLnN0cmluZ1RlbXBsYXRlKHRlbXBsYXRlTmFtZSwgdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3JpZyh0ZW1wbGF0ZU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRlbXBsYXRlRW5naW5lO1xufVxuXG5mdW5jdGlvbiBwdXNoVGVtcGxhdGUodGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZVRleHQpIHtcbiAgdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV0gPSB0ZW1wbGF0ZVRleHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRlbXBsYXRlKHRlbXBsYXRlTmFtZSkge1xuICBpZiAodHlwZW9mIHRlbXBsYXRlc1t0ZW1wbGF0ZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRlbXBsYXRlc1t0ZW1wbGF0ZU5hbWVdID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIG9yaWdUZW1wbGF0ZVN5c3RlbS5yZW1vdmVUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGtvLnNldFRlbXBsYXRlRW5naW5lKGNyZWF0ZVN0cmluZ1RlbXBsYXRlRW5naW5lKG5ldyBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSgpKSk7XG59XG5cbmZ1bmN0aW9uIGdldFRlbXBsYXRlQ29udGVudChpZCkge1xuICBpZiAodHlwZW9mIHRlbXBsYXRlc1tpZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlc1tpZF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9yaWdUZW1wbGF0ZVN5c3RlbS5nZXRUZW1wbGF0ZUNvbnRlbnQoaWQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBpbml0LFxuICBhZGRUZW1wbGF0ZTogcHVzaFRlbXBsYXRlLFxuICByZW1vdmVUZW1wbGF0ZTogcmVtb3ZlVGVtcGxhdGUsXG4gIGdldFRlbXBsYXRlQ29udGVudDogZ2V0VGVtcGxhdGVDb250ZW50XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrb2pxdWkgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna29qcXVpJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrb2pxdWknXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxudmFyIGV4dGVuZFZhbHVlQWNjZXNzb3IgPSBmdW5jdGlvbih2YWx1ZUFjY2Vzc29yLCBvYmopIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGtvLnV0aWxzLmV4dGVuZChvYmosIHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG5cbnZhciBvcHRpb25zID0ge1xuICBzaG93OiB7XG4gICAgZGVsYXk6IDUwMFxuICB9LFxuICB0cmFjazogdHJ1ZSxcbiAgaXRlbXM6ICdbdGl0bGVdW3RpdGxlIT1cIlwiXVt0aXRsZSE9XCIgXCJdJ1xufTtcblxua28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXBzID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiAkLmZuLnRvb2x0aXAgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBrby5iaW5kaW5nSGFuZGxlcnMudG9vbHRpcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHBvc2l0aW9uOiB7IG15OiBcImxlZnQrMTUgdG9wKzE1XCIsIGF0OiBcImNlbnRlciszMCBjZW50ZXIrMzBcIiB9XG4gICAgICAvLyBOT1RFIHRpdGxlIHdpdGggXCJcIiBhbmQgXCIgXCIgaXMgbmVlZGVkIHRvIGF2b2lkIGRlZmF1bHQgdG9vbHRpcHMgaW4gbmF0aXZlIGZpbGUgdXBsb2FkIGNvbnRyb2xzXG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXAuaW5pdChlbGVtZW50LCBleHRlbmRWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IsIG9wdGlvbnMpLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgIGlmICh0eXBlb2YgJC5mbi50b29sdGlwICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Yga28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXAudXBkYXRlKGVsZW1lbnQsIGV4dGVuZFZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3Nvciwgb3B0aW9ucyksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuLy8gZXF1YWxzIHRvIFwidmFsdWVcIiBiaW5kaW5nIGJ1dCBhcHBseSBcImludmFsaWRcIiBjbGFzcyBpZiBcInBhdHRlcm5cIiBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgdmFsdWUgbWF0Y2hlcyB0aGUgcnVsZVxua28uYmluZGluZ0hhbmRsZXJzWyd2YWxpZGF0ZWRWYWx1ZSddID0ge1xuXHRpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuXHRcdHZhciBuZXdWYWx1ZUFjY2Vzc29yID0gdmFsdWVBY2Nlc3Nvcjtcblx0XHRpZiAodHlwZW9mIGVsZW1lbnQucGF0dGVybiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHZhciByZSA9IG5ldyBSZWdFeHAoJ14oPzonICsgZWxlbWVudC5wYXR0ZXJuICsgJykkJyk7XG5cdFx0XHR2YXIgY29tcHV0ZWQgPSBrby5jb21wdXRlZCh7XG5cdFx0XHRcdHJlYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciByZXMgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG5cdFx0XHRcdFx0Ly8gVE9ETyBzdXBwb3J0IGZvciBlbGVtZW50LnJlcXVpcmVkID9cblx0XHRcdFx0XHR2YXIgdmFsaWQgPSByZXMgPT09IG51bGwgfHwgcmVzID09PSAnJyB8fCByZS50ZXN0KHJlcyk7XG5cdFx0XHRcdFx0Ly8gSUUxMSBkb2Vzbid0IHN1cHBvcnQgY2xhc3NMaXN0LnRvZ2dsZSgnaW52YWxpZCcsIHN0YXRlKVxuXHRcdFx0XHRcdGlmICh2YWxpZCkge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpbnZhbGlkJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaW52YWxpZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cml0ZToga28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgJiYgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92b2lkbGFicy9tb3NhaWNvL2lzc3Vlcy8xMDNcblx0XHRcdFx0XHRrby5zZWxlY3RFeHRlbnNpb25zLndyaXRlVmFsdWUoZWxlbWVudCwgdmFsdWUpO1xuXHRcdFx0XHRcdHZhciB1cGRWYWx1ZSA9IGtvLnNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHZhbHVlQWNjZXNzb3IoKSh1cGRWYWx1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuXHRcdFx0fSk7XG5cdFx0XHRuZXdWYWx1ZUFjY2Vzc29yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBjb21wdXRlZDtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGtvLmJpbmRpbmdIYW5kbGVyc1sndmFsdWUnXS5pbml0KGVsZW1lbnQsIG5ld1ZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzKTtcblx0fVxufTtcbmtvLmV4cHJlc3Npb25SZXdyaXRpbmcuX3R3b1dheUJpbmRpbmdzWyd2YWxpZGF0ZWRWYWx1ZSddID0gdHJ1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBnbG9iYWw6ZmFsc2UgKi9cblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3VuaXF1ZUlkJ10gPSB7XG4gIGN1cnJlbnRJbmRleDogMCxcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgdmFyIGRhdGEgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfHwge307XG4gICAgaWYgKGRhdGEuaWQoKSA9PT0gJycpIHtcbiAgICAgIHZhciBpZCwgZWwsIHByZWZpeDtcbiAgICAgIC8vIFRPRE8gd2UgbmVlZCBhIGJldHRlciBwcmVmaXhcbiAgICAgIHByZWZpeCA9ICdrb18nICsgKHR5cGVvZiBkYXRhLnR5cGUgIT09ICd1bmRlZmluZWQnID8ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShkYXRhLnR5cGUpIDogJ2Jsb2NrJyk7XG4gICAgICAvLyB3aGVuIGxvYWRpbmcgYW4gZXhpc2luZyBtb2RlbCwgSURzIGNvdWxkIGJlIGFscmVhZHkgYXNzaWduZWQuXG4gICAgICBkbyB7XG4gICAgICAgIGlkID0gcHJlZml4ICsgJ18nICsgKCsra28uYmluZGluZ0hhbmRsZXJzWyd1bmlxdWVJZCddLmN1cnJlbnRJbmRleCk7XG4gICAgICAgIGVsID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgLy8gd2hlbiBsb2FkaW5nIGFuIGV4aXN0aW5nIG1vZGVsIG15IFwiY3VycmVudEluZGV4XCIgaXMgZW1wdHkuXG4gICAgICAgICAgLy8gYnV0IHdlIGhhdmUgZXhpc3RpbmcgYmxvY2tzLCBzbyBJIG11c3QgYmUgc3VyZSBJIGRvbid0IHJldXNlIHRoZWlyIElEcy5cbiAgICAgICAgICAvLyBXZSB1c2UgZGlmZmVyZW50IHByZWZpeGVzIChwZXIgYmxvY2sgdHlwZSkgc28gdGhhdCBhIGhpZGRlbiBibG9jayBcbiAgICAgICAgICAvLyAoZm9yIHdoaWNoIHdlIGhhdmUgbm8gaWQgaW4gdGhlIHBhZ2UsIGUuZzogcHJlaGVhZGVyIGluIHZlcnNhZml4LTEpXG4gICAgICAgICAgLy8gd2lsbCBicmVhayBldmVydGhpbmcgb25jZSB3ZSByZXVzZSBpdHMgbmFtZS5cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoZWwpO1xuICAgICAgZGF0YS5pZChpZCk7XG4gICAgfVxuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1sndW5pcXVlSWQnXSA9IHRydWU7XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1sndmlydHVhbEF0dHInXSA9IHtcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDgpIHtcbiAgICAgIGtvLmJpbmRpbmdIYW5kbGVyc1snYXR0ciddLnVwZGF0ZShlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKTtcbiAgICB9XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd2aXJ0dWFsQXR0ciddID0gdHJ1ZTtcblxua28uYmluZGluZ0hhbmRsZXJzWyd2aXJ0dWFsQXR0clN0eWxlJ10gPSB7XG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSA4KSB7XG4gICAgICAvLyBJbiBcInByZXZpZXdcIiB3ZSBhbHNvIHNldCBcInJlcGxhY2Vkc3R5bGVcIiBzbyB0byBoYXZlIGFuIGF0dHJpYnV0ZSB0byBiZSB1c2VkIGJ5IElFIChJRSBicmVha3MgdGhlIFNUWUxFKSB0byBkbyB0aGUgZXhwb3J0LlxuICAgICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICAgIHZhciBhdHRycyA9IFtcInN0eWxlXCJdO1xuICAgICAgaWYgKGlzTm90V3lzaXd5Z01vZGUpIGF0dHJzLnB1c2goXCJyZXBsYWNlZHN0eWxlXCIpO1xuICAgICAgdmFyIGF0dHJWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gYXR0cnNbaV07XG4gICAgICAgIHZhciB0b1JlbW92ZSA9IChhdHRyVmFsdWUgPT09IGZhbHNlKSB8fCAoYXR0clZhbHVlID09PSBudWxsKSB8fCAoYXR0clZhbHVlID09PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAodG9SZW1vdmUpXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd2aXJ0dWFsQXR0clN0eWxlJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZpcnR1YWxTdHlsZSddID0ge1xuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gOCkge1xuICAgICAga28uYmluZGluZ0hhbmRsZXJzWydzdHlsZSddLnVwZGF0ZShlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKTtcbiAgICB9XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXSA9IHRydWU7XG5cblxua28uYmluZGluZ0hhbmRsZXJzWyd2aXJ0dWFsSHRtbCddID0ge1xuICBpbml0OiBrby5iaW5kaW5nSGFuZGxlcnNbJ2h0bWwnXS5pbml0LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgdmFyIGh0bWwgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG5cbiAgICAgIGtvLnZpcnR1YWxFbGVtZW50cy5lbXB0eU5vZGUoZWxlbWVudCk7XG4gICAgICBpZiAoKGh0bWwgIT09IG51bGwpICYmIChodG1sICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBodG1sID0gaHRtbC50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnNlZE5vZGVzID0ga28udXRpbHMucGFyc2VIdG1sRnJhZ21lbnQoaHRtbCk7XG4gICAgICAgIGlmIChwYXJzZWROb2Rlcykge1xuICAgICAgICAgIHZhciBlbmRDb21tZW50Tm9kZSA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBwYXJzZWROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgICAgICBlbmRDb21tZW50Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYXJzZWROb2Rlc1tpXSwgZW5kQ29tbWVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gcGxhaW4gbm9kZVxuICAgICAga28uYmluZGluZ0hhbmRsZXJzWydodG1sJ10udXBkYXRlKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpO1xuICAgIH1cblxuICAgIC8vIENvbnRlbnQgZm9yIHZpcnR1YWxIVE1MIG11c3Qgbm90IGJlIHBhcnNlZCBieSBLTywgaXQgaXMgc2ltcGxlIGNvbnRlbnQuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3ZpcnR1YWxIdG1sJ10gPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UgKi9cblxudmFyIHRpbnltY2UgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndGlueW1jZSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndGlueW1jZSddIDogbnVsbCk7XG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5yZXF1aXJlKFwiLi9ldmVudGFibGUuanNcIik7XG5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnT3JIdG1sID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcblxuICAgIGlmIChpc05vdFd5c2l3eWdNb2RlKVxuICAgICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVyc1sndmlydHVhbEh0bWwnXS5pbml0KCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLmluaXQoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciBpc05vdFd5c2l3eWdNb2RlID0gKHR5cGVvZiBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPT0gJ3VuZGVmaW5lZCcgfHwgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlICE9ICd3eXNpd3lnJyk7XG4gICAgaWYgKGlzTm90V3lzaXd5Z01vZGUpXG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd2aXJ0dWFsSHRtbCddLnVwZGF0ZShlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgICAvL2Vsc2UgXG4gICAgLy8gIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy51cGRhdGUoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd3eXNpd3lnT3JIdG1sJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0hyZWYgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gOCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZUFjY2Vzc29yKCk7XG5cbiAgICAgIHZhciBpc05vdFd5c2l3eWdNb2RlID0gKHR5cGVvZiBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPT0gJ3VuZGVmaW5lZCcgfHwgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlICE9ICd3eXNpd3lnJyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlhYWFwiLCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUsIGlzTm90V3lzaXd5Z01vZGUsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSk7XG4gICAgICBpZiAoaXNOb3RXeXNpd3lnTW9kZSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19uZXcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qanNoaW50IHNjcmlwdHVybDp0cnVlKi9cbiAgICAgICAgLy8gMjAxNTAyMjY6IHJlbW92ZWQgaHJlZiB0byB3b3JrIGFyb3VuZCBGRiBpc3N1ZXMgd2l0aCA8YSBocmVmPVwiXCI+PGRpdiBjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCI+Li48L2Rpdj48L2E+XG4gICAgICAgIC8vIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgJ2phdmFzY3JpcHQ6dm9pZCgwKScpO1xuICAgICAgICAvLyAyMDE1MDMwOTogb24gSUUsIGFuIGVkaXRhYmxlIDxhIGhyZWY9XCJcIiBkYXRhLWVkaXRhYmxlPVwiXCI+IHByZXZlbnQgdGlueW1jZSB0b29sYmFyIHRvIGJlIHNob3duLlxuICAgICAgICAvLyAgICAgICAgICAgc28gSSBjaGFuZ2UgYmVoYXZpb3VyIGJhc2VkIG9uIHRoZSB1c2Ugb2YgXCJ3eXNpd3lnT3JIdG1sXCJcbiAgICAgICAgLy8gQHNlZTogaHR0cDovL3d3dy50aW55bWNlLmNvbS9kZXZlbG9wL2J1Z3RyYWNrZXJfdmlldy5waHA/aWQ9NzQzMlxuICAgICAgICB2YXIgYWxsYmluZGluZ3MgPSBhbGxCaW5kaW5nc0FjY2Vzc29yKCk7XG4gICAgICAgIGlmICh0eXBlb2YgYWxsYmluZGluZ3Mud3lzaXd5Z09ySHRtbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaHJlZicsICdqYXZhc2NyaXB0OnZvaWQoMCknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZGhyZWYnLCAnIycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gOCkge1xuICAgICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICAgIC8vIE5PVEUgdGhpcyB1bndyYXAgaXMgbmVlZGVkIGFsc28gaW4gXCJ3eXNpd3lnXCIgbW9kZSwgb3RoZXJ3aXNlIGRlcGVuZGVuY3kgdHJhY2tpbmcgZGllcy5cbiAgICAgIHZhciBhdHRyVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgICBpZiAoaXNOb3RXeXNpd3lnTW9kZSkge1xuICAgICAgICBpZiAoKGF0dHJWYWx1ZSA9PT0gZmFsc2UpIHx8IChhdHRyVmFsdWUgPT09IG51bGwpIHx8IChhdHRyVmFsdWUgPT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgYXR0clZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3d5c2l3eWdIcmVmJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1NyYyA9IHtcbiAgY29udmVydGVkVXJsOiBmdW5jdGlvbihzcmMsIG1ldGhvZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciByZXMgPSBzcmMgKyBcIj9tZXRob2Q9XCIgKyBtZXRob2QgKyBcIiZ3aWR0aD1cIiArIHdpZHRoICsgKGhlaWdodCAhPT0gbnVsbCA/IFwiJmhlaWdodD1cIiArIGhlaWdodCA6ICcnKTtcbiAgICBjb25zb2xlLmxvZyhcImJhc2ljIGNvbnZlcnRlclVybFwiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIHBsYWNlaG9sZGVyVXJsOiBmdW5jdGlvbihwbHdpZHRoLCBwbGhlaWdodCwgcGx0ZXh0KSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyc3JjID0gXCInaHR0cDovL2xvcmVtcGl4ZWwuY29tL2cvJytcIiArIHBsd2lkdGggKyBcIisnLycrXCIgKyBwbGhlaWdodCArIFwiKycvYWJzdHJhY3QvJytlbmNvZGVVUklDb21wb25lbnQoXCIgKyBwbHRleHQgKyBcIilcIjtcbiAgICAvLyBodHRwOi8vcGxhY2Vob2xkLml0LzIwMHgxNTAucG5nL2NjY2NjYy8zMzMzMzMmdGV4dD1wbGFjZWhvbGQuaXQjc3RoYXNoLm5BM3IyNnZSLmRwdWZcbiAgICAvLyBwbGFjZWhvbGRlcnNyYyA9IFwiJ2h0dHA6Ly9wbGFjZWhvbGQuaXQvJytcIit3aWR0aCtcIisneCcrXCIraGVpZ2h0K1wiKycucG5nL2NjY2NjYy8zMzMzMzMmdGV4dD0nK1wiK3NpemU7XG4gICAgLy8gcGxhY2Vob2xkZXJzcmMgPSBcIidcIitjb252ZXJ0ZXJVdGlscy5hZGRTbGFzaGVzKGRlZmF1bHRWYWx1ZSkrXCInXCI7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICB2YXIgYXR0clZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZS5zcmMpO1xuICAgIHZhciBwbGFjZWhvbGRlclZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZS5wbGFjZWhvbGRlcik7XG4gICAgdmFyIHdpZHRoID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZS53aWR0aCk7XG4gICAgdmFyIGhlaWdodCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWUuaGVpZ2h0KTtcbiAgICBpZiAoKGF0dHJWYWx1ZSA9PT0gZmFsc2UpIHx8IChhdHRyVmFsdWUgPT09IG51bGwpIHx8IChhdHRyVmFsdWUgPT09IHVuZGVmaW5lZCkgfHwgKGF0dHJWYWx1ZSA9PT0gJycpKSB7XG4gICAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyVmFsdWUgPT0gJ29iamVjdCcgJiYgcGxhY2Vob2xkZXJWYWx1ZSAhPT0gbnVsbCkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLnBsYWNlaG9sZGVyVXJsKHBsYWNlaG9sZGVyVmFsdWUud2lkdGgsIHBsYWNlaG9sZGVyVmFsdWUuaGVpZ2h0LCBwbGFjZWhvbGRlclZhbHVlLnRleHQpKTtcbiAgICAgIGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWV0aG9kID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZS5tZXRob2QpO1xuICAgICAgaWYgKCFtZXRob2QpIG1ldGhvZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gJ2NvdmVyJyA6ICdyZXNpemUnO1xuICAgICAgdmFyIHNyYyA9IGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLmNvbnZlcnRlZFVybChhdHRyVmFsdWUudG9TdHJpbmcoKSwgbWV0aG9kLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJyAmJiB3aWR0aCAhPT0gbnVsbCkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCk7XG4gICAgZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcIndpZHRoXCIpO1xuICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJyAmJiBoZWlnaHQgIT09IG51bGwpIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImhlaWdodFwiKTtcbiAgfVxufTtcblxua28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdJZCA9IHtcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciBpc05vdFd5c2l3eWdNb2RlID0gKHR5cGVvZiBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPT0gJ3VuZGVmaW5lZCcgfHwgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlICE9ICd3eXNpd3lnJyk7XG4gICAgaWYgKCFpc05vdFd5c2l3eWdNb2RlKVxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICBpZiAoIWlzTm90V3lzaXd5Z01vZGUpXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkpO1xuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snd3lzaXd5Z0lkJ10gPSB0cnVlO1xuXG4vLyB1c2VkIG9uIGVkaXRhYmxlIFwiaXRlbVwiIHNvIHRvIGJpbmQgY2xpY2tzIG9ubHkgaW4gd3lzaXd5ZyBtb2RlLlxua28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdDbGljayA9IHtcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciBpc05vdFd5c2l3eWdNb2RlID0gKHR5cGVvZiBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPT0gJ3VuZGVmaW5lZCcgfHwgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlICE9ICd3eXNpd3lnJyk7XG4gICAgaWYgKCFpc05vdFd5c2l3eWdNb2RlKVxuICAgICAga28uYmluZGluZ0hhbmRsZXJzLmNsaWNrLmluaXQoZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd3eXNpd3lnQ2xpY2snXSA9IHRydWU7XG5cbi8vIHVzZWQgb24gZWRpdGFibGUgXCJpdGVtXCIgc28gdG8gYmluZCBjc3Mgb25seSBpbiB3eXNpd3lnIG1vZGUuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0NzcyA9IHtcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICBpZiAoIWlzTm90V3lzaXd5Z01vZGUpXG4gICAgICBrby5iaW5kaW5nSGFuZGxlcnMuY3NzLnVwZGF0ZShlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3d5c2l3eWdDc3MnXSA9IHRydWU7XG5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnSW1nID0ge1xuICBtYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yOiBmdW5jdGlvbih2YWx1ZUFjY2Vzc29yLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc1d5c2l3eWdNb2RlID0gKHR5cGVvZiBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3VuZGVmaW5lZCcgJiYgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd3eXNpd3lnJyk7XG5cbiAgICAgIHZhciBtb2RlbFZhbHVlID0gdmFsdWVBY2Nlc3NvcigpLFxuICAgICAgICB1bndyYXBwZWRWYWx1ZSA9IGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKG1vZGVsVmFsdWUpOyAvLyBVbndyYXAgd2l0aG91dCBzZXR0aW5nIGEgZGVwZW5kZW5jeSBoZXJlXG5cbiAgICAgIC8vIElmIHVud3JhcHBlZFZhbHVlLmRhdGEgaXMgdGhlIGFycmF5LCBwcmVzZXJ2ZSBhbGwgcmVsZXZhbnQgb3B0aW9ucyBhbmQgdW53cmFwIGFnYWluIHZhbHVlIHNvIHdlIGdldCB1cGRhdGVzXG4gICAgICBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKG1vZGVsVmFsdWUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbmFtZSc6IGlzV3lzaXd5Z01vZGUgPyB1bndyYXBwZWRWYWx1ZVsnX2VkaXRUZW1wbGF0ZSddIDogdW53cmFwcGVkVmFsdWVbJ190ZW1wbGF0ZSddLFxuICAgICAgICAndGVtcGxhdGVFbmdpbmUnOiBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZS5pbnN0YW5jZVxuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVyc1sndGVtcGxhdGUnXVsnaW5pdCddKGVsZW1lbnQsIGtvLmJpbmRpbmdIYW5kbGVyc1snd3lzaXd5Z0ltZyddLm1ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciwgYmluZGluZ0NvbnRleHQpKTtcbiAgfSxcbiAgJ3VwZGF0ZSc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgYmluZGluZ0NvbnRleHQgPSBiaW5kaW5nQ29udGV4dFsnZXh0ZW5kJ10odmFsdWVBY2Nlc3NvcigpKTtcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd0ZW1wbGF0ZSddWyd1cGRhdGUnXShlbGVtZW50LCBrby5iaW5kaW5nSGFuZGxlcnNbJ3d5c2l3eWdJbWcnXS5tYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IsIGJpbmRpbmdDb250ZXh0KSwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snd3lzaXd5Z0ltZyddID0gdHJ1ZTtcblxuLy8gTk9URTogdGhlcmUgYXJlIGlzc3VlcyB3aXRoIHRoZSBcInJhd1wiIGZvcm1hdCBhbmQgdHJhc2ggbGVmdCBhcm91bmQgYnkgdGlueW1jZSB3b3JrYXJvdW5kcyBmb3IgY29udGVudGVkaXRhYmxlIGlzc3Vlcy5cbi8vIHNldHRpbmcgXCJmb3JjZWRfcm9vdF9ibG9jazogZmFsc2VcIiBkaXNhYmxlIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBhZGRpbmcgYSB3cmFwcGVyIDxwPiB3aGVuIG5lZWRlZCBhbmQgdGhpcyBzZWVtcyB0byBmaXggbWFueSBpc3N1ZXMgaW4gSUUuXG4vLyBhbHNvLCBtYXliZSB3ZSBzaG91bGQgdXNlIHRoZSBcInJhd1wiIG9ubHkgZm9yIHRoZSBcImJlZm9yZSBTZXRDb250ZW50XCIgYW5kIGluc3RlYWQgcmVhZCB0aGUgXCJub24tcmF3XCIgY29udGVudCAodGhlIHJhdyBjb250ZW50IHNvbWV0aW1lcyBoYXZlIGRhdGEtIGF0dHJpYnV0ZXMgYW5kIHRvbyBtYW55IGVuZGluZyA8YnI+IGluIHRoZSBjb2RlKVxua28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcgPSB7XG4gIGN1cnJlbnRJbmRleDogMCxcbiAgc3RhbmRhcmRPcHRpb25zOiB7fSxcbiAgZnVsbE9wdGlvbnM6IHtcbiAgICB0b29sYmFyMTogJ2JvbGQgaXRhbGljIGZvcmVjb2xvciBiYWNrY29sb3IgaHIgc3R5bGVzZWxlY3QgcmVtb3ZlZm9ybWF0IHwgbGluayB1bmxpbmsgfCBwYXN0ZXRleHQgY29kZScsXG4gICAgLy90b29sYmFyMTogXCJib2xkIGl0YWxpYyB8IGZvcmVjb2xvciBiYWNrY29sb3IgfCBsaW5rIHVubGluayB8IGhyIHwgcGFzdGV0ZXh0IGNvZGVcIiwgLy8gfCBuZXdzbGV0dGVyX3Byb2ZpbGUgbmV3c2xldHRlcl9vcHRsaW5rIG5ld3NsZXR0ZXJfdW5zdWJzY3JpYmUgbmV3c2xldHRlcl9zaG93bGlua1wiO1xuICAgIC8vdG9vbGJhcjI6IFwiZm9ybWF0c2VsZWN0IGZvbnRzZWxlY3QgZm9udHNpemVzZWxlY3QgfCBhbGlnbmxlZnQgYWxpZ25jZW50ZXIgYWxpZ25yaWdodCBhbGlnbmp1c3RpZnkgfCBidWxsaXN0IG51bWxpc3RcIixcbiAgICBwbHVnaW5zOiBbXCJsaW5rIGhyIHBhc3RlIGxpc3RzIHRleHRjb2xvciBjb2RlXCJdLFxuICAgIC8vIHZhbGlkX2VsZW1lbnRzOiAnc3Ryb25nL2IsZW0vaSwqWypdJyxcbiAgICAvLyBleHRlbmRlZF92YWxpZF9lbGVtZW50czogJ3N0cm9uZy9iLGVtL2ksKlsqXScsXG4gICAgLy8gUmVtb3ZlZDogaW1hZ2UgZnVsbHNjcmVlbiBjb250ZXh0bWVudSBcbiAgICAvLyBkb3dubG9hZCBjdXN0b206XG4gICAgLy8ganF1ZXJ5IHZlcnNpb24gY29uIGxlZ2FjeW91dHB1dCwgYW5jaG9yLCBjb2RlLCBpbXBvcnRjc3MsIGxpbmssIHBhc3RlLCB0ZXh0Y29sb3IsIGhyLCBsaXN0c1xuICB9LFxuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgLy8gVE9ETyB1Z2x5LCBidXQgd29ya3MuLi5cbiAgICBrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlLmluaXQoZWxlbWVudCk7XG5cbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgdGlueW1jZS5yZW1vdmUoJyMnICsgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgIH0pO1xuXG4gICAgdmFyIHZhbHVlID0gdmFsdWVBY2Nlc3NvcigpO1xuXG4gICAgaWYgKCFrby5pc09ic2VydmFibGUodmFsdWUpKSB0aHJvdyBcIld5c2l3eWcgYmluZGluZyBjYWxsZWQgd2l0aCBub24gb2JzZXJ2YWJsZVwiO1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSA4KSB0aHJvdyBcIld5c2l3eWcgYmluZGluZyBjYWxsZWQgb24gdmlydHVhbCBub2RlLCBpZ25vcmluZy4uLi5cIiArIGVsZW1lbnQuaW5uZXJIVE1MO1xuXG4gICAgdmFyIHNlbGVjdG9ySWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICBpZiAoIXNlbGVjdG9ySWQpIHtcbiAgICAgIHNlbGVjdG9ySWQgPSAnd3lzaXd5Z18nICsgKCsra28uYmluZGluZ0hhbmRsZXJzWyd3eXNpd3lnJ10uY3VycmVudEluZGV4KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHNlbGVjdG9ySWQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsRWRpdG9yID0gZWxlbWVudC50YWdOYW1lID09ICdESVYnIHx8IGVsZW1lbnQudGFnTmFtZSA9PSAnVEQnO1xuICAgIHZhciBpc1N1YnNjcmliZXJDaGFuZ2UgPSBmYWxzZTtcbiAgICB2YXIgdGhpc0VkaXRvcjtcbiAgICB2YXIgaXNFZGl0b3JDaGFuZ2UgPSBmYWxzZTtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgc2VsZWN0b3I6ICcjJyArIHNlbGVjdG9ySWQsXG4gICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAvLyBtYXliZSBub3QgbmVlZGVkLCBidXQgd29uJ3QgaHVydC5cbiAgICAgIGhpZGRlbl9pbnB1dDogZmFsc2UsXG4gICAgICBwbHVnaW5zOiBbXCJwYXN0ZVwiXSxcbiAgICAgIHRvb2xiYXIxOiBcImJvbGQgaXRhbGljXCIsXG4gICAgICB0b29sYmFyMjogXCJcIixcbiAgICAgIC8vIHdlIGhhdmUgdG8gZGlzYWJsZSBwcmV2aWV3X3N0eWxlcyBvdGhlcndpc2UgdGlueW1jZSBwdXNoIGlubGluZSBldmVyeSBzdHlsZSBoZSB0aGluZ3Mgd2lsbCBiZSBhcHBsaWVkIGFuZCB0aGlzIG1ha2VzIHRoZSBzdHlsZSBtZW51IHRvIGluaGVyaXQgY29sb3IvZm9udC1mYW1pbHkgYW5kIG1vcmUuXG4gICAgICBwcmV2aWV3X3N0eWxlczogZmFsc2UsXG4gICAgICBwYXN0ZV9hc190ZXh0OiB0cnVlLFxuICAgICAgbGFuZ3VhZ2U6ICdlbicsXG4gICAgICBzY2hlbWE6IFwiaHRtbDVcIixcbiAgICAgIGV4dGVuZGVkX3ZhbGlkX2VsZW1lbnRzOiAnc3Ryb25nL2IsZW0vaSwqWypdJyxcbiAgICAgIG1lbnViYXI6IGZhbHNlLFxuICAgICAgc2tpbjogJ2dyYXktZmxhdCcsXG4gICAgICBzZXR1cDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIC8vIFRPRE8gY2hhbmdlIHNvbWV0aW1lcyBkb2Vzbid0IHRyaWdnZXIgKHdlIGhhdmUgdG8gZG9jdW1lbnQgd2hlbilcbiAgICAgICAgLy8gbGlzdGVuaW5nIG9uIGtleXVwIHdvdWxkIGluY3JlYXNlIGNvcnJlY3RuZXNzIGJ1dCB3ZSB3b3VsZCBuZWVkIGEgcmF0ZUxpbWl0IHRvIGF2b2lkIGZsb29kaW5nLlxuICAgICAgICBlZGl0b3Iub24oJ2NoYW5nZSByZWRvIHVuZG8nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIWlzU3Vic2NyaWJlckNoYW5nZSkge1xuICAgICAgICAgICAgaXNFZGl0b3JDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgLy8gd2UgZmFpbGVkIHdpdGggb3RoZXIgd2F5cyB0byBkbyB0aGlzOlxuICAgICAgICAgICAgLy8gdmFsdWUoJChlbGVtZW50KS5odG1sKCkpO1xuICAgICAgICAgICAgLy8gdmFsdWUoZWxlbWVudC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgdmFsdWUoZWRpdG9yLmdldENvbnRlbnQoe1xuICAgICAgICAgICAgICBmb3JtYXQ6ICdyYXcnXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpc0VkaXRvckNoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENsaWNraW5nIG9uIHRoZSBlbGVtZW50IG9uIGZvY3VzIGNoYW5nZSBhbGxvdyB0aGUgXCJjbGljXCIgY29kZSB0byBiZSB0cmlnZ2VyZWQgYW5kIHByb3BhZ2F0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAvLyBOb3QgZWxlZ2FudCwgbWF5YmUgd2UgaGF2ZSBiZXR0ZXIgb3B0aW9ucy5cbiAgICAgICAgZWRpdG9yLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFVzZWQgYnkgc2Nyb2xsZml4LmpzIChtYXliZSB0aGlzIGlzIG5vdCBuZWVkZWQgYnkgbmV3IHNjcm9sbGZpeC5qcylcbiAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgICBlZGl0b3IuZ2V0RWxlbWVudCgpLmNsaWNrKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5PVEU6IHRoaXMgZml4ZXMgaXNzdWUgd2l0aCBcImxlYWRpbmcgc3BhY2VzXCIgaW4gZGVmYXVsdCBjb250ZW50IHRoYXQgd2VyZSBsb3N0IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgZWRpdG9yLm9uKCdCZWZvcmVTZXRDb250ZW50JywgZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIGlmIChhcmdzLmluaXRpYWwpIGFyZ3MuZm9ybWF0ID0gJ3Jhdyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qIE5PVEU6IGRpc2FibGluZyBcIkVOVEVSXCIgaW4gdGlueSBlZGl0b3IsIG5vdCBhIGdvb2QgdGhpbmcgYnV0IG1heSBiZSBuZWVkZWQgdG8gd29yayBhcm91bmQgY29udGVudGVkaXRhYmxlIGlzc3Vlc1xuICAgICAgICBpZiAoIWZ1bGxFZGl0b3IpIHtcbiAgICAgICAgICAvLyBzZSBub24gYWJiaWFtbyBpbCBcImZ1bGwgRWRpdG9yXCIsIGRpc2FiaWxpdGlhbW8gbCdpbnZpby4gKHZhcmkgYnVnKVxuICAgICAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMTMpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICB0aGlzRWRpdG9yID0gZWRpdG9yO1xuXG4gICAgICB9XG4gICAgfTtcblxuICAgIGtvLnV0aWxzLmV4dGVuZChvcHRpb25zLCBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5zdGFuZGFyZE9wdGlvbnMpO1xuICAgIGlmIChmdWxsRWRpdG9yKSBrby51dGlscy5leHRlbmQob3B0aW9ucywga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuZnVsbE9wdGlvbnMpO1xuXG4gICAgLy8gd2UgaGF2ZSB0byBwdXQgaW5pdGlhbGl6YXRpb24gaW4gYSBzZXR0aW1lb3V0LCBvdGhlcndpc2Ugc3dpdGNoaW5nIGZyb20gXCIxXCIgdG8gXCIyXCIgY29sdW1ucyBibG9ja3NcbiAgICAvLyB3aWxsIHN0YXJ0IHRoZSBuZXcgZWRpdG9ycyBiZWZvcmUgZGlzcG9zaW5nIHRoZSBvbGQgb25lcyBhbmQgSURzIGdldCB0ZW1wb3JhcmlseSBkdXBsaWNhdGVkLlxuICAgIC8vIHVzaW5nIHNldFRpbWVvdXQgdGhlIGRpc3Bvc2UvY3JlYXRlIG9yZGVyIGlzIGNvcnJlY3Qgb24gZXZlcnkgYnJvd3NlciB0ZXN0ZWQuXG4gICAgZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0aW55bWNlLmluaXQob3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250ZW50ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgaWYgKCFpc0VkaXRvckNoYW5nZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlzU3Vic2NyaWJlckNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgLy8gd2UgZmFpbGVkIHNldHRpbmcgY29udGVudHMgaW4gb3RoZXIgd2F5cy4uLlxuICAgICAgICAgIC8vICQoZWxlbWVudCkuaHRtbChjb250ZW50KTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXNFZGl0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzRWRpdG9yLnNldENvbnRlbnQoY29udGVudCwge1xuICAgICAgICAgICAgICBmb3JtYXQ6ICdyYXcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga28udXRpbHMuc2V0SHRtbChlbGVtZW50LCBjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPRE8gZXhjZXB0aW9uIHNldHRpbmcgY29udGVudCB0byBlZGl0YWJsZSBlbGVtZW50XCIsIHR5cGVvZiB0aGlzRWRpdG9yLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBpc1N1YnNjcmliZXJDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCBudWxsLCB7XG4gICAgICBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnRcbiAgICB9KTtcblxuICAgIC8vIGRvIG5vdCBwYXJzZSBodG1sIGNvbnRlbnQgZm9yIEtPIGJpbmRpbmdzISFcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6IHRydWVcbiAgICB9O1xuXG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG4vLyByZXR1cm5zIDAgaWYgZXF1YWwgKDAuMC54IHJlbGVhc2UpLCAxIHdpdGggYmFja3dhcmQgY29tcGF0aWJsZSBhZGRpdGlvbnMgKDAueC4wIHJlbGVhc2UpLCAyIG9uIGxvc3QgZGF0YSBvciBpbmNvbXBhdGlibGUgZGF0YSAoeC4wLjAgcmVsZWFzZSlcbnZhciBjaGVja01vZGVsID0gZnVuY3Rpb24ocmVmZXJlbmNlLCBibG9ja0RlZnMsIG1vZGVsLCBvcmlnUHJlZml4LCByZXZlcnNlKSB7XG4gIHZhciBibG9ja0RlZnNPYmosIGksIHByZWZpeDtcbiAgdmFyIHZhbGlkID0gMDtcbiAgaWYgKHR5cGVvZiByZXZlcnNlID09ICd1bmRlZmluZWQnKSByZXZlcnNlID0gZmFsc2U7XG4gIGlmICh0eXBlb2YgYmxvY2tEZWZzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYmxvY2tEZWZzLnNwbGljZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgYmxvY2tEZWZzT2JqID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrRGVmcy5sZW5ndGg7IGkrKykgYmxvY2tEZWZzT2JqW2Jsb2NrRGVmc1tpXS50eXBlXSA9IGJsb2NrRGVmc1tpXTtcbiAgfSBlbHNlIHtcbiAgICBibG9ja0RlZnNPYmogPSBibG9ja0RlZnM7XG4gIH1cbiAgZm9yICh2YXIgcHJvcCBpbiByZWZlcmVuY2UpXG4gICAgaWYgKHJlZmVyZW5jZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgcHJlZml4ID0gdHlwZW9mIG9yaWdQcmVmaXggIT09ICd1bmRlZmluZWQnID8gb3JpZ1ByZWZpeCArIFwiLlwiICsgcHJvcCA6IHByb3A7XG4gICAgICBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTiBQcm9wZXJ0eSBcIiwgcHJlZml4LCBcImZvdW5kIGluIG1vZGVsIGlzIG5vdCBkZWZpbmVkIGJ5IHRlbXBsYXRlOiByZW1vdmluZyBpdCFcIik7XG4gICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgICAgZGVsZXRlIHJlZmVyZW5jZVtwcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIklORk8gUHJvcGVydHkgXCIsIHByZWZpeCwgXCJtaXNzaW5nIGluIG1vZGVsLCBjbG9uaW5nIGZyb20gcmVmZXJlbmNlIVwiKTtcbiAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAxKTtcbiAgICAgICAgICBtb2RlbFtwcm9wXSA9IHJlZmVyZW5jZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWxbcHJvcF0gIT0gdHlwZW9mIHJlZmVyZW5jZVtwcm9wXSkge1xuICAgICAgICAvLyBzZSBzb25vIGRpIHRpcG8gZGl2ZXJzbyBhbGxvcmEgcHJvdm8gYSB2ZWRlcmUgc2UgbCdhbHRybywgY29udmVydGl0byBkaSB0aXBvIG1hbnRpZW5lIHVuIHZhbG9yZSBlcXVpdmFsZW50ZS5cbiAgICAgICAgaWYgKG1vZGVsW3Byb3BdICE9PSBudWxsICYmIHJlZmVyZW5jZVtwcm9wXSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbW9kZWxbcHJvcF0gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChTdHJpbmcocmVmZXJlbmNlW3Byb3BdKSAhPSByZWZlcmVuY2VbcHJvcF0pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIERpZmZlcmVudCB0eXBlIDEgXCIsIHByZWZpeCwgdHlwZW9mIG1vZGVsW3Byb3BdLCB0eXBlb2YgcmVmZXJlbmNlW3Byb3BdLCBtb2RlbFtwcm9wXSwgcmVmZXJlbmNlW3Byb3BdKTtcbiAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWxbcHJvcF0gPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChOdW1iZXIocmVmZXJlbmNlW3Byb3BdKSAhPSByZWZlcmVuY2VbcHJvcF0pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIERpZmZlcmVudCB0eXBlIDIgXCIsIHByZWZpeCwgdHlwZW9mIG1vZGVsW3Byb3BdLCB0eXBlb2YgcmVmZXJlbmNlW3Byb3BdLCBtb2RlbFtwcm9wXSwgcmVmZXJlbmNlW3Byb3BdKTtcbiAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyBEaWZmZXJlbnQgdHlwZSAzIFwiLCBwcmVmaXgsIHR5cGVvZiBtb2RlbFtwcm9wXSwgdHlwZW9mIHJlZmVyZW5jZVtwcm9wXSwgbW9kZWxbcHJvcF0sIHJlZmVyZW5jZVtwcm9wXSk7XG4gICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlZmVyZW5jZVtwcm9wXSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVmZXJlbmNlW3Byb3BdICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VbcHJvcF0uc3BsaWNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZVtwcm9wXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGlmIChtb2RlbFtwcm9wXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBuZWVkcyBzb3J0aW5nP1xuICAgICAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kZWxbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kZWxbcHJvcF1baV0udHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IHJlZmVyZW5jZVtwcm9wXS5sZW5ndGggJiYgcmVmZXJlbmNlW3Byb3BdW2pdLnR5cGUgIT09IG1vZGVsW3Byb3BdW2ldLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImlnbm9yaW5nIFwiLCBwcmVmaXgsIHJlZmVyZW5jZVtwcm9wXVtqXS50eXBlLCBcIiBibG9jayB0eXBlIGluIHJlZmVyZW5jZSBub3QgZm91bmQgaW4gbW9kZWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID49IHJlZmVyZW5jZVtwcm9wXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk4gY2Fubm90IGZpbmQgXCIsIHByZWZpeCwgbW9kZWxbcHJvcF1baV0udHlwZSwgXCIgYmxvY2sgaW4gcmVmZXJlbmNlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldmVyc2UgY29uZGl0aW9uIHNvIHRvIHNraXAgXCJkZWVwIHRyYXZlcnNpbmdcIiBvbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCBjaGVja01vZGVsKHJlZmVyZW5jZVtwcm9wXVtqXSwgdW5kZWZpbmVkLCBtb2RlbFtwcm9wXVtpXSwgcHJlZml4ICsgXCJbXCIgKyBpICsgXCIuXCIgKyBtb2RlbFtwcm9wXVtpXS50eXBlICsgXCJdXCIpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IGFycmF5IHdlIGNoZWNrIGJsb2NrRGVmc1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZWZlcmVuY2VbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmZXJlbmNlW3Byb3BdW2ldLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyBmb3VuZCBhbiBvYmplY3Qgd2l0aCBubyB0eXBlXCIsIHByZWZpeCwgcmVmZXJlbmNlW3Byb3BdW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFibG9ja0RlZnNPYmouaGFzT3duUHJvcGVydHkocmVmZXJlbmNlW3Byb3BdW2ldLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRPRE8gdGhlIG1vZGVsIHVzZXMgYSBibG9jayB0eXBlIG5vdCBkZWZpbmVkIGJ5IHRoZSB0ZW1wbGF0ZS4gUkVNT1ZJTkcgSVQhIVwiLCBwcmVmaXgsIHJlZmVyZW5jZVtwcm9wXVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZVtwcm9wXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCBjaGVja01vZGVsKGJsb2NrRGVmc09ialtyZWZlcmVuY2VbcHJvcF1baV0udHlwZV0sIGJsb2NrRGVmc09iaiwgcmVmZXJlbmNlW3Byb3BdW2ldLCBwcmVmaXggKyBcIltcIiArIGkgKyBcIi5cIiArIHJlZmVyZW5jZVtwcm9wXVtpXS50eXBlICsgXCJdXCIpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1vZGVsW3Byb3BdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOIE51bGwgb2JqZWN0IGluIG1vZGVsIFwiLCBwcmVmaXgsIFwiaW5zdGVhZCBvZlwiLCByZWZlcmVuY2VbcHJvcF0sIFwiZGVsZXRpbmcgaXRcIik7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlZmVyZW5jZVtwcm9wXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIklORk8gTnVsbCBvYmplY3QgaW4gbW9kZWwgXCIsIHByZWZpeCwgXCJpbnN0ZWFkIG9mXCIsIHJlZmVyZW5jZVtwcm9wXSwgXCJjbG9uaW5nIGl0IGZyb20gdGhlIHJlZmVyZW5jZVwiKTtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAxKTtcbiAgICAgICAgICAgICAgICBtb2RlbFtwcm9wXSA9IHJlZmVyZW5jZVtwcm9wXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgY2hlY2tNb2RlbChyZWZlcmVuY2VbcHJvcF0sIGJsb2NrRGVmc09iaiwgbW9kZWxbcHJvcF0sIHByZWZpeCwgcmV2ZXJzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlbFtwcm9wXSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyBOdWxsIGluIHJlZmVyZW5jZSBidXQgbm90IG51bGwgaW4gbW9kZWxcIiwgcHJlZml4LCBtb2RlbFtwcm9wXSk7XG4gICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlZmVyZW5jZVtwcm9wXSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHJlZmVyZW5jZVtwcm9wXSAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiByZWZlcmVuY2VbcHJvcF0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyB1bnN1cHBvcnRlZCB0eXBlXCIsIHByZWZpeCwgdHlwZW9mIHJlZmVyZW5jZVtwcm9wXSk7XG4gICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgfVxuXG4gICAgfVxuICBpZiAoIXJldmVyc2UpIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIGNoZWNrTW9kZWwobW9kZWwsIGJsb2NrRGVmcywgcmVmZXJlbmNlLCB0eXBlb2Ygb3JpZ1ByZWZpeCAhPT0gJ3VuZGVmaW5lZCcgPyBvcmlnUHJlZml4ICsgXCIhUlwiIDogXCIhUlwiLCB0cnVlKSk7XG4gIHJldHVybiB2YWxpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tNb2RlbDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gUGFyc2VzIENTUyBkZWNsYXJhdGlvbnMgYW5kIHN1cHBvcnRzIHRoZSBwcm9wZXJ0eSBsYW5ndWFnZSAoLWtvLSopIGZvdW5kIGJldHdlZW4gdGhlbS5cbi8vIENyZWF0ZSBLTyBiaW5kaW5ncyBidXQgZG9lc24ndCBkZXBlbmQgb24gS08uXG4vLyBOZWVkcyBhIGJpbmRpbmdQcm92aWRlci5cblxudmFyIGNvbnZlcnRlclV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG52YXIgY3NzUGFyc2UgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL21lbnNjaC9saWIvcGFyc2VyLmpzXCIpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBkb211dGlscyA9IHJlcXVpcmUoXCIuL2RvbXV0aWxzLmpzXCIpO1xuXG52YXIgX2RlY2xhcmF0aW9uVmFsdWVMb29rdXAgPSBmdW5jdGlvbihkZWNsYXJhdGlvbnMsIHByb3BlcnR5bmFtZSwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpIHtcbiAgZm9yICh2YXIgaSA9IGRlY2xhcmF0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChkZWNsYXJhdGlvbnNbaV0udHlwZSA9PSAncHJvcGVydHknICYmIGRlY2xhcmF0aW9uc1tpXS5uYW1lID09IHByb3BlcnR5bmFtZSkge1xuICAgICAgcmV0dXJuIF9kZWNsYXJhdGlvblZhbHVlVXJsUHJlZml4ZXIoZGVjbGFyYXRpb25zW2ldLnZhbHVlLCB0ZW1wbGF0ZVVybENvbnZlcnRlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIF9wcm9wVG9DYW1lbENhc2UgPSBmdW5jdGlvbihwcm9wTmFtZSkge1xuICByZXR1cm4gcHJvcE5hbWUucmVwbGFjZSgvLShbYS16XSkvZywgZnVuY3Rpb24obWF0Y2gsIGNvbnRlbnRzLCBvZmZzZXQsIHMpIHtcbiAgICByZXR1cm4gY29udGVudHMudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59O1xuXG52YXIgX2RlY2xhcmF0aW9uVmFsdWVVcmxQcmVmaXhlciA9IGZ1bmN0aW9uKHZhbHVlLCB0ZW1wbGF0ZVVybENvbnZlcnRlcikge1xuICBpZiAodmFsdWUubWF0Y2goL3VybFxcKC4qXFwpLykpIHtcbiAgICB2YXIgcmVwbGFjZWQgPSB2YWx1ZS5yZXBsYWNlKC8odXJsXFwoKShbXlxcKV0qKShcXCkpL2csIGZ1bmN0aW9uKG1hdGNoZWQsIHByZWZpeCwgdXJsLCBwb3N0Zml4KSB7XG4gICAgICB2YXIgdHJpbW1lZCA9IHVybC50cmltKCk7XG4gICAgICB2YXIgYXBpY2UgPSB1cmwudHJpbSgpLmNoYXJBdCgwKTtcbiAgICAgIGlmIChhcGljZSA9PSAnXFwnJyB8fCBhcGljZSA9PSAnXCInKSB7XG4gICAgICAgIHRyaW1tZWQgPSB0cmltbWVkLnN1YnN0cigxLCB0cmltbWVkLmxlbmd0aCAtIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBpY2UgPSAnJztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdVcmwgPSB0ZW1wbGF0ZVVybENvbnZlcnRlcih0cmltbWVkKTtcbiAgICAgIGlmIChuZXdVcmwgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIGFwaWNlICsgbmV3VXJsICsgYXBpY2UgKyBwb3N0Zml4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcGxhY2VkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxudmFyIGVsYWJvcmF0ZURlY2xhcmF0aW9ucyA9IGZ1bmN0aW9uKHN0eWxlLCBkZWNsYXJhdGlvbnMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBiaW5kaW5nUHJvdmlkZXIsIGVsZW1lbnQsIGJhc2ljQmluZGluZ3MsIHJlbW92ZURpc3BsYXlOb25lKSB7XG4gIHZhciBuZXdCaW5kaW5ncyA9IHR5cGVvZiBiYXNpY0JpbmRpbmdzID09ICdvYmplY3QnICYmIGJhc2ljQmluZGluZ3MgIT09IG51bGwgPyBiYXNpY0JpbmRpbmdzIDoge307XG4gIHZhciBuZXdTdHlsZSA9IG51bGw7XG4gIHZhciBza2lwTGluZXMgPSAwO1xuICBpZiAodHlwZW9mIGRlY2xhcmF0aW9ucyA9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzdHlsZVNoZWV0ID0gY3NzUGFyc2UoXCIje1xcblwiICsgc3R5bGUgKyBcIn1cIiwge1xuICAgICAgY29tbWVudHM6IHRydWUsXG4gICAgICBwb3NpdGlvbjogdHJ1ZVxuICAgIH0pO1xuICAgIGRlY2xhcmF0aW9ucyA9IHN0eWxlU2hlZXQuc3R5bGVzaGVldC5ydWxlc1swXS5kZWNsYXJhdGlvbnM7XG4gICAgc2tpcExpbmVzID0gMTtcbiAgfVxuICBmb3IgKHZhciBpID0gZGVjbGFyYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIGlmIChkZWNsYXJhdGlvbnNbaV0udHlwZSA9PSAncHJvcGVydHknKSB7XG4gICAgICBpZiAocmVtb3ZlRGlzcGxheU5vbmUgPT09IHRydWUgJiYgZGVjbGFyYXRpb25zW2ldLm5hbWUgPT0gJ2Rpc3BsYXknICYmIGRlY2xhcmF0aW9uc1tpXS52YWx1ZSA9PSAnbm9uZScpIHtcbiAgICAgICAgaWYgKG5ld1N0eWxlID09PSBudWxsKSBuZXdTdHlsZSA9IHN0eWxlO1xuICAgICAgICBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBkZWNsYXJhdGlvbnNbaV0ucG9zaXRpb24uc3RhcnQsIGRlY2xhcmF0aW9uc1tpXS5wb3NpdGlvbi5lbmQsIHNraXBMaW5lcywgMCwgMCwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlY2wgPSBkZWNsYXJhdGlvbnNbaV0ubmFtZS5tYXRjaCgvXi1rby0oYmluZC18YXR0ci0pPyhbYS16MC05LV0qPykoLWlmfC1pZm5vdCk/JC8pO1xuICAgICAgICBpZiAoZGVjbCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJpbW96aW9uZSBkZWxsbyBzdGlsZSAta28tIGRhbGwnYXR0cmlidXRvIHN0eWxlLlxuICAgICAgICAgIGlmIChuZXdTdHlsZSA9PT0gbnVsbCAmJiB0eXBlb2Ygc3R5bGUgIT0gJ3VuZGVmaW5lZCcpIG5ld1N0eWxlID0gc3R5bGU7XG5cbiAgICAgICAgICB2YXIgaXNBdHRyID0gZGVjbFsxXSA9PSAnYXR0ci0nO1xuICAgICAgICAgIHZhciBpc0JpbmQgPSBkZWNsWzFdID09ICdiaW5kLSc7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gZGVjbFsyXTtcblxuICAgICAgICAgIHZhciBpc0lmID0gZGVjbFszXSA9PSAnLWlmJyB8fCBkZWNsWzNdID09ICctaWZub3QnO1xuICAgICAgICAgIHZhciBjb25kRGVjbDtcbiAgICAgICAgICB2YXIgYmluZFZhbHVlO1xuICAgICAgICAgIHZhciBwcm9wRGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgaWYgKGlzSWYpIHtcbiAgICAgICAgICAgIGNvbmREZWNsID0gZGVjbGFyYXRpb25zW2ldLm5hbWUuc3Vic3RyKDAsIGRlY2xhcmF0aW9uc1tpXS5uYW1lLmxlbmd0aCAtIGRlY2xbM10ubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25lZERlY2xhcmF0aW9uID0gX2RlY2xhcmF0aW9uVmFsdWVMb29rdXAoZGVjbGFyYXRpb25zLCBjb25kRGVjbCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbmVkRGVjbGFyYXRpb24gPT09IG51bGwpIHRocm93IFwiVW5hYmxlIHRvIGZpbmQgZGVjbGFyYXRpb24gXCIgKyBjb25kRGVjbCArIFwiIGZvciBcIiArIGRlY2xhcmF0aW9uc1tpXS5uYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICgoaXNBdHRyIHx8IGlzQmluZCkgJiYgKHR5cGVvZiBlbGVtZW50ID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzdHlsZSAhPSAndW5kZWZpbmVkJykpIHRocm93IFwiQXR0cmlidXRlcyBhbmQgYmluZCBkZWNsYXJhdGlvbnMgYXJlIG9ubHkgYWxsb3dlZCBpbiBpbmxpbmUgc3R5bGVzIVwiO1xuXG4gICAgICAgICAgICB2YXIgbmVlZERlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgYmluZFR5cGU7XG4gICAgICAgICAgICBpZiAoaXNBdHRyKSB7XG4gICAgICAgICAgICAgIHByb3BEZWZhdWx0VmFsdWUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICBuZWVkRGVmYXVsdFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJpbmRUeXBlID0gJ3ZpcnR1YWxBdHRyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQmluZCkge1xuICAgICAgICAgICAgICBuZWVkRGVmYXVsdFZhbHVlID0gdHlwZW9mIHN0eWxlICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgICAgaWYgKG5lZWREZWZhdWx0VmFsdWUpIHByb3BEZWZhdWx0VmFsdWUgPSBfZGVjbGFyYXRpb25WYWx1ZUxvb2t1cChkZWNsYXJhdGlvbnMsIHByb3BOYW1lLCB0ZW1wbGF0ZVVybENvbnZlcnRlcik7XG4gICAgICAgICAgICAgIGJpbmRUeXBlID0gJ3ZpcnR1YWxTdHlsZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiaW5kVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wRGVmYXVsdFZhbHVlID0gZG9tdXRpbHMuZ2V0SW5uZXJUZXh0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZWVkRGVmYXVsdFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09ICdodG1sJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIHByb3BEZWZhdWx0VmFsdWUgPSBkb211dGlscy5nZXRJbm5lckh0bWwoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5lZWREZWZhdWx0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVlZERlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZWVkRGVmYXVsdFZhbHVlICYmIHByb3BEZWZhdWx0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBmaW5kIGRlZmF1bHQgdmFsdWUgZm9yXCIsIGRlY2xhcmF0aW9uc1tpXS5uYW1lLCBkZWNsYXJhdGlvbnMpO1xuICAgICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBmaW5kIGRlZmF1bHQgdmFsdWUgZm9yIFwiICsgZGVjbGFyYXRpb25zW2ldLm5hbWUgKyBcIjogXCIgKyBkZWNsYXJhdGlvbnNbaV0udmFsdWUgKyBcIiBpbiBcIiArIGVsZW1lbnQgKyBcIiAoXCIgKyB0eXBlb2Ygc3R5bGUgKyBcIi9cIiArIHByb3BOYW1lICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmluZERlZmF1bHRWYWx1ZSA9IHByb3BEZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBiaW5kTmFtZSA9IF9wcm9wVG9DYW1lbENhc2UocHJvcE5hbWUpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBiaW5kVmFsdWUgPSBjb252ZXJ0ZXJVdGlscy5leHByZXNzaW9uQmluZGluZyhkZWNsYXJhdGlvbnNbaV0udmFsdWUsIGJpbmRpbmdQcm92aWRlciwgYmluZERlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RlbCBlbnN1cmUgcGF0aCBmYWlsZWRcIiwgZS5zdGFjaywgXCJuYW1lXCIsIGRlY2xhcmF0aW9uc1tpXS5uYW1lLCBcInZhbHVlXCIsIGRlY2xhcmF0aW9uc1tpXS52YWx1ZSwgXCJkZWZhdWx0XCIsIHByb3BEZWZhdWx0VmFsdWUsIFwiZWxlbWVudFwiLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJpbmRUeXBlICE9PSBudWxsICYmIHR5cGVvZiBuZXdCaW5kaW5nc1tiaW5kVHlwZV0gPT0gJ3VuZGVmaW5lZCcpIG5ld0JpbmRpbmdzW2JpbmRUeXBlXSA9IHt9O1xuXG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIEhSRUZzXG4gICAgICAgICAgICBpZiAoYmluZFR5cGUgPT0gJ3ZpcnR1YWxBdHRyJyAmJiBiaW5kTmFtZSA9PSAnaHJlZicpIHtcbiAgICAgICAgICAgICAgYmluZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICBiaW5kTmFtZSA9ICd3eXNpd3lnSHJlZic7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVtb3ZlIGl0LCBvdGhlcndpc2Ugd2UgZW5kcyB1cCB3aXRoIDIgcnVsZXMgd3JpdGluZyBpdC5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ICE9ICd1bmRlZmluZWQnICYmIGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgXCJocmVmXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE8gZXZhbHVhdGUgdGhlIHVzZSBvZiBcIi10aGVuXCIgKGFuZCAtZWxzZSkgcG9zdGZpeGVzIHRvIGNvbXBsZXRlIHRoZSAtaWYgaW5zdGVhZCBvZiByZWxheWluZ1xuICAgICAgICAgICAgLy8gb24gdGhlIHNhbWUgYmFzaWMgc2ludGF4IChvciBtYXliZSBpdCBpcyBiZXR0ZXIgdG8gc3VwcG9ydCB0ZXJuYXJ5IG9wZXJhdG9yIENPTkQgPyBUSEVOIDogRUxTRSkuXG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25Db25kaXRpb24gPSBfZGVjbGFyYXRpb25WYWx1ZUxvb2t1cChkZWNsYXJhdGlvbnMsIGRlY2xhcmF0aW9uc1tpXS5uYW1lICsgJy1pZicsIHRlbXBsYXRlVXJsQ29udmVydGVyKTtcbiAgICAgICAgICAgIHZhciBub3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbkNvbmRpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWNsYXJhdGlvbkNvbmRpdGlvbiA9IF9kZWNsYXJhdGlvblZhbHVlTG9va3VwKGRlY2xhcmF0aW9ucywgZGVjbGFyYXRpb25zW2ldLm5hbWUgKyAnLWlmbm90JywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgICBub3QgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKF9kZWNsYXJhdGlvblZhbHVlTG9va3VwKGRlY2xhcmF0aW9ucywgZGVjbGFyYXRpb25zW2ldLm5hbWUgKyAnLWlmbm90JywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGVycm9yOiBjYW5ub3QgdXNlIGJvdGggLWlmIGFuZCAtaWZub3QgcHJvcGVydHkgY29uZGl0aW9uc1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25Db25kaXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZ0NvbmQgPSBjb252ZXJ0ZXJVdGlscy5jb25kaXRpb25CaW5kaW5nKGRlY2xhcmF0aW9uQ29uZGl0aW9uLCBiaW5kaW5nUHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGJpbmRWYWx1ZSA9IChub3QgPyAnIScgOiAnJykgKyBcIihcIiArIGJpbmRpbmdDb25kICsgXCIpID8gXCIgKyBiaW5kVmFsdWUgKyBcIiA6IG51bGxcIjtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZGVhbCB3aXRoIC1rbyBzdHlsZSBiaW5kaW5nIGNvbmRpdGlvblwiLCBkZWNsYXJhdGlvbkNvbmRpdGlvbiwgZGVjbGFyYXRpb25zW2ldLm5hbWUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJpbmRUeXBlICE9PSBudWxsKSBuZXdCaW5kaW5nc1tiaW5kVHlwZV1bYmluZE5hbWVdID0gYmluZFZhbHVlO1xuICAgICAgICAgICAgZWxzZSBuZXdCaW5kaW5nc1tiaW5kTmFtZV0gPSBiaW5kVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcGFyc2luZyBAc3VwcG9ydHMgOnByZXZpZXdcbiAgICAgICAgICBpZiAobmV3U3R5bGUgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gaWYgXCJlbGVtZW50XCIgaXMgZGVmaW5lZCB0aGVuIHdlIGFyZSBwYXJzaW5nIGFuIFwiaW5saW5lXCIgc3R5bGUgYW5kIHdlIHdhbnQgdG8gcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIGRlY2xhcmF0aW9uc1tpXS5wb3NpdGlvbi5zdGFydCwgZGVjbGFyYXRpb25zW2ldLnBvc2l0aW9uLmVuZCwgc2tpcExpbmVzLCAwLCAwLCAnJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGFyZSBwYXJzaW5nIGEgZnVsbCBzdHlsZXNoZWV0Li4gbGV0J3MgcmV3cml0ZSB0aGUgZnVsbCBcInByb3A6IHZhbHVlXCIgd2l0aG91dCBjYXJpbmcgYWJvdXQgdGhlIG9yaWdpbmFsIHN5bnRheC5cbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZWRXaXRoID0gJyc7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgYW4gXCJpZlwiIHdlIHNpbXBseSBoYXZlIHRvIHJlbW92ZSBpdCwgb3RoZXJ3aXNlIHdlIHJlcGxhY2UgdGhlIGlucHV0IGNvZGUgd2l0aCBcInByb3A6IHZhbHVlXCIgZ2VuZXJhdGluZyBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgIGlmICghaXNJZikgcmVwbGFjZWRXaXRoID0gcHJvcE5hbWUgKyAnOiA8IS0tIGtvIHRleHQ6ICcgKyBiaW5kVmFsdWUgKyAnIC0tPicgKyBwcm9wRGVmYXVsdFZhbHVlICsgJzwhLS0gL2tvIC0tPic7XG4gICAgICAgICAgICAgICAgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgZGVjbGFyYXRpb25zW2ldLnBvc2l0aW9uLnN0YXJ0LCBkZWNsYXJhdGlvbnNbaV0ucG9zaXRpb24uZW5kLCBza2lwTGluZXMsIDAsIDAsIHJlcGxhY2VkV2l0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmVtb3ZlIHN0eWxlIGZhaWxlZFwiLCBlLCBcIm5hbWVcIiwgZGVjbGFyYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByZWZpeGluZyB1cmxzXG4gICAgICAgICAgdmFyIHJlcGxhY2VkVmFsdWUgPSBfZGVjbGFyYXRpb25WYWx1ZVVybFByZWZpeGVyKGRlY2xhcmF0aW9uc1tpXS52YWx1ZSwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpO1xuICAgICAgICAgIGlmIChyZXBsYWNlZFZhbHVlICE9IGRlY2xhcmF0aW9uc1tpXS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0eWxlID09PSBudWxsICYmIHR5cGVvZiBzdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIG5ld1N0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICBpZiAobmV3U3R5bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBkZWNsYXJhdGlvbnNbaV0ucG9zaXRpb24uc3RhcnQsIGRlY2xhcmF0aW9uc1tpXS5wb3NpdGlvbi5lbmQsIHNraXBMaW5lcywgMCwgMCwgZGVjbGFyYXRpb25zW2ldLm5hbWUgKyBcIjogXCIgKyByZXBsYWNlZFZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVtb3ZlIHN0eWxlIGZhaWxlZCByZXBsYWNpbmcgdXJsXCIsIGUsIFwibmFtZVwiLCBkZWNsYXJhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdHlsZSBoYW5kbGluZyBieSBjb25jYXRlbmF0ZWQgXCJzdHlsZSBhdHRyaWJ1dGVcIiAod29yc2UgcGVyZm9ybWFuY2UgYnV0IG1vcmUgc3RhYmxlIHRoYW4gZGlyZWN0IHN0eWxlIGhhbmRsaW5nKVxuICAgICAgICAgIHZhciBiaW5kTmFtZTIgPSBfcHJvcFRvQ2FtZWxDYXNlKGRlY2xhcmF0aW9uc1tpXS5uYW1lKTtcbiAgICAgICAgICB2YXIgYmluZCA9ICd2aXJ0dWFsQXR0clN0eWxlJztcbiAgICAgICAgICB2YXIgYmluZFZhbDIgPSB0eXBlb2YgbmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddICE9PSAndW5kZWZpbmVkJyA/IG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXVtiaW5kTmFtZTJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGRpc3QgPSAnICc7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdCaW5kaW5nc1tiaW5kXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbmV3QmluZGluZ3NbYmluZF0gPSBcIicnXCI7XG4gICAgICAgICAgICBkaXN0ID0gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBiaW5kVmFsMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG5ld0JpbmRpbmdzW2JpbmRdID0gXCInXCIgKyBkZWNsYXJhdGlvbnNbaV0ubmFtZSArIFwiOiAnKyhcIiArIGJpbmRWYWwyICsgXCIpKyc7XCIgKyBkaXN0ICsgXCInK1wiICsgbmV3QmluZGluZ3NbYmluZF07XG4gICAgICAgICAgICBkZWxldGUgbmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddW2JpbmROYW1lMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0JpbmRpbmdzW2JpbmRdID0gXCInXCIgKyBkZWNsYXJhdGlvbnNbaV0ubmFtZSArIFwiOiBcIiArIGNvbnZlcnRlclV0aWxzLmFkZFNsYXNoZXMocmVwbGFjZWRWYWx1ZSkgKyBcIjtcIiArIGRpc3QgKyBcIicrXCIgKyBuZXdCaW5kaW5nc1tiaW5kXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICBpZiAodHlwZW9mIGVsZW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIHByb3AgaW4gbmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddKVxuICAgICAgaWYgKG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVuZXhwZWN0ZWQgdmlydHVhbFN0eWxlIGJpbmRpbmcgYWZ0ZXIgY29udmVyc2lvbiB0byB2aXJ0dWFsQXR0ci5zdHlsZVwiLCBwcm9wLCBuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ11bcHJvcF0sIHN0eWxlKTtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIHZpcnR1YWxTdHlsZSBiaW5kaW5nIGFmdGVyIGNvbnZlcnNpb24gdG8gdmlydHVhbEF0dHIuc3R5bGUgZm9yIFwiICsgcHJvcDtcbiAgICAgIH1cbiAgICBkZWxldGUgbmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddO1xuXG4gICAgdmFyIGN1cnJlbnRCaW5kaW5ncyA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJyk7XG4gICAgdmFyIGRhdGFCaW5kID0gKGN1cnJlbnRCaW5kaW5ncyAhPT0gbnVsbCA/IGN1cnJlbnRCaW5kaW5ncyArIFwiLCBcIiA6IFwiXCIpICsgX2JpbmRpbmdTZXJpYWxpemVyKG5ld0JpbmRpbmdzKTtcbiAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcsIGRhdGFCaW5kKTtcbiAgfVxuXG4gIC8vIFRPRE8gYSBmdW5jdGlvbiB3aG9zZSByZXR1cm4gdHlwZSBkZXBlbmRzIG9uIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIGlzIHZlcnkgdWdseS4uIHBsZWFzZSBGSVggTUUuXG4gIGlmICh0eXBlb2Ygc3R5bGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjbGVhbiB2aXJ0dWFsU3R5bGUgaWYgZW1wdHlcbiAgICB2YXIgaGFzVmlydHVhbFN0eWxlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcHJvcDEgaW4gbmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddKVxuICAgICAgaWYgKG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXS5oYXNPd25Qcm9wZXJ0eShwcm9wMSkpIHtcbiAgICAgICAgaGFzVmlydHVhbFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgaWYgKCFoYXNWaXJ0dWFsU3R5bGUpIGRlbGV0ZSBuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ107XG4gICAgZWxzZSB7XG4gICAgICAvLyByZW1vdmUgYW5kIGFkZCBiYWNrIHZpcnR1YWxBdHRyU3R5bGUgc28gaXQgZ2V0cyBhcHBlbmRlZCBCRUZPUkUgdmlydHVhbEF0dHJTdHlsZSAoX2JpbmRpbmdTZXJpYWxpemVyIHJldmVyc2UgdGhlbS4uLilcbiAgICAgIGlmICh0eXBlb2YgbmV3QmluZGluZ3NbJ3ZpcnR1YWxBdHRyU3R5bGUnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHZzID0gbmV3QmluZGluZ3NbJ3ZpcnR1YWxBdHRyU3R5bGUnXTtcbiAgICAgICAgZGVsZXRlIG5ld0JpbmRpbmdzWyd2aXJ0dWFsQXR0clN0eWxlJ107XG4gICAgICAgIG5ld0JpbmRpbmdzWyd2aXJ0dWFsQXR0clN0eWxlJ10gPSB2cztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJucyBuZXcgc2VyaWFsaXplZCBiaW5kaW5nc1xuICAgIHJldHVybiBfYmluZGluZ1NlcmlhbGl6ZXIobmV3QmluZGluZ3MpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0eWxlO1xufTtcblxudmFyIF9iaW5kaW5nU2VyaWFsaXplciA9IGZ1bmN0aW9uKHZhbCkge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIHByb3AgaW4gdmFsKVxuICAgIGlmICh2YWwuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsW3Byb3BdID09ICdvYmplY3QnKSByZXMucHVzaChwcm9wICsgXCI6IFwiICsgXCJ7IFwiICsgX2JpbmRpbmdTZXJpYWxpemVyKHZhbFtwcm9wXSkgKyBcIiB9XCIpO1xuICAgICAgZWxzZSByZXMucHVzaChwcm9wICsgXCI6IFwiICsgdmFsW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiByZXMucmV2ZXJzZSgpLmpvaW4oJywgJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsYWJvcmF0ZURlY2xhcmF0aW9uczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVGhpcyBkZWFscyB3aXRoIENoZWVyaW8valF1ZXJ5IGlzc3Vlcy5cbi8vIE1vc3Qgb2YgdGhpcyBjb3VsZCBiZSBkb25lIHdpdGhvdXQgalF1ZXJ5LCB0b28sIGJ1dCBqUXVlcnkgaXMgZWFzaWVyIHRvIGJlIG1vY2tlZCB3aXRoIENoZWVyaW9cbi8vIE90aGVyd2lzZSB3ZSB3b3VsZCBuZWVkIGpzRG9tIHRvIHJ1biB0aGUgY29tcGlsZXIgaW4gdGhlIHNlcnZlciAod2l0aG91dCBhIHJlYWwgYnJvd3NlcilcblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xuXG5mdW5jdGlvbiBfZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIGlmIChzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBvYmpFeHRlbmQgPSBmdW5jdGlvbihvYmosIGV4dGVuZGVyKSB7XG4gIGlmICh0eXBlb2YgJC5leHRlbmQgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAkLmV4dGVuZCh0cnVlLCBvYmosIGV4dGVuZGVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gX2V4dGVuZChvYmosIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXh0ZW5kZXIpKSk7XG4gIH1cbn07XG5cbnZhciBnZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgdmFyIHJlcyA9ICQoZWxlbWVudCkuYXR0cihhdHRyaWJ1dGUpO1xuICBpZiAodHlwZW9mIHJlcyA9PSAndW5kZWZpbmVkJykgcmVzID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbiAgLy8gcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG59O1xuXG52YXIgc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAkKGVsZW1lbnQpLmF0dHIoYXR0cmlidXRlLCB2YWx1ZSk7XG4gIC8vIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufTtcblxudmFyIHJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAkKGVsZW1lbnQpLnJlbW92ZUF0dHIoYXR0cmlidXRlKTtcbiAgLy8gZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn07XG5cbnZhciBnZXRJbm5lclRleHQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiAkKGVsZW1lbnQpLnRleHQoKTtcbiAgLy8gaWYgKHR5cGVvZiBlbGVtZW50LmlubmVyVGV4dCAhPSAndW5kZWZpbmVkJykgcmV0dXJuIGVsZW1lbnQuaW5uZXJUZXh0O1xuICAvLyBlbHNlIHJldHVybiBlbGVtZW50LnRleHRDb250ZW50O1xufTtcblxudmFyIGdldElubmVySHRtbCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuICQoZWxlbWVudCkuaHRtbCgpO1xuICAvLyByZXR1cm4gZWxlbWVudC5pbm5lckhUTUw7XG59O1xuXG52YXIgZ2V0TG93ZXJUYWdOYW1lID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAvLyBzb21ldGltZXMgY2hlZXJpbyBkb2Vzbid0IGhhdmUgdGFnTmFtZSBidXQgXCJuYW1lXCIuXG4gIC8vIEJyb3dzZXJzIGhhdmUgXCJuYW1lXCIgd2l0aCBlbXB0eSBzdHJpbmdcbiAgLy8gU29tZXRpbWVzIGNoZWVyaW8gaGFzIHRhZ05hbWUgYnV0IG5vIHByb3AgZnVuY3Rpb24uXG4gIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICcnICYmIHR5cGVvZiBlbGVtZW50Lm5hbWUgPT0gJ3N0cmluZycpIHJldHVybiBlbGVtZW50Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGVsZW1lbnQudGFnTmFtZSAhPT0gJycpIHJldHVybiBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICQoZWxlbWVudCkucHJvcChcInRhZ05hbWVcIikudG9Mb3dlckNhc2UoKTtcbiAgLy8gcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIHNldENvbnRlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjb250ZW50KSB7XG4gICQoZWxlbWVudCkuaHRtbChjb250ZW50KTtcbiAgLy8gZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xufTtcblxudmFyIHJlcGxhY2VIdG1sID0gZnVuY3Rpb24oZWxlbWVudCwgaHRtbCkge1xuICAkKGVsZW1lbnQpLnJlcGxhY2VXaXRoKGh0bWwpO1xuICAvLyBlbGVtZW50Lm91dGVySFRNTCA9IGh0bWw7XG59O1xuXG52YXIgcmVtb3ZlRWxlbWVudHMgPSBmdW5jdGlvbigkZWxlbWVudHMsIHRyeURldGFjaCkge1xuICBpZiAodHJ5RGV0YWNoICYmIHR5cGVvZiAkZWxlbWVudHMuZGV0YWNoICE9PSAndW5kZWZpbmVkJykgJGVsZW1lbnRzLmRldGFjaCgpO1xuICAvLyBOT1RFOiB3ZSBkb24ndCBuZWVkIGFuIGVsc2UsIGFzIGRldGFjaCBpcyBzaW1wbHkgYW4gb3B0aW1pemF0aW9uXG4gICRlbGVtZW50cy5yZW1vdmUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcbiAgc2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGUsXG4gIHJlbW92ZUF0dHJpYnV0ZTogcmVtb3ZlQXR0cmlidXRlLFxuICBnZXRJbm5lclRleHQ6IGdldElubmVyVGV4dCxcbiAgZ2V0SW5uZXJIdG1sOiBnZXRJbm5lckh0bWwsXG4gIGdldExvd2VyVGFnTmFtZTogZ2V0TG93ZXJUYWdOYW1lLFxuICBzZXRDb250ZW50OiBzZXRDb250ZW50LFxuICByZXBsYWNlSHRtbDogcmVwbGFjZUh0bWwsXG4gIHJlbW92ZUVsZW1lbnRzOiByZW1vdmVFbGVtZW50cyxcbiAgb2JqRXh0ZW5kOiBvYmpFeHRlbmRcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgZWxhYm9yYXRlRGVjbGFyYXRpb25zID0gcmVxdWlyZShcIi4vZGVjbGFyYXRpb25zLmpzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xudmFyIG1vZGVsRGVmID0gcmVxdWlyZSgnLi9tb2RlbC5qcycpO1xuXG52YXIgX2dldE9wdGlvbnNPYmplY3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBvcHRpb25zQ291cGxlcyA9IG9wdGlvbnMuc3BsaXQoJ3wnKTtcbiAgdmFyIG9wdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zQ291cGxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvcHQgPSBvcHRpb25zQ291cGxlc1tpXS5zcGxpdCgnPScpO1xuICAgIG9wdHNbb3B0WzBdXSA9IG9wdC5sZW5ndGggPiAxID8gb3B0WzFdIDogb3B0WzBdO1xuICB9XG4gIHJldHVybiBvcHRzO1xufTtcblxuLy8gVE9ETyB0aGlzIHNob3VsZCBub3QgaGF2ZSBoYXJkY29kZWQgcnVsZXMgKHdlIG5vdyBoYXZlIGEgd2F5IHRvIGRlY2xhcmUgdGhlbSBpbiB0aGUgdGVtcGxhdGUgZGVmaW5pdGlvbilcbi8vIENhdGVnb3J5IFwic3R5bGVcIiBpcyB1c2VkIGJ5IGVkaXRUeXBlIFwic3R5bGVyXCJcbi8vIENhdGVvZ3J5IFwiY29udGVudFwiIGlzIHVzZWQgYnkgZWRpdFR5cGUgXCJlZGl0XCJcbi8vIFRPRE8gbWF5YmUgd2Ugc2hvdWxkIHVzZSBhIGNvbW1vbiBzdHJpbmcgaGVyZSwgYW5kIHJlbHkgb25seSBvbiB0aGUgb3JpZ2luYWwgY2F0ZWdvcnkuXG52YXIgX2ZpbHRlclByb3BzID0gZnVuY3Rpb24obW9kZWwsIGVkaXRUeXBlLCBsZXZlbCkge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIHByb3AgaW4gbW9kZWwpXG4gICAgaWYgKCFwcm9wLm1hdGNoKC9eY3VzdG9tU3R5bGUkLykgJiYgIXByb3AubWF0Y2goL15fLykgJiYgbW9kZWwuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHZhciBpc1N0eWxlUHJvcCA9IG1vZGVsW3Byb3BdICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbFtwcm9wXS5fY2F0ZWdvcnkgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kZWxbcHJvcF0uX2NhdGVnb3J5ID09ICdzdHlsZSc7XG4gICAgICBpZiAocHJvcCA9PSAnaWQnIHx8IHByb3AgPT0gJ3R5cGUnIHx8IHByb3AubWF0Y2goL0Jsb2NrcyQvKSkge30gZWxzZSBpZiAoZWRpdFR5cGUgPT0gJ3N0eWxlcicpIHtcbiAgICAgICAgaWYgKGlzU3R5bGVQcm9wIHx8IGxldmVsID4gMCkgcmVzLnB1c2gocHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKGVkaXRUeXBlID09ICdlZGl0Jykge1xuICAgICAgICAvLyBFZGl0aW5nIGZvciBwcm9wZXJ0aWVzIGluIHRoZSBcImNvbnRlbnRcIiBjYXRlZ29yeSBidXQgbm90IGRlZmluZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBibG9ja1xuICAgICAgICB2YXIgaXNDb250ZW50UHJvcCA9IG1vZGVsW3Byb3BdICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbFtwcm9wXS5fY2F0ZWdvcnkgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kZWxbcHJvcF0uX2NhdGVnb3J5ID09ICdjb250ZW50JyAmJlxuICAgICAgICAgICh0eXBlb2YgbW9kZWxbcHJvcF0uX2NvbnRleHQgPT0gJ3VuZGVmaW5lZCcgfHwgbW9kZWxbcHJvcF0uX2NvbnRleHQgIT0gJ2Jsb2NrJyk7XG4gICAgICAgIGlmIChpc0NvbnRlbnRQcm9wKSByZXMucHVzaChwcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVkaXRUeXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlcy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBfcHJvcElucHV0ID0gZnVuY3Rpb24obW9kZWwsIHByb3AsIHByb3BBY2Nlc3NvciwgZWRpdFR5cGUsIHdpZGdldHMpIHtcbiAgdmFyIGh0bWwgPSBcIlwiO1xuICB2YXIgd2lkZ2V0O1xuICBpZiAobW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl93aWRnZXQgIT0gJ3VuZGVmaW5lZCcpIHdpZGdldCA9IG1vZGVsLl93aWRnZXQ7XG5cbiAgaWYgKHR5cGVvZiB3aWRnZXQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBcIlVua25vd24gZGF0YSB0eXBlIGZvciBcIiArIHByb3A7XG4gIH1cblxuICAvLyBGb3IgY29udGVudCBlZGl0b3JzIHdlIGRlYWwgd2l0aCBmb2N1c2luZyAoY2xpY2tpbmcgaXMgaGFuZGxlZCBieSB0aGUgY29udGFpbmVyIERJVikuXG4gIHZhciBvbmZvY3VzYmluZGluZyA9ICdmb2N1c2FibGU6IHRydWUnO1xuICBpZiAoZWRpdFR5cGUgPT0gJ2VkaXQnKSB7XG4gICAgb25mb2N1c2JpbmRpbmcgKz0gJywgZXZlbnQ6IHsgZm9jdXM6IGZ1bmN0aW9uKHVpLCBldmVudCkgeyAkKCRlbGVtZW50KS5jbGljaygpOyB9IH0gJztcbiAgfVxuXG4gIGh0bWwgKz0gJzxsYWJlbCBjbGFzcz1cImRhdGEtJyArIHdpZGdldCArICdcIicgKyAod2lkZ2V0ID09ICdib29sZWFuJyA/ICcgZGF0YS1iaW5kPVwiZXZlbnQ6IHsgbW91c2Vkb3duOiBmdW5jdGlvbih1aSwgZXZ0KSB7IGlmIChldnQuYnV0dG9uID09IDApIHsgdmFyIGlucHV0ID0gJCgkZWxlbWVudCkuZmluZChcXCdpbnB1dFxcJyk7IHZhciBjaCA9IGlucHV0LnByb3AoXFwnY2hlY2tlZFxcJyk7IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGlucHV0LmNsaWNrKCk7IGlucHV0LnByb3AoXFwnY2hlY2tlZFxcJywgIWNoKTsgaW5wdXQudHJpZ2dlcihcXCdjaGFuZ2VcXCcpOyB9LCAwKTsgfSB9IH0sIGNsaWNrOiBmdW5jdGlvbih1aSwgZXZ0KSB7IGV2dC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBjbGlja0J1YmJsZTogZmFsc2VcIicgOiAnJykgKyAnPic7XG5cbiAgaWYgKHR5cGVvZiB3aWRnZXRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2lkZ2V0c1t3aWRnZXRdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB3ID0gd2lkZ2V0c1t3aWRnZXRdO1xuICAgIHZhciBwYXJhbWV0ZXJzID0ge307XG4gICAgaWYgKHR5cGVvZiB3LnBhcmFtZXRlcnMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgZm9yICh2YXIgcCBpbiB3LnBhcmFtZXRlcnMpXG4gICAgICAgIGlmICh3LnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkocCkgJiYgdHlwZW9mIG1vZGVsWydfJytwXSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgcGFyYW1ldGVyc1twXSA9IG1vZGVsWydfJytwXTtcbiAgICBodG1sICs9IHcuaHRtbChwcm9wQWNjZXNzb3IsIG9uZm9jdXNiaW5kaW5nLCBwYXJhbWV0ZXJzKTtcbiAgfSBlbHNlIGlmICh3aWRnZXQgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgaHRtbCArPSAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwibm90aGluZ1wiIGRhdGEtYmluZD1cImNoZWNrZWQ6ICcgKyBwcm9wQWNjZXNzb3IgKyAnLCAnICsgb25mb2N1c2JpbmRpbmcgKyAnXCIgLz4nO1xuICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwiY2hlY2tib3gtcmVwbGFjZXJcIiA+PC9zcGFuPic7IC8qIGRhdGEtYmluZD1cImNzczogeyBjaGVja2VkOiAnK3Byb3BBY2Nlc3NvcisnIH1cIiAqL1xuICB9IGVsc2UgaWYgKHdpZGdldCA9PSAnY29sb3InKSB7XG4gICAgaHRtbCArPSAnPGlucHV0IHNpemU9XCI3XCIgdHlwZT1cInRleHRcIiBkYXRhLWJpbmQ9XCJjb2xvcnBpY2tlcjogeyBjb2xvcjogJyArIHByb3BBY2Nlc3NvciArICcsIHN0cmluZ3M6ICRyb290LnQoXFwnVGhlbWUgQ29sb3JzLFN0YW5kYXJkIENvbG9ycyxXZWIgQ29sb3JzLFRoZW1lIENvbG9ycyxCYWNrIHRvIFBhbGV0dGUsSGlzdG9yeSxObyBoaXN0b3J5IHlldC5cXCcpIH0sICcgKyAnLCAnICsgb25mb2N1c2JpbmRpbmcgKyAnXCIgLz4nO1xuICB9IGVsc2UgaWYgKHdpZGdldCA9PSAnc2VsZWN0Jykge1xuICAgIGlmICh0eXBlb2YgbW9kZWwuX29wdGlvbnMgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBvcHRzID0gX2dldE9wdGlvbnNPYmplY3QobW9kZWwuX29wdGlvbnMpO1xuICAgICAgLy8gdmFyIG9wdHMgPSBtb2RlbC5fb3B0aW9ucztcbiAgICAgIGh0bWwgKz0gJzxzZWxlY3QgZGF0YS1iaW5kPVwidmFsdWU6ICcgKyBwcm9wQWNjZXNzb3IgKyAnLCAnICsgb25mb2N1c2JpbmRpbmcgKyAnXCI+JztcbiAgICAgIGZvciAodmFyIG9wdCBpbiBvcHRzKVxuICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBvcHQgKyAnXCIgZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudXQoXFwndGVtcGxhdGVcXCcsIFxcJycgKyB1dGlscy5hZGRTbGFzaGVzKG9wdHNbb3B0XSkgKyAnXFwnKVwiPicgKyBvcHRzW29wdF0gKyAnPC9vcHRpb24+JztcbiAgICAgICAgfVxuICAgICAgaHRtbCArPSAnPC9zZWxlY3Q+JztcbiAgICB9XG4gIH0gZWxzZSBpZiAod2lkZ2V0ID09ICdmb250Jykge1xuICAgIGh0bWwgKz0gJzxzZWxlY3QgdHlwZT1cInRleHRcIiBkYXRhLWJpbmQ9XCJ2YWx1ZTogJyArIHByb3BBY2Nlc3NvciArICcsICcgKyBvbmZvY3VzYmluZGluZyArICdcIj4nO1xuICAgIGh0bWwgKz0gJzxvcHRncm91cCBsYWJlbD1cIlNhbnMtU2VyaWYgRm9udHNcIj4nO1xuICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJBcmlhbCxIZWx2ZXRpY2Esc2Fucy1zZXJpZlwiPkFyaWFsPC9vcHRpb24+JztcbiAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiXFwnQ29taWMgU2FucyBNU1xcJyxjdXJzaXZlLHNhbnMtc2VyaWZcIj5Db21pYyBTYW5zIE1TPC9vcHRpb24+JztcbiAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiSW1wYWN0LENoYXJjb2FsLHNhbnMtc2VyaWZcIj5JbXBhY3Q8L29wdGlvbj4nO1xuICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJcXCdUcmVidWNoZXQgTVNcXCcsSGVsdmV0aWNhLHNhbnMtc2VyaWZcIj5UcmVidWNoZXQgTVM8L29wdGlvbj4nO1xuICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJWZXJkYW5hLEdlbmV2YSxzYW5zLXNlcmlmXCI+VmVyZGFuYTwvb3B0aW9uPic7XG4gICAgaHRtbCArPSAnPC9vcHRncm91cD4nO1xuICAgIGh0bWwgKz0gJzxvcHRncm91cCBsYWJlbD1cIlNlcmlmIEZvbnRzXCI+JztcbiAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiR2VvcmdpYSxzZXJpZlwiPkdlb3JnaWE8L29wdGlvbj4nO1xuICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJcXCdUaW1lcyBOZXcgUm9tYW5cXCcsVGltZXMsc2VyaWZcIj5UaW1lcyBOZXcgUm9tYW48L29wdGlvbj4nO1xuICAgIGh0bWwgKz0gJzwvb3B0Z3JvdXA+JztcbiAgICBodG1sICs9ICc8b3B0Z3JvdXAgbGFiZWw9XCJNb25vc3BhY2UgRm9udHNcIj4nO1xuICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJcXCdDb3VyaWVyIE5ld1xcJyxDb3VyaWVyLG1vbm9zcGFjZVwiPkNvdXJpZXIgTmV3PC9vcHRpb24+JztcbiAgICBodG1sICs9ICc8L29wdGdyb3VwPic7XG4gICAgaHRtbCArPSAnPC9zZWxlY3Q+JztcbiAgfSBlbHNlIGlmICh3aWRnZXQgPT0gJ3VybCcpIHtcbiAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwidWktdGV4dGJ1dHRvblwiPic7XG4gICAgLy8gPGEgY2xhc3M9XCJ1aS1zcGlubmVyLWJ1dHRvbiB1aS1zcGlubmVyLWRvd24gdWktY29ybmVyLWJyIHVpLWJ1dHRvbiB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1idXR0b24tdGV4dC1vbmx5XCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJidXR0b25cIj48c3BhbiBjbGFzcz1cInVpLWJ1dHRvbi10ZXh0XCI+PHNwYW4gY2xhc3M9XCJ1aS1pY29uIGZhIGZhLWZ3IGNhcmV0LWRvd25cIj7ilrw8L3NwYW4+PC9zcGFuPjwvYT5cbiAgICBodG1sICs9ICc8aW5wdXQgY2xhc3M9XCJ1aS10ZXh0YnV0dG9uLWlucHV0XCIgc2l6ZT1cIjdcIiB0eXBlPVwidXJsXCIgcGF0dGVybj1cIihtYWlsdG86LitALit8aHR0cHM/Oi8vLitcXFxcLi4rfFxcXFxbLipcXFxcXS4qKVwiIHZhbHVlPVwibm90aGluZ1wiIGRhdGEtYmluZD1cImNzczogeyB3aXRoQnV0dG9uOiB0eXBlb2YgJHJvb3QubGlua0RpYWxvZyAhPT0gXFwndW5kZWZpbmVkXFwnIH0sIHZhbGlkYXRlZFZhbHVlOiAnICsgcHJvcEFjY2Vzc29yICsgJywgJyArIG9uZm9jdXNiaW5kaW5nICsgJ1wiIC8+JztcbiAgICBodG1sICs9ICc8YSBjbGFzcz1cInVpLXRleHRidXR0b24tYnV0dG9uXCIgZGF0YS1iaW5kPVwidmlzaWJsZTogdHlwZW9mICRyb290LmxpbmtEaWFsb2cgIT09IFxcJ3VuZGVmaW5lZFxcJywgY2xpY2s6IHR5cGVvZiAkcm9vdC5saW5rRGlhbG9nICE9PSBcXCd1bmRlZmluZWRcXCcgPyAkcm9vdC5saW5rRGlhbG9nLmJpbmQoJGVsZW1lbnQucHJldmlvdXNTaWJsaW5nKSA6IGZhbHNlLCBidXR0b246IHsgaWNvbnM6IHsgcHJpbWFyeTogXFwnZmEgZmEtZncgZmEtZWxsaXBzaXMtaFxcJyB9LCBsYWJlbDogXFwnT3B6aW9uaVxcJywgdGV4dDogZmFsc2UgfVwiPk9wemlvbmk8L2E+JztcbiAgICBodG1sICs9ICc8L2Rpdj4nO1xuICB9IGVsc2UgaWYgKHdpZGdldCA9PSAnaW50ZWdlcicpIHtcbiAgICAvLyBhdCB0aGlzIHRpbWUgdGhlIFwic3RlcFwiIGRlcGVuZHMgb24gbWF4IGJlaW5nIGdyZWF0ZXIgdGhhbiAxMDAuXG4gICAgLy8gbWF5YmUgd2Ugc2hvdWxkIGV4cG9zZSBcInN0ZXBcIiBhcyBhIGNvbmZpZ3VyYXRpb24sIHRvb1xuICAgIHZhciBtaW4gPSAwO1xuICAgIHZhciBtYXggPSAxMDAwO1xuICAgIGlmIChtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX21heCAhPT0gJ3VuZGVmaW5lZCcpIG1heCA9IG1vZGVsLl9tYXg7XG4gICAgaWYgKG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fbWluICE9PSAndW5kZWZpbmVkJykgbWluID0gbW9kZWwuX21pbjtcbiAgICB2YXIgc3RlcCA9IChtYXggLSBtaW4pID49IDEwMCA/IDEwIDogMTtcbiAgICB2YXIgcGFnZSA9IHN0ZXAgKiA1O1xuICAgIGh0bWwgKz0gJzxpbnB1dCBjbGFzcz1cIm51bWJlci1zcGlubmVyXCIgc2l6ZT1cIjdcIiBzdGVwPVwiJyArIHN0ZXAgKyAnXCIgdHlwZT1cIm51bWJlclwiIHZhbHVlPVwiLTFcIiBkYXRhLWJpbmQ9XCJzcGlubmVyOiB7IG1pbjogJyArIG1pbiArICcsIG1heDogJyArIG1heCArICcsIHBhZ2U6ICcgKyBwYWdlICsgJywgdmFsdWU6ICcgKyBwcm9wQWNjZXNzb3IgKyAnIH0sIHZhbHVlVXBkYXRlOiBbXFwnY2hhbmdlXFwnLCBcXCdzcGluXFwnXScgKyAnLCAnICsgb25mb2N1c2JpbmRpbmcgKyAnXCIgLz4nO1xuICB9IGVsc2Uge1xuICAgIGh0bWwgKz0gJzxpbnB1dCBzaXplPVwiN1wiIHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCJub3RoaW5nXCIgZGF0YS1iaW5kPVwidmFsdWU6ICcgKyBwcm9wQWNjZXNzb3IgKyAnLCAnICsgb25mb2N1c2JpbmRpbmcgKyAnXCIgLz4nO1xuICB9XG5cbiAgaHRtbCArPSAnPC9sYWJlbD4nO1xuXG4gIHJldHVybiBodG1sO1xufTtcblxudmFyIF9nZXRHbG9iYWxTdHlsZVByb3AgPSBmdW5jdGlvbihnbG9iYWxTdHlsZXMsIG1vZGVsLCBwcm9wLCBwYXRoKSB7XG4gIHZhciBnbG9iYWxTdHlsZVByb3A7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09ICdvYmplY3QnIHx8IG1vZGVsID09PSBudWxsIHx8IHR5cGVvZiBtb2RlbC5fd2lkZ2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgcHJvcCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnICYmIHBhdGgubGVuZ3RoID4gMCAmJiB0eXBlb2YgZ2xvYmFsU3R5bGVzID09ICdvYmplY3QnICYmIHR5cGVvZiBnbG9iYWxTdHlsZXNbcGF0aF0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbFN0eWxlUHJvcCA9IGdsb2JhbFN0eWxlc1twYXRoXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFN0eWxlUHJvcDtcbn07XG5cbnZhciBfcHJvcEVkaXRvciA9IGZ1bmN0aW9uKHdpdGhCaW5kaW5nUHJvdmlkZXIsIHdpZGdldHMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBtb2RlbCwgdGhlbWVNb2RlbCwgcGF0aCwgcHJvcCwgZWRpdFR5cGUsIGxldmVsLCBiYXNlVGhyZXNob2xkLCBnbG9iYWxTdHlsZXMsIGdsb2JhbFN0eWxlUHJvcCwgdHJhY2tVc2FnZSwgcm9vdFByZXZpZXdCaW5kaW5nLCBwcmV2aWV3QmFja2dyb3VuZCkge1xuICBpZiAodHlwZW9mIGxldmVsID09ICd1bmRlZmluZWQnKSBsZXZlbCA9IDA7XG5cbiAgaWYgKHR5cGVvZiBwcm9wICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kZWwgPT0gJ29iamVjdCcgJiYgbW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl91c2Vjb3VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmxvZyhcIlRPRE8gRURJVE9SIGlnbm9yaW5nXCIsIHBhdGgsIFwicHJvcGVydHkgYmVjYXVzZSBpdCBpcyBub3QgdXNlZCBieSB0aGUgdGVtcGxhdGVcIiwgXCJwcm9wOlwiLCBwcm9wLCBcInR5cGU6XCIsIGVkaXRUeXBlLCBcImxldmVsOlwiLCBsZXZlbCwgd2l0aEJpbmRpbmdQcm92aWRlci5fdGVtcGxhdGVOYW1lKTtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIHZhciBwcm9wQWNjZXNzb3IgPSB0eXBlb2YgZ2xvYmFsU3R5bGVQcm9wICE9ICd1bmRlZmluZWQnID8gcHJvcCArICcuX2RlZmF1bHRDb21wdXRlZCcgOiBwcm9wO1xuXG4gIHZhciBodG1sID0gXCJcIjtcbiAgdmFyIHRpdGxlO1xuICB2YXIgaWZTdWJzUHJvcCA9IHByb3BBY2Nlc3NvcjtcbiAgdmFyIGlmU3Vic0d1dHRlciA9IDE7XG4gIC8vIHR5cGVvZiBnbG9iYWxTdHlsZVByb3AgIT0gJ3VuZGVmaW5lZCcgPyAxIDogMjtcbiAgdmFyIGlmU3Vic1RocmVzaG9sZCA9IDE7XG5cbiAgLy8gVGhlIHZpc2liaWxpdHkgaGFuZGxpbmcgaXMgYSBQSVRBXG4gIC8vIFxuICAvLyBIZXJlIGFyZSBzb21lIFwiZWRnZSBjYXNlc1wiIHRvIHRlc3Qgd2hlbmV2ZXIgd2UgY2hhbmdlIHNvbWV0aGluZyBoZXJlOlxuICAvLyBMTSBzb2NpYWwgZm9vdGVyOiByZW1vdmluZyBzaGFyZVZpc2liaWxlIG11c3QgYmUgcmVmbGVjdGVkIGluIHRoZSBib29sZWFucyBzdWItY2hlY2tzXG4gIC8vIEZMVUlEIHNvY2lhbCBibG9jazogbXVsdGlwbGUgY2xpY2tzIG9uIHRoZSBcIndhbmRcIiBzaG91bGQgbm90IG1ha2UgdGhlIGVkaXRvciBpbnZpc2libGVcbiAgLy8gQklTIGhlcm9NZW51IC0gQnkgY2hhbmdpbmcgdGhlIG1lbnUgdmlzaWJpbGl0eSBpdCBzaG91bGQgYmUgcmVmbGVjdGVkIGluIHN0eWxlIGVkaXRvcnMgZm9yIHRoZSBtZW51IGxpbmtzXG4gIC8vIEZMVUlEIGFsbW9zdCBldmVyeSBibG9jayB3aXRoIGEgY29sb3IgdmFyaWFudCBzb21ldGltZXMga2VlcHMgc2hvd2luZyBzdHlsZSBlZGl0b3IgZm9yIHRoZSBoaWRkZW4gdmFyaWFudC5cbiAgaWYgKHR5cGVvZiBtb2RlbCA9PSAnb2JqZWN0JyAmJiBtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX3dpZGdldCA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIERvIG5vdGhpbmcgaGVyZVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsU3R5bGVQcm9wID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZlN1YnNHdXR0ZXIgKz0gMTtcbiAgICB9XG4gIH1cblxuICAvLyBOT1RFIGJhc2VUaHJlc2hvbGQgaXMgYWRkZWQgb25seSB3aGVuIGdsb2JhbFN0eWxlIGlzIG5vdCBkZWZpbmVkIGJlY2F1c2Ugd2hlbiB3ZSBoYXZlIGdsb2JhbFN0eWxlXG4gIC8vIHdlJ3JlIGdvaW5nIHRvIGJpbmQgdGhlIGNvbXB1dGVkIHZhbHVlcyBhbmQgbm90IHRoZSBvcmlnaW5hbCBhbmQgdGhpcyB3YXkgd2UgZG9uJ3QgYWRkIG91cnNlcmYgdG8gdGhlIGRlcGVuZGVuY3kgXG4gIC8vIHRyYWNraW5nIChzdWJzY3JpcHRpb25Db3VudClcbiAgLy8gTk9URSBiYXNlVGhyZXNob2xkIGlzIGFuIFwiZXhwcmVzc2lvblwiIGFuZCBub3QgYSBmaXhlZCBudW1iZXIsIHNvIHRoaXMgaXMgYSBjb25jYXRlbmF0aW9uXG4gIGlmICh0eXBlb2YgZ2xvYmFsU3R5bGVQcm9wID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBiYXNlVGhyZXNob2xkICE9PSAndW5kZWZpbmVkJykgaWZTdWJzVGhyZXNob2xkICs9IGJhc2VUaHJlc2hvbGQ7XG5cbiAgaWYgKHR5cGVvZiBwcm9wICE9ICd1bmRlZmluZWQnICYmICEhdHJhY2tVc2FnZSkge1xuICAgIGh0bWwgKz0gJzwhLS0ga28gaWZTdWJzOiB7IGRhdGE6ICcgKyBpZlN1YnNQcm9wICsgJywgdGhyZXNob2xkOiAnICsgaWZTdWJzVGhyZXNob2xkICsgJywgZ3V0dGVyOiAnICsgaWZTdWJzR3V0dGVyICsgJyB9IC0tPic7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb3AgIT0gJ3VuZGVmaW5lZCcgJiYgKG1vZGVsID09PSBudWxsIHx8IHR5cGVvZiBtb2RlbC5fbmFtZSA9PSAndW5kZWZpbmVkJykpIHtcbiAgICAvLyBUT0RPIHRocm93IGV4Y2VwdGlvbj9cbiAgICBjb25zb2xlLmxvZyhcIlRPRE8gV0FSTiBNaXNzaW5nIGxhYmVsIGZvciBwcm9wZXJ0eSBcIiwgcHJvcCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wID09ICd1bmRlZmluZWQnICYmIG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fbmFtZSA9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUubG9nKFwiVE9ETyBXQVJOIE1pc3NpbmcgbGFiZWwgZm9yIG9iamVjdCBcIiwgbW9kZWwudHlwZSAvKiwgbW9kZWwgKi8gKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbW9kZWwgPT0gJ29iamVjdCcgJiYgbW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl93aWRnZXQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgcHJvcHMgPSBfZmlsdGVyUHJvcHMobW9kZWwsIGVkaXRUeXBlLCBsZXZlbCk7XG5cbiAgICB2YXIgaGFzQ3VzdG9tU3R5bGUgPSBlZGl0VHlwZSA9PSAnc3R5bGVyJyAmJiBtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuY3VzdG9tU3R5bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWxTdHlsZVByb3AgIT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBzZWxlY3RlZEl0ZW1CaW5kaW5nID0gJyc7XG4gICAgdmFyIGFkZGl0aW9uYWxDbGFzc2VzID0gJyc7XG4gICAgaWYgKHR5cGVvZiBwcm9wICE9PSAndW5kZWZpbmVkJyAmJiBlZGl0VHlwZSA9PSAnZWRpdCcpIHtcbiAgICAgIHNlbGVjdGVkSXRlbUJpbmRpbmcgPSAnLCBjbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0SXRlbSgnICsgcHJvcCArICcsICRkYXRhKTsgcmV0dXJuIGZhbHNlIH0sIGNsaWNrQnViYmxlOiBmYWxzZSwgY3NzOiB7IHNlbGVjdGVkaXRlbTogJHJvb3QuaXNTZWxlY3RlZEl0ZW0oJyArIHByb3AgKyAnKSB9LCBzY3JvbGxJbnRvVmlldzogJHJvb3QuaXNTZWxlY3RlZEl0ZW0oJyArIHByb3AgKyAnKSwgJztcbiAgICAgIGFkZGl0aW9uYWxDbGFzc2VzICs9ICcgc2VsZWN0YWJsZSc7XG4gICAgfVxuICAgIGlmIChoYXNDdXN0b21TdHlsZSkge1xuICAgICAgYWRkaXRpb25hbENsYXNzZXMgKz0gJyBzdXBwb3J0c0N1c3RvbVN0eWxlcyc7XG4gICAgfVxuICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJvYmpFZGl0IGxldmVsJyArIGxldmVsICsgYWRkaXRpb25hbENsYXNzZXMgKyAnXCIgZGF0YS1iaW5kPVwidG9vbHRpcHM6IHt9JyArIHNlbGVjdGVkSXRlbUJpbmRpbmcgKyAnXCI+JztcbiAgICB2YXIgbW9kZWxOYW1lID0gKG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fbmFtZSAhPSAndW5kZWZpbmVkJyA/IG1vZGVsLl9uYW1lIDogKHR5cGVvZiBwcm9wICE9PSAndW5kZWZpbmVkJyA/ICdbJyArIHByb3AgKyAnXScgOiAnJykpO1xuICAgIGlmIChoYXNDdXN0b21TdHlsZSkge1xuICAgICAgdmFyIHRoZW1lU2VjdGlvbk5hbWUgPSAnU3RpbGUnO1xuICAgICAgaWYgKHR5cGVvZiB0aGVtZU1vZGVsICE9PSAndW5kZWZpbmVkJyAmJiB0aGVtZU1vZGVsICE9PSBudWxsICYmIHR5cGVvZiB0aGVtZU1vZGVsLl9uYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGVtZVNlY3Rpb25OYW1lID0gdGhlbWVNb2RlbC5fbmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyBtaXNzaW5nIGxhYmVsIGZvciB0aGVtZSBzZWN0aW9uIFwiLCBwcm9wLCBtb2RlbCAhPT0gbnVsbCA/IG1vZGVsLnR5cGUgOiAnLScpO1xuICAgICAgfVxuXG4gICAgICBtb2RlbE5hbWUgPSAnPHNwYW4gY2xhc3M9XCJibG9ja1NlbGVjdGlvbk1ldGhvZFwiIGRhdGEtYmluZD1cInRleHQ6IGN1c3RvbVN0eWxlKCkgPyAkcm9vdC51dChcXCd0ZW1wbGF0ZVxcJywgXFwnJyArIHV0aWxzLmFkZFNsYXNoZXMobW9kZWxOYW1lKSArICdcXCcpIDogJHJvb3QudXQoXFwndGVtcGxhdGVcXCcsIFxcJycgKyB1dGlscy5hZGRTbGFzaGVzKHRoZW1lU2VjdGlvbk5hbWUpICsgJ1xcJylcIj5CbG9jazwvc3Bhbj4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbE5hbWUgPSAnPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudXQoXFwndGVtcGxhdGVcXCcsIFxcJycgKyB1dGlscy5hZGRTbGFzaGVzKG1vZGVsTmFtZSkgKyAnXFwnKVwiPicgKyBtb2RlbE5hbWUgKyAnPC9zcGFuPic7XG4gICAgfVxuICAgIHRpdGxlID0gbW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl9oZWxwICE9PSAndW5kZWZpbmVkJyA/ICcgdGl0bGU9XCInICsgdXRpbHMuYWRkU2xhc2hlcyhtb2RlbC5faGVscCkgKyAnXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudXQoXFwndGVtcGxhdGVcXCcsIFxcJycgKyB1dGlscy5hZGRTbGFzaGVzKG1vZGVsLl9oZWxwKSArICdcXCcpIH1cIicgOiAnJztcbiAgICBodG1sICs9ICc8c3BhbicgKyB0aXRsZSArICcgY2xhc3M9XCJvYmpMYWJlbCBsZXZlbCcgKyBsZXZlbCArICdcIj4nICsgbW9kZWxOYW1lICsgJzwvc3Bhbj4nO1xuXG4gICAgaWYgKGVkaXRUeXBlID09ICdlZGl0JyAmJiB0eXBlb2YgbW9kZWwuX2Jsb2NrRGVzY3JpcHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwiYmxvY2tEZXNjcmlwdGlvblwiIGRhdGEtYmluZD1cImh0bWw6ICRyb290LnV0KFxcJ3RlbXBsYXRlXFwnLCBcXCcnICsgdXRpbHMuYWRkU2xhc2hlcyhtb2RlbC5fYmxvY2tEZXNjcmlwdGlvbikgKyAnXFwnKVwiPicgKyBtb2RlbC5fYmxvY2tEZXNjcmlwdGlvbiArICc8L2Rpdj4nO1xuICAgIH1cblxuICAgIC8qIENVU1RPTSBTVFlMRSAqL1xuICAgIGlmIChoYXNDdXN0b21TdHlsZSkge1xuICAgICAgaHRtbCArPSAnPGxhYmVsIGNsYXNzPVwiZGF0YS1ib29sZWFuIGJsb2NrQ2hlY2tcIiBkYXRhLWJpbmQ9XCJ0b29sdGlwczogeyB9XCI+JztcbiAgICAgIGh0bWwgKz0gJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cIm5vdGhpbmdcIiBkYXRhLWJpbmQ9XCJmb2N1c2FibGU6IHRydWUsIGNoZWNrZWQ6IGN1c3RvbVN0eWxlXCIgLz4nO1xuICAgICAgaHRtbCArPSAnPHNwYW4gdGl0bGU9XCJTd2l0Y2ggYmV0d2VlbiBnbG9iYWwgYW5kIGJsb2NrIGxldmVsIHN0eWxlcyBlZGl0aW5nXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdTd2l0Y2ggYmV0d2VlbiBnbG9iYWwgYW5kIGJsb2NrIGxldmVsIHN0eWxlcyBlZGl0aW5nXFwnKSB9XCIgY2xhc3M9XCJjaGVja2JveC1yZXBsYWNlciBjaGVja2JveC1yZXBsYWNlci1vbm9mZlwiPjwvc3Bhbj4nOyAvLyAgZGF0YS1iaW5kPVwidG9vbHRpcDogeyBjb250ZW50OiBcXCdwZXJzb25hbGl6emEgdHV0dGlcXCcgfVwiXG4gICAgICBodG1sICs9ICc8L2xhYmVsPic7XG4gICAgICBodG1sICs9ICc8IS0tIGtvIHRlbXBsYXRlOiB7IG5hbWU6IFxcJ2N1c3RvbXN0eWxlXFwnLCBpZjogY3VzdG9tU3R5bGUgfSAtLT48IS0tIC9rbyAtLT4nO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvcCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgaHRtbCArPSAnPCEtLSBrbyB3aXRoOiAnICsgcHJvcCArICcgLS0+JztcblxuICAgICAgLyogUFJFVklFVyAqL1xuICAgICAgaWYgKGxldmVsID09IDEgJiYgdHlwZW9mIHByb3AgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlbC5fcHJldmlld0JpbmRpbmdzICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aXRoQmluZGluZ1Byb3ZpZGVyICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByb290UHJldmlld0JpbmRpbmcgIT0gJ3VuZGVmaW5lZCcpIGh0bWwgKz0gJzwhLS0ga28gd2l0aDogJHJvb3QuY29udGVudCgpIC0tPjxkaXYgY2xhc3M9XCJvYmpQcmV2aWV3XCIgZGF0YS1iaW5kPVwiJyArIHJvb3RQcmV2aWV3QmluZGluZyArICdcIj48L2Rpdj48IS0tIC9rbyAtLT4nO1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJldmlld0JhY2tncm91bmQgIT0gJ3VuZGVmaW5lZCcpIGh0bWwgKz0gJzwhLS0ga28gd2l0aDogJHBhcmVudCAtLT48ZGl2IGNsYXNzPVwib2JqUHJldmlld1wiIGRhdGEtYmluZD1cIicgKyBwcmV2aWV3QmFja2dyb3VuZCArICdcIj48L2Rpdj48IS0tIC9rbyAtLT4nO1xuICAgICAgICAgIHZhciBwcmV2aWV3QmluZGluZ3MgPSBlbGFib3JhdGVEZWNsYXJhdGlvbnModW5kZWZpbmVkLCBtb2RlbC5fcHJldmlld0JpbmRpbmdzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgd2l0aEJpbmRpbmdQcm92aWRlci5iaW5kKHRoaXMsIHBhdGggKyAnLicpKTtcbiAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwib2JqUHJldmlld1wiPjxkaXYgY2xhc3M9XCJvYmpQcmV2aWV3SW5uZXJcIiBkYXRhLWJpbmQ9XCInICsgcHJldmlld0JpbmRpbmdzICsgJ1wiPjwvZGl2PjwvZGl2Pic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBQUkVWSUVXICovXG4gICAgdmFyIHByZXZpZXdCRztcbiAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgIGlmICh0eXBlb2YgbW9kZWwuX3ByZXZpZXdCaW5kaW5ncyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmV2aWV3QkcgPSBlbGFib3JhdGVEZWNsYXJhdGlvbnModW5kZWZpbmVkLCBtb2RlbC5fcHJldmlld0JpbmRpbmdzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgd2l0aEJpbmRpbmdQcm92aWRlci5iaW5kKHRoaXMsIHBhdGgubGVuZ3RoID4gMCA/IHBhdGggKyAnLicgOiAnJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpLCBuZXdQYXRoO1xuXG4gICAgdmFyIGJlZm9yZSA9IGh0bWwubGVuZ3RoO1xuXG4gICAgdmFyIG5ld1RoZW1lTW9kZWw7XG4gICAgdmFyIG5ld0dsb2JhbFN0eWxlUHJvcDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3UGF0aCA9IHBhdGgubGVuZ3RoID4gMCA/IHBhdGggKyBcIi5cIiArIHByb3BzW2ldIDogcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIG1vZGVsW3Byb3BzW2ldXSAhPSAnb2JqZWN0JyB8fCBtb2RlbFtwcm9wc1tpXV0gPT09IG51bGwgfHwgdHlwZW9mIG1vZGVsW3Byb3BzW2ldXS5fd2lkZ2V0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5ld0dsb2JhbFN0eWxlUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGxldmVsID09PSAwICYmIHByb3BzW2ldID09ICd0aGVtZScpXG4gICAgICAgICAgaHRtbCArPSBfcHJvcEVkaXRvcih3aXRoQmluZGluZ1Byb3ZpZGVyLCB3aWRnZXRzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbW9kZWxbcHJvcHNbaV1dLCBuZXdUaGVtZU1vZGVsLCBuZXdQYXRoLCBwcm9wc1tpXSwgZWRpdFR5cGUsIDAsIGJhc2VUaHJlc2hvbGQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cmFja1VzYWdlLCByb290UHJldmlld0JpbmRpbmcpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdHbG9iYWxTdHlsZVByb3AgPSBfZ2V0R2xvYmFsU3R5bGVQcm9wKGdsb2JhbFN0eWxlcywgbW9kZWxbcHJvcHNbaV1dLCBwcm9wc1tpXSwgbmV3UGF0aCk7XG4gICAgICAgICAgaHRtbCArPSBfcHJvcEVkaXRvcih3aXRoQmluZGluZ1Byb3ZpZGVyLCB3aWRnZXRzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbW9kZWxbcHJvcHNbaV1dLCBuZXdUaGVtZU1vZGVsLCBuZXdQYXRoLCBwcm9wc1tpXSwgZWRpdFR5cGUsIGxldmVsICsgMSwgYmFzZVRocmVzaG9sZCwgZ2xvYmFsU3R5bGVzLCBuZXdHbG9iYWxTdHlsZVByb3AsIHRyYWNrVXNhZ2UsIHJvb3RQcmV2aWV3QmluZGluZywgcHJldmlld0JHKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld1BhdGggPSBwYXRoLmxlbmd0aCA+IDAgPyBwYXRoICsgXCIuXCIgKyBwcm9wc1tpXSA6IHByb3BzW2ldO1xuICAgICAgaWYgKCEodHlwZW9mIG1vZGVsW3Byb3BzW2ldXSAhPSAnb2JqZWN0JyB8fCBtb2RlbFtwcm9wc1tpXV0gPT09IG51bGwgfHwgdHlwZW9mIG1vZGVsW3Byb3BzW2ldXS5fd2lkZ2V0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICBuZXdHbG9iYWxTdHlsZVByb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gMCAmJiBwcm9wc1tpXSA9PSAndGhlbWUnKVxuICAgICAgICAgIGh0bWwgKz0gX3Byb3BFZGl0b3Iod2l0aEJpbmRpbmdQcm92aWRlciwgd2lkZ2V0cywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG1vZGVsW3Byb3BzW2ldXSwgbmV3VGhlbWVNb2RlbCwgbmV3UGF0aCwgcHJvcHNbaV0sIGVkaXRUeXBlLCAwLCBiYXNlVGhyZXNob2xkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJhY2tVc2FnZSwgcm9vdFByZXZpZXdCaW5kaW5nKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3R2xvYmFsU3R5bGVQcm9wID0gX2dldEdsb2JhbFN0eWxlUHJvcChnbG9iYWxTdHlsZXMsIG1vZGVsW3Byb3BzW2ldXSwgcHJvcHNbaV0sIG5ld1BhdGgpO1xuICAgICAgICAgIGh0bWwgKz0gX3Byb3BFZGl0b3Iod2l0aEJpbmRpbmdQcm92aWRlciwgd2lkZ2V0cywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG1vZGVsW3Byb3BzW2ldXSwgbmV3VGhlbWVNb2RlbCwgbmV3UGF0aCwgcHJvcHNbaV0sIGVkaXRUeXBlLCBsZXZlbCArIDEsIGJhc2VUaHJlc2hvbGQsIGdsb2JhbFN0eWxlcywgbmV3R2xvYmFsU3R5bGVQcm9wLCB0cmFja1VzYWdlLCByb290UHJldmlld0JpbmRpbmcsIHByZXZpZXdCRyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkZWQgPSBodG1sLmxlbmd0aCAtIGJlZm9yZTtcbiAgICBpZiAoYWRkZWQgPT09IDApIHtcbiAgICAgIC8vIE5vIGVkaXRhYmxlIGNvbnRlbnQ6IGlmIHRoaXMgaXMgaW4gY29udGV4dCBcInRlbXBsYXRlXCIgd2UgbGVhdmUgaXQgZW1wdHksIG90aGVyd2lzZSB3ZSBzaG93IGFuIGhlbHAuXG4gICAgICBpZiAodHlwZW9mIG1vZGVsID09ICdvYmplY3QnICYmIG1vZGVsICE9PSBudWxsICYmIG1vZGVsLl9jb250ZXh0ID09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETyBtb3ZlIG1lIHRvIGEgdG1wbD9cbiAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm9iakVtcHR5XCIgZGF0YS1iaW5kPVwiaHRtbDogJHJvb3QudChcXCdTZWxlY3RlZCBlbGVtZW50IGhhcyBubyBlZGl0YWJsZSBwcm9wZXJ0aWVzXFwnKVwiPlNlbGVjdGVkIGVsZW1lbnQgaGFzIG5vIGVkaXRhYmxlIHByb3BlcnRpZXM8L2Rpdj4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvcCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgaHRtbCArPSAnPCEtLSAva28gLS0+JztcbiAgICB9XG4gICAgaHRtbCArPSAnPC9kaXY+JztcblxuICB9IGVsc2Uge1xuICAgIHZhciBjaGVja2JveGVzID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsU3R5bGVzID09ICd1bmRlZmluZWQnKSBjaGVja2JveGVzID0gZmFsc2U7XG5cbiAgICBpZiAobW9kZWwgPT09IG51bGwgfHwgdHlwZW9mIG1vZGVsICE9ICdvYmplY3QnIHx8IHR5cGVvZiBtb2RlbC5fd2lkZ2V0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgYmluZGluZ3MgPSBbXTtcblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxTdHlsZVByb3AgIT0gJ3VuZGVmaW5lZCcpIGJpbmRpbmdzLnB1c2goJ2NzczogeyBub3RudWxsOiAnICsgcHJvcCArICcoKSAhPT0gbnVsbCB9Jyk7XG4gICAgICB0aXRsZSA9IG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5faGVscCAhPT0gJ3VuZGVmaW5lZCcgPyAnIHRpdGxlPVwiJyArIHV0aWxzLmFkZFNsYXNoZXMobW9kZWwuX2hlbHApICsgJ1wiIGRhdGEtYmluZD1cImF0dHI6IHsgdGl0bGU6ICRyb290LnV0KFxcJ3RlbXBsYXRlXFwnLCBcXCcnICsgdXRpbHMuYWRkU2xhc2hlcyhtb2RlbC5faGVscCkgKyAnXFwnKSB9XCInIDogJyc7XG4gICAgICBpZiAodGl0bGUubGVuZ3RoID4gMCkgYmluZGluZ3MucHVzaCgndG9vbHRpcHM6IHt9Jyk7XG4gICAgICB2YXIgYmluZCA9IGJpbmRpbmdzLmxlbmd0aCA+IDAgPyAnZGF0YS1iaW5kPVwiJyArIHV0aWxzLmFkZFNsYXNoZXMoYmluZGluZ3Muam9pbigpKSArICdcIicgOiAnJztcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJwcm9wRWRpdG9yICcgKyAoY2hlY2tib3hlcyA/ICdjaGVja2JveGVzJyA6ICcnKSArICdcIicgKyBiaW5kICsgJz4nO1xuXG4gICAgICB2YXIgbW9kZWxOYW1lMiA9IChtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX25hbWUgIT0gJ3VuZGVmaW5lZCcgPyBtb2RlbC5fbmFtZSA6ICh0eXBlb2YgcHJvcCAhPT0gJ3VuZGVmaW5lZCcgPyAnWycgKyBwcm9wICsgJ10nIDogJycpKTtcbiAgICAgIG1vZGVsTmFtZTIgPSAnPHNwYW4gZGF0YS1iaW5kPVwidGV4dDogJHJvb3QudXQoXFwndGVtcGxhdGVcXCcsIFxcJycgKyB1dGlscy5hZGRTbGFzaGVzKG1vZGVsTmFtZTIpICsgJ1xcJylcIj4nICsgbW9kZWxOYW1lMiArICc8L3NwYW4+JztcbiAgICAgIGh0bWwgKz0gJzxzcGFuJyArIHRpdGxlICsgJyBjbGFzcz1cInByb3BMYWJlbFwiPicgKyBtb2RlbE5hbWUyICsgJzwvc3Bhbj4nO1xuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInByb3BJbnB1dCAnICsgKHR5cGVvZiBnbG9iYWxTdHlsZXMgIT0gJ3VuZGVmaW5lZCcgPyAnbG9jYWwnIDogJycpICsgJ1wiIGRhdGEtYmluZD1cImNzczogeyBkZWZhdWx0OiAnICsgcHJvcCArICcoKSA9PT0gbnVsbCB9XCI+JztcbiAgICAgIGh0bWwgKz0gX3Byb3BJbnB1dChtb2RlbCwgcHJvcCwgcHJvcEFjY2Vzc29yLCBlZGl0VHlwZSwgd2lkZ2V0cyk7XG4gICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxTdHlsZVByb3AgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInByb3BJbnB1dCBnbG9iYWxcIiBkYXRhLWJpbmQ9XCJjc3M6IHsgb3ZlcnJpZGRlbjogJyArIHByb3AgKyAnKCkgIT09IG51bGwgfVwiPic7XG4gICAgICAgIGh0bWwgKz0gX3Byb3BJbnB1dChtb2RlbCwgcHJvcCwgZ2xvYmFsU3R5bGVQcm9wLCBlZGl0VHlwZSwgd2lkZ2V0cyk7XG4gICAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XG5cbiAgICAgICAgaWYgKGNoZWNrYm94ZXMpIHtcbiAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicHJvcENoZWNrXCI+PGxhYmVsIGRhdGEtYmluZD1cInRvb2x0aXBzOiB7fVwiPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBkYXRhLWJpbmQ9XCJmb2N1c2FibGU6IHRydWUsIGNsaWNrOiBmdW5jdGlvbihldnQsIG9iaikgeyAkcm9vdC5sb2NhbEdsb2JhbFN3aXRjaCgnICsgcHJvcCArICcsICcgKyBnbG9iYWxTdHlsZVByb3AgKyAnKTsgcmV0dXJuIHRydWU7IH0sIGNoZWNrZWQ6ICcgKyBwcm9wICsgJygpICE9PSBudWxsXCI+JztcbiAgICAgICAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cImNoZWNrYm94LXJlcGxhY2VyXCIgZGF0YS1iaW5kPVwiY3NzOiB7IGNoZWNrZWQ6ICcgKyBwcm9wICsgJygpICE9PSBudWxsIH0sIGF0dHI6IHsgdGl0bGU6ICRyb290LnQoXFwnVGhpcyBzdHlsZSBpcyBzcGVjaWZpYyBmb3IgdGhpcyBibG9jazogY2xpY2sgaGVyZSB0byByZW1vdmUgdGhlIGN1c3RvbSBzdHlsZSBhbmQgcmV2ZXJ0IHRvIHRoZSB0aGVtZSB2YWx1ZVxcJykgfVwiPjwvc3Bhbj4nO1xuICAgICAgICAgIGh0bWwgKz0gJzwvbGFiZWw+PC9kaXY+JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaHRtbCArPSAnPC9kaXY+JztcbiAgICB9IGVsc2UgaWYgKG1vZGVsID09PSBudWxsIHx8IHR5cGVvZiBtb2RlbCAhPSAnb2JqZWN0Jykge1xuICAgICAgLy8gVE9ETyByZW1vdmUgZGVidWcgb3V0cHV0XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicHJvcEVkaXRvciB1bmtub3duXCI+W0F8JyArIHByb3AgKyBcInxcIiArIHR5cGVvZiBtb2RlbCArICddPC9kaXY+JztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETyByZW1vdmUgZGVidWcgb3V0cHV0XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicHJvcEVkaXRvciB1bmtub3duXCI+W0J8JyArIHByb3AgKyBcInxcIiArIHR5cGVvZiBtb2RlbCArICddPC9kaXY+JztcbiAgICB9XG5cblxuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9wICE9ICd1bmRlZmluZWQnICYmICEhdHJhY2tVc2FnZSkge1xuICAgIGh0bWwgKz0gJzwhLS0gL2tvIC0tPic7XG4gICAgaHRtbCArPSAnPCEtLSBrbyBpZlN1YnM6IHsgbm90OiB0cnVlLCBkYXRhOiAnICsgaWZTdWJzUHJvcCArICcsIHRocmVzaG9sZDogJyArIGlmU3Vic1RocmVzaG9sZCArICcsIGd1dHRlcjogMCB9IC0tPic7XG4gICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJsYWJlbCBub3R1c2VkXCI+KCcgKyBwcm9wICsgJyk8L3NwYW4+JztcbiAgICBodG1sICs9ICc8IS0tIC9rbyAtLT4nO1xuICB9XG5cbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5cbnZhciBjcmVhdGVCbG9ja0VkaXRvciA9IGZ1bmN0aW9uKGRlZnMsIHdpZGdldHMsIHRoZW1lVXBkYXRlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgZWRpdFR5cGUsIHRlbXBsYXRlQ3JlYXRvciwgYmFzZVRocmVzaG9sZCwgdHJhY2tHbG9iYWxTdHlsZXMsIHRyYWNrVXNhZ2UsIGZyb21MZXZlbCkge1xuICBpZiAodHlwZW9mIHRyYWNrVXNhZ2UgPT0gJ3VuZGVmaW5lZCcpIHRyYWNrVXNhZ2UgPSB0cnVlO1xuICB2YXIgbW9kZWwgPSBtb2RlbERlZi5nZXREZWYoZGVmcywgdGVtcGxhdGVOYW1lKTtcblxuICB2YXIgcm9vdE1vZGVsID0gbW9kZWxEZWYuZ2V0RGVmKGRlZnMsIHJvb3RNb2RlbE5hbWUpO1xuICB2YXIgcm9vdFByZXZpZXdCaW5kaW5ncztcbiAgaWYgKHR5cGVvZiByb290TW9kZWwuX3ByZXZpZXdCaW5kaW5ncyAhPSAndW5kZWZpbmVkJyAmJiB0ZW1wbGF0ZU5hbWUgIT0gJ3RoYWVtZScgJiYgZWRpdFR5cGUgPT0gJ3N0eWxlcicpIHtcbiAgICByb290UHJldmlld0JpbmRpbmdzID0gZWxhYm9yYXRlRGVjbGFyYXRpb25zKHVuZGVmaW5lZCwgcm9vdE1vZGVsLl9wcmV2aWV3QmluZGluZ3MsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBtb2RlbERlZi5nZXRCaW5kVmFsdWUuYmluZCh1bmRlZmluZWQsIGRlZnMsIHRoZW1lVXBkYXRlciwgcm9vdE1vZGVsTmFtZSwgcm9vdE1vZGVsTmFtZSwgJycpKTtcbiAgfVxuXG4gIHZhciBnbG9iYWxTdHlsZXMgPSB0eXBlb2YgdHJhY2tHbG9iYWxTdHlsZXMgIT0gJ3VuZGVmaW5lZCcgJiYgdHJhY2tHbG9iYWxTdHlsZXMgPyBkZWZzW3RlbXBsYXRlTmFtZV0uX2dsb2JhbFN0eWxlcyA6IHVuZGVmaW5lZDtcbiAgdmFyIGdsb2JhbFN0eWxlUHJvcCA9IHR5cGVvZiB0cmFja0dsb2JhbFN0eWxlcyAhPSAndW5kZWZpbmVkJyAmJiB0cmFja0dsb2JhbFN0eWxlcyA/IGRlZnNbdGVtcGxhdGVOYW1lXS5fZ2xvYmFsU3R5bGUgOiB1bmRlZmluZWQ7XG5cblxuICB2YXIgdGhlbWVNb2RlbDtcbiAgaWYgKHR5cGVvZiBnbG9iYWxTdHlsZVByb3AgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG1tID0gbW9kZWxEZWYuZ2V0RGVmKGRlZnMsICd0aGVtZScpO1xuICAgIC8vIFRPRE8gcmVtb3ZlIGRlcHJlY2F0ZWQgJHRoZW1lXG4gICAgdGhlbWVNb2RlbCA9IG1tW2dsb2JhbFN0eWxlUHJvcC5yZXBsYWNlKC9eKFxcJHRoZW1lfF90aGVtZV8pXFwuLywgJycpXTtcbiAgfVxuXG5cbiAgdmFyIHdpdGhCaW5kaW5nUHJvdmlkZXIgPSBtb2RlbERlZi5nZXRCaW5kVmFsdWUuYmluZCh1bmRlZmluZWQsIGRlZnMsIHRoZW1lVXBkYXRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lKTtcbiAgd2l0aEJpbmRpbmdQcm92aWRlci5fdGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuXG4gIHZhciBodG1sID0gJzxkaXYgY2xhc3M9XCJlZGl0b3JcIj4nO1xuICBodG1sICs9IFwiPGRpdiBjbGFzcz1cXFwiYmxvY2tUeXBlXCIgKyAodHlwZW9mIGdsb2JhbFN0eWxlcyAhPSAndW5kZWZpbmVkJyA/IFwiIHdpdGhkZWZhdWx0c1wiIDogXCJcIikgKyBcIlxcXCI+XCIgKyBtb2RlbC50eXBlICsgXCI8L2Rpdj5cIjtcblxuICB2YXIgZWRpdG9yQ29udGVudCA9IF9wcm9wRWRpdG9yKHdpdGhCaW5kaW5nUHJvdmlkZXIsIHdpZGdldHMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBtb2RlbCwgdGhlbWVNb2RlbCwgXCJcIiwgdW5kZWZpbmVkLCBlZGl0VHlwZSwgZnJvbUxldmVsLCBiYXNlVGhyZXNob2xkLCBnbG9iYWxTdHlsZXMsIGdsb2JhbFN0eWxlUHJvcCwgdHJhY2tVc2FnZSwgcm9vdFByZXZpZXdCaW5kaW5ncyk7XG4gIGlmIChlZGl0b3JDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICBodG1sICs9IGVkaXRvckNvbnRlbnQ7XG4gIH1cblxuICBodG1sICs9ICc8L2Rpdj4nO1xuXG4gIHRlbXBsYXRlQ3JlYXRvcihodG1sLCB0ZW1wbGF0ZU5hbWUsIGVkaXRUeXBlKTtcbn07XG5cbnZhciBjcmVhdGVCbG9ja0VkaXRvcnMgPSBmdW5jdGlvbihkZWZzLCB3aWRnZXRzLCB0aGVtZVVwZGF0ZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsIHRlbXBsYXRlQ3JlYXRvciwgYmFzZVRocmVzaG9sZCkge1xuICBjcmVhdGVCbG9ja0VkaXRvcihkZWZzLCB3aWRnZXRzLCB0aGVtZVVwZGF0ZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsICdlZGl0JywgdGVtcGxhdGVDcmVhdG9yLCBiYXNlVGhyZXNob2xkKTtcbiAgY3JlYXRlQmxvY2tFZGl0b3IoZGVmcywgd2lkZ2V0cywgdGhlbWVVcGRhdGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCAnc3R5bGVyJywgdGVtcGxhdGVDcmVhdG9yLCBiYXNlVGhyZXNob2xkLCB0cnVlKTtcbn07XG5cbnZhciBnZW5lcmF0ZUVkaXRvcnMgPSBmdW5jdGlvbih0ZW1wbGF0ZURlZiwgd2lkZ2V0cywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHRlbXBsYXRlQ3JlYXRvciwgYmFzZVRocmVzaG9sZCkge1xuICB2YXIgZGVmcyA9IHRlbXBsYXRlRGVmLl9kZWZzO1xuICB2YXIgdGVtcGxhdGVOYW1lID0gdGVtcGxhdGVEZWYudGVtcGxhdGVOYW1lO1xuICB2YXIgYmxvY2tzID0gdGVtcGxhdGVEZWYuX2Jsb2NrcztcbiAgdmFyIGlkeDtcbiAgdmFyIGJsb2NrRGVmcyA9IFtdO1xuICBmb3IgKGlkeCA9IDA7IGlkeCA8IGJsb2Nrcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgaWYgKHR5cGVvZiBibG9ja3NbaWR4XS5jb250YWluZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBibG9ja0RlZnMucHVzaChtb2RlbERlZi5nZW5lcmF0ZU1vZGVsKGRlZnMsIGJsb2Nrc1tpZHhdLmJsb2NrKSk7XG4gICAgfVxuICAgIGNyZWF0ZUJsb2NrRWRpdG9ycyhkZWZzLCB3aWRnZXRzLCB1bmRlZmluZWQsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBibG9ja3NbaWR4XS5yb290LCBibG9ja3NbaWR4XS5ibG9jaywgdGVtcGxhdGVDcmVhdG9yLCBiYXNlVGhyZXNob2xkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmc1sndGhlbWUnXSAhPSAndW5kZWZpbmVkJykgY3JlYXRlQmxvY2tFZGl0b3IoZGVmcywgd2lkZ2V0cywgdW5kZWZpbmVkLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgdGVtcGxhdGVOYW1lLCAndGhlbWUnLCAnc3R5bGVyJywgdGVtcGxhdGVDcmVhdG9yLCB1bmRlZmluZWQsIGZhbHNlLCBmYWxzZSwgLTEpO1xuICByZXR1cm4gYmxvY2tEZWZzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUVkaXRvcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlICovXG5cbnZhciBtb2RlbERlZiA9IHJlcXVpcmUoXCIuL21vZGVsLmpzXCIpO1xuXG52YXIgd3JhcHBlZFJlc3VsdE1vZGVsID0gZnVuY3Rpb24odGVtcGxhdGVEZWYpIHtcbiAgdmFyIGRlZnMgPSB0ZW1wbGF0ZURlZi5fZGVmcztcbiAgdmFyIHRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlRGVmLnRlbXBsYXRlTmFtZTtcbiAgdmFyIGZpbmFsTW9kZWxDb250ZW50RGVmID0gbW9kZWxEZWYuZ2V0RGVmKGRlZnMsIHRlbXBsYXRlTmFtZSk7XG5cbiAgdmFyIGZpbmFsTW9kZWxDb250ZW50ID0gbW9kZWxEZWYuZ2VuZXJhdGVSZXN1bHRNb2RlbCh0ZW1wbGF0ZURlZik7XG5cbiAgdmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi93cmFwcGVyLmpzXCIpO1xuICB2YXIgcmVzID0gd3JhcHBlcihmaW5hbE1vZGVsQ29udGVudCwgZmluYWxNb2RlbENvbnRlbnREZWYsIGRlZnMpO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG4vLyByZXF1aXJlcyBvbmx5IHdoZW4gaW1wb3J0ZWRcbnZhciB0cmFuc2xhdGVUZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHQgPSByZXF1aXJlKCcuL3BhcnNlci5qcycpO1xuICByZXR1cm4gdHQuYXBwbHkodHQsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyByZXF1aXJlcyBvbmx5IHdoZW4gaW1wb3J0ZWRcbnZhciBnZW5lcmF0ZUVkaXRvcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdlID0gcmVxdWlyZSgnLi9lZGl0b3IuanMnKTtcbiAgcmV0dXJuIGdlLmFwcGx5KGdlLCBhcmd1bWVudHMpO1xufTtcblxudmFyIGNoZWNrTW9kZWwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNtID0gcmVxdWlyZSgnLi9jaGVja21vZGVsLmpzJyk7XG4gIHJldHVybiBjbS5hcHBseShjbSwgYXJndW1lbnRzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0cmFuc2xhdGVUZW1wbGF0ZTogdHJhbnNsYXRlVGVtcGxhdGUsXG4gIHdyYXBwZWRSZXN1bHRNb2RlbDogd3JhcHBlZFJlc3VsdE1vZGVsLFxuICBnZW5lcmF0ZVJlc3VsdE1vZGVsOiBtb2RlbERlZi5nZW5lcmF0ZVJlc3VsdE1vZGVsLFxuICBnZW5lcmF0ZUVkaXRvcnM6IGdlbmVyYXRlRWRpdG9ycyxcbiAgY2hlY2tNb2RlbDogY2hlY2tNb2RlbFxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG9iakV4dGVuZCA9IHJlcXVpcmUoXCIuL2RvbXV0aWxzLmpzXCIpLm9iakV4dGVuZDtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbnZhciBfdmFsdWVTZXQgPSBmdW5jdGlvbihkZWZzLCBtb2RlbCwgcHJvcCwgdmFsdWUpIHtcbiAgdmFyIGRvdFBvcyA9IHByb3AuaW5kZXhPZignLicpO1xuICBpZiAoZG90UG9zID09IC0xKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlbFtwcm9wXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5sb2coXCJVbmRlZmluZWQgcHJvcCBcIiArIHByb3AgKyBcIiB3aGlsZSBzZXR0aW5nIHZhbHVlIFwiICsgdmFsdWUgKyBcIiBpbiBtb2RlbC5fdmFsdWVTZXRcIik7XG4gICAgfSBlbHNlIGlmIChtb2RlbFtwcm9wXSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucHVzaCA9PSAndW5kZWZpbmVkJykgY29uc29sZS5sb2coXCJudWxscHJvcG9iamVjdHZhbHVlXCIsIHByb3AsIHZhbHVlKTtcbiAgICAgIG1vZGVsW3Byb3BdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWxbcHJvcF0gPT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZGVsW3Byb3BdLnB1c2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHZhbHVlcztcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSB2YWx1ZS5tYXRjaCgvXlxcWyguKilcXF0kLyk7XG4gICAgICAgIGlmICh2YWx1ZXNTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXNTdHJpbmdbMV0uc3BsaXQoJywnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZGVmYXVsdCB2YWx1ZSBmb3IgYXJyYXkgcHJvcGVydHkgXCIgKyBwcm9wICsgXCI6IFwiICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUucHVzaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZGVmYXVsdCB2YWx1ZSBmb3IgYXJyYXkgcHJvcGVydHkgXCIgKyBwcm9wICsgXCI6IFwiICsgdmFsdWUgKyBcIiB0eXBlb2YgXCIgKyAodHlwZW9mIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbaV0uc3Vic3RyKDAsIDEpID09ICdAJykge1xuICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgKEApLCBzbyB3ZSBjYW4gcmVtb3ZlIFwiZGVmc1wiIGZyb20gdGhpcyBmdW5jdGlvbiwgdG9vLlxuICAgICAgICAgIHJlcy5wdXNoKF9nZW5lcmF0ZU1vZGVsKGRlZnMsIHZhbHVlc1tpXS5zdWJzdHIoMSkpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZXNbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlcy5wdXNoKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZGVsW3Byb3BdID0gcmVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsW3Byb3BdID09ICdzdHJpbmcnIHx8IHR5cGVvZiBtb2RlbFtwcm9wXSA9PSAnYm9vbGVhbicpIHtcbiAgICAgIC8vIFRPRE8gZG9lcyB0aGlzIHN0aWxsIGhhcHBlbj8gRGVidWcvdGVzdCBtZS5cbiAgICAgIG1vZGVsW3Byb3BdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWxbcHJvcF0gPT0gJ29iamVjdCcgJiYgbW9kZWxbcHJvcF0gIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsW3Byb3BdLl93aWRnZXQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIGNvbnNvbGUubG9nKFwib2JqZWN0dmFsdWVcIiwgcHJvcCwgbW9kZWxbcHJvcF0uX3dpZGdldCwgdmFsdWUpO1xuICAgICAgLy8gX2RhdGEgaXMgZGVmaW5lZCBmb3IgcHJpbWl0aXZlIHR5cGVzXG4gICAgICBtb2RlbFtwcm9wXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNldHRpbmdcIiwgdHlwZW9mIG1vZGVsW3Byb3BdLCBtb2RlbFtwcm9wXSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJvcE5hbWUgPSBwcm9wLnN1YnN0cigwLCBkb3RQb3MpO1xuICAgIF92YWx1ZVNldChkZWZzLCBtb2RlbFtwcm9wTmFtZV0sIHByb3Auc3Vic3RyKGRvdFBvcyArIDEpLCB2YWx1ZSk7XG4gIH1cbn07XG5cbnZhciBfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmID0gZnVuY3Rpb24oZGVmcywgdGVtcGxhdGVOYW1lLCBwcm9wZXJ0aWVzLCBuYW1lZFByb3BlcnRpZXMpIHtcbiAgaWYgKHR5cGVvZiBkZWZzW3RlbXBsYXRlTmFtZV0gIT09ICd1bmRlZmluZWQnICYmIGRlZnNbdGVtcGxhdGVOYW1lXS5faW5pdGlhbGl6ZWQgJiYgIWRlZnNbdGVtcGxhdGVOYW1lXS5fd3JpdGVhYmxlKSB7XG4gICAgY29uc29sZS5sb2coXCJfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmXCIsIGRlZnMsIHRlbXBsYXRlTmFtZSwgcHJvcGVydGllcywgbmFtZWRQcm9wZXJ0aWVzKTtcbiAgICB0aHJvdyBcIlRyeWluZyB0byBhbHRlciBub24gd3JpdGVhYmxlIG1vZGVsOiBcIiArIHRlbXBsYXRlTmFtZSArIFwiIC8gXCIgKyBwcm9wZXJ0aWVzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZzW3RlbXBsYXRlTmFtZV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZWZzW3RlbXBsYXRlTmFtZV0gPSB7XG4gICAgICBfd3JpdGVhYmxlOiB0cnVlXG4gICAgfTtcbiAgICAvLyBGYWxsYmFjayBjb21wdXRhdGlvbiBvZiBcImNhdGVnb3J5XCIgZGVwZW5kaW5nIG9uIHRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgLy8gVE9ETyByZW1vdmUgbWU6IHRoaXMgc2hvdWxkIGJlIGFsd2F5cyBkZWZpbmVkIGluIHRoZSB0ZW1wbGF0ZSBkZWZpbml0aW9uLCBubyBuZWVkIHRvIGhhcmRjb2RlIHRoaXMgc3R1ZmYuXG4gICAgaWYgKHR5cGVvZiBuYW1lZFByb3BlcnRpZXMgPT0gJ3VuZGVmaW5lZCcpIG5hbWVkUHJvcGVydGllcyA9IHt9O1xuICAgIGlmICh0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzLmNhdGVnb3J5ID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWZzW3RlbXBsYXRlTmFtZV0uX2NhdGVnb3J5ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodGVtcGxhdGVOYW1lLm1hdGNoKC8oXnR8LlQpaGVtZSQvKSB8fCB0ZW1wbGF0ZU5hbWUubWF0Y2goLyhec3wuUyl0eWxlJC8pIHx8IHRlbXBsYXRlTmFtZS5tYXRjaCgvKF5jfC5DKW9sb3IkLykgfHwgdGVtcGxhdGVOYW1lLm1hdGNoKC8oXnJ8LlIpYWRpdXMkLykpIHtcbiAgICAgICAgbmFtZWRQcm9wZXJ0aWVzLmNhdGVnb3J5ID0gJ3N0eWxlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVkUHJvcGVydGllcy5jYXRlZ29yeSA9ICdjb250ZW50JztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGlmICh0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRPRE8gY2hlY2sgaWYgdGhpcyBpcyBuZWVkZWQgYmVmb3JlIHRoZSBlbmRpbmcgbmFtZWRQcm9wZXJ0eSBcImxvb3BcIiBvciBub3QuXG4gICAgaWYgKHR5cGVvZiBuYW1lZFByb3BlcnRpZXMubmFtZSAhPSAndW5kZWZpbmVkJykgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9uYW1lID0gbmFtZWRQcm9wZXJ0aWVzLm5hbWU7XG5cbiAgICBpZiAodHlwZW9mIG5hbWVkUHJvcGVydGllcy50aGVtZU92ZXJyaWRlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWZzW3RlbXBsYXRlTmFtZV0uX3RoZW1lT3ZlcnJpZGUgPSBuYW1lZFByb3BlcnRpZXMudGhlbWVPdmVycmlkZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lZFByb3BlcnRpZXMuZ2xvYmFsU3R5bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlZnNbdGVtcGxhdGVOYW1lXS5fZ2xvYmFsU3R5bGUgPSBuYW1lZFByb3BlcnRpZXMuZ2xvYmFsU3R5bGU7XG4gICAgICAvLyBUT0RPIHJlbW92ZSBkZXByZWNhdGVkICR0aGVtZVxuICAgICAgdmFyIGdsb2JhbFN0eWxlU3ViID0gbmFtZWRQcm9wZXJ0aWVzLmdsb2JhbFN0eWxlLnJlcGxhY2UoL14oXFwkdGhlbWV8X3RoZW1lXylcXC4vLCAnJyk7XG4gICAgICB2YXIgcCA9IGdsb2JhbFN0eWxlU3ViLmluZGV4T2YoJy4nKTtcbiAgICAgIHZhciBncyA9IHAgIT0gLTEgPyBnbG9iYWxTdHlsZVN1Yi5zdWJzdHIoMCwgcCkgOiBnbG9iYWxTdHlsZVN1YjtcbiAgICAgIF9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgJ3RoZW1lJywgZ3MpO1xuXG4gICAgICBpZiAodHlwZW9mIGRlZnNbdGVtcGxhdGVOYW1lXS5fdGhlbWVPdmVycmlkZSA9PT0gJ3VuZGVmaW5lZCcgfHwgISFkZWZzW3RlbXBsYXRlTmFtZV0uX3RoZW1lT3ZlcnJpZGUpIHtcbiAgICAgICAgX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCB0ZW1wbGF0ZU5hbWUsIFwiY3VzdG9tU3R5bGU9ZmFsc2VcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzLmNvbnRleHROYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9jb250ZXh0ID0gbmFtZWRQcm9wZXJ0aWVzLmNvbnRleHROYW1lO1xuICAgICAgLy8gVE9ETyBpcyBpdCBjb3JyZWN0IHRvIGZhbGxiYWNrIHRvIFwiYm9keVRoZW1lXCIgZm9yIGJsb2NrcyBub3QgZGVjbGFyaW5nIGEgZGVmYXVsdCB0aGVtZT9cbiAgICAgIC8vIE1heWJlIGl0IHdvdWxkIGJlIGJldHRlciB0byBzaW1wbHkgZGVjbGFyZSBpdCBhcyBtYW5kYXRvcnkgYnV0IGxlYXZlIHRoZSBkZWZhdWx0IGNvbmZpZ3V0YXRpb25cbiAgICAgIC8vIHRvIHRoZSB0ZW1wbGF0ZSBkZWZpbml0aW9uLlxuICAgICAgaWYgKG5hbWVkUHJvcGVydGllcy5jb250ZXh0TmFtZSA9PSAnYmxvY2snICYmIHR5cGVvZiBkZWZzW3RlbXBsYXRlTmFtZV0uX2dsb2JhbFN0eWxlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlZnNbdGVtcGxhdGVOYW1lXS5fZ2xvYmFsU3R5bGUgPSAnX3RoZW1lXy5ib2R5VGhlbWUnO1xuICAgICAgICBfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsICd0aGVtZScsICdib2R5VGhlbWUnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGRlZnNbdGVtcGxhdGVOYW1lXS5fdGhlbWVPdmVycmlkZSA9PSAndW5kZWZpbmVkJyB8fCBkZWZzW3RlbXBsYXRlTmFtZV0uX3RoZW1lT3ZlcnJpZGUpIHtcbiAgICAgICAgICBfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsIHRlbXBsYXRlTmFtZSwgXCJjdXN0b21TdHlsZT1mYWxzZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVkUHJvcGVydGllcy5leHRlbmQgIT0gJ3VuZGVmaW5lZCcpIGRlZnNbdGVtcGxhdGVOYW1lXS50eXBlID0gbmFtZWRQcm9wZXJ0aWVzLmV4dGVuZDtcbiAgfVxuXG4gIGZvciAodmFyIG5wIGluIG5hbWVkUHJvcGVydGllcykgaWYgKG5hbWVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShucCkgJiYgdHlwZW9mIG5hbWVkUHJvcGVydGllc1tucF0gIT09ICd1bmRlZmluZWQnICYmIFsnbmFtZScsICdleHRlbmQnLCAnY29udGV4dE5hbWUnLCAnZ2xvYmFsU3R5bGUnLCd0aGVtZU92ZXJyaWRlJ10uaW5kZXhPZihucCkgPT0gLTEpIHtcbiAgICBkZWZzW3RlbXBsYXRlTmFtZV1bJ18nK25wXSA9IG5hbWVkUHJvcGVydGllc1tucF07XG4gIH1cblxuICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT0gJ3VuZGVmaW5lZCcgJiYgcHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9wcm9wcyA9IHR5cGVvZiBkZWZzW3RlbXBsYXRlTmFtZV0uX3Byb3BzICE9ICd1bmRlZmluZWQnICYmIGRlZnNbdGVtcGxhdGVOYW1lXS5fcHJvcHMubGVuZ3RoID4gMCA/IGRlZnNbdGVtcGxhdGVOYW1lXS5fcHJvcHMgKyBcIiBcIiArIHByb3BlcnRpZXMgOiBwcm9wZXJ0aWVzO1xuICB9XG59O1xuXG4vLyByZW1vdmUgdGhlIGZpcnN0IFwic2VxdWVuY2VcIiBpbiBhIGNhbWVsY2FzZWQgd29yZCAoZS5nOiBteUNhbWVsQ2FzZSA9PiBjYW1lbENhc2UpLlxudmFyIF9yZW1vdmVQcmVmaXggPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJlcyA9IHN0ci5tYXRjaCgvXlteQS1aXSsoW0EtWl0pKC4qKSQvKTtcbiAgcmV0dXJuIHJlcyAhPT0gbnVsbCA/IHJlc1sxXS50b0xvd2VyQ2FzZSgpICsgcmVzWzJdIDogbnVsbDtcbn07XG5cbi8vIFRPRE8gZGVmcyBpcyBuZWVkZWQgb25seSBiZWNhdXNlIF92YWx1ZVNldCBuZWVkcyBpdC4uIHdlIHNob3VsZCByZW1vdmUgaXQgZG93bnN0cmVhbS5cbnZhciBfZ2VuZXJhdGVNb2RlbEZyb21EZWYgPSBmdW5jdGlvbihtb2RlbERlZiwgZGVmcykge1xuICB2YXIgcmVzID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBtb2RlbERlZilcbiAgICBpZiAoIXByb3AubWF0Y2goL15fLiovKSAmJiBtb2RlbERlZi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIHZhbHVlID0gbW9kZWxEZWZbcHJvcF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5fY29tcGxleCAhPSAndW5kZWZpbmVkJyAmJiB2YWx1ZS5fY29tcGxleCkge1xuICAgICAgICByZXNbcHJvcF0gPSBfZ2VuZXJhdGVNb2RlbEZyb21EZWYodmFsdWUsIGRlZnMpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wID09ICd0eXBlJykge1xuICAgICAgICByZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIG1vc3QgdGltZXMgdGhpcyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IF92YWx1ZVNldFxuICAgICAgICByZXNbcHJvcF0gPSBudWxsO1xuICAgICAgICAvLyBmb3IgY3VzdG9tU3R5bGUgdGhpcyBpcyBzZXQgdG8gbnVsbC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIG1vZGVsIGRlZlwiLCBwcm9wLCB2YWx1ZSwgbW9kZWxEZWYpO1xuICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgbW9kZWwgZGVmIFtcIiArIHByb3AgKyBcIl09XCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgaWYgKHR5cGVvZiBtb2RlbERlZi5fZGVmYXVsdFZhbHVlcyAhPSAndW5kZWZpbmVkJykge1xuICAgIHZhciBkZWZhdWx0cyA9IG1vZGVsRGVmLl9kZWZhdWx0VmFsdWVzO1xuICAgIGZvciAodmFyIHByb3AyIGluIGRlZmF1bHRzKVxuICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KHByb3AyKSkge1xuICAgICAgICBfdmFsdWVTZXQoZGVmcywgcmVzLCBwcm9wMiwgZGVmYXVsdHNbcHJvcDJdKTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG52YXIgX2dlbmVyYXRlTW9kZWwgPSBmdW5jdGlvbihkZWZzLCBuYW1lKSB7XG4gIHZhciBtb2RlbERlZiA9IF9nZXRNb2RlbERlZihkZWZzLCBuYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gIHJldHVybiBfZ2VuZXJhdGVNb2RlbEZyb21EZWYobW9kZWxEZWYsIGRlZnMpO1xufTtcblxudmFyIF9nZXREZWYgPSBmdW5jdGlvbihkZWZzLCBuYW1lKSB7XG4gIHJldHVybiBfZ2V0TW9kZWxEZWYoZGVmcywgbmFtZSwgZmFsc2UsIHRydWUpO1xufTtcblxudmFyIF9nZXRNb2RlbERlZiA9IGZ1bmN0aW9uKGRlZnMsIG5hbWUsIHJldHVybkNsb25lLCByZWFkb25seSkge1xuICAvLyBsb29rdXAgXCJuYW1lXCIgaW4gdGhlIHRlbXBsYXRlIGRlZmluaXRpb25cbiAgaWYgKHR5cGVvZiBkZWZzW25hbWVdID09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaWYgdGhlIG5hbWUgaGFzIGEgc3BhY2UgdGhlbiByZXR1cm5zLlxuICAgIGlmIChuYW1lLmluZGV4T2YoJyAnKSAhPSAtMSkgcmV0dXJuIG51bGw7XG4gICAgLy8gb3RoZXJ3aXNlIHRyeSBsb29raW5nIHVwIHVzaW5nIGEgZGVwcmVmaXhlZCBuYW1lLlxuICAgIHZhciByZXMgPSBfcmVtb3ZlUHJlZml4KG5hbWUpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE8gdGhlIGRlcHJlZml4aW5nIGlzIHBvd2VyZnVsLCBidXQgbWF5YmUgbm90IHJlYWxseSBuZWVkZWQuXG4gICAgICByZXR1cm4gX2dldE1vZGVsRGVmKGRlZnMsIHJlcywgcmV0dXJuQ2xvbmUsIHJlYWRvbmx5KTtcbiAgICB9XG4gICAgLy8gbm90IGEgcHJlZml4ZWQgbmFtZVxuICAgIC8vIFRPRE8gc2hvdWxkIHdlIHJhaXNlIGFuIGVycm9yP1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIHdoZW4gdGhlIG5hbWUgaXMgYWxyZWFkeSBkZWZpbmVkLi4uXG4gICAgdmFyIGRlZk9iaiA9IGRlZnNbbmFtZV07XG4gICAgaWYgKHR5cGVvZiBkZWZPYmogIT0gJ29iamVjdCcpIHRocm93IFwiQmxvY2sgZGVmaW5pdGlvbiBtdXN0IGJlIGFuIG9iamVjdDogZm91bmQgXCIgKyBkZWZPYmogKyBcIiBmb3IgXCIgKyBuYW1lO1xuXG4gICAgaWYgKHR5cGVvZiBkZWZPYmouX2luaXRpYWxpemVkID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBQb3B1bGF0ZSBcInR5cGVcIiBkZXBlbmRpbmcgb24gbmFtZVxuICAgICAgaWYgKHR5cGVvZiBkZWZPYmoudHlwZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCcgJykgPT0gLTEpIHtcbiAgICAgICAgICBkZWZPYmoudHlwZSA9IG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmT2JqLnR5cGUgPSBuYW1lLnN1YnN0cihuYW1lLmluZGV4T2YoJyAnKSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5vdCBhIFwiZGF0YVwiIHR5cGUgdGhlbiBsZXQncyBkZWFsIHdpdGggaW5oZXJpdGFuY2VcbiAgICAgIGlmIChkZWZPYmoudHlwZSAhPSBuYW1lICYmIHR5cGVvZiBkZWZPYmouX3dpZGdldCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdHlwZURlZiA9IF9nZXRNb2RlbERlZihkZWZzLCBkZWZPYmoudHlwZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBleHRlbmRlZCA9IG9iakV4dGVuZCh0eXBlRGVmLCBkZWZPYmopO1xuICAgICAgICBkZWZPYmogPSBleHRlbmRlZDtcbiAgICAgICAgZGVmc1tuYW1lXSA9IGRlZk9iajtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZk9iai5fd2lkZ2V0ID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWZPYmouX3Byb3BzID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWZPYmouX2NvbXBsZXggPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gVE9ETyBoZXJlIEkgdHJpZWQgdG8gZGVhbCB3aXRoIGluaGVyaXRhbmNlIGZvciBldmVyeSBvYmplY3Qgd2l0aG91dCBhIFwidHlwZVwiIGJ5IHVzaW5nIGEgc2ltcGxlIGRlcHJlZml4LlxuICAgICAgICAvLyBidXQgdGhpcyBicmVhayBvbiB0aGVtZSBjb250YWluaW5nIFwicGFnZVRoZW1lXCIgdGhhdCB3b3VsZCBpbmhlcml0IGZyb20gaXMgcGFyZW50LiAoY3JlYXRpbmcgYSBsb29wKVxuICAgICAgICAvKlxuICAgICAgICB2YXIgc3VwZXJUeXBlID0gX3JlbW92ZVByZWZpeChkZWZPYmoudHlwZSk7XG4gICAgICAgIGlmIChzdXBlclR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkV4dGVuZGluZ1wiLCB0eXBlRGVmLCBuYW1lLCBzdXBlclR5cGUsIGRlZk9iai50eXBlKTtcbiAgICAgICAgICB2YXIgdHlwZURlZiA9IF9nZXRNb2RlbERlZihkZWZzLCBzdXBlclR5cGUsIHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBleHRlbmRlZCA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgdHlwZURlZiwgZGVmT2JqKTtcbiAgICAgICAgICBkZWZPYmogPSBleHRlbmRlZDtcbiAgICAgICAgICBkZWZzW25hbWVdID0gZGVmT2JqO1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICB9XG4gICAgICBkZWZPYmouX3dyaXRlYWJsZSA9IHRydWU7XG4gICAgICBkZWZPYmouX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlZk9iai5fcHJvcHMgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBkZWYgPSBkZWZPYmouX3Byb3BzO1xuICAgICAgZGVmID0gZGVmLnNwbGl0KFwiIFwiKTtcblxuICAgICAgaWYgKGRlZi5sZW5ndGggPiAwICYmIHR5cGVvZiBkZWZPYmouX3dyaXRlYWJsZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQWx0ZXJpbmcgYSBub24gd3JpdGFibGUgb2JqZWN0IFwiLCBuYW1lLCBkZWYsIGRlZk9iaik7XG4gICAgICAgIHRocm93IFwiQWx0ZXJpbmcgYSBub24gd3JpdGFibGUgb2JqZWN0OiBcIiArIG5hbWUgKyBcIiBkZWY6IFwiICsgZGVmO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlZk9iai5fcHJvY2Vzc2VkRGVmcyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWZPYmouX3Byb2Nlc3NlZERlZnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkZWZPYmouX2dsb2JhbFN0eWxlcyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWZPYmouX2dsb2JhbFN0eWxlcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlZk9iai5fZGVmYXVsdFZhbHVlcyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWZPYmouX2RlZmF1bHRWYWx1ZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBkZWZbaV07XG4gICAgICAgIGlmIChwcm9wLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICAgIHZhciBvcmlnUHJvcCA9IHByb3A7XG4gICAgICAgIHZhciBkZWZWYWx1ZSA9IG51bGw7XG4gICAgICAgIC8vIHBhcnNlcyAgXCJwcm9wXCIgXCJwcm9wPXZhbHVlXCIgYW5kIFwicHJvcFtdXCIgZGVjbGFyYXRpb25zXG4gICAgICAgIHZhciBwcm9wRGVmID0gcHJvcC5tYXRjaCgvXihbXj1cXFtcXF1dKykoXFxbXFxdKT8oPT8pKC4qKSQvKTtcbiAgICAgICAgaWYgKHByb3BEZWYgIT09IG51bGwpIHtcbiAgICAgICAgICBwcm9wID0gcHJvcERlZlsxXTtcbiAgICAgICAgICAvLyBUT0RPIGFycmF5IGRlZmluaXRpb24gc2hvdWxkIGJlIGRvbmUgZGlmZmVyZW50bHlcbiAgICAgICAgICBpZiAocHJvcERlZlsyXSA9PSAnW10nKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHR5cGUgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIGluIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmT2JqW3Byb3BdID09ICd1bmRlZmluZWQnKSBkZWZPYmpbcHJvcF0gPSBbXTtcbiAgICAgICAgICAgIGRlZlZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wRGVmWzNdID09ICc9Jykge1xuICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgaGFyZGNvZGVkIFwidmlzaWJsZVwiIG1hdGNoaW5nICh0aGlzIHNob3VsZCBiZSBkZWZpbmVkIGluIHRoZSB0ZW1wbGF0ZSBkZWZpbml0aW9uKVxuICAgICAgICAgICAgaWYgKHByb3AubWF0Y2goLyhednxWKWlzaWJsZSQvKSkgZGVmVmFsdWUgPSBTdHJpbmcocHJvcERlZls0XSkudG9Mb3dlckNhc2UoKSA9PSAndHJ1ZSc7XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wLm1hdGNoKC9eY3VzdG9tU3R5bGUkLykpIHtcbiAgICAgICAgICAgICAgZGVmVmFsdWUgPSBTdHJpbmcocHJvcERlZls0XSkudG9Mb3dlckNhc2UoKSA9PSAndHJ1ZSc7XG4gICAgICAgICAgICB9IGVsc2UgZGVmVmFsdWUgPSBwcm9wRGVmWzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlcyBmb3VuZCBpbiBcInByb3BlcnRpZXNcIiBhcmUgbm90IGJlaW5nIHByb2Nlc3NlZCBieSBcIm1vZGVsRW5zdXJlVmFsdWVcIiBhbmQgYnkgY29uc2VxdWVuY2UgZG8gbm90IGNhbGwgXCJ0aGVtZVVwZGF0ZXJcIi5cbiAgICAgICAgLy8gVE9ETyBkb2N1bWVudCB3aHkgdGhpcyBpcyBuZWVkZWQsIG9yIHJlbW92ZS5cbiAgICAgICAgaWYgKGRlZlZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkZWZPYmouX2RlZmF1bHRWYWx1ZXNbcHJvcF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIChwcm9wLm1hdGNoKC9eXy8pKSBjb25zb2xlLmxvZyhcImRlZlZhbHVlIGZvclwiLCBwcm9wLCBcImluXCIsIG5hbWUpO1xuICAgICAgICAgICAgZGVmT2JqLl9kZWZhdWx0VmFsdWVzW3Byb3BdID0gZGVmVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWZPYmpbcHJvcF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgdmFsID0gX2dldE1vZGVsRGVmKGRlZnMsIG5hbWUgKyAnICcgKyBwcm9wLCB0cnVlKTtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWwgPSBfZ2V0TW9kZWxEZWYoZGVmcywgcHJvcCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZk9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZk9iai5fcHJvY2Vzc2VkRGVmc1twcm9wXSA9IG9yaWdQcm9wO1xuICAgICAgICBkZWZPYmouX2NvbXBsZXggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZGVmT2JqLl9wcm9wcztcbiAgICB9XG5cbiAgICBpZiAocmV0dXJuQ2xvbmUpIHtcbiAgICAgIGRlZk9iai5fd3JpdGVhYmxlID0gZmFsc2U7XG4gICAgICB2YXIgY2xvbmVkID0gb2JqRXh0ZW5kKHt9LCBkZWZPYmopO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9IGVsc2UgaWYgKHJlYWRvbmx5KSB7XG4gICAgICBkZWZPYmouX3dyaXRlYWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGRlZk9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBkZWZPYmouX3dyaXRlYWJsZSA9PSAndW5kZWZpbmVkJyB8fCBkZWZPYmouX3dyaXRlYWJsZSA9PT0gZmFsc2UpIHRocm93IFwiUmV0cmlldmluZyBub24gd3JpdGVhYmxlIG9iamVjdCBkZWZpbml0aW9uOiBcIiArIG5hbWU7XG4gICAgICByZXR1cm4gZGVmT2JqO1xuICAgIH1cbiAgfVxufTtcblxudmFyIF9pbmNyZWFzZVVzZUNvdW50ID0gZnVuY3Rpb24ocmVhZG9ubHksIG1vZGVsKSB7XG4gIGlmICghcmVhZG9ubHkpIHtcbiAgICBpZiAodHlwZW9mIG1vZGVsLl91c2Vjb3VudCA9PSAndW5kZWZpbmVkJykgbW9kZWwuX3VzZWNvdW50ID0gMDtcbiAgICBtb2RlbC5fdXNlY291bnQrKztcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWwuX3VzZWNvdW50ID09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVSUk9SIHRyeWluZyB0byBiaW5kIGFuIHVudXNlZCBwcm9wZXJ0eSB3aGlsZSByZWFkb25seVwiLCBtb2RlbCk7XG4gICAgdGhyb3cgXCJFUlJPUiB0cnlpbmcgdG8gYmluZCBhbiB1bnVzZWQgcHJvcGVydHlcIjtcbiAgfVxufTtcblxudmFyIGVuc3VyZUdsb2JhbFN0eWxlID0gZnVuY3Rpb24oZGVmcywgcmVhZG9ubHksIGdzQmluZGluZ1Byb3ZpZGVyLCBtb2RlbE5hbWUsIHBhdGgsIGdzRnVsbFBhdGgsIGRlZmF1bHRWYWx1ZSwgb3ZlcnJpZGVEZWZhdWx0KSB7XG5cbiAgdmFyIGdsb2JhbFN0eWxlQmluZGluZ0JpbmRWYWx1ZSA9IGdzQmluZGluZ1Byb3ZpZGVyKGdzRnVsbFBhdGgsIGRlZmF1bHRWYWx1ZSwgb3ZlcnJpZGVEZWZhdWx0KTtcblxuICBpZiAodHlwZW9mIGRlZnNbbW9kZWxOYW1lXS5fZ2xvYmFsU3R5bGVzW3BhdGhdID09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHJlYWRvbmx5KSB0aHJvdyBcIkNhbm5vdCBmaW5kIF9nbG9iYWxTdHlsZSBmb3IgXCIgKyBwYXRoICsgXCIgaW4gXCIgKyBtb2RlbE5hbWUgKyBcIiFcIjtcbiAgICBpZiAocGF0aC5pbmRleE9mKCcuJykgIT0gLTEgfHwgKHR5cGVvZiBkZWZzW21vZGVsTmFtZV1bcGF0aF0gPT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlZnNbbW9kZWxOYW1lXVtwYXRoXS5fd2lkZ2V0ICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgIGRlZnNbbW9kZWxOYW1lXS5fZ2xvYmFsU3R5bGVzW3BhdGhdID0gZ2xvYmFsU3R5bGVCaW5kaW5nQmluZFZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkZWZzW21vZGVsTmFtZV0uX2dsb2JhbFN0eWxlc1twYXRoXSAhPSBnbG9iYWxTdHlsZUJpbmRpbmdCaW5kVmFsdWUpIHRocm93IFwiVW5leHBlY3RlZCBjb25mbGljdGluZyBnbG9iYWxTdHlsZSBbMl0gZm9yIFwiICsgbW9kZWxOYW1lICsgXCIvXCIgKyBwYXRoICsgXCI6IG9sZD1cIiArIGRlZnNbbW9kZWxOYW1lXS5fZ2xvYmFsU3R5bGVzW3BhdGhdICsgXCIgbmV3PVwiICsgZ2xvYmFsU3R5bGVCaW5kaW5nQmluZFZhbHVlO1xufTtcblxuLy8gdGhlbWVVcGRhdGVyLCBkZWZhdWx0VmFsdWUsIG92ZXJyaWRlRGVmYXVsdCwgc2V0Y2F0ZWdvcnkgYXJlIG9ubHkgdXNlZCBpbiAhcmVhZG9ubHkgbW9kZVxudmFyIG1vZGVsRW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZSA9IGZ1bmN0aW9uKHJlYWRvbmx5LCBkZWZzLCB0aGVtZVVwZGF0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgd2l0aGluLCBmdWxsUGF0aCwgZGVmYXVsdFZhbHVlLCBvdmVycmlkZURlZmF1bHQsIHNldGNhdGVnb3J5KSB7XG4gIHZhciBtb2RlbE5hbWU7XG4gIHZhciByZXM7XG4gIHZhciBwYXRoO1xuICAvLyBUT0RPIHJlbW92ZSAnJCcgYW5kICcjJyBoYW5kaW5nXG4gIGlmIChmdWxsUGF0aC5zdWJzdHIoMCwgMSkgPT0gJyQnKSB7XG4gICAgY29uc29sZS53YXJuKFwiREVQUkVDQVRFRCAkIGluIGJpbmRpbmdQcm92aWRlcjogXCIsIGZ1bGxQYXRoLCB0ZW1wbGF0ZU5hbWUpO1xuICAgIHZhciBwID0gZnVsbFBhdGguaW5kZXhPZignLicpO1xuICAgIGlmIChwID09IC0xKSB7XG4gICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZnVsbFBhdGg6IFwiICsgZnVsbFBhdGggKyBcIi9cIiArIHdpdGhpbiArIFwiL1wiICsgdGVtcGxhdGVOYW1lICsgXCIvXCIgKyBkZWZhdWx0VmFsdWUgKyBcIi9cIiArIG92ZXJyaWRlRGVmYXVsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxOYW1lID0gZnVsbFBhdGguc3Vic3RyKDEsIHAgLSAxKTtcbiAgICAgIHBhdGggPSBmdWxsUGF0aC5zdWJzdHIocCArIDEpO1xuICAgICAgLy8gVE9ETyByZWZhY3RvciBtZSBwbGVhc2VcbiAgICAgIGlmIChtb2RlbE5hbWUgPT0gJ3RoZW1lJykge1xuICAgICAgICB2YXIgcDIgPSBwYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgICAgbW9kZWxOYW1lID0gcGF0aC5zdWJzdHIoMCwgcDIpO1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIocDIgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCAkIHNlcXVlbmNlOiBcIiArIG1vZGVsTmFtZSArIFwiIGluIFwiICsgZnVsbFBhdGg7XG4gICAgICB9XG4gICAgICByZXMgPSBcIiRyb290LmNvbnRlbnQoKS50aGVtZSgpLlwiICsgbW9kZWxOYW1lICsgXCIoKS5cIiArIHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcLicsICdnJyksICcoKS4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZnVsbFBhdGguc3Vic3RyKDAsIDEpID09ICcjJykge1xuICAgIGNvbnNvbGUud2FybihcIkRFUFJFQ0FURUQgIyBpbiBiaW5kaW5nUHJvdmlkZXI6IFwiLCBmdWxsUGF0aCwgdGVtcGxhdGVOYW1lKTtcbiAgICBtb2RlbE5hbWUgPSByb290TW9kZWxOYW1lO1xuICAgIHBhdGggPSBmdWxsUGF0aC5zdWJzdHIoMSk7XG4gICAgcmVzID0gXCIkcm9vdC5jb250ZW50KCkuXCIgKyBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXC4nLCAnZycpLCAnKCkuJyk7XG4gIH0gZWxzZSBpZiAoZnVsbFBhdGguc3Vic3RyKDAsIDgpID09ICdfdGhlbWVfLicpIHtcbiAgICB2YXIgcDMgPSBmdWxsUGF0aC5pbmRleE9mKCcuJywgOCk7XG4gICAgbW9kZWxOYW1lID0gZnVsbFBhdGguc3Vic3RyKDgsIHAzIC0gOCk7XG4gICAgcGF0aCA9IGZ1bGxQYXRoLnN1YnN0cihwMyArIDEpO1xuICAgIHJlcyA9IFwiJHJvb3QuY29udGVudCgpLnRoZW1lKCkuXCIgKyBtb2RlbE5hbWUgKyBcIigpLlwiICsgcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwuJywgJ2cnKSwgJygpLicpO1xuICB9IGVsc2UgaWYgKGZ1bGxQYXRoLnN1YnN0cigwLCA3KSA9PSAnX3Jvb3RfLicpIHtcbiAgICBtb2RlbE5hbWUgPSByb290TW9kZWxOYW1lO1xuICAgIHBhdGggPSBmdWxsUGF0aC5zdWJzdHIoNyk7XG4gICAgcmVzID0gXCIkcm9vdC5jb250ZW50KCkuXCIgKyBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXC4nLCAnZycpLCAnKCkuJyk7XG4gIH0gZWxzZSB7XG4gICAgbW9kZWxOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgIHBhdGggPSB3aXRoaW4gKyBmdWxsUGF0aDtcbiAgICByZXMgPSBmdWxsUGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwuJywgJ2cnKSwgJygpLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZzW21vZGVsTmFtZV0gPT09ICd1bmRlZmluZWQnKSB0aHJvdyBcIkNhbm5vdCBmaW5kIG1vZGVsIGRlZiBmb3IgW1wiICsgbW9kZWxOYW1lICsgXCJdXCI7XG5cbiAgdmFyIHByb3BQb3MgPSBwYXRoLmluZGV4T2YoJy4nKTtcbiAgdmFyIHByb3BOYW1lID0gcHJvcFBvcyA9PSAtMSA/IHBhdGggOiBwYXRoLnN1YnN0cigwLCBwcm9wUG9zKTtcblxuICBpZiAobW9kZWxOYW1lLmluZGV4T2YoJy0nKSAhPSAtMSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFUlJPUiBjYW5ub3QgdXNlIC0gZm9yIGJsb2NrIG5hbWVzXCIsIG1vZGVsTmFtZSk7XG4gICAgdGhyb3cgXCJFUlJPUiB1bmV4cGVjdGVkIGNoYXIgaW4gYmxvY2sgbmFtZTogXCIgKyBtb2RlbE5hbWU7XG4gIH1cbiAgaWYgKHByb3BOYW1lLmluZGV4T2YoJy0nKSAhPSAtMSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFUlJPUiBjYW5ub3QgdXNlIC0gZm9yIHByb3BlcnR5IG5hbWVzXCIsIHByb3BOYW1lKTtcbiAgICB0aHJvdyBcIkVSUk9SIHVuZXhwZWN0ZWQgY2hhciBpbiBwcm9wZXJ0eSBuYW1lOiBcIiArIG1vZGVsTmFtZTtcbiAgfVxuXG4gIC8vIEZhc3RwYXRoXG4gIGlmIChyZWFkb25seSkge1xuICAgIGlmICh0eXBlb2YgZGVmc1ttb2RlbE5hbWVdLl9nbG9iYWxTdHlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0gIT09ICd1bmRlZmluZWQnICYmIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0uX2NhdGVnb3J5ID09ICdzdHlsZScpIHtcbiAgICAgIHJlcyArPSAnLl9kZWZhdWx0Q29tcHV0ZWQnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gZ2V0cyB0aGUgd3JpdGFibGUgbW9kZWwgd2hlbiBcIiFyZWFkb25seVwiIG9yIHRoZSByZWFkb25seSBtb2RlbCBvdGhlcndpc2VcbiAgdmFyIG1vZGVsO1xuICBpZiAocmVhZG9ubHkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiQ2Fubm90IHVzZSBkZWZhdWx0VmFsdWUgaW4gcmVhZG9ubHkgbW9kZSFcIjtcbiAgICBpZiAob3ZlcnJpZGVEZWZhdWx0KSB0aHJvdyBcIkNhbm5vdCB1c2Ugb3ZlcnJpZGVEZWZhdWx0IGluIHJlYWRvbmx5IG1vZGUgZm9yIFwiICsgbW9kZWxOYW1lICsgXCIvXCIgKyBwYXRoICsgXCIvXCIgKyBvdmVycmlkZURlZmF1bHQgKyBcIiFcIjtcbiAgICBpZiAodHlwZW9mIHNldGNhdGVnb3J5ICE9PSAndW5kZWZpbmVkJykgdGhyb3cgXCJDYW5ub3Qgc2V0IGNhdGVnb3J5IGZvciBcIiArIG1vZGVsTmFtZSArIFwiL1wiICsgcGF0aCArIFwiL1wiICsgc2V0Y2F0ZWdvcnkgKyBcIiBpbiByZWFkb25seSBtb2RlIVwiO1xuICAgIG1vZGVsID0gX2dldE1vZGVsRGVmKGRlZnMsIG1vZGVsTmFtZSwgZmFsc2UsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChkZWZzW21vZGVsTmFtZV0uX3dyaXRlYWJsZSA9PT0gZmFsc2UpIGNvbnNvbGUubG9nKFwiVE9ETyBkZWJ1ZyB1c2UgY2FzZXMgZm9yIHRoaXMgY29uZGl0aW9uXCIsIG1vZGVsTmFtZSwgcGF0aCk7XG4gICAgbW9kZWwgPSBfZ2V0TW9kZWxEZWYoZGVmcywgbW9kZWxOYW1lLCBkZWZzW21vZGVsTmFtZV0uX3dyaXRlYWJsZSA9PT0gZmFsc2UpO1xuICB9XG5cbiAgaWYgKG1vZGVsID09PSBudWxsKSB0aHJvdyBcIlVuZXhwZWN0ZWQgbW9kZWwgZm9yIFtcIiArIG1vZGVsTmFtZSArIFwiXVwiO1xuXG4gIC8vIGlmIHRoZSBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdHMgd2UgaGF2ZSB0byBjcmVhdGUgaXQuXG4gIGlmICh0eXBlb2YgbW9kZWxbcHJvcE5hbWVdID09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd2hlbiBpbiByZWFkb25seSBtb2RlIHRoaXMgY2Fubm90IGJlIGRvbmUhXG4gICAgaWYgKHJlYWRvbmx5KSB0aHJvdyBcIkNhbm5vdCBmaW5kIHBhdGggXCIgKyBwcm9wTmFtZSArIFwiIGZvciBcIiArIG1vZGVsTmFtZSArIFwiIVwiO1xuICAgIF9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgbW9kZWxOYW1lLCBwcm9wTmFtZSk7XG4gICAgbW9kZWwgPSBfZ2V0TW9kZWxEZWYoZGVmcywgbW9kZWxOYW1lLCBmYWxzZSk7XG4gIH1cblxuICAvLyBOZWVkcyB0byBkbyB0aGlzIGFnYWluLCBiZWNhdXNlIFwiX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZlwiIGNvdWxkIGhhdmUgYmVlbiBqdXN0IGNyZWF0ZWQgdGhlIHByb3BlcnR5IChlLmc6IGJhY2tncm91bmRDb2xvciBidXR0b25CbG9jayBub3QgZ2V0dGluZyBkZWZhdWx0Q29tcHV0ZWQgaW4gdGVtcGxhdGUtbG0pXG4gIGlmICh0eXBlb2YgZGVmc1ttb2RlbE5hbWVdLl9nbG9iYWxTdHlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0gIT09ICd1bmRlZmluZWQnICYmIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0gIT09IG51bGwgJiYgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXS5fY2F0ZWdvcnkgPT0gJ3N0eWxlJykge1xuICAgIHJlcyArPSAnLl9kZWZhdWx0Q29tcHV0ZWQnO1xuICB9XG5cbiAgdmFyIGNoaWxkTW9kZWwgPSBtb2RlbDtcbiAgdHJ5IHtcbiAgICBfaW5jcmVhc2VVc2VDb3VudChyZWFkb25seSwgY2hpbGRNb2RlbCk7XG4gICAgaWYgKHByb3BQb3MgIT0gLTEpIHtcbiAgICAgIHZhciBteXBhdGggPSBwYXRoO1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgcHJvcCA9IG15cGF0aC5zdWJzdHIoMCwgcHJvcFBvcyk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRNb2RlbFtwcm9wXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IFwiRm91bmQgYW4gdW5leHBlY3RlZCBwcm9wIFwiICsgcHJvcCArIFwiIGZvciBtb2RlbCBcIiArIG1vZGVsTmFtZSArIFwiIGZvciBcIiArIHBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZE1vZGVsID0gY2hpbGRNb2RlbFtwcm9wXTtcbiAgICAgICAgX2luY3JlYXNlVXNlQ291bnQocmVhZG9ubHksIGNoaWxkTW9kZWwpO1xuICAgICAgICBteXBhdGggPSBteXBhdGguc3Vic3RyKHByb3BQb3MgKyAxKTtcbiAgICAgICAgcHJvcFBvcyA9IG15cGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICB9IHdoaWxlIChwcm9wUG9zICE9IC0xKTtcblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZE1vZGVsW215cGF0aF0gPT0gJ3VuZGVmaW5lZCcgfHwgY2hpbGRNb2RlbFtteXBhdGhdID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IFwiRm91bmQgYW4gdW5leHBlY3RlZCBwYXRoIHRlcm1pbmF0aW9uIFwiICsgbXlwYXRoICsgXCIgZm9yIG1vZGVsIFwiICsgbW9kZWxOYW1lICsgXCIgZm9yIFwiICsgcGF0aDtcbiAgICAgIH1cbiAgICAgIGNoaWxkTW9kZWwgPSBjaGlsZE1vZGVsW215cGF0aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkTW9kZWwgPSBjaGlsZE1vZGVsW3BhdGhdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGRNb2RlbCA9PT0gJ3VuZGVmaW5lZCcgfHwgY2hpbGRNb2RlbCA9PT0gbnVsbCkgdGhyb3cgXCJVbmV4cGVjdGVkIG51bGwgbW9kZWwgZm9yIFwiICsgbW9kZWxOYW1lICsgXCIvXCIgKyB3aXRoaW4gKyBcIi9cIiArIGZ1bGxQYXRoO1xuXG4gICAgaWYgKHR5cGVvZiBzZXRjYXRlZ29yeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNoaWxkTW9kZWwuX2NhdGVnb3J5ID0gc2V0Y2F0ZWdvcnk7XG4gICAgfVxuXG4gICAgX2luY3JlYXNlVXNlQ291bnQocmVhZG9ubHksIGNoaWxkTW9kZWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRPRE8gRVJST1IgUHJvcGVydHkgbG9va3VwIGV4Y2VwdGlvblwiLCBlLCBtb2RlbE5hbWUsIHBhdGgsIHRlbXBsYXRlTmFtZSwgZnVsbFBhdGgsIGRlZnMpO1xuICAgIHRocm93IGU7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZnNbbW9kZWxOYW1lXS5fZ2xvYmFsU3R5bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdID09ICdvYmplY3QnICYmIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0gIT09IG51bGwgJiYgdHlwZW9mIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0uX2NhdGVnb3J5ICE9ICd1bmRlZmluZWQnICYmIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0uX2NhdGVnb3J5ID09ICdzdHlsZScpIHtcbiAgICAvLyBUT0RPIGNhbiBJIHJlc3RyaWN0IHRoaXMgY29kZSB0byAhcmVhZG9ubHkgbW9kZT9cbiAgICB2YXIgZ3NCaW5kaW5nUHJvdmlkZXIgPSBtb2RlbEVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUuYmluZCh1bmRlZmluZWQsIHJlYWRvbmx5LCBkZWZzLCB0aGVtZVVwZGF0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgJycpO1xuXG4gICAgdmFyIHN1YlBhdGggPSBwYXRoLmluZGV4T2YoJy4nKSAhPSAtMSA/IHBhdGguc3Vic3RyKHBhdGguaW5kZXhPZignLicpKSA6ICcnO1xuXG4gICAgLy8gVGhlIG5leHQgY29kZSBzdXBwb3J0cyBvbmx5IHByb3BlcnRpZXMgd2l0aCBvbmUgZG90IChvYmplY3QucHJvcGVydHkpLlxuICAgIGlmIChzdWJQYXRoLmluZGV4T2YoJy4nLCAxKSAhPSAtMSkgdGhyb3cgXCJUT0RPIHVuc3VwcG9ydGVkIG9iamVjdCBuZXN0aW5nISBcIiArIHBhdGg7XG5cbiAgICB2YXIgZ3NQYXRoID0gZGVmc1ttb2RlbE5hbWVdLl9nbG9iYWxTdHlsZSArICcuJyArIHByb3BOYW1lO1xuICAgIGlmICh0eXBlb2YgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXSA9PSAnb2JqZWN0JyAmJiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdICE9PSBudWxsICYmIHR5cGVvZiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdLl9nbG9iYWxTdHlsZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgZ3NQYXRoID0gZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXS5fZ2xvYmFsU3R5bGU7XG4gICAgfVxuXG4gICAgZW5zdXJlR2xvYmFsU3R5bGUoZGVmcywgcmVhZG9ubHksIGdzQmluZGluZ1Byb3ZpZGVyLCBtb2RlbE5hbWUsIHByb3BOYW1lLCBnc1BhdGgsIHVuZGVmaW5lZCwgZmFsc2UpO1xuXG4gICAgdmFyIGdzRnVsbFBhdGggPSBnc1BhdGggKyBzdWJQYXRoO1xuXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT0gJ3VuZGVmaW5lZCcgJiYgZGVmc1ttb2RlbE5hbWVdLl9kZWZhdWx0VmFsdWVzW3BhdGhdICE9PSBudWxsKSBkZWZhdWx0VmFsdWUgPSBkZWZzW21vZGVsTmFtZV0uX2RlZmF1bHRWYWx1ZXNbcGF0aF07XG5cbiAgICBlbnN1cmVHbG9iYWxTdHlsZShkZWZzLCByZWFkb25seSwgZ3NCaW5kaW5nUHJvdmlkZXIsIG1vZGVsTmFtZSwgcGF0aCwgZ3NGdWxsUGF0aCwgZGVmYXVsdFZhbHVlLCBvdmVycmlkZURlZmF1bHQpO1xuXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAocmVhZG9ubHkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBzZXQgYSBuZXcgdGhlbWUgZGVmYXVsdCB2YWx1ZVwiLCBnc0Z1bGxQYXRoLnN1YnN0cig3KSwgZGVmYXVsdFZhbHVlLCBcIndoaWxlIGluIHJlYWRvbmx5IG1vZGVcIik7XG4gICAgICAgIHRocm93IFwiQ2Fubm90IHNldCBhIG5ldyB0aGVtZSBkZWZhdWx0IHZhbHVlIChcIiArIGRlZmF1bHRWYWx1ZSArIFwiKSBmb3IgXCIgKyBnc0Z1bGxQYXRoLnN1YnN0cig3KSArIFwiIHdoaWxlIGluIHJlYWRvbmx5IG1vZGUhXCI7XG4gICAgICB9XG4gICAgICB0aGVtZVVwZGF0ZXIoJ2RlZmF1bHQnLCBnc0Z1bGxQYXRoLnN1YnN0cig3KSwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIGNvbXBsZXggc3R1ZmYuIElmIHRoZSB0aGVtZSB1c2VzIGluaGVyaXRhbmNlIHdlIGVuZm9yY2UgaXQgdXNpbmcgd2l0aCB0aGUgc2FtZSB2YWx1ZSwgYnV0IHRoaXMgaXMgYSBsaW1pdC5cbiAgICBkZWZhdWx0VmFsdWUgPSBudWxsO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZGVmc1ttb2RlbE5hbWVdLl9kZWZhdWx0VmFsdWVzW3BhdGhdID09ICd1bmRlZmluZWQnIHx8ICh0eXBlb2Ygb3ZlcnJpZGVEZWZhdWx0ICE9ICd1bmRlZmluZWQnICYmIG92ZXJyaWRlRGVmYXVsdCkpIHtcbiAgICAgIGlmIChyZWFkb25seSkgdGhyb3cgXCJDYW5ub3Qgc2V0IG5ldyBfZGVmYXVsdFZhbHVlcyBbMV0gZm9yIFwiICsgcGF0aCArIFwiIGluIFwiICsgbW9kZWxOYW1lICsgXCIhXCI7XG4gICAgICBkZWZzW21vZGVsTmFtZV0uX2RlZmF1bHRWYWx1ZXNbcGF0aF0gPSBkZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHJlYWRvbmx5ICYmIGRlZnNbbW9kZWxOYW1lXS5fZGVmYXVsdFZhbHVlc1twYXRoXSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IFwiQ2Fubm90IHNldCBuZXcgX2RlZmF1bHRWYWx1ZXMgWzJdIGZvciBcIiArIHBhdGggKyBcIiBpbiBcIiArIG1vZGVsTmFtZSArIFwiIVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcmVtb3ZlIGRlZmF1bHQgdmFsdWUuIFVnbHkuIChOZWVkcyB0aGlzIGZvciBkZWZhdWx0cyBpbiB0ZW1wbGF0ZS1sbSBzb2NpYWxMaW5rc0ljb24pXG4gICAgICAgIGRlZnNbbW9kZWxOYW1lXS5fZGVmYXVsdFZhbHVlc1twYXRoXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGRlZnNbbW9kZWxOYW1lXS5fZGVmYXVsdFZhbHVlc1twYXRoXSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRPRE8gZXJyb3IhISEgVHJ5aW5nIHRvIHNldCBhIG5ldyBkZWZhdWx0IHZhbHVlIGZvciBcIiArIG1vZGVsTmFtZSArIFwiIFwiICsgcGF0aCArIFwiIHdoaWxlIGl0IGFscmVhZHkgZXhpc3RzIChjdXJyZW50OiBcIiArIGRlZnNbbW9kZWxOYW1lXS5fZGVmYXVsdFZhbHVlc1twYXRoXSArIFwiLCBuZXc6IFwiICsgZGVmYXVsdFZhbHVlICsgXCIpXCIpO1xuICAgICAgICB0aHJvdyBcIlRyeWluZyB0byBzZXQgYSBuZXcgZGVmYXVsdCB2YWx1ZSBmb3IgXCIgKyBtb2RlbE5hbWUgKyBcIiBcIiArIHBhdGggKyBcIiB3aGlsZSBpdCBhbHJlYWR5IGV4aXN0cyAoY3VycmVudDogXCIgKyBkZWZzW21vZGVsTmFtZV0uZGVmYXVsdFZhbHVlc1twYXRoXSArIFwiLCBuZXc6IFwiICsgZGVmYXVsdFZhbHVlICsgXCIpXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBnZW5lcmF0ZVJlc3VsdE1vZGVsID0gZnVuY3Rpb24odGVtcGxhdGVEZWYpIHtcbiAgdmFyIGRlZnMgPSB0ZW1wbGF0ZURlZi5fZGVmcztcbiAgdmFyIHRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlRGVmLnRlbXBsYXRlTmFtZTtcblxuICB2YXIgZmluYWxNb2RlbENvbnRlbnQgPSBfZ2VuZXJhdGVNb2RlbChkZWZzLCB0ZW1wbGF0ZU5hbWUpO1xuXG4gIC8vIFRPRE8gdWdseSB0byBhZGQgdGhpcyBtYW51YWxseVxuICBpZiAodHlwZW9mIGRlZnNbJ3RoZW1lJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmluYWxNb2RlbENvbnRlbnQudGhlbWUgPSBfZ2VuZXJhdGVNb2RlbChkZWZzLCAndGhlbWUnKTtcbiAgfVxuXG4gIHJldHVybiBmaW5hbE1vZGVsQ29udGVudDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyB1c2VkIHRvIGNvbXBpbGUgdGhlIHRlbXBsYXRlXG4gIGVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWU6IG1vZGVsRW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgZmFsc2UpLFxuICAvLyB1c2VkIGluIHJ1bnRpbWUgdGhlIHRlbXBsYXRlXG4gIGdldEJpbmRWYWx1ZTogbW9kZWxFbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlLmJpbmQodW5kZWZpbmVkLCB0cnVlKSxcbiAgZ2VuZXJhdGVNb2RlbDogX2dlbmVyYXRlTW9kZWwsXG4gIGdlbmVyYXRlUmVzdWx0TW9kZWw6IGdlbmVyYXRlUmVzdWx0TW9kZWwsXG4gIGdldERlZjogX2dldERlZixcbiAgY3JlYXRlT3JVcGRhdGVCbG9ja0RlZjogX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZlxufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgY29udmVydGVyVXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbnZhciBlbGFib3JhdGVEZWNsYXJhdGlvbnMgPSByZXF1aXJlKFwiLi9kZWNsYXJhdGlvbnMuanNcIik7XG52YXIgcHJvY2Vzc1N0eWxlc2hlZXRSdWxlcyA9IHJlcXVpcmUoXCIuL3N0eWxlc2hlZXQuanNcIik7XG52YXIgbW9kZWxEZWYgPSByZXF1aXJlKFwiLi9tb2RlbC5qc1wiKTtcbnZhciBkb211dGlscyA9IHJlcXVpcmUoXCIuL2RvbXV0aWxzLmpzXCIpO1xuXG52YXIgd3JhcEVsZW1lbnRXaXRoQ29uZGl0aW9uID0gZnVuY3Rpb24oYXR0cmlidXRlLCBlbGVtZW50LCBiaW5kaW5nUHJvdmlkZXIpIHtcbiAgdmFyIGNvbmQgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKTtcblxuICB0cnkge1xuICAgIHZhciBiaW5kaW5nID0gY29udmVydGVyVXRpbHMuY29uZGl0aW9uQmluZGluZyhjb25kLCBiaW5kaW5nUHJvdmlkZXIpO1xuICAgICQoZWxlbWVudCkuYmVmb3JlKCc8IS0tIGtvIGlmOiAnICsgYmluZGluZyArICcgLS0+Jyk7XG4gICAgJChlbGVtZW50KS5hZnRlcignPCEtLSAva28gLS0+Jyk7XG4gICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJNb2RlbCBlbnN1cmUgcGF0aCBmYWlsZWQgaW4gaWYvdmFyaWFudFwiLCBlbGVtZW50LCBjb25kLCBhdHRyaWJ1dGUpO1xuICAgIHRocm93IGU7XG4gIH1cblxufTtcblxudmFyIHJlcGxhY2VkQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCBcInJlcGxhY2VkXCIgKyBhdHRyaWJ1dGVOYW1lKSk7XG59O1xuXG52YXIgcHJvY2Vzc1N0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGJpbmRpbmdQcm92aWRlciwgYWRkVW5pcXVlSWQpIHtcbiAgdmFyIHN0eWxlID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdyZXBsYWNlZHN0eWxlJyk7XG4gIHZhciBuZXdTdHlsZSA9IG51bGw7XG4gIHZhciBuZXdCaW5kaW5ncztcbiAgaWYgKGFkZFVuaXF1ZUlkKSBuZXdCaW5kaW5ncyA9IHtcbiAgICB1bmlxdWVJZDogJyRkYXRhJyxcbiAgICBhdHRyOiB7XG4gICAgICBpZDogJ2lkJ1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlRGlzcGxheU5vbmUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tZGlzcGxheScpICE9PSBudWxsO1xuXG4gIG5ld1N0eWxlID0gZWxhYm9yYXRlRGVjbGFyYXRpb25zKHN0eWxlLCB1bmRlZmluZWQsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBiaW5kaW5nUHJvdmlkZXIsIGVsZW1lbnQsIG5ld0JpbmRpbmdzLCByZW1vdmVEaXNwbGF5Tm9uZSk7XG5cbiAgLy8gb25seSB3aGVuIHVzaW5nIFwicmVwbGFjZWRcIlxuICBpZiAobmV3U3R5bGUgPT09IG51bGwpIHtcbiAgICBuZXdTdHlsZSA9IHN0eWxlO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGJpbmRpbmdzIHdlIGtlZXAgcmVwbGFjZWRzdHlsZSB0byBiZSB1c2VkIGJ5IElFIGR1cmluZyBvdXRwdXRcbiAgICAvLyBvdGhlcndpc2UgSSByZW1vdmUgaXQgYmVjYXVzZSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHZpcnR1YWxBdHRyU3R5bGUgYmluZGluZy5cbiAgICAvLyBUT0RPIG1heWJlIHdlIGJldHRlciB1c2UgZGlmZmVyZW50IG5hbWVzIGZvciBcInJlcGxhY2VkXCIgdXNlZCBkdXJpbmcgdGVtcGxhdGUgY29udmVyc2lvblxuICAgIC8vIGFuZCB0aGUgb25lcyB1c2VkIHRvIGNyZWF0ZSB0aGUgb3V0cHV0LlxuICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAncmVwbGFjZWRzdHlsZScpO1xuICB9XG5cbiAgaWYgKG5ld1N0eWxlICE9PSBudWxsKSB7XG4gICAgaWYgKG5ld1N0eWxlLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ3N0eWxlJywgbmV3U3R5bGUpO1xuICAgIH0gZWxzZSBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ3N0eWxlJyk7XG4gIH1cbn07XG5cblxuLy8gVE9ETyBmaXhpbmcgVVJMcyBpcyBhbHNvIG5lZWRlZCB3aGVyZSBzdHlsZXMgdXNlcyBwYXRoIChlLmc6IGJhY2tncm91bmQtaW1hZ2UsIEBpbXBvcnQpXG52YXIgX2ZpeFJlbGF0aXZlUGF0aCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGluZGV4LCBlbGVtZW50KSB7XG4gIHZhciB1cmwgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKTtcbiAgdmFyIG5ld1VybCA9IHRlbXBsYXRlVXJsQ29udmVydGVyKHVybCk7XG4gIGlmIChuZXdVcmwgIT09IG51bGwpIHtcbiAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlLCBuZXdVcmwpO1xuICB9XG59O1xuXG5cbnZhciBwcm9jZXNzQmxvY2sgPSBmdW5jdGlvbihlbGVtZW50LCBkZWZzLCB0aGVtZVVwZGF0ZXIsIGJsb2NrUHVzaGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgY29udGV4dE5hbWUsIHJvb3RNb2RlbE5hbWUsIGNvbnRhaW5lck5hbWUsIGdlbmVyYXRlVW5pcXVlSWQsIHRlbXBsYXRlQ3JlYXRvcikge1xuXG4gIHRyeSB7XG5cbiAgdmFyIHRlbXBsYXRlTmFtZTtcbiAgdmFyIHZhcmlhbnROYW1lID0gJycsXG4gICAgdmFyaWFudERlZiA9ICcnO1xuICBpZiAoY29udGV4dE5hbWUgPT0gJ2Jsb2NrJykge1xuICAgIHRlbXBsYXRlTmFtZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1ibG9jaycpO1xuICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1ibG9jaycpO1xuICB9IGVsc2UgaWYgKGNvbnRleHROYW1lID09ICd0ZW1wbGF0ZScpIHtcbiAgICB0ZW1wbGF0ZU5hbWUgPSByb290TW9kZWxOYW1lO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFwiVW5leHBlY3RlZCBjb250ZXh0IG5hbWUgd2hpbGUgcHJvY2Vzc2luZyBibG9jazogXCIgKyBjb250ZXh0TmFtZTtcbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKFwicHJvY2Vzc0Jsb2NrXCIsIGNvbnRleHROYW1lLCByb290TW9kZWxOYW1lLCBjb250YWluZXJOYW1lLCB0ZW1wbGF0ZU5hbWUpO1xuXG4gIC8vIFJlbW92ZSBlbGVtZW50XG4gICQoJ1tkYXRhLWtvLXJlbW92ZV0nLCBlbGVtZW50KS5yZW1vdmUoKTtcblxuICB2YXIgZml4ZWRCbG9ja3MgPSAkKCdbZGF0YS1rby1ibG9ja10nLCBlbGVtZW50KS5yZXBsYWNlV2l0aCgnPHJlcGxhY2VkYmxvY2s+Jyk7XG5cbiAgLy8gVXJscyBpbiB0aGVzZSBhdHRyaWJ1dGVzIG5lZWRzIFwicmVsYXRpdml6YXRpb25cIlxuICB2YXIgdXJsYXR0cnMgPSBbJ2hyZWYnLCAnc3JjJywgJ2RhdGEta28tcGxhY2Vob2xkZXItc3JjJywgJ2JhY2tncm91bmQnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cmxhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGZhY2NpbyBpbCBiaW5kIHBlciBub24gZGVmaW5pcmUgZnVuemlvbmkgaW4gdW4gbG9vcCAoanNoaW50KVxuICAgIHZhciBmdW5jID0gX2ZpeFJlbGF0aXZlUGF0aC5iaW5kKHVuZGVmaW5lZCwgdXJsYXR0cnNbaV0sIHRlbXBsYXRlVXJsQ29udmVydGVyKTtcbiAgICAkKCdbJyArIHVybGF0dHJzW2ldICsgJ10nLCBlbGVtZW50KS5lYWNoKGZ1bmMpO1xuICB9XG5cbiAgdmFyIGRhdGFEZWZzID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXByb3BlcnRpZXMnKTtcbiAgaWYgKGRhdGFEZWZzID09PSBudWxsKSBkYXRhRGVmcyA9IFwiXCI7XG4gICQoXCJbZGF0YS1rby1wcm9wZXJ0aWVzXVwiLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgaWYgKGRhdGFEZWZzLmxlbmd0aCA+IDApIGRhdGFEZWZzID0gZGF0YURlZnMgKyBcIiBcIjtcbiAgICBkYXRhRGVmcyA9IGRhdGFEZWZzICsgZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXByb3BlcnRpZXMnKTtcbiAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcHJvcGVydGllcycpO1xuICB9KTtcblxuICBtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsIHRlbXBsYXRlTmFtZSwgZGF0YURlZnMsIHsgY29udGV4dE5hbWU6IGNvbnRleHROYW1lIH0pO1xuXG4gIHZhciBiaW5kaW5nUHJvdmlkZXIgPSBtb2RlbERlZi5lbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlLmJpbmQodW5kZWZpbmVkLCBkZWZzLCB0aGVtZVVwZGF0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgJycpO1xuICBpZiAoY29udGV4dE5hbWUgPT0gJ2Jsb2NrJykgYmluZGluZ1Byb3ZpZGVyKCdpZCcsICcnKTtcblxuICAkKCdzdHlsZScsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB2YXIgc3R5bGUgPSBkb211dGlscy5nZXRJbm5lckh0bWwoZWxlbWVudCk7XG5cbiAgICB2YXIgYmxvY2tEZWZzVXBkYXRlciA9IG1vZGVsRGVmLmNyZWF0ZU9yVXBkYXRlQmxvY2tEZWYuYmluZCh1bmRlZmluZWQsIGRlZnMpO1xuICAgIHZhciBsb2NhbFdpdGhCaW5kaW5nUHJvdmlkZXIgPSBtb2RlbERlZi5lbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlLmJpbmQodW5kZWZpbmVkLCBkZWZzLCB0aGVtZVVwZGF0ZXIsIHJvb3RNb2RlbE5hbWUpO1xuICAgIHZhciBuZXdTdHlsZSA9IHByb2Nlc3NTdHlsZXNoZWV0UnVsZXMoc3R5bGUsIHVuZGVmaW5lZCwgbG9jYWxXaXRoQmluZGluZ1Byb3ZpZGVyLCBibG9ja0RlZnNVcGRhdGVyLCB0aGVtZVVwZGF0ZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUpO1xuXG4gICAgaWYgKG5ld1N0eWxlICE9IHN0eWxlKSB7XG4gICAgICBpZiAobmV3U3R5bGUudHJpbSgpICE9PSAnJykge1xuICAgICAgICB2YXIgdG1wTmFtZSA9IHRlbXBsYXRlQ3JlYXRvcihuZXdTdHlsZSk7XG4gICAgICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJywgJ3RlbXBsYXRlOiB7IG5hbWU6IFxcJycgKyB0bXBOYW1lICsgJ1xcJyB9Jyk7XG4gICAgICAgIC8vIGhvIGNyZWF0byBpbCB0ZW1wbGF0ZSBxdWluZGkgcG9zc28gc3Z1b3RhcmUgaWwgc29yZ2VudGUuXG4gICAgICAgIGRvbXV0aWxzLnNldENvbnRlbnQoZWxlbWVudCwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHN0eWxlcyBibG9ja3NcbiAgICAgICAgZG9tdXRpbHMucmVtb3ZlRWxlbWVudHMoJChlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBwcm9jZXNzU3R5bGUoZWxlbWVudCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGJpbmRpbmdQcm92aWRlciwgZ2VuZXJhdGVVbmlxdWVJZCk7XG5cbiAgLy8gVE9ETyBocmVmIHNob3VsZCBiZSBzdXBwb3J0ZWQuIGRhdGEta28tZGlzcGxheSBhbmQgZGF0YS1rby13cmFwIHNob3VsZCBuZXZlciBoYXBwZW4gaW4gaGVyZS5cbiAgdmFyIG5vdHN1cHBvcnRlZCA9IFsnZGF0YS1rby1kaXNwbGF5JywgJ2RhdGEta28tZWRpdGFibGUnLCAnZGF0YS1rby13cmFwJywgJ2hyZWYnXTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBub3RzdXBwb3J0ZWQubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgYXR0ciA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCBub3RzdXBwb3J0ZWRbal0pO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFUlJPUjogVW5zdXBwb3J0ZWQgXCIgKyBub3RzdXBwb3J0ZWRbal0gKyBcIiB1c2VkIHRvZ2V0aGVyIHdpdGggZGF0YS1rby1ibG9ja1wiLCBlbGVtZW50KTtcbiAgICAgIHRocm93IFwiRVJST1I6IFVuc3VwcG9ydGVkIFwiICsgbm90c3VwcG9ydGVkW2pdICsgXCIgdXNlZCB0b2dldGhlciB3aXRoIGRhdGEta28tYmxvY2tcIjtcbiAgICB9XG4gIH1cblxuICAvLyBzaW1wbHkgcHJlcHJvY2Vzc2VkIGFzIGRhdGEta28td3JhcCArIC1rby1hdHRyLWhyZWZcbiAgJChcIltkYXRhLWtvLWxpbmtdXCIsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB2YXIgdXJsVmFyID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWxpbmsnKTtcbiAgICB2YXIgcmVwU3R5bGUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ3JlcGxhY2Vkc3R5bGUnKTtcbiAgICBpZiAodHlwZW9mIHJlcFN0eWxlID09ICd1bmRlZmluZWQnIHx8IHJlcFN0eWxlID09PSBudWxsKSByZXBTdHlsZSA9ICcnO1xuICAgIGlmIChyZXBTdHlsZSAhPT0gJycpIHJlcFN0eWxlID0gJy1rby1hdHRyLWhyZWY6IEAnICsgdXJsVmFyICsgXCI7IFwiICsgcmVwU3R5bGU7XG4gICAgZWxzZSByZXBTdHlsZSA9ICcta28tYXR0ci1ocmVmOiBAJyArIHVybFZhcjtcbiAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ3JlcGxhY2Vkc3R5bGUnLCByZXBTdHlsZSk7XG4gICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXdyYXAnLCB1cmxWYXIpO1xuICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1saW5rJyk7XG4gIH0pO1xuXG4gICQoXCJbcmVwbGFjZWRzdHlsZV1cIiwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHByb2Nlc3NTdHlsZShlbGVtZW50LCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgYmluZGluZ1Byb3ZpZGVyLCBmYWxzZSk7XG4gIH0pO1xuXG4gICQoXCJbcmVwbGFjZWRodHRwLWVxdWl2XVwiLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgcmVwbGFjZWRBdHRyaWJ1dGVzKGVsZW1lbnQsIFwiaHR0cC1lcXVpdlwiKTtcbiAgfSk7XG5cbiAgJChcIltkYXRhLWtvLWRpc3BsYXldXCIsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB3cmFwRWxlbWVudFdpdGhDb25kaXRpb24oJ2RhdGEta28tZGlzcGxheScsIGVsZW1lbnQsIGJpbmRpbmdQcm92aWRlcik7XG4gIH0pO1xuXG4gICQoXCJbZGF0YS1rby1lZGl0YWJsZV1cIiwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHZhciBuZXdCaW5kaW5nLCBkZWZhdWx0VmFsdWUsIG1vZGVsLCBjdXJyZW50QmluZGluZ3MsIGRhdGFCaW5kO1xuXG5cbiAgICB2YXIgZGF0YUVkaXRhYmxlID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsIFwiZGF0YS1rby1lZGl0YWJsZVwiKTtcblxuICAgIC8vIFRPRE8gYWRkIHZhbGlkYXRpb24gb2YgdGhlIGVkaXRhYmxlXG5cbiAgICB2YXIgaXRlbUJpbmRWYWx1ZTtcbiAgICB2YXIgc2VsZWN0QmluZGluZztcbiAgICBpZiAoZGF0YUVkaXRhYmxlLmxhc3RJbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICB2YXIgc3VicyA9IGRhdGFFZGl0YWJsZS5zdWJzdHIoMCwgZGF0YUVkaXRhYmxlLmxhc3RJbmRleE9mKCcuJykpO1xuICAgICAgaXRlbUJpbmRWYWx1ZSA9IGJpbmRpbmdQcm92aWRlcihzdWJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbUJpbmRWYWx1ZSA9IGJpbmRpbmdQcm92aWRlcihkYXRhRWRpdGFibGUpO1xuICAgIH1cbiAgICBzZWxlY3RCaW5kaW5nID0gXCJ3eXNpd3lnQ2xpY2s6IGZ1bmN0aW9uKG9iaiwgZXZ0KSB7ICRyb290LnNlbGVjdEl0ZW0oXCIgKyBpdGVtQmluZFZhbHVlICsgXCIsICRkYXRhKTsgcmV0dXJuIGZhbHNlIH0sIGNsaWNrQnViYmxlOiBmYWxzZSwgd3lzaXd5Z0NzczogeyBzZWxlY3RlZGl0ZW06ICRyb290LmlzU2VsZWN0ZWRJdGVtKFwiICsgaXRlbUJpbmRWYWx1ZSArIFwiKSB9LCBzY3JvbGxJbnRvVmlldzogJHJvb3QuaXNTZWxlY3RlZEl0ZW0oXCIgKyBpdGVtQmluZFZhbHVlICsgXCIpXCI7XG5cbiAgICBpZiAoZG9tdXRpbHMuZ2V0TG93ZXJUYWdOYW1lKGVsZW1lbnQpICE9ICdpbWcnKSB7XG5cblxuICAgICAgZGVmYXVsdFZhbHVlID0gZG9tdXRpbHMuZ2V0SW5uZXJIdG1sKGVsZW1lbnQpO1xuICAgICAgdmFyIG1vZGVsQmluZFZhbHVlID0gYmluZGluZ1Byb3ZpZGVyKGRhdGFFZGl0YWJsZSwgZGVmYXVsdFZhbHVlLCB0cnVlLCAnd3lzaXd5ZycpO1xuICAgICAgbmV3QmluZGluZyA9IFwiXCI7XG5cbiAgICAgIGlmICghZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsIFwiaWRcIikpIHtcbiAgICAgICAgbmV3QmluZGluZyArPSBcInd5c2l3eWdJZDogaWQoKSsnX1wiICsgZGF0YUVkaXRhYmxlLnJlcGxhY2UoJy4nLCAnXycpICsgXCInLCBcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RCaW5kaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBuZXdCaW5kaW5nICs9IHNlbGVjdEJpbmRpbmcgKyBcIiwgXCI7XG4gICAgICB9XG5cbiAgICAgIG5ld0JpbmRpbmcgKz0gXCJ3eXNpd3lnT3JIdG1sOiBcIiArIG1vZGVsQmluZFZhbHVlO1xuXG4gICAgICBpZiAoZG9tdXRpbHMuZ2V0TG93ZXJUYWdOYW1lKGVsZW1lbnQpID09ICd0ZCcpIHtcbiAgICAgICAgdmFyIHdyYXBwaW5nRGl2ID0gJCgnPGRpdiBkYXRhLWtvLXdyYXA9XCJmYWxzZVwiIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJVwiPjwvZGl2PicpWzBdO1xuICAgICAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUod3JhcHBpbmdEaXYsICdkYXRhLWJpbmQnLCBuZXdCaW5kaW5nKTtcbiAgICAgICAgdmFyIG5ld0NvbnRlbnQgPSBkb211dGlscy5nZXRJbm5lckh0bWwoJCgnPGRpdj48L2Rpdj4nKS5hcHBlbmQod3JhcHBpbmdEaXYpKTtcbiAgICAgICAgZG9tdXRpbHMuc2V0Q29udGVudChlbGVtZW50LCBuZXdDb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRCaW5kaW5ncyA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJyk7XG4gICAgICAgIGRhdGFCaW5kID0gKGN1cnJlbnRCaW5kaW5ncyAhPT0gbnVsbCA/IGN1cnJlbnRCaW5kaW5ncyArIFwiLCBcIiA6IFwiXCIpICsgbmV3QmluZGluZztcbiAgICAgICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnLCBkYXRhQmluZCk7XG4gICAgICAgIGRvbXV0aWxzLnNldENvbnRlbnQoZWxlbWVudCwgJycpO1xuICAgICAgfVxuICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWVkaXRhYmxlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3aWR0aCA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnd2lkdGgnKTtcbiAgICAgIGlmICh3aWR0aCA9PT0gJycpIHdpZHRoID0gbnVsbDtcbiAgICAgIGlmICh3aWR0aCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6IGRhdGEta28tZWRpdGFibGUgaW1hZ2VzIG11c3QgZGVjbGFyZSBhIFdJRFRIIGF0dHJpYnV0ZSFcIiwgZWxlbWVudCk7XG4gICAgICAgIHRocm93IFwiRVJST1I6IGRhdGEta28tZWRpdGFibGUgaW1hZ2VzIG11c3QgZGVjbGFyZSBhIFdJRFRIIGF0dHJpYnV0ZSFcIjtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHQgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2hlaWdodCcpO1xuICAgICAgaWYgKGhlaWdodCA9PT0gJycpIGhlaWdodCA9IG51bGw7XG5cbiAgICAgIHZhciBhbGlnbiA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnYWxpZ24nKTtcblxuICAgICAgY3VycmVudEJpbmRpbmdzID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnKTtcblxuICAgICAgLy8gVE9ETyB0aGlzIGlzIHVnbHkuLi4gbWF5YmUgYSBiZXR0ZXIgc3RyYXRlZ3kgaXMgdG8gcGFzcyB0aGlzIGFyb3VuZCB1c2luZyBcImRhdGEtXCIgYXR0cmlidXRlc1xuICAgICAgdmFyIGR5bkhlaWdodCA9IGN1cnJlbnRCaW5kaW5ncyAmJiBjdXJyZW50QmluZGluZ3MubWF0Y2goL3ZpcnR1YWxBdHRyOiB7W159XSogaGVpZ2h0OiAoW14sfV0qKVssfV0vKTtcbiAgICAgIGlmIChkeW5IZWlnaHQpIGhlaWdodCA9IGR5bkhlaWdodFsxXTtcbiAgICAgIHZhciBkeW5XaWR0aCA9IGN1cnJlbnRCaW5kaW5ncyAmJiBjdXJyZW50QmluZGluZ3MubWF0Y2goL3ZpcnR1YWxBdHRyOiB7W159XSogd2lkdGg6IChbXix9XSopWyx9XS8pO1xuICAgICAgaWYgKGR5bldpZHRoKSB3aWR0aCA9IGR5bldpZHRoWzFdO1xuXG4gICAgICB2YXIgbWV0aG9kO1xuXG4gICAgICBkZWZhdWx0VmFsdWUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcGxhY2Vob2xkZXItc3JjJyk7XG4gICAgICAvLyBUT0RPIG1ha2Ugc3VyZSB0aGlzIGRlZmF1bHQgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIG9uZSBjaGVja2VkIGJ5IGltZy13eXNpd3lnIHRlbXBsYXRlLlxuICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdzcmMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnc3JjJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplO1xuICAgICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICBzaXplID0gd2lkdGggKyBcIisneCcrXCIgKyBoZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgc2l6ZSA9IFwiJ3cnK1wiICsgd2lkdGggKyBcIisnJ1wiO1xuICAgICAgfSBlbHNlIGlmICghd2lkdGgpIHtcbiAgICAgICAgc2l6ZSA9IFwiJ2gnK1wiICsgaGVpZ2h0ICsgXCIrJydcIjtcbiAgICAgIH1cbiAgICAgIHZhciBwbGFjZWhvbGRlcnNyYztcbiAgICAgIHZhciBwbGhlaWdodCA9IGhlaWdodCB8fCBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcGxhY2Vob2xkZXItaGVpZ2h0Jyk7XG4gICAgICB2YXIgcGx3aWR0aCA9IHdpZHRoIHx8IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wbGFjZWhvbGRlci13aWR0aCcpO1xuXG4gICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ3NyYycpO1xuICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWVkaXRhYmxlJyk7XG4gICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcGxhY2Vob2xkZXItaGVpZ2h0Jyk7XG4gICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcGxhY2Vob2xkZXItd2lkdGgnKTtcbiAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wbGFjZWhvbGRlci1zcmMnKTtcblxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBwbGFjZWhvbGRlcnNyYyA9IFwieyB3aWR0aDogXCIgKyBwbHdpZHRoICsgXCIsIGhlaWdodDogXCIgKyBwbGhlaWdodCArIFwiLCB0ZXh0OiBcIiArIHNpemUgKyBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwbHdpZHRoIHx8ICFwbGhlaWdodCkge1xuICAgICAgICAvLyBUT0RPIHJhaXNlIGFuIGV4Y2VwdGlvbj9cbiAgICAgICAgY29uc29sZS5lcnJvcihcIklNRyBkYXRhLWtvLWVkaXRhYmxlIG11c3QgZGVjbGFyZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMsIG9yIHRoZWlyIHBsYWNlaG9sZGVyIGNvdW50ZXJwYXJ0cyBkYXRhLWtvLXBsYWNlaG9sZGVyLXdpZHRoL2RhdGEta28tcGxhY2Vob2xkZXItaGVpZ2h0XCIsIGVsZW1lbnQpO1xuICAgICAgICB0aHJvdyBcIkVSUk9SOiBJTUcgZGF0YS1rby1lZGl0YWJsZSBNVVNUIGRlY2xhcmUgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzLCBvciB0aGVpciBwbGFjZWhvbGRlciBjb3VudGVycGFydHMgZGF0YS1rby1wbGFjZWhvbGRlci13aWR0aC9kYXRhLWtvLXBsYWNlaG9sZGVyLWhlaWdodFwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmluZGluZ1ZhbHVlID0gYmluZGluZ1Byb3ZpZGVyKGRhdGFFZGl0YWJsZSwgdmFsdWUsIGZhbHNlLCAnd3lzaXd5ZycpO1xuICAgICAgbmV3QmluZGluZyA9IFwid3lzaXd5Z1NyYzogeyB3aWR0aDogXCIgKyB3aWR0aCArIFwiLCBoZWlnaHQ6IFwiICsgaGVpZ2h0ICsgXCIsIHNyYzogXCIgKyBiaW5kaW5nVmFsdWUgKyBcIiwgcGxhY2Vob2xkZXI6IFwiICsgcGxhY2Vob2xkZXJzcmMgKyBcIiB9XCI7XG4gICAgICBkYXRhQmluZCA9IChjdXJyZW50QmluZGluZ3MgIT09IG51bGwgPyBjdXJyZW50QmluZGluZ3MgKyBcIiwgXCIgOiBcIlwiKSArIG5ld0JpbmRpbmc7XG4gICAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcsIGRhdGFCaW5kKTtcblxuICAgICAgdmFyIHRtcGxOYW1lID0gdGVtcGxhdGVDcmVhdG9yKGVsZW1lbnQpO1xuXG4gICAgICB2YXIgY29udGFpbmVyQmluZCA9ICd7IHdpZHRoOiAnICsgd2lkdGg7XG4gICAgICBpZiAoYWxpZ24gPT0gJ2xlZnQnKSBjb250YWluZXJCaW5kICs9ICcsIGZsb2F0OiBcXCdsZWZ0XFwnJztcbiAgICAgIGVsc2UgaWYgKGFsaWduID09ICdyaWdodCcpIGNvbnRhaW5lckJpbmQgKz0gJywgZmxvYXQ6IFxcJ3JpZ2h0XFwnJztcbiAgICAgIGVsc2UgaWYgKGFsaWduID09ICdjZW50ZXInKSBjb25zb2xlLmxvZygnbm9uIHNvIGNvc2EgZmEgYWxpZ249Y2VudGVyIHN1IHVuYSBpbWcgZSBxdWluZGkgbm9uIHNvIGNvbWUgc2ltdWxhcm5lIGxcXCdlZGl0aW5nJyk7XG4gICAgICBlbHNlIGlmIChhbGlnbiA9PSAndG9wJykgY29udGFpbmVyQmluZCArPSAnLCB2ZXJ0aWNhbEFsaWduOiBcXCd0b3BcXCcnO1xuICAgICAgZWxzZSBpZiAoYWxpZ24gPT0gJ21pZGRsZScpIGNvbnRhaW5lckJpbmQgKz0gJywgdmVydGljYWxBbGlnbjogXFwnbWlkZGxlXFwnJztcbiAgICAgIGVsc2UgaWYgKGFsaWduID09ICdib3R0b20nKSBjb250YWluZXJCaW5kICs9ICcsIHZlcnRpY2FsQWxpZ246IFxcJ2JvdHRvbVxcJyc7XG4gICAgICBjb250YWluZXJCaW5kICs9ICd9JztcblxuICAgICAgJChlbGVtZW50KS5iZWZvcmUoJzwhLS0ga28gd3lzaXd5Z0ltZzogeyBfZGF0YTogJGRhdGEsIF9pdGVtOiAnICsgaXRlbUJpbmRWYWx1ZSArICcsIF90ZW1wbGF0ZTogXFwnJyArIHRtcGxOYW1lICsgJ1xcJywgX2VkaXRUZW1wbGF0ZTogXFwnaW1nLXd5c2l3eWdcXCcsIF9zcmM6ICcgKyBiaW5kaW5nVmFsdWUgKyAnLCBfd2lkdGg6ICcgKyB3aWR0aCArICcsIF9oZWlnaHQ6ICcgKyBoZWlnaHQgKyAnLCBfYWxpZ246ICcgKyAoYWxpZ24gPT09IG51bGwgPyB1bmRlZmluZWQgOiAnXFwnJyArIGFsaWduICsgJ1xcJycpICsgJywgX3NpemU6ICcgKyBzaXplICsgJywgX21ldGhvZDogJyArIG1ldGhvZCArICcsIF9wbGFjZWhvbGRlcnNyYzogJyArIHBsYWNlaG9sZGVyc3JjICsgJywgX3N0eWxlYmluZDogJyArIGNvbnRhaW5lckJpbmQgKyAnIH0gLS0+Jyk7XG4gICAgICAkKGVsZW1lbnQpLmFmdGVyKCc8IS0tIC9rbyAtLT4nKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQXBwbGllZCBhZnRlciB0aGUgZGF0YS1lZGl0YWJsZSBzbyB0byBhdm9pZCBwcm9jZXNzaW5nIGhyZWZzIGZvciBlZGl0YWJsZSBjb250ZW50XG4gICQoXCJbaHJlZl1cIiwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHZhciBhdHRyVmFsdWUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2hyZWYnKTtcbiAgICB2YXIgbmV3QmluZGluZyA9ICd3eXNpd3lnSHJlZjogXFwnJyArIGNvbnZlcnRlclV0aWxzLmFkZFNsYXNoZXMoYXR0clZhbHVlKSArICdcXCcnO1xuICAgIHZhciBjdXJyZW50QmluZGluZ3MgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcpO1xuICAgIHZhciBkYXRhQmluZCA9IChjdXJyZW50QmluZGluZ3MgIT09IG51bGwgPyBjdXJyZW50QmluZGluZ3MgKyBcIiwgXCIgOiBcIlwiKSArIG5ld0JpbmRpbmc7XG4gICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnLCBkYXRhQmluZCk7XG4gIH0pO1xuXG4gICQoXCJyZXBsYWNlZGJsb2NrXCIsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB2YXIgYmxvY2tFbGVtZW50ID0gZml4ZWRCbG9ja3NbaW5kZXhdO1xuXG4gICAgdmFyIGJsb2NrTmFtZSA9IHByb2Nlc3NCbG9jayhibG9ja0VsZW1lbnQsIGRlZnMsIHRoZW1lVXBkYXRlciwgYmxvY2tQdXNoZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCAnYmxvY2snLCB0ZW1wbGF0ZU5hbWUsIGNvbnRhaW5lck5hbWUsIHRydWUsIHRlbXBsYXRlQ3JlYXRvcik7XG4gICAgLy8gcmVwbGFjZWQgYmxvY2tzIGFyZSBkZWZpbmVkIGluIHRoZSBtb2RlbCByb290XG4gICAgdmFyIG1vZGVsQmluZFZhbHVlID0gbW9kZWxEZWYuZW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZShkZWZzLCB0aGVtZVVwZGF0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgJycsIGJsb2NrTmFtZSk7XG5cbiAgICAvLyB0aGlzIHdheSB3ZSBjYWxsIGJsb2NrLXd5c2l3eWcgb3IgYmxvY2stc2hvdyBhbmQgbm90IGRpcmVjdGx5IHRoZSByaWdodCBibG9ja1xuICAgICQoZWxlbWVudCkuYmVmb3JlKCc8IS0tIGtvIGJsb2NrOiB7IGRhdGE6ICcgKyBjb252ZXJ0ZXJVdGlscy5hZGRTbGFzaGVzKG1vZGVsQmluZFZhbHVlKSArICcsIHRlbXBsYXRlOiBcXCdibG9ja1xcJyB9IC0tPicpO1xuICAgICQoZWxlbWVudCkuYWZ0ZXIoJzwhLS0gL2tvIC0tPicpO1xuICAgICQoZWxlbWVudCkucmVtb3ZlKCk7XG4gIH0pO1xuXG4gIC8vIFRPRE8gZG8gd2UgcmVhbGx5IG5lZWQgdG8gbG9vcCBpbiByZXZlcnNlIG9yZGVyP1xuICAvLyBkYXRhLWtvLXdyYXAgaGF2ZSB0byBiZSBwcm9jZXNzZWQgYXQgdGhlIGVuZCwgZXhwZWNpYWxseSBhZnRlciBcInJlcGxhY2VibG9ja3NcIlxuICAvLyBvdGhlcndpc2UgYSBkYXRhLWtvLXdyYXAgd3JhcHBpbmcgYSBkYXRhLWtvLWJsb2NrIHdvdWxkIGJyZWFrIGV2ZXJ5dGhpbmcuXG4gICQoJChcIltkYXRhLWtvLXdyYXBdXCIsIGVsZW1lbnQpLmdldCgpLnJldmVyc2UoKSwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHZhciBjb25kID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXdyYXAnKTtcbiAgICBpZiAodHlwZW9mIGNvbmQgPT09ICd1bmRlZmluZWQnIHx8IGNvbmQgPT09ICcnIHx8IGNvbmQgPT09ICd0cnVlJykge1xuICAgICAgdGhyb3cgXCJVbnN1cHBvcnRlZCBlbXB0eSB2YWx1ZSBmb3IgZGF0YS1rby13cmFwOiB1c2UgZmFsc2UgdmFsdWUgaWYgeW91IHdhbnQgdG8gYWx3YXlzIHJlbW92ZSB0aGUgdGFnXCI7XG4gICAgfVxuXG4gICAgdmFyIGNvbmRCaW5kaW5nID0gY29udmVydGVyVXRpbHMuY29uZGl0aW9uQmluZGluZyhjb25kLCBiaW5kaW5nUHJvdmlkZXIpO1xuXG4gICAgLypcbiAgICAgICAgICB2YXIgY29uZEJpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbmQgPT09ICd1bmRlZmluZWQnIHx8IGNvbmQgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlVuc3VwcG9ydGVkIGVtcHR5IHZhbHVlIGZvciBkYXRhLWtvLXdyYXA6IHVzZSBmYWxzZSB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhbHdheXMgcmVtb3ZlIHRoZSB0YWdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbmQgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIGNvbmRCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25kID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHRocm93IFwiVW5zdXBwb3J0ZWQgdHJ1ZSB2YWx1ZSBmb3IgZGF0YS1rby13cmFwLiBUaGlzIG1ha2VzIG5vIHNlbnNlOiB1c2UgZmFsc2Ugb3IgYSB2YXJpYWJsZVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25kQmluZGluZyA9IGJpbmRpbmdQcm92aWRlcihjb25kKSsnKCknO1xuICAgICAgICAgIH1cbiAgICAqL1xuXG4gICAgdmFyIGRhdGFCaW5kID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnKTtcblxuICAgIHZhciBpbm5lclRtcGxOYW1lLCBvdXRlclRtcGxOYW1lO1xuICAgIC8vIFRPRE8gdWdseSBoYXJkY29kZWQgaGFuZGxpbmc6IGF0IHRoZSB2ZXJ5IGxlYXN0IHRoaXMgc2hvdWxkIGJlIGludm9rZWQgYnkgdGhlIGRhdGEtY29udGFpbmVyIGNhbGxlci5cbiAgICBpZiAoZGF0YUJpbmQgIT09ICcnICYmIGRhdGFCaW5kICE9PSBudWxsICYmIGRhdGFCaW5kLm1hdGNoKC8oYmxvY2t8d3lzaXd5Z09ySHRtbCk6LykpIHtcbiAgICAgIC8vIHdlIGNhbid0IHB1dCB0aGUgY29udGVudCBpbiBhIHRlbXBsYXRlIGJlY2F1c2UgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgYmluZGluZ1xuICAgICAgdmFyIGlubmVyVG1wbENvbnRlbnQgPSAnPCEtLSBrbyAnICsgZGF0YUJpbmQgKyAnIC0tPicgKyBkb211dGlscy5nZXRJbm5lckh0bWwoZWxlbWVudCkgKyAnPCEtLSAva28gLS0+JztcbiAgICAgIGlubmVyVG1wbE5hbWUgPSB0ZW1wbGF0ZUNyZWF0b3IoaW5uZXJUbXBsQ29udGVudCk7XG4gICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28td3JhcCcpO1xuICAgICAgb3V0ZXJUbXBsTmFtZSA9IHRlbXBsYXRlQ3JlYXRvcihlbGVtZW50KTtcbiAgICAgIGRvbXV0aWxzLnJlcGxhY2VIdG1sKGVsZW1lbnQsICc8IS0tIGtvIHRlbXBsYXRlOiAvKiBzcGVjaWFsICovICh0eXBlb2YgdGVtcGxhdGVNb2RlICE9IFxcJ3VuZGVmaW5lZFxcJyAmJiB0ZW1wbGF0ZU1vZGUgPT0gXFwnd3lzaXd5Z1xcJykgfHwgJyArIGNvbmRCaW5kaW5nICsgJyA/IFxcJycgKyBvdXRlclRtcGxOYW1lICsgJ1xcJyA6IFxcJycgKyBpbm5lclRtcGxOYW1lICsgJ1xcJyAtLT48IS0tIC9rbyAtLT4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgcHV0IHRoZSBjb250ZW50IGluIGEgdGVtcGxhdGUgYW5kIHRoZSBmcmFtZSBpbiBhbm90aGVyIHRlbXBsYXRlIGluY2x1ZGluZyB0aGlzIG9uZS5cbiAgICAgIGlubmVyVG1wbE5hbWUgPSB0ZW1wbGF0ZUNyZWF0b3IoZG9tdXRpbHMuZ2V0SW5uZXJIdG1sKGVsZW1lbnQpKTtcbiAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby13cmFwJyk7XG4gICAgICBkb211dGlscy5zZXRDb250ZW50KGVsZW1lbnQsICc8IS0tIGtvIHRlbXBsYXRlOiBcXCcnICsgaW5uZXJUbXBsTmFtZSArICdcXCcgLS0+PCEtLSAva28gLS0+Jyk7XG4gICAgICBvdXRlclRtcGxOYW1lID0gdGVtcGxhdGVDcmVhdG9yKGVsZW1lbnQpO1xuICAgICAgZG9tdXRpbHMucmVwbGFjZUh0bWwoZWxlbWVudCwgJzwhLS0ga28gdGVtcGxhdGU6ICh0eXBlb2YgdGVtcGxhdGVNb2RlICE9IFxcJ3VuZGVmaW5lZFxcJyAmJiB0ZW1wbGF0ZU1vZGUgPT0gXFwnd3lzaXd5Z1xcJykgfHwgJyArIGNvbmRCaW5kaW5nICsgJyA/IFxcJycgKyBvdXRlclRtcGxOYW1lICsgJ1xcJyA6IFxcJycgKyBpbm5lclRtcGxOYW1lICsgJ1xcJyAtLT48IS0tIC9rbyAtLT4nKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdGVtcGxhdGVDcmVhdG9yKGVsZW1lbnQsIHRlbXBsYXRlTmFtZSwgJ3Nob3cnKTtcblxuICBibG9ja1B1c2hlcihyb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsIGNvbnRleHROYW1lLCBjb250YWluZXJOYW1lKTtcblxuICByZXR1cm4gdGVtcGxhdGVOYW1lO1xuXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXhjZXB0aW9uIHdoaWxlIHBhcnNpbmcgdGhlIHRlbXBsYXRlXCIsIGUsIGVsZW1lbnQpO1xuICAgIHRocm93IGU7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gY29uZGl0aW9uYWxfcmVwbGFjZShodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLzwhLS1cXFtpZiAoW15cXF1dKilcXF0+KCg/Oig/IS0tKVtcXHNcXFNdKSo/KTwhXFxbZW5kaWZcXF0tLT4vZywgZnVuY3Rpb24obWF0Y2gsIGNvbmRpdGlvbiwgYm9keSkge1xuICAgIHZhciBkZCA9ICc8IS0tIGNjOnN0YXJ0IC0tPic7XG4gICAgZGQgKz0gYm9keS5yZXBsYWNlKC88KFtBLVphLXo6XSspL2csICc8IS0tIGNjOmJvOiQxIC0tPjxjYycpIC8vIGJlZm9yZSBvcGVuIHRhZ1xuICAgICAgICAgICAucmVwbGFjZSgvPFxcLyhbQS1aYS16Ol0rKT4vZywnPCEtLSBjYzpiYzokMSAtLT48L2NjPjwhLS0gY2M6YWM6JDEgLS0+JykgLy8gYmVmb3JlL2FmdGVyIGNsb3NlIHRhZ1xuICAgICAgICAgICAucmVwbGFjZSgvXFwvPi9nLCcvPjwhLS0gY2M6c2MgLS0+Jyk7IC8vIHNlbGYtY2xvc2UgdGFnXG4gICAgZGQgKz0gJzwhLS0gY2M6ZW5kIC0tPic7XG4gICAgdmFyIG91dHB1dCA9ICc8cmVwbGFjZWRjYyBjb25kaXRpb249XCInK2NvbmRpdGlvbisnXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+JztcbiAgICBvdXRwdXQgKz0gJCgnPGRpdj4nKS5hcHBlbmQoJChkZCkpLmh0bWwoKVxuICAgICAgLnJlcGxhY2UoL148IS0tIGNjOnN0YXJ0IC0tPi8sICcnKVxuICAgICAgLnJlcGxhY2UoLzwhLS0gY2M6ZW5kIC0tPiQvLCAnJyk7XG4gICAgb3V0cHV0ICs9ICc8L3JlcGxhY2VkY2M+JztcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcbn1cblxuXG52YXIgdHJhbnNsYXRlVGVtcGxhdGUgPSBmdW5jdGlvbih0ZW1wbGF0ZU5hbWUsIGh0bWwsIHRlbXBsYXRlVXJsQ29udmVydGVyLCB0ZW1wbGF0ZUNyZWF0b3IpIHtcbiAgdmFyIGRlZnMgPSB7fTtcbiAgdmFyIHJlcGxhY2VkSHRtbCA9IGNvbmRpdGlvbmFsX3JlcGxhY2UoaHRtbC5yZXBsYWNlKC8oPFtePl0rXFxzKShzdHlsZXxodHRwLWVxdWl2KSg9XCJbXlwiXSpcIltePl0qPikvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIHAxICsgJ3JlcGxhY2VkJyArIHAyICsgcDM7XG4gIH0pKTtcbiAgdmFyIGNvbnRlbnQgPSAkKHJlcGxhY2VkSHRtbCk7XG4gIHZhciBlbGVtZW50ID0gY29udGVudFswXTtcblxuICB2YXIgYmxvY2tzID0gW107IC8vIHtyb290TmFtZSwgYmxvY2tOYW1lLCBjb250YWluZXJOYW1lfVxuICB2YXIgX2Jsb2NrUHVzaGVyID0gZnVuY3Rpb24ocm9vdE5hbWUsIGJsb2NrTmFtZSwgY29udGV4dE5hbWUsIGNvbnRhaW5lck5hbWUpIHtcbiAgICBibG9ja3MucHVzaCh7XG4gICAgICByb290OiByb290TmFtZSxcbiAgICAgIGJsb2NrOiBibG9ja05hbWUsXG4gICAgICBjb250ZXh0OiBjb250ZXh0TmFtZSxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyTmFtZVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE8gaGF2ZSB0byBhY2NlcHQgbnVsbHMgYXMgdW5kZWZpbmVkcyAoYmVjYXVzZSBvZiBtb2RlbC5qcyBiZWhhdmlvdXIpXG4gIHZhciB0aGVtZVVwZGF0ZXIgPSBmdW5jdGlvbihuYW1lLCBrZXksIHZhbCkge1xuICAgIGlmICh0eXBlb2YgZGVmc1sndGhlbWVzJ10gPT09ICd1bmRlZmluZWQnKSBkZWZzWyd0aGVtZXMnXSA9IHt9O1xuICAgIGlmICh0eXBlb2YgZGVmc1sndGhlbWVzJ11bbmFtZV0gPT09ICd1bmRlZmluZWQnKSBkZWZzWyd0aGVtZXMnXVtuYW1lXSA9IHt9O1xuICAgIGlmICh0eXBlb2YgZGVmc1sndGhlbWVzJ11bbmFtZV1ba2V5XSA9PT0gJ3VuZGVmaW5lZCcgfHwgZGVmc1sndGhlbWVzJ11bbmFtZV1ba2V5XSA9PT0gbnVsbCkgZGVmc1sndGhlbWVzJ11bbmFtZV1ba2V5XSA9IHZhbDtcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmVjVmFsID0gZGVmc1sndGhlbWVzJ11bbmFtZV1ba2V5XTtcbiAgICAgIGlmIChwcmVjVmFsICE9IHZhbCkgY29uc29sZS5sb2coXCJFcnJvciBzZXR0aW5nIGEgbmV3IGRlZmF1bHQgZm9yIHByb3BlcnR5IFwiICsga2V5ICsgXCIgaW4gdGhlbWUgXCIgKyBuYW1lICsgXCIuIG9sZDpcIiArIHByZWNWYWwgKyBcIiBuZXc6XCIgKyB2YWwgKyBcIiFcIik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjb250YWluZXJzID0gJChcIltkYXRhLWtvLWNvbnRhaW5lcl1cIiwgY29udGVudCk7XG4gIHZhciBjb250YWluZXJzRG9tID0ge307XG4gIGNvbnRhaW5lcnMuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHZhciBjb250YWluZXJOYW1lID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWNvbnRhaW5lcicpICsgXCJCbG9ja3NcIjtcblxuICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1jb250YWluZXInKTtcbiAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcsICdibG9jazogJyArIGNvbnRhaW5lck5hbWUpO1xuXG4gICAgdmFyIGNvbnRhaW5lckJsb2NrcyA9ICQoXCI+IFtkYXRhLWtvLWJsb2NrXVwiLCBlbGVtZW50KTtcbiAgICBkb211dGlscy5yZW1vdmVFbGVtZW50cyhjb250YWluZXJCbG9ja3MsIHRydWUpO1xuXG4gICAgY29udGFpbmVyc0RvbVtjb250YWluZXJOYW1lXSA9IGNvbnRhaW5lckJsb2NrcztcbiAgfSk7XG5cbiAgLy8gVE9ETyByZW1vdmUgaGFyZGNvZGVkIHByb3BlcnRpZXM6IHdlIG5lZWQgdGhlbSBiZWNhdXNlIHdpdGhvdXQgdGhlc2UgbG9hZGluZyBhIGJhc2ljIHRlbXBsYXRlIGZhaWxzLlxuICAvLyBOZWVkZWQgaW4gb3JkZXIgdG8gdXNlIGRhdGEta28tYmxvY2tcbiAgbW9kZWxEZWYuY3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCAnaWQnKTtcbiAgLy8gTmVlZGVkIGFsd2F5cyBhcyBpdCBpcyB0aGUgZGVmYXVsdCB0aGVtZSBzZWN0aW9uLlxuICBtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsICdib2R5VGhlbWUnKTtcbiAgLy8gTmVlZGVkIGZvciBkYXRhLWtvLWNvbnRhaW5lclxuICBtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsICdibG9ja3MnLCAnYmxvY2tzW10nKTtcblxuICAvLyBOZWVkZWQgaWYgeW91IHdhbnQgdG8gdXNlIGEgdGV4dCB2YXJpYWJsZT8gVE9ETyB0aGlzIHNob3VsZCBub3QgYmUgbmVlZGVkIVxuICBtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsICd0ZXh0Jyk7XG5cbiAgcHJvY2Vzc0Jsb2NrKGVsZW1lbnQsIGRlZnMsIHRoZW1lVXBkYXRlciwgX2Jsb2NrUHVzaGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgJ3RlbXBsYXRlJywgdGVtcGxhdGVOYW1lLCB1bmRlZmluZWQsIGZhbHNlLCB0ZW1wbGF0ZUNyZWF0b3IpO1xuXG4gIHZhciBibG9ja1Byb2Nlc3MgPSBmdW5jdGlvbihjb250YWluZXJOYW1lLCBpbmRleCwgZWxlbWVudCkge1xuICAgIHByb2Nlc3NCbG9jayhlbGVtZW50LCBkZWZzLCB0aGVtZVVwZGF0ZXIsIF9ibG9ja1B1c2hlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsICdibG9jaycsIHRlbXBsYXRlTmFtZSwgY29udGFpbmVyTmFtZSwgdHJ1ZSwgdGVtcGxhdGVDcmVhdG9yKTtcbiAgfTtcblxuICBmb3IgKHZhciBwcm9wIGluIGNvbnRhaW5lcnNEb20pXG4gICAgaWYgKGNvbnRhaW5lcnNEb20uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHZhciBjb250YWluZXJCbG9ja3MgPSBjb250YWluZXJzRG9tW3Byb3BdO1xuICAgICAgdmFyIGNvbnRhaW5lck5hbWUgPSBwcm9wO1xuXG4gICAgICBtb2RlbERlZi5lbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlKGRlZnMsIHRoZW1lVXBkYXRlciwgdGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZU5hbWUsICcnLCBjb250YWluZXJOYW1lICsgXCIuYmxvY2tzXCIsIFwiW11cIik7XG5cbiAgICAgIGNvbnRhaW5lckJsb2Nrcy5lYWNoKGJsb2NrUHJvY2Vzcy5iaW5kKHVuZGVmaW5lZCwgY29udGFpbmVyTmFtZSkpO1xuICAgIH1cblxuICB2YXIgdGVtcGxhdGVEZWYgPSB7XG4gICAgX2RlZnM6IGRlZnMsXG4gICAgdGVtcGxhdGVOYW1lOiB0ZW1wbGF0ZU5hbWUsXG4gICAgX2Jsb2NrczogYmxvY2tzXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZWZzW3RlbXBsYXRlTmFtZV0uX3ZlcnNpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGVtcGxhdGVEZWYudmVyc2lvbiA9IGRlZnNbdGVtcGxhdGVOYW1lXS5fdmVyc2lvbjtcbiAgfVxuXG4gIHJldHVybiB0ZW1wbGF0ZURlZjtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc2xhdGVUZW1wbGF0ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gUGFyc2VzIENTUy9zdHlsZXNoZWV0cyBkZWNsYXJhdGlvbnMgLWtvLWJsb2NrZGVmcy8ta28tdGhlbWVzXG4vLyBJdCByZXR1cm5zIEtPIGJpbmRpbmdzIGJ1dCBkb2Vzbid0IGRlcGVuZCBvbiBLT1xuLy8gTmVlZHMgYSBiaW5kaW5nUHJvdmlkZXJcbi8vIEFsc28gdXNlcyBhIGJsb2NrRGVmc1VwZGF0ZXIgdG8gdXBkYXRlIGRlZmluaXRpb25zIHdoaWxlIHBhcnNpbmcgdGhlIHN0eWxlc2hlZXQuXG5cbnZhciBjc3NQYXJzZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9wYXJzZXIuanNcIik7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xudmFyIGNvbnZlcnRlclV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG52YXIgZWxhYm9yYXRlRGVjbGFyYXRpb25zID0gcmVxdWlyZShcIi4vZGVjbGFyYXRpb25zLmpzXCIpO1xuXG4vKiBUZW1wb3JhcnkgZXhwZXJpbWVudGFsIGNvZGUgbm90IHVzZWRcbnZhciBfcHJvY2Vzc1N0eWxlU2hlZXRSdWxlc19wcm9jZXNzVGhlbWVzID0gZnVuY3Rpb24gKGJpbmRpbmdQcm92aWRlciwgdGhlbWVVcGRhdGVyLCBydWxlcykge1xuICB2YXIgc2VscywgZGVjbHMsIGksIGosIGs7XG4gIGZvciggaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChydWxlc1tpXS50eXBlID09ICdydWxlJykge1xuICAgICAgc2VscyA9IHJ1bGVzW2ldLnNlbGVjdG9ycztcbiAgICAgIGRlY2xzID0gcnVsZXNbaV0uZGVjbGFyYXRpb25zO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHNlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGRlY2xzLmxlbmd0aDsgaysrKSBpZiAoZGVjbHNba10udHlwZSA9PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBiaW5kVmFsID0gYmluZGluZ1Byb3ZpZGVyKCckJytkZWNsc1trXS5uYW1lKTtcbiAgICAgICAgICAgIHRoZW1lVXBkYXRlcihzZWxzW2pdLCBkZWNsc1trXS5uYW1lLCBkZWNsc1trXS52YWx1ZSwgYmluZFZhbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFeGNlcHRpb24gc2V0dGluZyB0aGVtZSBmb3JcIiwgZGVjbHNba10ubmFtZSwgZGVjbHNba10udmFsdWUsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiovXG5cbnZhciBfcHJvY2Vzc1N0eWxlU2hlZXRSdWxlc19wcm9jZXNzQmxvY2tEZWYgPSBmdW5jdGlvbihibG9ja0RlZnNVcGRhdGVyLCBydWxlcykge1xuICB2YXIgcHJvcGVydGllcywgbmFtZWRQcm9wcywgZGVjbHM7XG4gIC8vIG5hbWUsIGNvbnRleHROYW1lLCBnbG9iYWxTdHlsZSwgdGhlbWVPdmVycmlkZSwgZXh0ZW5kLCBtaW4sIG1heCwgd2lkZ2V0LCBvcHRpb25zLCBjYXRlZ29yeSwgdmFyaWFudCwgaGVscCwgYmxvY2tEZXNjcmlwdGlvbiwgdmVyc2lvbiwgXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocnVsZXNbaV0udHlwZSA9PSAncnVsZScpIHtcbiAgICAgIHZhciBzZWxzID0gcnVsZXNbaV0uc2VsZWN0b3JzO1xuICAgICAgdmFyIGhhc0RlY2xhcmF0aW9ucyA9IGZhbHNlO1xuICAgICAgdmFyIGhhc1ByZXZpZXdzID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHNlbHNbal0ubWF0Y2goLzpwcmV2aWV3JC8pKSB7XG4gICAgICAgICAgaGFzUHJldmlld3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc0RlY2xhcmF0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNQcmV2aWV3cyAmJiBoYXNEZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjYW5ub3QgbWl4IHNlbGVjdG9ycyB0eXBlICg6cHJldmlldyBhbmQgZGVjbGFyYXRpb25zKSBpbiBAc3VwcG9ydHMgLWtvLWJsb2NrZGVmcyBcIiwgc2Vscyk7XG4gICAgICAgIHRocm93IFwiQ2Fubm90IG1peCBzZWxlY3RvcnMgdHlwZSAoOnByZXZpZXcgYW5kIGRlY2xhcmF0aW9ucykgaW4gQHN1cHBvcnRzIC1rby1ibG9ja2RlZnNcIjtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzUHJldmlld3MgJiYgIWhhc0RlY2xhcmF0aW9ucykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNhbm5vdCBmaW5kIGtub3duIHNlbGVjdG9ycyBpbiBAc3VwcG9ydHMgLWtvLWJsb2NrZGVmcyBcIiwgc2Vscyk7XG4gICAgICAgIHRocm93IFwiQ2Fubm90IGZpbmQga25vd24gc2VsZWN0b3JzIGluIEBzdXBwb3J0cyAta28tYmxvY2tkZWZzXCI7XG4gICAgICB9XG4gICAgICBpZiAoaGFzRGVjbGFyYXRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSAnJztcbiAgICAgICAgbmFtZWRQcm9wcyA9IHt9O1xuXG4vKlxuICAgICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250ZXh0TmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZ2xvYmFsU3R5bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoZW1lT3ZlcnJpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGV4dGVuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbWF4ID0gdW5kZWZpbmVkO1xuICAgICAgICBtaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHdpZGdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgY2F0ZWdvcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhcmlhbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGhlbHAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJsb2NrRGVzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICovXG4gICAgICAgIGRlY2xzID0gcnVsZXNbaV0uZGVjbGFyYXRpb25zO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRlY2xzLmxlbmd0aDsgaysrKSBpZiAoZGVjbHNba10udHlwZSA9PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ2xhYmVsJykgbmFtZWRQcm9wcy5uYW1lID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnY29udGV4dCcpIG5hbWVkUHJvcHMuY29udGV4dE5hbWUgPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdwcm9wZXJ0aWVzJykgcHJvcGVydGllcyA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ3RoZW1lJykgbmFtZWRQcm9wcy5nbG9iYWxTdHlsZSA9ICdfdGhlbWVfLicgKyBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICd0aGVtZU92ZXJyaWRlJykgbmFtZWRQcm9wcy50aGVtZU92ZXJyaWRlID0gU3RyaW5nKGRlY2xzW2tdLnZhbHVlKS50b0xvd2VyQ2FzZSgpID09ICd0cnVlJztcbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdleHRlbmQnKSBleHRlbmQgPSBkZWNsc1trXS52YWx1ZTtcblxuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ21heCcpIG1heCA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ21pbicpIG1pbiA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ29wdGlvbnMnKSBvcHRpb25zID0gZGVjbHNba10udmFsdWU7XG5cbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICd3aWRnZXQnKSB3aWRnZXQgPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdjYXRlZ29yeScpIGNhdGVnb3J5ID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAndmFyaWFudCcpIHZhcmlhbnQgPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdoZWxwJykgaGVscCA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ2Jsb2NrRGVzY3JpcHRpb24nKSBibG9ja0Rlc2NyaXB0aW9uID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAndmVyc2lvbicpIHZlcnNpb24gPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVkUHJvcHNbZGVjbHNba10ubmFtZV0gPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICAgIC8vIFRPRE8gaW4gcGFzdCB3ZSBkZXRlY3RlZCB1bnN1cHBvcnRlZCBwcm9wZXJ0aWVzLCB3aGlsZSBub3cgd2Ugc2ltcGxlIHB1c2ggZXZlcnkgZGVjbGFyYXRpb24gaW4gYSBuYW1lZFByb3BlcnR5LlxuICAgICAgICAgICAgLy8gVGhpcyBtYWtlIGl0IGhhcmRlciB0byBzcG90IGVycm9ycyBpbiBkZWNsYXJhdGlvbnMuXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJVbmtub3duIHByb3BlcnR5IHByb2Nlc3NpbmcgQHN1cHBvcnRzIC1rby1ibG9ja2RlZnMgXCIsIGRlY2xzW2tdLCBzZWxzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzZWxzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgYmxvY2tEZWZzVXBkYXRlcihzZWxzW2xdLCBwcm9wZXJ0aWVzLCBuYW1lZFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc1ByZXZpZXdzKSB7XG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgc2Vscy5sZW5ndGg7IG0rKykge1xuICAgICAgICAgIHZhciBsb2NhbEJsb2NrTmFtZSA9IHNlbHNbbV0uc3Vic3RyKDAsIHNlbHNbbV0uaW5kZXhPZignOicpKTtcbiAgICAgICAgICB2YXIgcHJldmlld0JpbmRpbmdzID0gcnVsZXNbaV0uZGVjbGFyYXRpb25zO1xuICAgICAgICAgIGJsb2NrRGVmc1VwZGF0ZXIobG9jYWxCbG9ja05hbWUsIHVuZGVmaW5lZCwgeyBwcmV2aWV3QmluZGluZ3M6IHByZXZpZXdCaW5kaW5ncyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElnbm9yaW5nIGNvbW1lbnRzIG9yIG90aGVyIGNvbnRlbnRcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwcm9jZXNzU3R5bGVzaGVldFJ1bGVzID0gZnVuY3Rpb24oc3R5bGUsIHJ1bGVzLCBsb2NhbFdpdGhCaW5kaW5nUHJvdmlkZXIsIGJsb2NrRGVmc1VwZGF0ZXIsIHRoZW1lVXBkYXRlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSkge1xuICB2YXIgbmV3U3R5bGUgPSBzdHlsZTtcbiAgdmFyIGxhc3RTdGFydCA9IG51bGw7XG5cbiAgaWYgKHR5cGVvZiBydWxlcyA9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzdHlsZVNoZWV0ID0gY3NzUGFyc2Uoc3R5bGUsIHtcbiAgICAgIGNvbW1lbnRzOiB0cnVlLFxuICAgICAgcG9zaXRpb246IHRydWVcbiAgICB9KTtcbiAgICBpZiAoc3R5bGVTaGVldC50eXBlICE9ICdzdHlsZXNoZWV0JyB8fCB0eXBlb2Ygc3R5bGVTaGVldC5zdHlsZXNoZWV0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInVuYWJsZSB0byBwcm9jZXNzIHN0eWxlU2hlZXRcIiwgc3R5bGVTaGVldCk7XG4gICAgICB0aHJvdyBcIlVuYWJsZSB0byBwYXJzZSBzdHlsZXNoZWV0XCI7XG4gICAgfVxuICAgIHJ1bGVzID0gc3R5bGVTaGVldC5zdHlsZXNoZWV0LnJ1bGVzO1xuICB9XG5cbiAgLy8gV0FSTiBjdXJyZW5sdHkgdGhpcyBwYXJzZXMgcnVsZXMgaW4gcmV2ZXJzZSBvcmRlciBzbyB0aGF0IHN0cmluZyByZXBsYWNlbWVudHMgd29ya3MgdXNpbmcgaW5wdXQgXCJwb3NpdGlvbnNcIlxuICAvLyBvdGhlcndpc2UgaXQgc2hvdWxkIGNvbXB1dGUgbmV3IG9mZnNldHMgb24gZXZlcnkgcmVwbGFjZW1lbnQuXG4gIC8vIEJ1dCB0aGlzIGNyZWF0ZSBpc3N1ZXMgYmVjYXVzZSBvZiBkZWZpbml0aW9ucyBiZWluZyBwYXJzZWQgaW4gcmV2ZXJzZSBvcmRlciwgc28gdGhpcyBpcyBub3QgYSBnb29kIGlkZWEuXG4gIC8vIFNvbWV0aW1lcywgdG8gd29yayBhcm91bmQgdGhpcyBpc3N1ZXMsIHlvdSBuZWVkIHRvIGNyZWF0ZSAyIGRpZmZlcmVudCA8c3R5bGU+IGJsb2Nrcy5cbiAgdmFyIGJpbmRpbmdQcm92aWRlcjtcblxuICBmb3IgKHZhciBpID0gcnVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocnVsZXNbaV0udHlwZSA9PSAnc3VwcG9ydHMnICYmIHJ1bGVzW2ldLm5hbWUgPT0gJy1rby1ibG9ja2RlZnMnKSB7XG4gICAgICBfcHJvY2Vzc1N0eWxlU2hlZXRSdWxlc19wcm9jZXNzQmxvY2tEZWYoYmxvY2tEZWZzVXBkYXRlciwgcnVsZXNbaV0ucnVsZXMpO1xuICAgICAgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgcnVsZXNbaV0ucG9zaXRpb24uc3RhcnQsIGxhc3RTdGFydCwgMCwgMCwgMCwgJycpO1xuICAgICAgLyogdGVtcG9yYXJ5IGV4cGVyaW1lbnRhbCBjb2RlIG5vdCB1c2VkXG4gICAgICB9IGVsc2UgaWYgKHJ1bGVzW2ldLnR5cGUgPT0gJ3N1cHBvcnRzJyAmJiBydWxlc1tpXS5uYW1lID09ICcta28tdGhlbWVzJykge1xuICAgICAgICBiaW5kaW5nUHJvdmlkZXIgPSBsb2NhbFdpdGhCaW5kaW5nUHJvdmlkZXIuYmluZCh0aGlzLCAndGhlbWUnLCAnJyk7XG4gICAgICAgIF9wcm9jZXNzU3R5bGVTaGVldFJ1bGVzX3Byb2Nlc3NUaGVtZXMoYmluZGluZ1Byb3ZpZGVyLCB0aGVtZVVwZGF0ZXIsIHJ1bGVzW2ldLnJ1bGVzKTtcbiAgICAgICAgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgcnVsZXNbaV0ucG9zaXRpb24uc3RhcnQsIGxhc3RTdGFydCwgMCwgMCwgMCwgJycpO1xuICAgICAgKi9cbiAgICB9IGVsc2UgaWYgKHJ1bGVzW2ldLnR5cGUgPT0gJ21lZGlhJyB8fCBydWxlc1tpXS50eXBlID09ICdzdXBwb3J0cycpIHtcbiAgICAgIG5ld1N0eWxlID0gcHJvY2Vzc1N0eWxlc2hlZXRSdWxlcyhuZXdTdHlsZSwgcnVsZXNbaV0ucnVsZXMsIGxvY2FsV2l0aEJpbmRpbmdQcm92aWRlciwgYmxvY2tEZWZzVXBkYXRlciwgdGhlbWVVcGRhdGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lKTtcbiAgICB9IGVsc2UgaWYgKHJ1bGVzW2ldLnR5cGUgPT0gJ2NvbW1lbnQnKSB7XG4gICAgICAvLyBpZ25vcmUgY29tbWVudHNcbiAgICB9IGVsc2UgaWYgKHJ1bGVzW2ldLnR5cGUgPT0gJ3J1bGUnKSB7XG4gICAgICB2YXIgc2VscyA9IHJ1bGVzW2ldLnNlbGVjdG9ycztcbiAgICAgIHZhciBuZXdTZWwgPSBcIlwiO1xuICAgICAgdmFyIGZvdW5kQmxvY2tNYXRjaCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKG5ld1NlbC5sZW5ndGggPiAwKSBuZXdTZWwgKz0gXCIsIFwiO1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZWxzW2pdLm1hdGNoKC9cXFtkYXRhLWtvLWJsb2NrPShbXiBdKilcXF0vKTtcbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGZvdW5kQmxvY2tNYXRjaCAhPT0gbnVsbCAmJiBmb3VuZEJsb2NrTWF0Y2ggIT0gbWF0Y2hbMV0pIHRocm93IFwiRm91bmQgbXVsdGlwbGUgYmxvY2stbWF0Y2ggYXR0cmlidXRlIHNlbGVjdG9yczogY2Fubm90IHRyYW5zbGF0ZSBpdCAoXCIgKyBmb3VuZEJsb2NrTWF0Y2ggKyBcIiB2cyBcIiArIG1hdGNoWzFdICsgXCIpXCI7XG4gICAgICAgICAgZm91bmRCbG9ja01hdGNoID0gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgICAgbmV3U2VsICs9ICc8IS0tIGtvIHRleHQ6IHRlbXBsYXRlTW9kZSA9PVxcJ3d5c2l3eWdcXCcgPyBcXCcjbWFpbi13eXNpd3lnLWFyZWEgXFwnIDogXFwnXFwnIC0tPjwhLS0gL2tvIC0tPicgKyBzZWxzW2pdO1xuICAgICAgfVxuICAgICAgaWYgKGZvdW5kQmxvY2tNYXRjaCkge1xuICAgICAgICB2YXIgbG9vcFByZWZpeCA9ICc8IS0tIGtvIGZvcmVhY2g6ICRyb290LmZpbmRPYmplY3RzT2ZUeXBlKCRkYXRhLCBcXCcnICsgZm91bmRCbG9ja01hdGNoICsgJ1xcJykgLS0+JztcbiAgICAgICAgdmFyIGxvb3BQb3N0Zml4ID0gJzwhLS0gL2tvIC0tPic7XG4gICAgICAgIHZhciBlbmQgPSBsYXN0U3RhcnQ7XG4gICAgICAgIHZhciBzcGFjaW5nID0gXCIgXCI7XG4gICAgICAgIGlmIChydWxlc1tpXS5kZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChydWxlc1tpXS5kZWNsYXJhdGlvbnNbMF0ucG9zaXRpb24uc3RhcnQubGluZSAhPSBydWxlc1tpXS5wb3NpdGlvbi5lbmQubGluZSkge1xuICAgICAgICAgICAgc3BhY2luZyA9IFwiXFxuXCIgKyAobmV3IEFycmF5KHJ1bGVzW2ldLnBvc2l0aW9uLnN0YXJ0LmNvbCkpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBydWxlc1tpXS5kZWNsYXJhdGlvbnNbcnVsZXNbaV0uZGVjbGFyYXRpb25zLmxlbmd0aCAtIDFdLnBvc2l0aW9uLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSBudWxsKSBuZXdTdHlsZSArPSBzcGFjaW5nICsgbG9vcFBvc3RmaXg7XG4gICAgICAgIGVsc2UgaWYgKGVuZCA9PSBsYXN0U3RhcnQpIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIGVuZCwgbGFzdFN0YXJ0LCAwLCAwLCAwLCBzcGFjaW5nICsgbG9vcFBvc3RmaXgpO1xuICAgICAgICBlbHNlIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIGVuZCwgbGFzdFN0YXJ0LCAwLCAwLCAwLCBzcGFjaW5nICsgJ30nICsgc3BhY2luZyArIGxvb3BQb3N0Zml4KTtcbiAgICAgICAgbmV3U2VsID0gbG9vcFByZWZpeCArIHNwYWNpbmcgKyBuZXdTZWwucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcW2RhdGEta28tYmxvY2s9JyArIGZvdW5kQmxvY2tNYXRjaCArICdcXFxcXScsICdnJyksICc8IS0tIGtvIHRleHQ6IFxcJyNcXCcraWQoKSAtLT4nICsgZm91bmRCbG9ja01hdGNoICsgJzwhLS0gL2tvIC0tPicpO1xuXG4gICAgICAgIGJsb2NrRGVmc1VwZGF0ZXIoZm91bmRCbG9ja01hdGNoLCAnJywgeyBjb250ZXh0TmFtZTogJ2Jsb2NrJyB9KTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE8gbWVuc2NoIHVwZGF0ZSAodXNpbmcgb3JpZ2luYWwgbWVuc2NoIGxpYnJhcnkgd2UgbmVlZGVkIHRoaXMgbGluZSwgd2hpbGUgdGhlIHBhdGNoZWQgb25lIGRvZXNuJ3QgbmVlZCB0aGlzIGNvZGUpXG4gICAgICAvLyBuZXdTZWwgKz0gXCIge1wiO1xuICAgICAgdmFyIGxvY2FsQmxvY2tOYW1lID0gZm91bmRCbG9ja01hdGNoID8gZm91bmRCbG9ja01hdGNoIDogdGVtcGxhdGVOYW1lO1xuICAgICAgYmluZGluZ1Byb3ZpZGVyID0gbG9jYWxXaXRoQmluZGluZ1Byb3ZpZGVyLmJpbmQodGhpcywgbG9jYWxCbG9ja05hbWUsICcnKTtcbiAgICAgIHZhciBlbGFib3JhdGVkU3R5bGUgPSBlbGFib3JhdGVEZWNsYXJhdGlvbnMobmV3U3R5bGUsIHJ1bGVzW2ldLmRlY2xhcmF0aW9ucywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGJpbmRpbmdQcm92aWRlcik7XG4gICAgICBpZiAoZWxhYm9yYXRlZFN0eWxlICE9PSBudWxsKSBuZXdTdHlsZSA9IGVsYWJvcmF0ZWRTdHlsZTtcblxuICAgICAgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgcnVsZXNbaV0ucG9zaXRpb24uc3RhcnQsIHJ1bGVzW2ldLnBvc2l0aW9uLmVuZCwgMCwgMCwgMCwgbmV3U2VsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIHJ1bGUgdHlwZVwiLCBydWxlc1tpXS50eXBlLCBcIndoaWxlIHBhcnNpbmcgPHN0eWxlPiBydWxlc1wiKTtcbiAgICB9XG4gICAgbGFzdFN0YXJ0ID0gcnVsZXNbaV0ucG9zaXRpb24uc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIG5ld1N0eWxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzU3R5bGVzaGVldFJ1bGVzOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBqc2VwID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9qc2VwL3NyYy9qc2VwLmpzXCIpO1xuXG5qc2VwLmFkZEJpbmFyeU9wKFwib3JcIiwgMSk7XG5qc2VwLmFkZEJpbmFyeU9wKFwiYW5kXCIsIDIpO1xuanNlcC5hZGRCaW5hcnlPcChcImVxXCIsIDYpO1xuanNlcC5hZGRCaW5hcnlPcChcIm5lcVwiLCA2KTtcbmpzZXAuYWRkQmluYXJ5T3AoXCJsdFwiLCA3KTtcbmpzZXAuYWRkQmluYXJ5T3AoXCJsdGVcIiwgNyk7XG5qc2VwLmFkZEJpbmFyeU9wKFwiZ3RcIiwgNyk7XG5qc2VwLmFkZEJpbmFyeU9wKFwiZ3RlXCIsIDcpO1xuXG52YXIgYWRkU2xhc2hlcyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXFxcXCInXS9nLCAnXFxcXCQmJykucmVwbGFjZSgvXFx1MDAwMC9nLCAnXFxcXDAnKTtcbn07XG5cbnZhciByZW1vdmVTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlLCBzdGFydFBvcywgZW5kUG9zLCBza2lwUm93cywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgaW5zZXJ0KSB7XG4gIHZhciBzdHlsZVJvd3MgPSBzdHlsZS5zcGxpdChcIlxcblwiKTtcbiAgdmFyIHN0YXJ0ID0gc3RhcnRPZmZzZXQ7XG4gIHZhciBlbmQgPSBlbmRPZmZzZXQ7XG4gIGZvciAodmFyIHIgPSAxICsgc2tpcFJvd3M7IHIgPCBzdGFydFBvcy5saW5lOyByKyspIHN0YXJ0ICs9IHN0eWxlUm93c1tyIC0gMSAtIHNraXBSb3dzXS5sZW5ndGggKyAxO1xuICBzdGFydCArPSBzdGFydFBvcy5jb2w7XG4gIGlmIChlbmRQb3MgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciByMiA9IDEgKyBza2lwUm93czsgcjIgPCBlbmRQb3MubGluZTsgcjIrKykgZW5kICs9IHN0eWxlUm93c1tyMiAtIDEgLSBza2lwUm93c10ubGVuZ3RoICsgMTtcbiAgICBlbmQgKz0gZW5kUG9zLmNvbDtcbiAgfSBlbHNlIGVuZCArPSBzdHlsZS5sZW5ndGggKyAxO1xuICB2YXIgbmV3U3R5bGUgPSBzdHlsZS5zdWJzdHIoMCwgc3RhcnQgLSAxKSArIGluc2VydCArIHN0eWxlLnN1YnN0cihlbmQgLSAxKTtcbiAgcmV0dXJuIG5ld1N0eWxlO1xufTtcblxudmFyIGV4cHJlc3Npb25HZW5lcmF0b3IgPSBmdW5jdGlvbihub2RlLCBiaW5kaW5nUHJvdmlkZXIsIGRlZlZhbCkge1xuICBmdW5jdGlvbiBtYXBPcGVyYXRvcihvcCkge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgcmV0dXJuICd8fCc7XG4gICAgICBjYXNlICdhbmQnOlxuICAgICAgICByZXR1cm4gJyYmJztcbiAgICAgIGNhc2UgJ2x0JzpcbiAgICAgICAgcmV0dXJuICc8JztcbiAgICAgIGNhc2UgJ2x0ZSc6XG4gICAgICAgIHJldHVybiAnPD0nO1xuICAgICAgY2FzZSAnZ3QnOlxuICAgICAgICByZXR1cm4gJz4nO1xuICAgICAgY2FzZSAnZ3RlJzpcbiAgICAgICAgcmV0dXJuICc+PSc7XG4gICAgICBjYXNlICdlcSc6XG4gICAgICAgIHJldHVybiAnPT0nO1xuICAgICAgY2FzZSAnbmVxJzpcbiAgICAgICAgcmV0dXJuICchPSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gb3A7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuKG5vZGUsIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyLCBkZWZWYWwpIHtcbiAgICBpZiAodHlwZW9mIGxvb2t1cG1lbWJlciA9PSAndW5kZWZpbmVkJykgbG9va3VwbWVtYmVyID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVmVmFsICE9PSAndW5kZWZpbmVkJyAmJiBub2RlLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIG5vZGUudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIGNvbnNvbGUubG9nKFwiQ2Fubm90IGFwcGx5IGRlZmF1bHQgdmFsdWUgdG8gdmFyaWFibGUgd2hlbiB1c2luZyBleHByZXNzaW9uc1wiKTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gJygnICsgZ2VuKG5vZGUubGVmdCwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIpICsgJyAnICsgbWFwT3BlcmF0b3Iobm9kZS5vcGVyYXRvcikgKyAnICcgKyBnZW4obm9kZS5yaWdodCwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIpICsgJyknO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nKSB7XG4gICAgICB2YXIgYXJncyA9IG5vZGUuYXJndW1lbnRzLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBnZW4obiwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuKG5vZGUuY2FsbGVlLCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlcikgKyAnKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiVW5hcnlFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiBub2RlLm9wZXJhdG9yICsgZ2VuKG5vZGUuYXJndW1lbnQsIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgbm9kZS5jb21wdXRlZCkge1xuICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGNvbXB1dGVkIG1lbWJlciBleHByZXNzaW9uXCI7XG4gICAgICAvLyByZXR1cm4gZ2VuKG5vZGUub2JqZWN0KSArICdbJyArIGdlbihub2RlLnByb3BlcnR5KSArICddJztcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgIW5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHZhciBtZSA9IGdlbihub2RlLm9iamVjdCwgYmluZGluZ1Byb3ZpZGVyLCBmYWxzZSkgKyAnLicgKyBnZW4obm9kZS5wcm9wZXJ0eSwgYmluZGluZ1Byb3ZpZGVyLCBmYWxzZSk7XG4gICAgICBpZiAobG9va3VwbWVtYmVyICYmIG5vZGUub2JqZWN0Lm5hbWUgIT09ICdNYXRoJyAmJiBub2RlLm9iamVjdC5uYW1lICE9PSAnQ29sb3InKSByZXR1cm4gYmluZGluZ1Byb3ZpZGVyKG1lLCBkZWZWYWwpICsgJygpJztcbiAgICAgIHJldHVybiBtZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHtcbiAgICAgIHJldHVybiBub2RlLnJhdztcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICB2YXIgaWQgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobG9va3VwbWVtYmVyKSByZXR1cm4gYmluZGluZ1Byb3ZpZGVyKGlkLCBkZWZWYWwpICsgJygpJztcbiAgICAgIGVsc2UgcmV0dXJuIGlkO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJykge1xuICAgICAgcmV0dXJuICcoJyArIGdlbihub2RlLnRlc3QsIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyKSArICcgPyAnICsgZ2VuKG5vZGUuY29uc2VxdWVudCwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIpICsgJyA6ICcgKyBnZW4obm9kZS5hbHRlcm5hdGUsIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyKSArICcpJztcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0NvbXBvdW5kJykge1xuICAgICAgdGhyb3cgXCJTeW50YXggZXJyb3IgaW4gZXhwcmVzc2lvbjogb3BlcmF0b3IgZXhwZWN0ZWQgYWZ0ZXIgXCIgKyBnZW4obm9kZS5ib2R5WzBdLCBiaW5kaW5nUHJvdmlkZXIsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJGb3VuZCBhbiB1bnN1cHBvcnRlZCBleHByZXNzaW9uIHR5cGU6IFwiICsgbm9kZS50eXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZW4obm9kZSwgYmluZGluZ1Byb3ZpZGVyLCB1bmRlZmluZWQsIGRlZlZhbCk7XG59O1xuXG52YXIgZXhwcmVzc2lvbkJpbmRpbmcgPSBmdW5jdGlvbihleHByZXNzaW9uLCBiaW5kaW5nUHJvdmlkZXIsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgbWF0Y2hlcztcbiAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgIT09ICd1bmRlZmluZWQnICYmIGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCkge1xuICAgIHZhciBjaGVjayA9IGV4cHJlc3Npb24udHJpbSgpLnJlcGxhY2UoL0BcXFsoW15cXF1dKylcXF18QChbYS16QS1aMC05XFwuX10rKVxcYi9nLCAnIyMjdmFyIyMjJyk7XG4gICAgY2hlY2sgPSBjaGVjay5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgXCJcXFxcJCZcIik7XG4gICAgaWYgKGNoZWNrID09ICcjIyN2YXIjIyMnKSBtYXRjaGVzID0gW251bGwsIGRlZmF1bHRWYWx1ZV07XG4gICAgZWxzZSB7XG4gICAgICBjaGVjayA9ICdeJyArIGNoZWNrLnJlcGxhY2UoLyMjI3ZhciMjIy9nLCAnKC4rKScpICsgJyQnO1xuICAgICAgbWF0Y2hlcyA9IGRlZmF1bHRWYWx1ZS50cmltKCkubWF0Y2gobmV3IFJlZ0V4cChjaGVjaykpO1xuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIC8vIFRPRE8gdGhyb3cgZXJyb3I/XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2Fubm90IGZpbmQgbWF0Y2hlc1wiLCBtYXRjaGVzLCBcImZvclwiLCBkZWZhdWx0VmFsdWUsIGV4cHJlc3Npb24sIGNoZWNrLCBleHByZXNzaW9uKTtcbiAgICAgICAgdGhyb3cgXCJDYW5ub3QgZmluZCBkZWZhdWx0IHZhbHVlIGZvciBcIiArIGV4cHJlc3Npb24gKyBcIiBpbiBcIiArIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgdmFycyA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFwiJ1wiICsgZXhwcmVzc2lvbi5yZXBsYWNlKC9AXFxbKFteXFxdXSspXFxdfEAoW2EtekEtWjAtOVxcLl9dKylcXGJ8KCcpL2csIGZ1bmN0aW9uKG1hdGNoLCBwMSwgcDIsIHAzKSB7XG4gICAgICAvLyBlc2NhcGluZy4uXG4gICAgICBpZiAocDMpIHJldHVybiBcIlxcXFxcIiArIHAzO1xuICAgICAgdmFycysrO1xuICAgICAgdmFyIHZhck5hbWUgPSBwMSB8fCBwMjtcbiAgICAgIHZhciBkZWZWYWw7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXNbdmFyc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGVmVmFsID0gbWF0Y2hlc1t2YXJzXS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBQlpaWiBDYW5ub3QgZmluZCBkZWZhdWx0IHZhbHVlIGZvclwiLCB2YXJOYW1lLCBcImluXCIsIG1hdGNoZXMsIFwiYXNcIiwgdmFycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGluIGNhc2Ugd2UgZm91bmQgcDEgd2UgYXJlIGluIGEgQFtzZXF1ZW5jZV0gc28gd2Ugc3RhcnQgYW4gZXhwcmVzc2lvbiBwYXJzZXJcbiAgICAgIGlmIChwMSkge1xuICAgICAgICB2YXIgcGFyc2V0cmVlID0ganNlcChwMSk7XG4gICAgICAgIHZhciBnZW50cmVlID0gZXhwcmVzc2lvbkdlbmVyYXRvcihwYXJzZXRyZWUsIGJpbmRpbmdQcm92aWRlciwgZGVmVmFsKTtcbiAgICAgICAgcmV0dXJuIFwiJytcIiArIGdlbnRyZWUgKyBcIisnXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCInK1wiICsgYmluZGluZ1Byb3ZpZGVyKHZhck5hbWUsIGRlZlZhbCkgKyBcIigpKydcIjtcbiAgICB9KSArIFwiJ1wiO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC8oXnxbXlxcXFxdKScnXFwrL2csICckMScpLnJlcGxhY2UoL1xcKycnL2csICcnKTtcblxuICAgIGlmICh2YXJzID09PSAwICYmIHJlc3VsdCAhPT0gJ2ZhbHNlJyAmJiByZXN1bHQgIT09ICd0cnVlJykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgZXhwcmVzc2lvbiB3aXRoIG5vIHZhbGlkIEB2YXJpYWJsZSByZWZlcmVuY2VzXCIsIGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgXCJFeGNlcHRpb24gcGFyc2luZyBleHByZXNzaW9uIFwiICsgZXhwcmVzc2lvbiArIFwiIFwiICsgZTtcbiAgfVxufTtcblxudmFyIGNvbmRpdGlvbkJpbmRpbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGJpbmRpbmdQcm92aWRlcikge1xuICB2YXIgcGFyc2V0cmVlID0ganNlcChjb25kaXRpb24pO1xuICB2YXIgZ2VudHJlZSA9IGV4cHJlc3Npb25HZW5lcmF0b3IocGFyc2V0cmVlLCBiaW5kaW5nUHJvdmlkZXIpO1xuICByZXR1cm4gZ2VudHJlZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRTbGFzaGVzOiBhZGRTbGFzaGVzLFxuICByZW1vdmVTdHlsZTogcmVtb3ZlU3R5bGUsXG4gIGNvbmRpdGlvbkJpbmRpbmc6IGNvbmRpdGlvbkJpbmRpbmcsXG4gIGV4cHJlc3Npb25CaW5kaW5nOiBleHByZXNzaW9uQmluZGluZ1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVGhpcyBpcyBjb21wbGV4IGNvZGUgdG8gaGFuZGxlIFwibGl2ZVwiIG1vZGVsIGluc3RydW1lbnRhdGlvbiBhbmQgZGVwZW5kZW5jeSB0cmFja2luZy5cbi8vIFRoaXMgYWRkcyBfd3JhcCBhbmQgX3Vud3JhcCBtZXRob2RzIHRvIHRoZSBtb2RlbCBhbmQgYWxzbyBpbnN0cnVtZW50IHRoZSBibG9jayBsaXN0IHNvIHRvIGF1dG9tYXRpY2FsbHlcbi8vIHdyYXAvdXB3cmFwIG9iamVjdHMgb24gc2ltcGxlIGFycmF5IG1ldGhvZHMgKHB1c2gsIHNwbGljZSlcblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIga293cmFwID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9rbm9ja291dC53cmFwL2tub2Nrb3V0LndyYXAuanNcIik7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG52YXIgX2dldE9wdGlvbnNPYmplY3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBvcHRpb25zQ291cGxlcyA9IG9wdGlvbnMuc3BsaXQoJ3wnKTtcbiAgdmFyIG9wdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zQ291cGxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvcHQgPSBvcHRpb25zQ291cGxlc1tpXS5zcGxpdCgnPScpO1xuICAgIG9wdHNbb3B0WzBdXSA9IG9wdC5sZW5ndGggPiAxID8gb3B0WzFdIDogb3B0WzBdO1xuICB9XG4gIHJldHVybiBvcHRzO1xufTtcblxuLy8gZ2VuZXJhdGUgYSBjb21wdXRlZCB2YXJpYWJsZSBoYW5kbGluZyB0aGUgZmFsbGJhY2sgdG8gdGhlbWUgdmFyaWFibGVcbnZhciBfbWFrZUNvbXB1dGVkID0gZnVuY3Rpb24odGFyZ2V0LCBkZWYsIG51bGxJZkVxdWFsLCBzY2hlbWVTZWxlY3RvciwgdGhlbWVQYXRoLCB0aGVtZXMpIHtcbiAgdmFyIHJlcyA9IGtvLmNvbXB1dGVkKHtcbiAgICAncmVhZCc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbCA9IHRhcmdldCgpO1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgc2NoZW1lID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShzY2hlbWVTZWxlY3Rvcik7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1lID09ICd1bmRlZmluZWQnIHx8IHNjaGVtZSA9PSAnY3VzdG9tJykge1xuICAgICAgICAgIHJldHVybiBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoZW1lc1tzY2hlbWVdW3RoZW1lUGF0aF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICAnd3JpdGUnOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIHNjaGVtZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoc2NoZW1lU2VsZWN0b3IpO1xuICAgICAgdmFyIGRlZlZhbDtcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1lID09ICd1bmRlZmluZWQnIHx8IHNjaGVtZSA9PSAnY3VzdG9tJykge1xuICAgICAgICBkZWZWYWwgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZShkZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmVmFsID0gdGhlbWVzW3NjaGVtZV1bdGhlbWVQYXRoXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEhbnVsbElmRXF1YWwpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IGRlZlZhbCkgdGFyZ2V0KG51bGwpO1xuICAgICAgICBlbHNlIHRhcmdldCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3VycmVudCA9IGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKHRhcmdldCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBkZWZWYWwgfHwgY3VycmVudCAhPT0gbnVsbCkgdGFyZ2V0KHZhbHVlKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXM7XG59O1xuXG52YXIgX25leHRWYXJpYW50RnVuY3Rpb24gPSBmdW5jdGlvbihrbywgcHJvcCwgdmFyaWFudHMpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUocHJvcCk7XG4gIHZhciB2YXJpYW50VmFsdWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJpYW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhcmlhbnRWYWx1ZSA9IGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKHZhcmlhbnRzW2ldKTtcbiAgICBpZiAodmFyaWFudFZhbHVlID09IGN1cnJlbnRWYWx1ZSkgYnJlYWs7XG4gIH1cblxuICBpZiAoaSA9PSB2YXJpYW50cy5sZW5ndGgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJEaWRuJ3QgZmluZCBhIHZhcmlhbnQhXCIsIHByb3AsIGN1cnJlbnRWYWx1ZSwgdmFyaWFudHMpO1xuICAgIGkgPSB2YXJpYW50cy5sZW5ndGggLSAxO1xuICB9XG5cbiAgdmFyIG5leHRWYXJpYW50ID0gaSArIDE7XG4gIGlmIChuZXh0VmFyaWFudCA9PSB2YXJpYW50cy5sZW5ndGgpIG5leHRWYXJpYW50ID0gMDtcbiAgdmFyIG5leHRWYWx1ZSA9IGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKHZhcmlhbnRzW25leHRWYXJpYW50XSk7XG5cbiAgcHJvcChuZXh0VmFsdWUpO1xufTtcblxudmFyIF9nZXRWYXJpYW50cyA9IGZ1bmN0aW9uKGRlZikge1xuICB2YXIgdmFyaWFudFByb3AgPSBkZWYuX3ZhcmlhbnQ7XG4gIHZhciB2YXJpYW50T3B0aW9ucztcbiAgaWYgKHR5cGVvZiBkZWZbdmFyaWFudFByb3BdICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgZGVmW3ZhcmlhbnRQcm9wXS5fd2lkZ2V0ID09PSAndW5kZWZpbmVkJyB8fCAodHlwZW9mIGRlZlt2YXJpYW50UHJvcF0uX29wdGlvbnMgIT09ICdzdHJpbmcnICYmIGRlZlt2YXJpYW50UHJvcF0uX3dpZGdldCAhPT0gJ2Jvb2xlYW4nKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIHZhcmlhbnQgZGVjbGFyYXRpb25cIiwgdmFyaWFudFByb3AsIGRlZlt2YXJpYW50UHJvcF0pO1xuICAgIHRocm93IFwiVW5leHBlY3RlZCB2YXJpYW50IGRlY2xhcmF0aW9uOiBjYW5ub3QgZmluZCBwcm9wZXJ0eSBcIiArIHZhcmlhbnRQcm9wICsgXCIgb3IgaXRzIF9vcHRpb25zIHN0cmluZyBhbmQgaXQgaXMgbm90IGEgYm9vbGVhblwiO1xuICB9XG4gIC8vIFRPRE8gSSByZWFkIHRoZSBcImtleXNcIiBidXQgdGhpcyBpcyBub3QgMTAwJSBjb3JyZWN0IGJlY2F1c2UgdGhleSBhcmUgbm90IGdhcmFudGVlZCB0byBiZSBzb3J0ZWQgYXMgaW4gZGVjbGFyYXRpb25cbiAgaWYgKHR5cGVvZiBkZWZbdmFyaWFudFByb3BdLl9vcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgdmFyaWFudE9wdGlvbnMgPSBPYmplY3Qua2V5cyhfZ2V0T3B0aW9uc09iamVjdChkZWZbdmFyaWFudFByb3BdLl9vcHRpb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyaWFudE9wdGlvbnMgPSBbdHJ1ZSwgZmFsc2VdO1xuICB9XG4gIHJldHVybiB2YXJpYW50T3B0aW9ucztcbn07XG5cbnZhciBfbWFrZUNvbXB1dGVkRnVuY3Rpb24gPSBmdW5jdGlvbihkZWYsIGRlZnMsIHRobXMsIGtvLCBjb250ZW50TW9kZWwsIGlzQ29udGVudCwgdCkge1xuICBpZiAodHlwZW9mIGRlZiA9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2Yga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0KS50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5sb2coXCJUT0RPIEVSUk9SIEZvdW5kIGEgbm9uLXR5cGVkIGRlZiBcIiwgZGVmLCB0KTtcbiAgICAgIHRocm93IFwiRm91bmQgYSBub24tdHlwZWQgZGVmIFwiICsgZGVmO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0KS50eXBlKTtcbiAgICBkZWYgPSBkZWZzW3R5cGVdO1xuICAgIGlmICh0eXBlb2YgZGVmICE9PSAnb2JqZWN0JykgY29uc29sZS5sb2coXCJUT0RPIEVSUk9SIEZvdW5kIGEgbm9uLW9iamVjdCBkZWYgXCIsIGRlZiwgXCJmb3JcIiwgdHlwZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnRNb2RlbCA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaXNDb250ZW50ICE9ICd1bmRlZmluZWQnICYmIGlzQ29udGVudCkge1xuICAgIGNvbnRlbnRNb2RlbCA9IHQ7XG4gIH1cblxuICB2YXIgc2VsZlBhdGggPSAnJHJvb3QuY29udGVudCgpLic7XG5cbiAgdmFyIHBwID0gZGVmLl9nbG9iYWxTdHlsZXM7XG4gIGlmICh0eXBlb2YgcHAgIT0gJ3VuZGVmaW5lZCcpXG4gICAgZm9yICh2YXIgcCBpbiBwcClcbiAgICAgIGlmIChwcC5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICB2YXIgc2NoZW1lUGF0aE9yaWcgPSAnJHJvb3QuY29udGVudCgpLnRoZW1lKCkuc2NoZW1lJztcbiAgICAgICAgdmFyIHNjaGVtZVBhdGgsIHZtLCBwYXRoO1xuXG4gICAgICAgIGlmIChwcFtwXS5zdWJzdHIoMCwgc2VsZlBhdGgubGVuZ3RoKSA9PSBzZWxmUGF0aCkge1xuICAgICAgICAgIHBhdGggPSBwcFtwXS5zdWJzdHIoc2VsZlBhdGgubGVuZ3RoKTtcbiAgICAgICAgICB2bSA9IGNvbnRlbnRNb2RlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcIlVORVhQRUNURUQgZ2xvYmFsU3R5bGUgcGF0aCAoXCIgKyBwcFtwXSArIFwiKSBvdXRzaWRlIHNlbGZQYXRoIChcIiArIHNlbGZQYXRoICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtZVBhdGhPcmlnLnN1YnN0cigwLCBzZWxmUGF0aC5sZW5ndGgpID09IHNlbGZQYXRoKSB7XG4gICAgICAgICAgc2NoZW1lUGF0aCA9IHNjaGVtZVBhdGhPcmlnLnN1YnN0cihzZWxmUGF0aC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiSVMgVEhJUyBDT1JSRUNUP1wiLCBzY2hlbWVQYXRoT3JpZywgc2VsZlBhdGgpO1xuICAgICAgICAgIHNjaGVtZVBhdGggPSBzY2hlbWVQYXRoT3JpZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2hlbWVTZWxlY3RvciA9IHZtO1xuXG4gICAgICAgIHZhciBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KCcoKS4nKTtcbiAgICAgICAgdmFyIHRoZW1lUGF0aCA9ICcnO1xuICAgICAgICB2YXIgc2tpcCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdm0gPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZtKVtwYXRoUGFydHNbaV1dO1xuICAgICAgICAgIC8vIHVnbHkgdGhpbmcgdG8gZmluZCB0aGUgcGF0aCB0byB0aGUgc2NoZW1hIGNvbG9yIHByb3BlcnR5IChzb21ldGltZXMgd2UgaGF2ZSB0aGVtZS5ib2R5VGhlbWUsIHNvbWUgb3RoZXIgd2UgaGF2ZSBjb250ZW50LnRoZW1lLmJvZHlUaGVtZS4uLilcbiAgICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgaWYgKHBhdGhQYXJ0c1tpXSA9PSAndGhlbWUnKSBza2lwID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGVtZVBhdGgubGVuZ3RoID4gMCkgdGhlbWVQYXRoICs9ICcuJztcbiAgICAgICAgICAgIHRoZW1lUGF0aCArPSBwYXRoUGFydHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjaGVtZVBhcnRzID0gc2NoZW1lUGF0aC5zcGxpdCgnKCkuJyk7XG4gICAgICAgIGZvciAodmFyIGkzID0gMDsgaTMgPCBzY2hlbWVQYXJ0cy5sZW5ndGg7IGkzKyspIHtcbiAgICAgICAgICBzY2hlbWVTZWxlY3RvciA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoc2NoZW1lU2VsZWN0b3IpW3NjaGVtZVBhcnRzW2kzXV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVsbElmRXF1YWwgPSB0cnVlO1xuICAgICAgICB2YXIgdFBhcnRzID0gcC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdDtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHRQYXJ0cy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICB0YXJnZXQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHRhcmdldClbdFBhcnRzW2kyXV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtvLmlzT2JzZXJ2YWJsZSh0YXJnZXQpKSB0aHJvdyBcIlVuZXhwZWN0ZWQgbm9uIG9ic2VydmFibGUgdGFyZ2V0IFwiICsgcCArIFwiL1wiICsgdGhlbWVQYXRoO1xuXG4gICAgICAgIHRhcmdldC5fZGVmYXVsdENvbXB1dGVkID0gX21ha2VDb21wdXRlZCh0YXJnZXQsIHZtLCBudWxsSWZFcXVhbCwgc2NoZW1lU2VsZWN0b3IsIHRoZW1lUGF0aCwgdGhtcyk7XG4gICAgICB9XG5cbiAgaWYgKHR5cGVvZiBkZWYuX3ZhcmlhbnQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgcFBhcnRzID0gZGVmLl92YXJpYW50LnNwbGl0KCcuJyk7XG4gICAgLy8gbG9va3MgaW4gdCBhbmQgbm90IGNvbnRlbnRNb2RlbCBiZWNhdXNlIHZhcmlhbnRzIGFyZSBkZWNsYXJlZCBvbiBzaW5nbGUgYmxvY2tzLlxuICAgIHZhciBwVGFyZ2V0ID0gdDtcbiAgICB2YXIgcFBhcmVudCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodCk7XG4gICAgZm9yICh2YXIgaTQgPSAwOyBpNCA8IHBQYXJ0cy5sZW5ndGg7IGk0KyspIHtcbiAgICAgIHBUYXJnZXQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHBUYXJnZXQpW3BQYXJ0c1tpNF1dO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBUYXJnZXQuX2RlZmF1bHRDb21wdXRlZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5sb2coXCJGb3VuZCB2YXJpYW50IG9uIGEgc3R5bGUgcHJvcGVydHk6IGJld2FyZSB2YXJpYW50cyBzaG91bGQgYmUgb25seSB1c2VkIG9uIGNvbnRlbnQgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgbWF0Y2ggdGhlIHRoZW1lIGZhbGxiYWNrIGJlaGF2aW91clwiLCBkZWYuX3ZhcmlhbnQpO1xuICAgICAgcFRhcmdldCA9IHBUYXJnZXQuX2RlZmF1bHRDb21wdXRlZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwVGFyZ2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVSUk9SIGxvb2tpbmcgZm9yIHZhcmlhbnQgdGFyZ2V0XCIsIGRlZi5fdmFyaWFudCwgdCk7XG4gICAgICB0aHJvdyBcIkVSUk9SIGxvb2tpbmcgZm9yIHZhcmlhbnQgdGFyZ2V0IFwiICsgZGVmLl92YXJpYW50O1xuICAgIH1cbiAgICBwUGFyZW50Ll9uZXh0VmFyaWFudCA9IF9uZXh0VmFyaWFudEZ1bmN0aW9uLmJpbmQocFRhcmdldCwga28sIHBUYXJnZXQsIF9nZXRWYXJpYW50cyhkZWYpKTtcbiAgfVxuXG4gIGZvciAodmFyIHByb3AyIGluIGRlZilcbiAgICBpZiAoZGVmLmhhc093blByb3BlcnR5KHByb3AyKSkge1xuICAgICAgdmFyIHZhbCA9IGRlZltwcm9wMl07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbC5fY29udGV4dCAhPSAndW5kZWZpbmVkJyAmJiB2YWwuX2NvbnRleHQgPT0gJ2Jsb2NrJykge1xuICAgICAgICB2YXIgcHJvcFZtID0gY29udGVudE1vZGVsW3Byb3AyXSgpO1xuICAgICAgICB2YXIgbmV3Vm0gPSBfbWFrZUNvbXB1dGVkRnVuY3Rpb24oZGVmc1twcm9wMl0sIGRlZnMsIHRobXMsIGtvLCBjb250ZW50TW9kZWwsIGlzQ29udGVudCwgcHJvcFZtKTtcbiAgICAgICAgdFtwcm9wMl0obmV3Vm0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiB2YWwudHlwZSA9PSAnYmxvY2tzJykge1xuICAgICAgICB2YXIgbWFpblZtID0gY29udGVudE1vZGVsW3Byb3AyXSgpO1xuICAgICAgICB2YXIgYmxvY2tzVm0gPSBtYWluVm0uYmxvY2tzKCk7XG4gICAgICAgIHZhciBvbGRCbG9jaywgYmxvY2tUeXBlLCBuZXdCbG9jaztcbiAgICAgICAgZm9yICh2YXIgaWIgPSAwOyBpYiA8IGJsb2Nrc1ZtLmxlbmd0aDsgaWIrKykge1xuICAgICAgICAgIG9sZEJsb2NrID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShibG9ja3NWbVtpYl0pO1xuICAgICAgICAgIGJsb2NrVHlwZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUob2xkQmxvY2sudHlwZSk7XG4gICAgICAgICAgbmV3QmxvY2sgPSBfbWFrZUNvbXB1dGVkRnVuY3Rpb24oZGVmc1tibG9ja1R5cGVdLCBkZWZzLCB0aG1zLCBrbywgY29udGVudE1vZGVsLCBpc0NvbnRlbnQsIG9sZEJsb2NrKTtcbiAgICAgICAgICBibG9ja3NWbVtpYl0obmV3QmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJsb2Nrc09icyA9IG1haW5WbS5ibG9ja3M7XG5cbiAgICAgICAgX2F1Z21lbnRCbG9ja3NPYnNlcnZhYmxlKGJsb2Nrc09icywgX2Jsb2NrSW5zdHJ1bWVudEZ1bmN0aW9uLmJpbmQobWFpblZtLCB1bmRlZmluZWQsIGRlZnMsIHRobXMsIGtvLCB1bmRlZmluZWQsIGNvbnRlbnRNb2RlbCwgaXNDb250ZW50KSk7XG5cbiAgICAgICAgY29udGVudE1vZGVsW3Byb3AyXS5fd3JhcCA9IF9tYWtlQmxvY2tzV3JhcC5iaW5kKGNvbnRlbnRNb2RlbFtwcm9wMl0sIGJsb2Nrc09icy5faW5zdHJ1bWVudEJsb2NrKTtcbiAgICAgICAgY29udGVudE1vZGVsW3Byb3AyXS5fdW53cmFwID0gX3Vud3JhcC5iaW5kKGNvbnRlbnRNb2RlbFtwcm9wMl0pO1xuICAgICAgfVxuICAgIH1cblxuICByZXR1cm4gdDtcbn07XG5cbnZhciBfYXVnbWVudEJsb2Nrc09ic2VydmFibGUgPSBmdW5jdGlvbihibG9ja3NPYnMsIGluc3RydW1lbnQpIHtcbiAgYmxvY2tzT2JzLl9pbnN0cnVtZW50QmxvY2sgPSBpbnN0cnVtZW50O1xuICBpZiAodHlwZW9mIGJsb2Nrc09icy5vcmlnUHVzaCA9PSAndW5kZWZpbmVkJykge1xuICAgIGJsb2Nrc09icy5vcmlnUHVzaCA9IGJsb2Nrc09icy5wdXNoO1xuICAgIGJsb2Nrc09icy5wdXNoID0gX21ha2VQdXNoLmJpbmQoYmxvY2tzT2JzKTtcbiAgICBibG9ja3NPYnMub3JpZ1NwbGljZSA9IGJsb2Nrc09icy5zcGxpY2U7XG4gICAgYmxvY2tzT2JzLnNwbGljZSA9IF9tYWtlU3BsaWNlLmJpbmQoYmxvY2tzT2JzKTtcbiAgfVxufTtcblxudmFyIF9tYWtlQmxvY2tzV3JhcCA9IGZ1bmN0aW9uKGluc3RydW1lbnQsIGlucHV0TW9kZWwpIHtcbiAgdmFyIG1vZGVsID0ga28udG9KUyhpbnB1dE1vZGVsKTtcbiAgdmFyIGlucHV0ID0gbW9kZWwuYmxvY2tzO1xuICBtb2RlbC5ibG9ja3MgPSBbXTtcbiAgdmFyIHJlcyA9IGtvd3JhcC5mcm9tSlMobW9kZWwsIHVuZGVmaW5lZCwgdHJ1ZSkoKTtcbiAgX2F1Z21lbnRCbG9ja3NPYnNlcnZhYmxlKHJlcy5ibG9ja3MsIGluc3RydW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG9iaiA9IGtvLnRvSlMoaW5wdXRbaV0pO1xuICAgIC8vIGNvbnNvbGUubG9nKFwiX21ha2VCbG9ja3NXcmFwIHNldCBibG9ja0lkXCIsIG9iai5pZCwgJ2Jsb2NrXycraSk7XG4gICAgb2JqLmlkID0gJ2Jsb2NrXycgKyBpO1xuICAgIHJlcy5ibG9ja3MucHVzaChvYmopO1xuICB9XG4gIHRoaXMocmVzKTtcbn07XG5cbnZhciBfbWFrZVB1c2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB0aHJvdyBcIkFycmF5IHB1c2ggd2l0aCBtdWx0aXBsZSBhcmd1bWVudHMgbm90IGltcGxlbWVudGVkXCI7XG4gIC8vIHVud3JhcCBvYnNlcnZhYmxlIGJsb2Nrcywgb3RoZXJ3aXNlIHZpc2liaWxpdHkgKGRlcGVuZGVuY3kpIGhhbmRsaW5nIGJyZWFrc1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYga28uaXNPYnNlcnZhYmxlKGFyZ3VtZW50c1swXSkpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXS5fdW53cmFwID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXS5fdW53cmFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV0FSTjogcHVzaGluZyBvYnNlcnZhYmxlIHdpdGggbm8gX3Vud3JhcCBmdW5jdGlvbiAoVE9ETyByZW1vdmUgbWUsIGV4cGVjdGVkIGNvbmRpdGlvbilcIik7XG4gICAgfVxuICB9XG4gIGlmICgha28uaXNPYnNlcnZhYmxlKGFyZ3VtZW50c1swXSkpIHtcbiAgICB2YXIgaW5zdHJ1bWVudGVkID0gdGhpcy5faW5zdHJ1bWVudEJsb2NrKGFyZ3VtZW50c1swXSk7XG4gICAgcmV0dXJuIHRoaXMub3JpZ1B1c2guYXBwbHkodGhpcywgW2luc3RydW1lbnRlZF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm9yaWdQdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cbnZhciBfbWFrZVNwbGljZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHRocm93IFwiQXJyYXkgc3BsaWNlIHdpdGggbXVsdGlwbGUgb2JqZWN0cyBub3QgaW1wbGVtZW50ZWRcIjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGtvLmlzT2JzZXJ2YWJsZShhcmd1bWVudHNbMl0pKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0uX3Vud3JhcCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmd1bWVudHNbMl0gPSBhcmd1bWVudHNbMl0uX3Vud3JhcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldBUk46IHNwbGljaW5nIG9ic2VydmFibGUgd2l0aCBubyBfdW53cmFwIGZ1bmN0aW9uIChUT0RPIHJlbW92ZSBtZSwgZXhwZWN0ZWQgY29uZGl0aW9uKVwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmICFrby5pc09ic2VydmFibGUoYXJndW1lbnRzWzJdKSkge1xuICAgIHZhciBpbnN0cnVtZW50ZWQgPSB0aGlzLl9pbnN0cnVtZW50QmxvY2soYXJndW1lbnRzWzJdKTtcbiAgICByZXR1cm4gdGhpcy5vcmlnU3BsaWNlLmFwcGx5KHRoaXMsIFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgaW5zdHJ1bWVudGVkXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ1NwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG4vLyBkZWYsIGRlZnMgYW5kIHRoZW1lcyBhcmUgYm91bmQgaW4gXCJfbW9kZWxJbnN0cnVtZW50XCIgd2hpbGUgdGhlIG5leHQgcGFyYW1ldGVycyBhcmUgZXhwb3NlZCBieSB0aGlzIG1vZHVsZVxudmFyIF9ibG9ja0luc3RydW1lbnRGdW5jdGlvbiA9IGZ1bmN0aW9uKGRlZiwgZGVmcywgdGhlbWVzLCBrbm9ja291dCwgc2VsZiwgbW9kZWxDb250ZW50LCBpc0NvbnRlbnQsIHNlbGYyKSB7XG4gIC8vIHVnbHk6IHNvbWV0aW1lcyB3ZSBoYXZlIHRvIGJpbmQgY29udGVudCBidXQgbm90IHNlbGYsIHNvIHdlIHJlcGVhdCBzZWxmIGF0IHRoZSBlbmQgYXMgXCJzZWxmMlwiXG4gIGlmICh0eXBlb2Ygc2VsZiA9PSAndW5kZWZpbmVkJykgc2VsZiA9IHNlbGYyO1xuXG4gIHZhciBjb21wdXRlZEZ1bmN0aW9ucztcbiAgY29tcHV0ZWRGdW5jdGlvbnMgPSB7XG4gICAgJyc6IF9tYWtlQ29tcHV0ZWRGdW5jdGlvbi5iaW5kKHNlbGYsIGRlZiwgZGVmcywgdGhlbWVzLCBrbm9ja291dCwgbW9kZWxDb250ZW50LCBpc0NvbnRlbnQpXG4gIH07XG5cbiAgdmFyIHJlcyA9IGtvd3JhcC5mcm9tSlMoc2VsZiwgY29tcHV0ZWRGdW5jdGlvbnMsIHRydWUpO1xuICByZXMuX3Vud3JhcCA9IF91bndyYXAuYmluZChyZXMpO1xuICByZXR1cm4gcmVzO1xufTtcblxudmFyIF93cmFwID0gZnVuY3Rpb24oaW5zdHJ1bWVudCwgdW53cmFwcGVkKSB7XG4gIHZhciBuZXdDb250ZW50ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShpbnN0cnVtZW50KGtvLCB1bndyYXBwZWQsIHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICB0aGlzKG5ld0NvbnRlbnQpO1xufTtcblxudmFyIF91bndyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGtvLnRvSlModGhpcyk7XG59O1xuXG52YXIgX21vZGVsSW5zdHJ1bWVudCA9IGZ1bmN0aW9uKG1vZGVsLCBtb2RlbERlZiwgZGVmcykge1xuICB2YXIgX2luc3RydW1lbnQgPSBfYmxvY2tJbnN0cnVtZW50RnVuY3Rpb24uYmluZCh1bmRlZmluZWQsIG1vZGVsRGVmLCBkZWZzLCBkZWZzWyd0aGVtZXMnXSk7XG4gIHZhciByZXMgPSBfaW5zdHJ1bWVudChrbywgbW9kZWwsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIC8vIHJlcy5faW5zdHJ1bWVudCA9IF9pbnN0cnVtZW50O1xuICByZXMuX3dyYXAgPSBfd3JhcC5iaW5kKHJlcywgX2luc3RydW1lbnQpO1xuICByZXMuX3Vud3JhcCA9IF91bndyYXAuYmluZChyZXMpO1xuICByZXR1cm4gcmVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBfbW9kZWxJbnN0cnVtZW50OyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgJCAgICAgICA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbClcbnZhciBrbyAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbClcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIilcblxuZnVuY3Rpb24gaGFuZGxlQ3JlYXRpb25OYW1lKHZpZXdNb2RlbCkge1xuICB2YXIgb3JpZ2luYWxWYWx1ZVxuICB2aWV3TW9kZWwudGl0bGVNb2RlICAgICAgICAgPSBrby5vYnNlcnZhYmxlKCdzaG93JylcbiAgdmlld01vZGVsLm1ldGFkYXRhLm5hbWUgICAgID0ga28ub2JzZXJ2YWJsZSh2aWV3TW9kZWwubWV0YWRhdGEubmFtZSlcblxuICB2aWV3TW9kZWwuY3JlYXRpb25OYW1lICAgICAgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmlld01vZGVsLm1ldGFkYXRhLm5hbWUoKSB8fCB2aWV3TW9kZWwudCgndGl0bGUtZW1wdHknKVxuICB9LCB2aWV3TW9kZWwpXG5cbiAgdmlld01vZGVsLmVuYWJsZUVkaXRDcmVhdGlvbk5hbWUgID0gZnVuY3Rpb24gKGRhdGEsIGV2ZW50KSB7XG4gICAgY29uc29sZS5sb2coJ2VuYWJsZUVkaXRDcmVhdGlvbk5hbWUnLCBkYXRhKVxuICAgIG9yaWdpbmFsVmFsdWUgPSB2aWV3TW9kZWwubWV0YWRhdGEubmFtZSgpXG4gICAgdmlld01vZGVsLnRpdGxlTW9kZSgnZWRpdCcpXG4gIH1cblxuICB2aWV3TW9kZWwuY2FuY2VsRWRpdENyZWF0aW9uTmFtZSAgPSBmdW5jdGlvbiAoZGF0YSwgZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZygnY2FuY2VsRWRpdENyZWF0aW9uTmFtZScpXG4gICAgdmlld01vZGVsLm1ldGFkYXRhLm5hbWUob3JpZ2luYWxWYWx1ZSlcbiAgICBvcmlnaW5hbFZhbHVlID0gJydcbiAgICB2aWV3TW9kZWwudGl0bGVNb2RlKCdzaG93JylcbiAgfVxuXG4gIHZpZXdNb2RlbC5zYXZlRWRpdENyZWF0aW9uTmFtZSAgPSBmdW5jdGlvbiAoZGF0YSwgZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZygnc2F2ZUVkaXRDcmVhdGlvbk5hbWUnLCB2aWV3TW9kZWwubWV0YWRhdGEubmFtZSgpKVxuICAgIHZpZXdNb2RlbC50aXRsZU1vZGUoJ3NhdmluZycpXG4gICAgdmlld01vZGVsLm5vdGlmaWVyLmluZm8odmlld01vZGVsLnQoJ2VkaXQtdGl0bGUtYWpheC1wZW5kaW5nJykpXG5cbiAgICAkLmFqYXgoe1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIHVybDogICAgdmlld01vZGVsLm1ldGFkYXRhLnVybC51cGRhdGUsXG4gICAgICBkYXRhOiAgIHtcbiAgICAgICAgbmFtZTogdmlld01vZGVsLm1ldGFkYXRhLm5hbWUoKSxcbiAgICAgIH0sXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5zdWNjZXNzKHZpZXdNb2RlbC50KCdlZGl0LXRpdGxlLWFqYXgtc3VjY2VzcycpKVxuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5lcnJvcih2aWV3TW9kZWwudCgnZWRpdC10aXRsZS1hamF4LWZhaWwnKSlcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBvcmlnaW5hbFZhbHVlID0gJydcbiAgICAgICAgdmlld01vZGVsLnRpdGxlTW9kZSgnc2hvdycpXG4gICAgICB9LFxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVDcmVhdGlvbk5hbWVcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIga28gICAgICAgICAgICA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpXG52YXIgdXJsICAgICAgICAgICA9IHJlcXVpcmUoJ3VybCcpXG52YXIgc2x1Z0ZpbGVuYW1lICA9IHJlcXVpcmUoJy4uLy4uLy4uL3NoYXJlZC9zbHVnLWZpbGVuYW1lLmpzJylcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZvaWRsYWJzL21vc2FpY28vd2lraS9Nb3NhaWNvLVBsdWdpbnNcblxuLy8vLy8vXG4vLyBWSUVXLU1PREVMIFBMVUdJTlNcbi8vLy8vL1xuXG52YXIgc2VydmVyU3RvcmFnZSA9IHJlcXVpcmUoJy4vYmFkc2VuZGVyLXNlcnZlci1zdG9yYWdlJylcbnZhciBlZGl0VGl0bGUgICAgID0gcmVxdWlyZSgnLi9iYWRzZW5kZXItZWRpdC10aXRsZScpXG5cbmZ1bmN0aW9uIHNldEVkaXRvckljb24odmlld01vZGVsKSB7XG4gIHZpZXdNb2RlbC5sb2dvUGF0aCAgPSAnL21lZGlhL2VkaXRvci1pY29uLnBuZydcbiAgdmlld01vZGVsLmxvZ29VcmwgICA9ICcvJ1xuICB2aWV3TW9kZWwubG9nb0FsdCAgID0gJ0JhZHNlbmRlcidcbn1cblxuZnVuY3Rpb24gZXh0ZW5kVmlld01vZGVsKG9wdHMsIGN1c3RvbUV4dGVuc2lvbnMpIHtcbiAgY3VzdG9tRXh0ZW5zaW9ucy5wdXNoKHNlcnZlclN0b3JhZ2UpXG4gIGN1c3RvbUV4dGVuc2lvbnMucHVzaChzZXRFZGl0b3JJY29uKVxuICBjdXN0b21FeHRlbnNpb25zLnB1c2goZWRpdFRpdGxlKVxufVxuXG4vLyBPUFRJT05TXG5cbnZhciB0aW55bWNlQ29uZmlnRnVsbCA9IHtcbiAgdG9vbGJhcjE6ICdib2xkIGl0YWxpYyBmb3JlY29sb3IgYmFja2NvbG9yIGhyIGZvbnRzaXplc2VsZWN0IHN0eWxlc2VsZWN0IHJlbW92ZWZvcm1hdCB8IGxpbmsgdW5saW5rIHwgcGFzdGV0ZXh0IGNvZGUnLFxuICAvLy0gZm9udC1zaXplIHNlbGVjdFxuICAvLy0gaHR0cHM6Ly93d3cudGlueW1jZS5jb20vZG9jcy9jb25maWd1cmUvY29udGVudC1mb3JtYXR0aW5nLyNmb250c2l6ZV9mb3JtYXRzXG4gIGZvbnRzaXplX2Zvcm1hdHM6ICc4cHggMTBweCAxMnB4IDE0cHggMThweCAyNHB4IDM2cHgnLFxuICAvLy0gYWRkIGNvbG9ycGlja2VyXG4gIC8vLSBodHRwczovL3d3dy50aW55bWNlLmNvbS9kb2NzL3BsdWdpbnMvY29sb3JwaWNrZXIvXG4gIHBsdWdpbnM6IFtcImxpbmsgaHIgcGFzdGUgbGlzdHMgdGV4dGNvbG9yIGNvbG9ycGlja2VyIGNvZGVcIl0sXG4gIC8vLSBodHRwczovL3d3dy50aW55bWNlLmNvbS9kb2NzL2NvbmZpZ3VyZS9jb250ZW50LWZvcm1hdHRpbmcvI3N0eWxlX2Zvcm1hdHNcbiAgc3R5bGVfZm9ybWF0czogW1xuICAgIHt0aXRsZTogJ0lubGluZScsIGl0ZW1zOiBbXG4gICAgICB7dGl0bGU6ICdCb2xkJyAgICAgICAgICwgaWNvbjogXCJib2xkXCIgICAgICAgICAsIGlubGluZTogJ3N0cm9uZyd9LFxuICAgICAge3RpdGxlOiAnSXRhbGljJyAgICAgICAsIGljb246IFwiaXRhbGljXCIgICAgICAgLCBpbmxpbmU6ICdlbSd9LFxuICAgICAge3RpdGxlOiAnVW5kZXJsaW5lJyAgICAsIGljb246IFwidW5kZXJsaW5lXCIgICAgLCBpbmxpbmU6ICdzcGFuJywgc3R5bGVzOiB7J3RleHQtZGVjb3JhdGlvbicgOiAndW5kZXJsaW5lJ319LFxuICAgICAge3RpdGxlOiAnU3RyaWtldGhyb3VnaCcsIGljb246IFwic3RyaWtldGhyb3VnaFwiLCBpbmxpbmU6ICdzcGFuJywgc3R5bGVzOiB7J3RleHQtZGVjb3JhdGlvbicgOiAnbGluZS10aHJvdWdoJ319LFxuICAgICAge3RpdGxlOiAnU3VwZXJzY3JpcHQnICAsIGljb246IFwic3VwZXJzY3JpcHRcIiAgLCBpbmxpbmU6ICdzdXAnfSxcbiAgICAgIHt0aXRsZTogJ1N1YnNjcmlwdCcgICAgLCBpY29uOiBcInN1YnNjcmlwdFwiICAgICwgaW5saW5lOiAnc3ViJ30sXG4gICAgICB7dGl0bGU6ICdDb2RlJyAgICAgICAgICwgaWNvbjogXCJjb2RlXCIgICAgICAgICAsIGlubGluZTogJ2NvZGUnfSxcbiAgICBdfSxcbiAgICB7dGl0bGU6ICdBbGlnbm1lbnQnLCBpdGVtczogW1xuICAgICAge3RpdGxlOiAnTGVmdCcgICAsIGljb246IFwiYWxpZ25sZWZ0XCIgICAsIGJsb2NrOiAnZGl2Jywgc3R5bGVzOiB7J3RleHQtYWxpZ24nIDogJ2xlZnQnfX0sXG4gICAgICB7dGl0bGU6ICdDZW50ZXInICwgaWNvbjogXCJhbGlnbmNlbnRlclwiICwgYmxvY2s6ICdkaXYnLCBzdHlsZXM6IHsndGV4dC1hbGlnbicgOiAnY2VudGVyJ319LFxuICAgICAge3RpdGxlOiAnUmlnaHQnICAsIGljb246IFwiYWxpZ25yaWdodFwiICAsIGJsb2NrOiAnZGl2Jywgc3R5bGVzOiB7J3RleHQtYWxpZ24nIDogJ3JpZ2h0J319LFxuICAgICAge3RpdGxlOiAnSnVzdGlmeScsIGljb246IFwiYWxpZ25qdXN0aWZ5XCIsIGJsb2NrOiAnZGl2Jywgc3R5bGVzOiB7J3RleHQtYWxpZ24nIDogJ2p1c3RpZnknfX0sXG4gICAgXX0sXG4gIF0sXG59XG5cbi8vLy8vL1xuLy8gS05PQ0tPVVQgRVhURU5EXG4vLy8vLy9cblxuZnVuY3Rpb24gdGVtcGxhdGVVcmxDb252ZXJ0ZXIob3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24gYmFkc2VuZGVyVGVtcGxhdGVVcmxDb252ZXJ0ZXIodXJsKSB7XG4gICAgaWYgKCF1cmwpIHJldHVybiBudWxsXG4gICAgLy8gaGFuZGxlOiBbdW5zdWJzY3JpYmVfbGlua10gb3IgbWFpbHRvOlttYWlsXVxuICAgIGlmICgvXFxdJC8udGVzdCh1cmwpKSByZXR1cm4gbnVsbFxuICAgIC8vIGhhbmRsZSBhYnNvbHV0ZSB1cmw6IGh0dHBcbiAgICBpZiAoL15odHRwLy50ZXN0KHVybCkpIHJldHVybiBudWxsXG4gICAgLy8gaGFuZGxlIEVTUCB0YWdzOiBpbiBVUkwgPCVcbiAgICBpZiAoLzwlLy50ZXN0KHVybCkpIHJldHVybiBudWxsXG4gICAgLy8gaGFuZGxlIG90aGVyIHVybHM6IGltZy9zb2NpYWxfZGVmL3R3aXR0ZXJfb2sucG5nXG4gICAgdmFyIHVybFJlZ2V4cCAgICAgICA9IC8oW15cXC9dKikkL1xuICAgIHZhciBleHRlbnRpb25SZWdleHAgPSAvXFwuWzAtOWEtel0rJC9cbiAgICAvLyBhcyBpdCBpcyBkb25lLCBhbGwgZmlsZXMgYXJlIGZsYXR0ZW4gaW4gYXNzZXQgZm9sZGVyICh1cGxvYWRzIG9yIFMzKVxuICAgIHVybCA9IHVybFJlZ2V4cC5leGVjKHVybClbMV1cbiAgICAvLyBoYW5kbGUgZXZlcnkgb3RoZXIgY2FzZTpcbiAgICAvLyAgICp8VU5TVUJ8KlxuICAgIC8vICAgI3BvdWljXG4gICAgaWYgKCFleHRlbnRpb25SZWdleHAudGVzdCh1cmwpKSByZXR1cm4gbnVsbFxuICAgIC8vIEFsbCBpbWFnZXMgYXQgdXBsb2FkIGFyZSBzbHVnZ2VkXG4gICAgLy8gICAgYmxvY2sgdGh1bWJuYWlscyBhcmUgYmFzZWQgb24gaHRtbCBibG9jayBJRFxuICAgIC8vICAgIHdlIG5lZWQgdG8gcmV0cmVpdmUgdGhlIGZpbGUgdXJsIGJ5IHNsdWdnaW5nIHRoZSBpZFxuICAgIC8vIFRoZSBzYW1lIGFwcGxpZXMgZm9yIHVwbG9hZGVkIHJlc291cmNlcyBpbWFnZXM6XG4gICAgLy8gICAgaHRtbCBpbWcgc3JjIG1heSBkaWZmZXIgZnJvbSB1cGxvYWRlZCBuYW1lc1xuICAgIHVybCA9IHNsdWdGaWxlbmFtZSh1cmwpXG4gICAgdXJsID0gb3B0cy5pbWdQcm9jZXNzb3JCYWNrZW5kICsgb3B0cy5tZXRhZGF0YS5fd2lyZWZyYW1lICArICctJyArIHVybFxuICAgIHJldHVybiB1cmxcbiAgfVxufVxuXG4vLyBrbm9ja291dCBpcyBhIGdsb2JhbCBvYmplY3QuXG4vLyBTbyB3ZSBjYW4gZXh0ZW5kIGl0IGVhc2lseVxuXG4vLyB0aGlzIGVxdWl2YWxlbnQgdG8gdGhlIG9yaWdpbmFsIGFwcC5qcyNhcHBseUJpbmRpbmdPcHRpb25zXG5mdW5jdGlvbiBleHRlbmRLbm9ja291dChvcHRzKSB7XG5cbiAgLy8gQ2hhbmdlIHRpbnlNQ0UgZnVsbCBlZGl0b3Igb3B0aW9uc1xuICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5mdWxsT3B0aW9ucyA9IHRpbnltY2VDb25maWdGdWxsXG5cbiAgLy8gVGhpcyBpcyBub3QgdXNlZCBieSBrbm9ja291dCBwZXIgc2UuXG4gIC8vIFN0b3JlIHRoaXMgZnVuY3Rpb24gaW4gS08gZ2xvYmFsIG9iamVjdCBzbyBpdCBjYW4gYmUgYWNjZXNzZWQgYnkgdGVtcGxhdGUtbG9hZGVyLmpzI3RlbXBsYXRlTG9hZGVyXG4gIC8vIGJhZHNlbmRlclRlbXBsYXRlVXJsQ29udmVydGVyIGlzIHVzZWQ6XG4gIC8vICAtIGZvciBwcmV2aWV3IGltYWdlcyBvbiBsZWZ0IGJhclxuICAvLyAgLSBmb3Igc3RhdGljIGxpbmtzIGluIHRlbXBsYXRlc1xuICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1NyYy50ZW1wbGF0ZVVybENvbnZlcnRlciA9IHRlbXBsYXRlVXJsQ29udmVydGVyKG9wdHMpXG5cbiAgLy8gb3B0aW9ucyBoYXZlIGJlZW4gc2V0IGluIHRoZSBlZGl0b3IgdGVtcGxhdGVcbiAgdmFyIGltZ1Byb2Nlc3NvckJhY2tlbmQgPSB1cmwucGFyc2Uob3B0cy5pbWdQcm9jZXNzb3JCYWNrZW5kKVxuXG4gIC8vIHNlbmQgdGhlIG5vbi1yZXNpemVkIGltYWdlIHVybFxuICBrby5iaW5kaW5nSGFuZGxlcnMuZmlsZXVwbG9hZC5yZW1vdGVGaWxlUHJlcHJvY2Vzc29yID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBjb25zb2xlLmluZm8oJ1JFTU9URSBGSUxFIFBSRVBST0NFU1NPUicpXG4gICAgY29uc29sZS5sb2coZmlsZSlcbiAgICB2YXIgZmlsZVVybCA9IHVybC5mb3JtYXQoe1xuICAgICAgcHJvdG9jb2w6IGltZ1Byb2Nlc3NvckJhY2tlbmQucHJvdG9jb2wsXG4gICAgICBob3N0OiAgICAgaW1nUHJvY2Vzc29yQmFja2VuZC5ob3N0LFxuICAgICAgcGF0aG5hbWU6IGltZ1Byb2Nlc3NvckJhY2tlbmQucGF0aG5hbWUsXG4gICAgfSk7XG4gICAgZmlsZS51cmwgPSB1cmwucmVzb2x2ZShmaWxlVXJsLCB1cmwucGFyc2UoZmlsZS51cmwpLnBhdGhuYW1lKVxuICAgIHJldHVybiBmaWxlXG4gIH1cblxuICAvLyBwdXNoIFwiY29udmVydGVkVXJsXCIgbWV0aG9kIHRvIHRoZSB3eXNpd3lnU3JjIGJpbmRpbmdcbiAga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMuY29udmVydGVkVXJsID0gZnVuY3Rpb24oc3JjLCBtZXRob2QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaW1hZ2VOYW1lID0gdXJsLnBhcnNlKHNyYykucGF0aG5hbWVcbiAgICBpZiAoIWltYWdlTmFtZSkgY29uc29sZS53YXJuKCdubyBwYXRobmFtZSBmb3IgaW1hZ2UnLCBzcmMpXG4gICAgY29uc29sZS5pbmZvKCdDT05WRVJURUQgVVJMJywgaW1hZ2VOYW1lLCBtZXRob2QsIHdpZHRoLCBoZWlnaHQpXG4gICAgaW1hZ2VOYW1lICAgICA9IGltYWdlTmFtZS5yZXBsYWNlKCcvaW1nLycsICcnKVxuICAgIHZhciBwYXRoICAgICAgPSBvcHRzLmJhc2VQYXRoICsgJy8nICsgbWV0aG9kXG4gICAgcGF0aCAgICAgICAgICA9IHBhdGggKyAnLycgKyB3aWR0aCArICd4JyArIGhlaWdodCArICcvJyArIGltYWdlTmFtZVxuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1NyYy5wbGFjZWhvbGRlclVybCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHRleHQpIHtcbiAgICAvLyBjb25zb2xlLmluZm8oJ1BMQUNFSE9MREVSIFVSTCcsIHdpZHRoLCBoZWlnaHQsIHRleHQpXG4gICAgcmV0dXJuIG9wdHMuYmFzZVBhdGggKyAnL3BsYWNlaG9sZGVyLycgKyB3aWR0aCArICd4JyArIGhlaWdodCArICcucG5nJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHRlbmRWaWV3TW9kZWw6ICBleHRlbmRWaWV3TW9kZWwsXG4gIGV4dGVuZEtub2Nrb3V0OiAgIGV4dGVuZEtub2Nrb3V0LFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIilcbnZhciAkICAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKVxudmFyIGtvICAgICAgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKVxudmFyIF9vbWl0ICAgPSByZXF1aXJlKCdsb2Rhc2gub21pdCcpXG52YXIgaXNFbWFpbCA9IHJlcXVpcmUoJ3ZhbGlkYXRvci9saWIvaXNFbWFpbCcpXG5cbmZ1bmN0aW9uIGdldERhdGEodmlld01vZGVsKSB7XG4gIC8vIGdhdGhlciBtZXRhXG4gIC8vIHJlbW92ZSBrZXlzIHRoYXQgYXJlbid0IG5lY2Vzc2FyeSB0byB1cGRhdGVcbiAgdmFyIGRhdGFzICA9IF9vbWl0KGtvLnRvSlModmlld01vZGVsLm1ldGFkYXRhKSwgWyd1cmxDb252ZXJ0ZXInLCAndGVtcGxhdGUnXSlcbiAgZGF0YXMuZGF0YSA9IHZpZXdNb2RlbC5leHBvcnRKUygpXG4gIHJldHVybiBkYXRhc1xufVxuXG52YXIgbG9hZGVyID0gZnVuY3Rpb24gKHZpZXdNb2RlbCkge1xuICBjb25zb2xlLmluZm8oJ2luaXQgc2VydmVyIHN0b3JhZ2UgKHNhdmUsIHRlc3QsIGRvd25sb2FkKScpXG5cbiAgdmFyIHNhdmVDbWQgPSB7XG4gICAgbmFtZTogJ1NhdmUnLCAvLyBsMTBuIGhhcHBlbnMgaW4gdGhlIHRlbXBsYXRlXG4gICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICB9O1xuICBzYXZlQ21kLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICBzYXZlQ21kLmVuYWJsZWQoZmFsc2UpO1xuICAgIHZhciBkYXRhID0gZ2V0RGF0YSh2aWV3TW9kZWwpXG4gICAgY29uc29sZS5pbmZvKCdTQVZFIERBVEEnKVxuICAgIGNvbnNvbGUubG9nKGRhdGEpXG5cbiAgICAvLyBmb3JjZSBKU09OIGZvciBib2R5cGFyc2VyIHRvIGNhdGNoIHVwXG4gICAgLy8gPT4ga2VlcCB0eXBlcyBzZXJ2ZXIgc2lkZVxuICAgICQuYWpheCh7XG4gICAgICB1cmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgbWV0aG9kOiAgICAgICAnUE9TVCcsXG4gICAgICBjb250ZW50VHlwZTogICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIGRhdGE6ICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICBzdWNjZXNzOiAgICAgIG9uUG9zdFN1Y2Nlc3MsXG4gICAgICBlcnJvcjogICAgICAgIG9uUG9zdEVycm9yLFxuICAgICAgY29tcGxldGU6ICAgICBvblBvc3RDb21wbGV0ZSxcbiAgICB9KVxuXG4gICAgLy8gdXNlIGNhbGxiYWNrIGZvciBlYXNpZXIgalF1ZXJ5IHVwZGF0ZXNcbiAgICAvLyA9PiBEZXByZWNhdGlvbiBub3RpY2UgZm9yIC5zdWNjZXNzKCksIC5lcnJvcigpLCBhbmQgLmNvbXBsZXRlKClcbiAgICBmdW5jdGlvbiBvblBvc3RTdWNjZXNzKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICBjb25zb2xlLmxvZygnc2F2ZSBzdWNjZXNzJylcbiAgICAgIGlmIChkYXRhLm1ldGEucmVkaXJlY3QpIHtcbiAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICdlZGl0b3InLCBkYXRhLm1ldGEucmVkaXJlY3QpXG4gICAgICB9XG4gICAgICB2aWV3TW9kZWwubm90aWZpZXIuc3VjY2Vzcyh2aWV3TW9kZWwudChcIkNyZWF0aW9uIGhhcyBiZWVuIHNhdmVkXCIpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUG9zdEVycm9yKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgY29uc29sZS5sb2coJ3NhdmUgZXJyb3InKVxuICAgICAgY29uc29sZS5sb2coZXJyb3JUaHJvd24pXG4gICAgICB2aWV3TW9kZWwubm90aWZpZXIuZXJyb3Iodmlld01vZGVsLnQoXCJTYXZlIGVycmlyXCIpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUG9zdENvbXBsZXRlKCkge1xuICAgICAgc2F2ZUNtZC5lbmFibGVkKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZXN0Q21kID0ge1xuICAgIG5hbWU6ICdUZXN0JywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgIGVuYWJsZWQ6IGtvLm9ic2VydmFibGUodHJ1ZSlcbiAgfVxuICB0ZXN0Q21kLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmluZm8oJ1RFU1QnKVxuICAgIHRlc3RDbWQuZW5hYmxlZChmYWxzZSlcbiAgICB2YXIgZW1haWwgPSB2aWV3TW9kZWwudCgnSW5zZXJ0IGhlcmUgdGhlIHJlY2lwaWVudCBlbWFpbCBhZGRyZXNzJylcbiAgICBlbWFpbCAgICAgPSBnbG9iYWwucHJvbXB0KHZpZXdNb2RlbC50KFwiVGVzdCBlbWFpbCBhZGRyZXNzXCIpLCBlbWFpbClcblxuICAgIGlmICghaXNFbWFpbChlbWFpbCkpIHtcbiAgICAgIGdsb2JhbC5hbGVydCh2aWV3TW9kZWwudCgnSW52YWxpZCBlbWFpbCBhZGRyZXNzJykpO1xuICAgICAgcmV0dXJuIHRlc3RDbWQuZW5hYmxlZCh0cnVlKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiVE9ETyB0ZXN0aW5nLi4uXCIsIGVtYWlsKVxuICAgIHZhciBtZXRhZGF0YSAgPSBrby50b0pTKHZpZXdNb2RlbC5tZXRhZGF0YSlcbiAgICB2YXIgZGF0YXMgICAgID0ge1xuICAgICAgYWN0aW9uOiAgICdlbWFpbCcsXG4gICAgICByY3B0OiAgICAgZW1haWwsXG4gICAgICBzdWJqZWN0OiAgJ1t0ZXN0XSAnICsgbWV0YWRhdGEuaWQsXG4gICAgICBodG1sOiAgICAgdmlld01vZGVsLmV4cG9ydEhUTUwoKVxuICAgIH1cbiAgICAkLmFqYXgoe1xuICAgICAgdXJsOiAgICAgICAgICAvZGwvLFxuICAgICAgbWV0aG9kOiAgICAgICAnUE9TVCcsXG4gICAgICBkYXRhOiAgICAgICAgIGRhdGFzLFxuICAgICAgc3VjY2VzczogICAgICBvblRlc3RTdWNjZXNzLFxuICAgICAgZXJyb3I6ICAgICAgICBvblRlc3RFcnJvcixcbiAgICAgIGNvbXBsZXRlOiAgICAgb25UZXN0Q29tcGxldGUsXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIG9uVGVzdFN1Y2Nlc3MoZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd0ZXN0IHN1Y2Nlc3MnKVxuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLnN1Y2Nlc3Modmlld01vZGVsLnQoXCJUZXN0IGVtYWlsIHNlbnQuLi5cIikpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25UZXN0RXJyb3IoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICBjb25zb2xlLmxvZygndGVzdCBlcnJvcicpXG4gICAgICBjb25zb2xlLmxvZyhlcnJvclRocm93bilcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5lcnJvcih2aWV3TW9kZWwudCgnVW5leHBlY3RlZCBlcnJvciB0YWxraW5nIHRvIHNlcnZlcjogY29udGFjdCB1cyEnKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRlc3RDb21wbGV0ZSgpIHtcbiAgICAgIHRlc3RDbWQuZW5hYmxlZCh0cnVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZG93bmxvYWRDbWQgPSB7XG4gICAgbmFtZTogJ0Rvd25sb2FkJywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgIGVuYWJsZWQ6IGtvLm9ic2VydmFibGUodHJ1ZSlcbiAgfVxuICBkb3dubG9hZENtZC5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5pbmZvKCdET1dOTE9BRCcpXG4gICAgZG93bmxvYWRDbWQuZW5hYmxlZChmYWxzZSlcbiAgICB2aWV3TW9kZWwubm90aWZpZXIuaW5mbyh2aWV3TW9kZWwudChcIkRvd25sb2FkaW5nLi4uXCIpKVxuICAgIHZpZXdNb2RlbC5leHBvcnRIVE1MdG9UZXh0YXJlYSgnI2Rvd25sb2FkSHRtbFRleHRhcmVhJylcbiAgICAkKCcjZG93bmxvYWRIdG1sRmlsZW5hbWUnKS52YWwodmlld01vZGVsLm1ldGFkYXRhLm5hbWUoKSlcbiAgICAkKCcjZG93bmxvYWRGb3JtJylcbiAgICAuYXR0cignYWN0aW9uJywgJy9kbC8nKVxuICAgIC5zdWJtaXQoKVxuICAgIGRvd25sb2FkQ21kLmVuYWJsZWQodHJ1ZSlcbiAgfVxuXG4gIHZpZXdNb2RlbC5zYXZlICAgICAgPSBzYXZlQ21kXG4gIHZpZXdNb2RlbC50ZXN0ICAgICAgPSB0ZXN0Q21kXG4gIHZpZXdNb2RlbC5kb3dubG9hZCAgPSBkb3dubG9hZENtZFxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9hZGVyO1xuIiwidmFyIHRpbnljb2xvciA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvdGlueWNvbG9yL3Rpbnljb2xvci5qc1wiKTtcblxuZnVuY3Rpb24gQ29sb3IodGlueWNvbG9yKSB7XG4gIHRoaXMuZ2V0QnJpZ2h0bmVzcyA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZ2V0QnJpZ2h0bmVzcygpO1xuICB9O1xuICB0aGlzLmlzTGlnaHQgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmlzTGlnaHQoKTtcbiAgfTtcbiAgdGhpcy5pc0RhcmsgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmlzRGFyaygpO1xuICB9O1xuICB0aGlzLmdldEx1bWluYW5jZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZ2V0THVtaW5hbmNlKCk7XG4gIH07XG5cblxuICB0aGlzLmxpZ2h0ZW4gPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikubGlnaHRlbihhbW91bnQpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIHRoaXMuYnJpZ2h0ZW4gPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuYnJpZ2h0ZW4oYW1vdW50KS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLmRhcmtlbiA9IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5kYXJrZW4oYW1vdW50KS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLmRlc2F0dXJhdGUgPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZGVzYXR1cmF0ZShhbW91bnQpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIHRoaXMuc2F0dXJhdGUgPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuc2F0dXJhdGUoYW1vdW50KS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLmdyZXlzY2FsZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZ3JleXNjYWxlKCkudG9IZXhTdHJpbmcoKTtcbiAgfTtcbiAgdGhpcy5zcGluID0gZnVuY3Rpb24oY29sb3IsIGFtb3VudCkge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLnNwaW4oYW1vdW50KS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLmNvbXBsZW1lbnQgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmNvbXBsZW1lbnQoKS50b0hleFN0cmluZygpO1xuICB9O1xuXG4gIHRoaXMubWl4ID0gdGlueWNvbG9yLm1peDtcbiAgdGhpcy5yZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eTtcbiAgdGhpcy5pc1JlYWRhYmxlID0gdGlueWNvbG9yLmlzUmVhZGFibGU7XG4gIHRoaXMubW9zdFJlYWRhYmxlID0gdGlueWNvbG9yLm1vc3RSZWFkYWJsZTtcbn1cblxudmFyIGNvbG9yUGx1Z2luID0gZnVuY3Rpb24odm0pIHtcbiAgZ2xvYmFsLkNvbG9yID0gbmV3IENvbG9yKHRpbnljb2xvcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbG9yUGx1Z2luOyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UgKi9cbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIgaW5saW5lRG9jdW1lbnQgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2p1aWNlL2xpYi9pbmxpbmVcIikoe30pLmlubGluZURvY3VtZW50O1xuXG52YXIgaW5saW5lclBsdWdpbiA9IGZ1bmN0aW9uKHZtKSB7XG4gIHZtLmlubGluZSA9IGZ1bmN0aW9uKGRvYykge1xuICAgIHZhciBzdHlsZSA9IFtdO1xuICAgICQoJ3N0eWxlW2RhdGEtaW5saW5lPVwidHJ1ZVwiXScsIGRvYykuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSAkKGVsZW1lbnQpLmh0bWwoKTtcbiAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzwhLS0ga28gKCg/IS0tKS4pKj8gLS0+L2csICcnKTsgLy8gdGhpcyByZXBsYWNlcyB0aGUgYWJvdmUgd2l0aCBhIG1vcmUgZm9ybWFsIChidXQgc2xvd2VyKSBzb2x1dGlvblxuICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvPCEtLSBcXC9rbyAtLT4vZywgJycpO1xuICAgICAgc3R5bGUucHVzaChjb250ZW50KTtcbiAgICAgICQoZWxlbWVudCkucmVtb3ZlQXR0cignZGF0YS1pbmxpbmUnKTtcbiAgICB9KTtcbiAgICB2YXIgc3R5bGVUZXh0ID0gc3R5bGUuam9pbihcIlxcblwiKTtcbiAgICB2YXIgJGNvbnRleHQgPSBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09ICd1bmRlZmluZWQnKSBjb250ZXh0ID0gZG9jO1xuICAgICAgcmV0dXJuICQoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgIH07XG4gICAgJGNvbnRleHQucm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICQoJzpyb290JywgZG9jKTtcbiAgICB9O1xuICAgIGlubGluZURvY3VtZW50KCRjb250ZXh0LCBzdHlsZVRleHQsIHsgc3R5bGVBdHRyaWJ1dGVOYW1lOiAncmVwbGFjZWRzdHlsZScgfSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlubGluZXJQbHVnaW47IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xuXG5pZiAoZmFsc2UpIHtcblxudmFyIGxzTG9hZGVyID0gZnVuY3Rpb24oaGFzaF9rZXksIGVtYWlsUHJvY2Vzc29yQmFja2VuZCkge1xuICB2YXIgbWRTdHIgPSBnbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtZXRhZGF0YS1cIiArIGhhc2hfa2V5KTtcbiAgaWYgKG1kU3RyICE9PSBudWxsKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHZhciB0ZCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRlbXBsYXRlLVwiICsgaGFzaF9rZXkpO1xuICAgIGlmICh0ZCAhPT0gbnVsbCkgbW9kZWwgPSBKU09OLnBhcnNlKHRkKTtcbiAgICB2YXIgbWQgPSBKU09OLnBhcnNlKG1kU3RyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IG1kLFxuICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgZXh0ZW5zaW9uOiBsc0NvbW1hbmRQbHVnaW5GYWN0b3J5KG1kLCBlbWFpbFByb2Nlc3NvckJhY2tlbmQpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIkNhbm5vdCBmaW5kIHN0b3JlZCBkYXRhIGZvciBcIitoYXNoX2tleTtcbiAgfVxufTtcblxudmFyIGxzQ29tbWFuZFBsdWdpbkZhY3RvcnkgPSBmdW5jdGlvbihtZCwgZW1haWxQcm9jZXNzb3JCYWNrZW5kKSB7XG4gIHZhciBjb21tYW5kc1BsdWdpbiA9IGZ1bmN0aW9uKG1ka2V5LCBtZG5hbWUsIHZpZXdNb2RlbCkge1xuXG4gICAgLy8gY29uc29sZS5sb2coXCJsb2FkaW5nIGZyb20gbWV0YWRhdGFcIiwgbWQsIG1vZGVsKTtcbiAgICB2YXIgc2F2ZUNtZCA9IHtcbiAgICAgIG5hbWU6ICdTYXZlJywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgc2F2ZUNtZC5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBzYXZlQ21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmlld01vZGVsLm1ldGFkYXRhLmNoYW5nZWQgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKHR5cGVvZiB2aWV3TW9kZWwubWV0YWRhdGEua2V5ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBmaW5kIGtldCBpbiBtZXRhZGF0YSBvYmplY3QuLi5cIiwgdmlld01vZGVsLm1ldGFkYXRhKTtcbiAgICAgICAgdmlld01vZGVsLm1ldGFkYXRhLmtleSA9IG1ka2V5O1xuICAgICAgfVxuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWV0YWRhdGEtXCIgKyBtZGtleSwgdmlld01vZGVsLmV4cG9ydE1ldGFkYXRhKCkpO1xuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidGVtcGxhdGUtXCIgKyBtZGtleSwgdmlld01vZGVsLmV4cG9ydEpTT04oKSk7XG4gICAgICBzYXZlQ21kLmVuYWJsZWQodHJ1ZSk7XG4gICAgfTtcbiAgICB2YXIgdGVzdENtZCA9IHtcbiAgICAgIG5hbWU6ICdUZXN0JywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgdmFyIGRvd25sb2FkQ21kID0ge1xuICAgICAgbmFtZTogJ0Rvd25sb2FkJywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgdGVzdENtZC5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0ZXN0Q21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmFyIGVtYWlsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidGVzdGVtYWlsXCIpO1xuICAgICAgaWYgKGVtYWlsID09PSBudWxsIHx8IGVtYWlsID09ICdudWxsJykgZW1haWwgPSB2aWV3TW9kZWwudCgnSW5zZXJ0IGhlcmUgdGhlIHJlY2lwaWVudCBlbWFpbCBhZGRyZXNzJyk7XG4gICAgICBlbWFpbCA9IGdsb2JhbC5wcm9tcHQodmlld01vZGVsLnQoXCJUZXN0IGVtYWlsIGFkZHJlc3NcIiksIGVtYWlsKTtcbiAgICAgIGlmIChlbWFpbC5tYXRjaCgvQC8pKSB7XG4gICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRlc3RlbWFpbFwiLCBlbWFpbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyB0ZXN0aW5nLi4uXCIsIGVtYWlsKTtcbiAgICAgICAgdmFyIHBvc3RVcmwgPSBlbWFpbFByb2Nlc3NvckJhY2tlbmQgPyBlbWFpbFByb2Nlc3NvckJhY2tlbmQgOiAnL2RsLyc7XG4gICAgICAgIHZhciBwb3N0ID0gJC5wb3N0KHBvc3RVcmwsIHtcbiAgICAgICAgICBhY3Rpb246ICdlbWFpbCcsXG4gICAgICAgICAgcmNwdDogZW1haWwsXG4gICAgICAgICAgc3ViamVjdDogXCJbdGVzdF0gXCIgKyBtZGtleSArIFwiIC0gXCIgKyBtZG5hbWUsXG4gICAgICAgICAgaHRtbDogdmlld01vZGVsLmV4cG9ydEhUTUwoKVxuICAgICAgICB9LCBudWxsLCAnaHRtbCcpO1xuICAgICAgICBwb3N0LmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKHZpZXdNb2RlbC50KCdVbmV4cGVjdGVkIGVycm9yIHRhbGtpbmcgdG8gc2VydmVyOiBjb250YWN0IHVzIScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvc3Quc3VjY2VzcyhmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInN1Y2Nlc3NcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgICB2aWV3TW9kZWwubm90aWZpZXIuc3VjY2Vzcyh2aWV3TW9kZWwudChcIlRlc3QgZW1haWwgc2VudC4uLlwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwb3N0LmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB0ZXN0Q21kLmVuYWJsZWQodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLmFsZXJ0KHZpZXdNb2RlbC50KCdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnKSk7XG4gICAgICAgIHRlc3RDbWQuZW5hYmxlZCh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGRvd25sb2FkQ21kLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRvd25sb2FkQ21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmluZm8odmlld01vZGVsLnQoXCJEb3dubG9hZGluZy4uLlwiKSk7XG4gICAgICB2aWV3TW9kZWwuZXhwb3J0SFRNTHRvVGV4dGFyZWEoJyNkb3dubG9hZEh0bWxUZXh0YXJlYScpO1xuICAgICAgdmFyIHBvc3RVcmwgPSBlbWFpbFByb2Nlc3NvckJhY2tlbmQgPyBlbWFpbFByb2Nlc3NvckJhY2tlbmQgOiAnL2RsLyc7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkRm9ybScpLnNldEF0dHJpYnV0ZShcImFjdGlvblwiLCBwb3N0VXJsKTtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWRGb3JtJykuc3VibWl0KCk7XG4gICAgICBkb3dubG9hZENtZC5lbmFibGVkKHRydWUpO1xuICAgIH07XG5cbiAgICB2aWV3TW9kZWwuc2F2ZSA9IHNhdmVDbWQ7XG4gICAgdmlld01vZGVsLnRlc3QgPSB0ZXN0Q21kO1xuICAgIHZpZXdNb2RlbC5kb3dubG9hZCA9IGRvd25sb2FkQ21kO1xuICB9LmJpbmQodW5kZWZpbmVkLCBtZC5rZXksIG1kLm5hbWUpO1xuXG4gIHJldHVybiBjb21tYW5kc1BsdWdpbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbHNMb2FkZXI7XG5cbn0gZWxzZSBpZiAodHJ1ZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge31cblxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCIuLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMva25vY2tvdXQtc29ydGFibGUvYnVpbGQva25vY2tvdXQtc29ydGFibGUubWluLmpzXCIpO1xuXG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9qcXVlcnl1aS1zcGlubmVyLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvanF1ZXJ5dWktdGFicy5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL2NvbG9ycGlja2VyLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvYmxvY2tzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvY3NzdGV4dC5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL2JpbmQtaWZyYW1lLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZHJvcHBhYmxlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZmlsZXVwbG9hZC5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL3ZpcnR1YWxzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3Mvd3lzaXd5Z3MuanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9zY3JvbGxmaXguanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9pZi1zdWJzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZXh0c29ydGFibGVzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZXZlbnRhYmxlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvdG9vbHRpcHMuanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9leHRlbmRlci1wYWdpbmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvdmFsaWRhdGVkLXZhbHVlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3Mvc2Nyb2xsaW50b3ZpZXcuanNcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBrb2pxdWkgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna29qcXVpJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrb2pxdWknXSA6IG51bGwpOyAvLyBqdXN0IGZvciB0aGUgd2lkZ2V0IHBsdWdpbnNcbnZhciB0ZW1wbGF0ZUNvbnZlcnRlciA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlci9tYWluLmpzXCIpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBpbml0aWFsaXplVmlld21vZGVsID0gcmVxdWlyZShcIi4vdmlld21vZGVsLmpzXCIpO1xudmFyIHRlbXBsYXRlU3lzdGVtID0gcmVxdWlyZSgnLi9iaW5kaW5ncy9jaG9vc2UtdGVtcGxhdGUuanMnKTtcblxuLy8gY2FsbCBhIGdpdmVuIG1ldGhvZCBvbiBldmVyeSBwbHVnaW4gaW1wbGVtZW50aW5nIGl0LlxuLy8gc3VwcG9ydHMgYSBcInJldmVyc2VcIiBwYXJhbWV0ZXIgdG8gY2FsbCB0aGUgbWV0aG9kcyBmcm9tIHRoZSBsYXN0IG9uZSB0byB0aGUgZmlyc3Qgb25lLlxudmFyIHBsdWdpbnNDYWxsID0gZnVuY3Rpb24ocGx1Z2lucywgbWV0aG9kTmFtZSwgYXJncywgcmV2ZXJzZSkge1xuICB2YXIgc3RhcnQsIGVuZCwgZGlmZiwgcmVzLCByZXN1bHRzO1xuICByZXN1bHRzID0gW107XG4gIGlmICh0eXBlb2YgcmV2ZXJzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV2ZXJzZSkge1xuICAgIHN0YXJ0ID0gcGx1Z2lucy5sZW5ndGggLSAxO1xuICAgIGVuZCA9IDA7XG4gICAgZGlmZiA9IC0xO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gMDtcbiAgICBlbmQgPSBwbHVnaW5zLmxlbmd0aCAtIDE7XG4gICAgZGlmZiA9IDE7XG4gIH1cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpICE9IGVuZCArIGRpZmY7IGkgKz0gZGlmZikge1xuICAgIGlmICh0eXBlb2YgcGx1Z2luc1tpXVttZXRob2ROYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlcyA9IHBsdWdpbnNbaV1bbWV0aG9kTmFtZV0uYXBwbHkocGx1Z2luc1tpXSwgYXJncyk7XG4gICAgICBpZiAodHlwZW9mIHJlcyAhPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdHMucHVzaChyZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIHdvcmthcm91bmQgZm9yIGtub2Nrb3V0LWpxdWVyeXVpJ3MgYnV0dG9uc2V0L2J1dHRvbiBkaXNwb3NhbDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ndmFzL2tub2Nrb3V0LWpxdWVyeXVpL2lzc3Vlcy8yNVxudmFyIG9yaWdEaXNwb3NlQ2FsbGJhY2sgPSBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrO1xua28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayA9IGZ1bmN0aW9uKG5vZGUsIGNhbGxiYWNrKSB7XG4gIHZhciBuZXdDYWxsYmFjayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coXCJjb3VnaHQgZGlzcG9zZSBjYWxsYmFjayBleGNlcHRpb25cIiwgZSk7XG4gICAgfVxuICB9O1xuICBvcmlnRGlzcG9zZUNhbGxiYWNrKG5vZGUsIG5ld0NhbGxiYWNrKTtcbn07XG5cbnZhciBiaW5kaW5nUGx1Z2luTWFrZXIgPSBmdW5jdGlvbihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKSB7XG4gIHJldHVybiB7XG4gICAgdmlld01vZGVsOiBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ2FwcGx5QmluZGluZ3MnLCBrby5hcHBseUJpbmRpbmdzLmJpbmQodW5kZWZpbmVkLCB2aWV3TW9kZWwpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIsIGVyci5zdGFjayk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGVyZm9ybWFuY2VBd2FyZUNhbGxlcigndW5hcHBseUJpbmRpbmdzJywga28uY2xlYW5Ob2RlLmJpbmQodGhpcywgZ2xvYmFsLmRvY3VtZW50LmJvZHkpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIsIGVyci5zdGFjayk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG52YXIgdGVtcGxhdGVDcmVhdG9yID0gZnVuY3Rpb24odGVtcGxhdGVQbHVnaW4sIGh0bWxPckVsZW1lbnQsIG9wdGlvbmFsTmFtZSwgdGVtcGxhdGVNb2RlKSB7XG4gIHZhciB0bXBOYW1lID0gb3B0aW9uYWxOYW1lO1xuICBpZiAodHlwZW9mIG9wdGlvbmFsTmFtZSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGVtcGxhdGVNb2RlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBodG1sT3JFbGVtZW50ICE9ICdvYmplY3QnIHx8IGh0bWxPckVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdyZXBsYWNlZGh0bWwnKSB0bXBOYW1lICs9ICctJyArIHRlbXBsYXRlTW9kZTtcbiAgfVxuXG4gIHdoaWxlICh0eXBlb2YgdG1wTmFtZSA9PSAndW5kZWZpbmVkJyB8fCB0bXBOYW1lID09PSBudWxsIHx8IHRlbXBsYXRlUGx1Z2luLmV4aXN0cyh0bXBOYW1lKSkge1xuICAgIHRtcE5hbWUgPSAnYW5vbnltb3VzLScgKyBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogMTAwMDAwKSArIDEpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBodG1sT3JFbGVtZW50ID09ICdvYmplY3QnICYmIGh0bWxPckVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICdyZXBsYWNlZGh0bWwnKSB7XG4gICAgdmFyICRlbCA9ICQoaHRtbE9yRWxlbWVudCk7XG4gICAgdmFyICRoZWFkID0gJCgncmVwbGFjZWRoZWFkJywgJGVsKTtcbiAgICB2YXIgJGJvZHkgPSAkKCdyZXBsYWNlZGJvZHknLCAkZWwpO1xuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLWhlYWQnLCAkaGVhZC5odG1sKCkgfHwgJycpO1xuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLXNob3cnLCAkYm9keS5odG1sKCkgfHwgJycpO1xuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLXByZXZpZXcnLCAkZWwuaHRtbCgpKTtcbiAgICB0ZW1wbGF0ZVBsdWdpbi5hZGRlcih0bXBOYW1lICsgJy13eXNpd3lnJywgJGVsLmh0bWwoKSk7XG5cbiAgICAvLyAkaGVhZC5hdHRyKCdkYXRhLWJpbmQnLCAnYmxvY2s6IGNvbnRlbnQnKTtcbiAgICAkaGVhZC5jaGlsZHJlbigpLmRldGFjaCgpO1xuICAgICRoZWFkLmh0bWwoXCI8IS0tIGtvIGJsb2NrOiBjb250ZW50IC0tPjwhLS0gL2tvIC0tPlwiKTtcbiAgICAkaGVhZC5iZWZvcmUoJzwhLS0ga28gd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiBcXCdoZWFkXFwnIH0gLS0+Jyk7XG4gICAgJGhlYWQuYWZ0ZXIoJzwhLS0gL2tvIC0tPicpO1xuICAgICRib2R5Lmh0bWwoXCI8IS0tIGtvIGJsb2NrOiBjb250ZW50IC0tPjwhLS0gL2tvIC0tPlwiKTtcblxuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLWlmcmFtZScsICRlbFswXS5vdXRlckhUTUwpO1xuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGh0bWxPckVsZW1lbnQgPT0gJ29iamVjdCcpIHtcbiAgICB0ZW1wbGF0ZVBsdWdpbi5hZGRlcih0bXBOYW1lLCBodG1sT3JFbGVtZW50Lm91dGVySFRNTCk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGVQbHVnaW4uYWRkZXIodG1wTmFtZSwgaHRtbE9yRWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gdG1wTmFtZTtcbn07XG5cbi8vIEFkYXB0ZXIgdG8gdHJhbnNmb3JtIFwidmlld01vZGVsIHBsdWdpbnNcIiBpbnRvIG1vcmUgZ2VuZXJpYyBwbHVnaW5zLlxuZnVuY3Rpb24gX3ZpZXdNb2RlbFBsdWdpbkluc3RhbmNlKHBsdWdpbkZ1bmN0aW9uKSB7XG4gIHZhciBpbnN0YW5jZTtcbiAgcmV0dXJuIHtcbiAgICB2aWV3TW9kZWw6IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgaW5zdGFuY2UgPSBwbHVnaW5GdW5jdGlvbih2aWV3TW9kZWwpO1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW5zdGFuY2UuaW5pdCAhPT0gJ3VuZGVmaW5lZCcpIGluc3RhbmNlLmluaXQoKTtcbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGluc3RhbmNlLmRpc3Bvc2UgIT09ICd1bmRlZmluZWQnKSBpbnN0YW5jZS5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xufVxuXG5pZiAoZmFsc2UpIHtcblxudmFyIF90ZW1wbGF0ZVVybENvbnZlcnRlciA9IGZ1bmN0aW9uKGJhc2VQYXRoLCB1cmwpIHtcbiAgaWYgKCF1cmwubWF0Y2goL15bXlxcL10qOi8pICYmICF1cmwubWF0Y2goL15cXC8vKSAmJiAhdXJsLm1hdGNoKC9eXFxbLykgJiYgIXVybC5tYXRjaCgvXiM/JC8pKSB7XG4gICAgLy8gVE9ETyB0aGlzIGNvdWxkIGJlIHNtYXJ0ZXIgam9pbmluZyB0aGUgdXJscy4uLlxuICAgIHJldHVybiBiYXNlUGF0aCArIHVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxudmFyIHRlbXBsYXRlTG9hZGVyID0gZnVuY3Rpb24ocGVyZm9ybWFuY2VBd2FyZUNhbGxlciwgdGVtcGxhdGVGaWxlTmFtZSwgdGVtcGxhdGVNZXRhZGF0YSwganNvcmpzb24sIGV4dGVuc2lvbnMsIGdhbGxlcnlVcmwpIHtcbiAgdmFyIHRlbXBsYXRlRmlsZSA9IHR5cGVvZiB0ZW1wbGF0ZUZpbGVOYW1lID09ICdzdHJpbmcnID8gdGVtcGxhdGVGaWxlTmFtZSA6IHRlbXBsYXRlTWV0YWRhdGEudGVtcGxhdGU7XG4gIHZhciB0ZW1wbGF0ZVBhdGggPSBcIi4vXCI7XG4gIHZhciBwID0gdGVtcGxhdGVGaWxlLmxhc3RJbmRleE9mKCcvJyk7XG4gIGlmIChwICE9IC0xKSB7XG4gICAgdGVtcGxhdGVQYXRoID0gdGVtcGxhdGVGaWxlLnN1YnN0cigwLCBwICsgMSk7XG4gIH1cblxuICB2YXIgdGVtcGxhdGVVcmxDb252ZXJ0ZXIgPSBfdGVtcGxhdGVVcmxDb252ZXJ0ZXIuYmluZCh1bmRlZmluZWQsIHRlbXBsYXRlUGF0aCk7XG5cbiAgdmFyIG1ldGFkYXRhO1xuICBpZiAodHlwZW9mIHRlbXBsYXRlTWV0YWRhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtZXRhZGF0YSA9IHtcbiAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZUZpbGUsXG4gICAgICAvLyBUT0RPIGwxMG4/XG4gICAgICBuYW1lOiAnTm8gbmFtZScsXG4gICAgICBjcmVhdGVkOiBEYXRlLm5vdygpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtZXRhZGF0YSA9IHRlbXBsYXRlTWV0YWRhdGE7XG4gIH1cblxuICAkLmdldCh0ZW1wbGF0ZUZpbGUsIGZ1bmN0aW9uKHRlbXBsYXRlY29kZSkge1xuICAgIHZhciByZXMgPSB0ZW1wbGF0ZUNvbXBpbGVyKHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBcInRlbXBsYXRlXCIsIHRlbXBsYXRlY29kZSwganNvcmpzb24sIG1ldGFkYXRhLCBleHRlbnNpb25zLCBnYWxsZXJ5VXJsKTtcbiAgICByZXMuaW5pdCgpO1xuICB9KTtcbn07XG5cbn0gZWxzZSBpZiAodHJ1ZSkge1xuXG4vLyBrZWVwIGZ1bmN0aW9uIHNpZ25hdHVyZXNcbnZhciB0ZW1wbGF0ZUxvYWRlciA9IGZ1bmN0aW9uKHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIsIHRlbXBsYXRlRmlsZU5hbWUsIHRlbXBsYXRlTWV0YWRhdGEsIGpzb3Jqc29uLCBleHRlbnNpb25zLCBnYWxsZXJ5VXJsKSB7XG4gIGNvbnNvbGUuaW5mbygnVEVNUExBVEUgTE9BREVSJylcblxuICAvLyBzZWUgZXh0L2JhZHNlbmRlci1leHRlbnNpb25zLmpzI3RlbXBsYXRlVXJsQ29udmVydGVyXG4gIHZhciB0ZW1wbGF0ZVVybENvbnZlcnRlciA9IGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLnRlbXBsYXRlVXJsQ29udmVydGVyO1xuXG4gIHZhciBtZXRhZGF0YSAgPSB0ZW1wbGF0ZU1ldGFkYXRhO1xuXG4gIC8vIEtlZXAgWEhSIHRvIGxvYWQgdGVtcGxhdGUuXG4gIC8vIERvbid0IHdhbnQgdG8gb3V0cHV0IGFsbCB0aGUgaHRtbCBpbiBpbml0aWFsaXphdGlvblxuICAvLyBTaG91bGQgaGFuZGxlIGVycm9yc1xuICAkLmdldCh0ZW1wbGF0ZUZpbGVOYW1lLCBmdW5jdGlvbih0ZW1wbGF0ZWNvZGUpIHtcbiAgICB2YXIgcmVzID0gdGVtcGxhdGVDb21waWxlcihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgXCJ0ZW1wbGF0ZVwiLCB0ZW1wbGF0ZWNvZGUsIGpzb3Jqc29uLCBtZXRhZGF0YSwgZXh0ZW5zaW9ucywgZ2FsbGVyeVVybCk7XG4gICAgcmVzLmluaXQoKTtcbiAgfSk7XG59O1xuXG59XG5cbnZhciB0ZW1wbGF0ZUNvbXBpbGVyID0gZnVuY3Rpb24ocGVyZm9ybWFuY2VBd2FyZUNhbGxlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHRlbXBsYXRlTmFtZSwgdGVtcGxhdGVjb2RlLCBqc29yanNvbiwgbWV0YWRhdGEsIGV4dGVuc2lvbnMsIGdhbGxlcnlVcmwpIHtcbiAgLy8gd2Ugc3RyaXAgY29udGVudCBiZWZvcmUgPGh0bWw+IHRhZyBhbmQgYWZ0ZXIgPC9odG1sPiBiZWNhdXNlIGpxdWVyeSBkb2Vzbid0IHBhcnNlIGl0LlxuICAvLyB3ZSdsbCBrZWVwIGl0IFwicmF3XCIgYW5kIHVzZSBpdCBpbiB0aGUgcHJldmlldy9vdXRwdXQgbWV0aG9kcy5cbiAgdmFyIHJlcyA9IHRlbXBsYXRlY29kZS5tYXRjaCgvXihbXFxTXFxzXSopKFs8XWh0bWxbXj5dKj5bXFxTXFxzXSo8XFwvaHRtbD4pKFtcXFNcXHNdKikkL2kpO1xuICBpZiAocmVzID09PSBudWxsKSB0aHJvdyBcIlVuYWJsZSB0byBmaW5kIDxodG1sPiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgaW4gdGhlIHRlbXBsYXRlXCI7XG4gIHZhciBwcmVmaXggPSByZXNbMV07XG4gIC8vIHdlIHBhcnNlIHRoZSBodG1sIGNvbnRlbnQgYWZ0ZXIgcmVwbGFjaW5nIHRoZSB0YWcgbmFtZSBmb3IgaHRtbC9oZWFkL2JvZHkgc28gdG8gYXZvaWQganF1ZXJ5IGlzc3VlcyBpbiBwYXJzaW5nLlxuICB2YXIgYmFzaWNTdHJ1Y3R1cmUgPSB7ICc8aHRtbCc6IDAsICc8aGVhZCc6IDAsICc8Ym9keSc6IDAsICc8L2h0bWwnOiAwLCAnPC9ib2R5JzogMCwgJzwvaGVhZCc6IDAgfTtcbiAgdmFyIGh0bWwgPSByZXNbMl0ucmVwbGFjZSgvKDxcXC8/KShodG1sfGhlYWR8Ym9keSkoW14+XSo+KS9naSwgZnVuY3Rpb24obWF0Y2gsIHAxLCBwMiwgcDMpIHtcbiAgICBiYXNpY1N0cnVjdHVyZVsocDErcDIpLnRvTG93ZXJDYXNlKCldICs9IDE7XG4gICAgcmV0dXJuIHAxICsgJ3JlcGxhY2VkJyArIHAyICsgcDM7XG4gIH0pO1xuICBmb3IgKHZhciBlbGUgaW4gYmFzaWNTdHJ1Y3R1cmUpIGlmIChiYXNpY1N0cnVjdHVyZS5oYXNPd25Qcm9wZXJ0eShlbGUpKSBpZiAoYmFzaWNTdHJ1Y3R1cmVbZWxlXSAhPSAxKSB7XG4gICAgaWYgKGJhc2ljU3RydWN0dXJlW2VsZV0gPT09IDApIHRocm93IFwiRVJST1I6IG1pc3NpbmcgbWFuZGF0b3J5IGVsZW1lbnQgXCIrZWxlK1wiPlwiO1xuICAgIGlmIChiYXNpY1N0cnVjdHVyZVtlbGVdID4gMSkgdGhyb3cgXCJFUlJPUjogbXVsdGlwbGUgZWxlbWVudCBcIitlbGUrXCI+IG9jY291cmVuY2VzIGFyZSBub3Qgc3VwcG9ydGVkIChmb3VuZCBcIitiYXNpY1N0cnVjdHVyZVtlbGVdK1wiIG9jY291cmVuY2VzKVwiO1xuICB9XG4gIHZhciBwb3N0Zml4ID0gcmVzWzNdO1xuICB2YXIgYmxvY2tEZWZzID0gW107XG4gIHZhciBlbmFibGVVbmRvID0gdHJ1ZTtcbiAgdmFyIGVuYWJsZVJlY29yZGVyID0gdHJ1ZTtcbiAgdmFyIGJhc2VUaHJlc2hvbGQgPSAnKyRyb290LmNvbnRlbnRMaXN0ZW5lcnMoKSc7XG5cbiAgdmFyIHBsdWdpbnMgPSBbXTtcblxuICBpZiAodHlwZW9mIGV4dGVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbnNbaV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbHVnaW5zLnB1c2goX3ZpZXdNb2RlbFBsdWdpbkluc3RhbmNlKGV4dGVuc2lvbnNbaV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBsdWdpbnMucHVzaChleHRlbnNpb25zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY3JlYXRlZFRlbXBsYXRlcyA9IFtdO1xuICB2YXIgdGVtcGxhdGVzUGx1Z2luID0ge1xuICAgIGFkZGVyOiBmdW5jdGlvbihpZCwgaHRtbCkge1xuICAgICAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykgdGhyb3cgXCJUZW1wbGF0ZSBzeXN0ZW06IGNhbm5vdCBjcmVhdGUgbmV3IHRlbXBsYXRlIFwiICsgaWQ7XG4gICAgICB2YXIgdHJhc2ggPSBodG1sLm1hdGNoKC8oZGF0YSk/LWtvLVteID06XSovZyk7XG4gICAgICBpZiAodHJhc2gpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVSUk9SOiBmb3VuZCB1bmV4cGVjdGVkIC1rby0gYXR0cmlidXRlIGluIGNvbXBpbGVkIHRlbXBsYXRlXCIsIGlkLCBcIiwgeW91IHByb2JhYmx5IG1pc3BlbGxlZCBpdDpcIiwgdHJhc2gpO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoaWQsIGh0bWwpO1xuICAgICAgY3JlYXRlZFRlbXBsYXRlcy5wdXNoKGlkKTtcbiAgICB9LFxuICAgIGV4aXN0czogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBlbCA9IHRlbXBsYXRlU3lzdGVtLmdldFRlbXBsYXRlQ29udGVudChpZCk7XG4gICAgICBpZiAodHlwZW9mIGVsICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHRydWU7XG4gICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IGNyZWF0ZWRUZW1wbGF0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGVtcGxhdGVTeXN0ZW0ucmVtb3ZlVGVtcGxhdGUoY3JlYXRlZFRlbXBsYXRlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGtvLmJpbmRpbmdIYW5kbGVyc1snYmxvY2snXS50ZW1wbGF0ZUV4aXN0cyA9IHRlbXBsYXRlc1BsdWdpbi5leGlzdHM7XG5cbiAgLy8gdGVtcGxhdGVjcmVhdG9yIHRyYWNrcyBjcmVhdGVkIHRlbXBsYXRlICh2aWEgdGVtcGxhdGVBZGRlcikgc28gdG8gYmUgYWJsZSB0byBkaXNwb3NlIHRoZW0gbGF0ZXJcbiAgdmFyIG15VGVtcGxhdGVDcmVhdG9yID0gdGVtcGxhdGVDcmVhdG9yLmJpbmQodW5kZWZpbmVkLCB0ZW1wbGF0ZXNQbHVnaW4pO1xuXG4gIC8vIGZpcnN0IHBhc3M6IHdlIFwiY29tcGlsZVwiIHRoZSB0ZW1wbGF0ZSBpbnRvIGEgdGVybXBsYXRlRGVmIG9iamVjdFxuICB2YXIgdGVtcGxhdGVEZWYgPSBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKCd0cmFuc2xhdGVUZW1wbGF0ZScsIHRlbXBsYXRlQ29udmVydGVyLnRyYW5zbGF0ZVRlbXBsYXRlLmJpbmQodW5kZWZpbmVkLCB0ZW1wbGF0ZU5hbWUsIGh0bWwsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBteVRlbXBsYXRlQ3JlYXRvcikpO1xuXG4gIC8vIHNlY29uZCBwYXNzOiBnaXZlbiB0aGUgdGVtcGxhdGVEZWYgd2UgY3JlYXRlIGEgYmFzZSBjb250ZW50IG1vZGVsIG9iamVjdCBmb3IgdGhpcyB0ZW1wbGF0ZS5cbiAgdmFyIGNvbnRlbnQgPSBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKCdnZW5lcmF0ZU1vZGVsJywgdGVtcGxhdGVDb252ZXJ0ZXIud3JhcHBlZFJlc3VsdE1vZGVsLmJpbmQodW5kZWZpbmVkLCB0ZW1wbGF0ZURlZikpO1xuXG4gIC8vIHRoaXJkIHBhc3M6IHdlIGNyZWF0ZSBcInN0eWxlL2NvbnRlbnQgZWRpdG9yc1wiIGZvciBldmVyeSBibG9ja1xuICB2YXIgd2lkZ2V0cyA9IHt9O1xuICB2YXIgd2lkZ2V0UGx1Z2lucyA9IHBsdWdpbnNDYWxsKHBsdWdpbnMsICd3aWRnZXQnLCBbJCwga28sIGtvanF1aV0pO1xuICBmb3IgKHZhciB3aSA9IDA7IHdpIDwgd2lkZ2V0UGx1Z2lucy5sZW5ndGg7IHdpKyspIHtcbiAgICB3aWRnZXRzW3dpZGdldFBsdWdpbnNbd2ldLndpZGdldF0gPSB3aWRnZXRQbHVnaW5zW3dpXTtcbiAgfVxuICBibG9ja0RlZnMucHVzaC5hcHBseShibG9ja0RlZnMsIHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ2dlbmVyYXRlRWRpdG9ycycsIHRlbXBsYXRlQ29udmVydGVyLmdlbmVyYXRlRWRpdG9ycy5iaW5kKHVuZGVmaW5lZCwgdGVtcGxhdGVEZWYsIHdpZGdldHMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBteVRlbXBsYXRlQ3JlYXRvciwgYmFzZVRocmVzaG9sZCkpKTtcblxuICB2YXIgaW5jb21wYXRpYmxlVGVtcGxhdGUgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBqc29yanNvbiAhPT0gJ3VuZGVmaW5lZCcgJiYganNvcmpzb24gIT09IG51bGwpIHtcbiAgICB2YXIgdW53cmFwcGVkO1xuICAgIGlmICh0eXBlb2YganNvcmpzb24gPT0gJ3N0cmluZycpIHtcbiAgICAgIHVud3JhcHBlZCA9IGtvLnV0aWxzLnBhcnNlSnNvbihqc29yanNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVud3JhcHBlZCA9IGpzb3Jqc29uO1xuICAgIH1cblxuICAgIC8vIHdlIHJ1biBhIGJhc2ljIGNvbXBhdGliaWxpdHkgY2hlY2sgYmV0d2VlbiB0aGUgY29udGVudC1tb2RlbCB3ZSBleHBlY3QgYW5kIHRoZSBpbml0aWFsaXphdGlvbiBtb2RlbFxuICAgIHZhciBjaGVja01vZGVsUmVzID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlcignY2hlY2tNb2RlbCcsIHRlbXBsYXRlQ29udmVydGVyLmNoZWNrTW9kZWwuYmluZCh1bmRlZmluZWQsIGNvbnRlbnQuX3Vud3JhcCgpLCBibG9ja0RlZnMsIHVud3JhcHBlZCkpO1xuICAgIC8vIGlmIGNoZWNrTW9kZWxSZXMgaXMgMSB0aGVuIHRoZSBtb2RlbCBpcyBub3QgZnVsbHkgY29tcGF0aWJsZSBidXQgd2UgZml4ZWQgaXRcbiAgICBpZiAoY2hlY2tNb2RlbFJlcyA9PSAyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVHJ5aW5nIHRvIGNvbXBpbGUgYW4gaW5jb21wYXRpYmxlIHRlbXBsYXRlIHZlcnNpb24hXCIsIGNvbnRlbnQuX3Vud3JhcCgpLCBibG9ja0RlZnMsIHVud3JhcHBlZCk7XG4gICAgICBpbmNvbXBhdGlibGVUZW1wbGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnQuX3dyYXAodW53cmFwcGVkKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBpbmplY3QgbW9kZWwgY29udGVudCFcIiwgZXgpO1xuICAgICAgaW5jb21wYXRpYmxlVGVtcGxhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgYnVpbGQgdGhlIHRlbXBsYXRlIGZvciB0aGUgcHJldmlldy9vdXRwdXQsIGJ1dCBjb25jYXRlbmF0aW5nIHByZWZpeCwgdGVtcGxhdGUgYW5kIGNvbnRlbnQgYW5kIHN0cmlwcGluZyB0aGUgXCJyZXBsYWNlZFwiIHByZWZpeCBhZGRlZCB0byBcInByb2JsZW1hdGljXCIgdGFnIChodG1sL2hlYWQvYm9keSlcbiAgdmFyIGlmcmFtZVRwbCA9IHByZWZpeCArIHRlbXBsYXRlU3lzdGVtLmdldFRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZU5hbWUgKyAnLWlmcmFtZScpLnJlcGxhY2UoLyg8XFwvPylyZXBsYWNlZChodG1sfGhlYWR8Ym9keSkoW14+XSo+KS9naSwgZnVuY3Rpb24obWF0Y2gsIHAxLCBwMiwgcDMpIHtcbiAgICByZXR1cm4gcDEgKyBwMiArIHAzO1xuICB9KSArIHBvc3RmaXg7XG5cbiAgLy8gc3RvcmUgdGhpcyBzbyB0byByZXN0b3JlIGl0IG9uIGRpc3Bvc2FsZVxuICB2YXIgb3JpZ2lGcmFtZVRwbCA9IGtvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lLnRwbDtcbiAga28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsID0gaWZyYW1lVHBsO1xuICB2YXIgaUZyYW1lUGx1Z2luID0ge1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAga28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsID0gb3JpZ2lGcmFtZVRwbDtcbiAgICB9XG4gIH07XG5cbiAgcGx1Z2lucy5wdXNoKGlGcmFtZVBsdWdpbik7XG4gIHBsdWdpbnMucHVzaCh0ZW1wbGF0ZXNQbHVnaW4pO1xuXG4gIC8vIGluaXRpYWxpemUgdGhlIHZpZXdNb2RlbCBvYmplY3QgYmFzZWQgb24gdGhlIGNvbnRlbnQgbW9kZWwuXG4gIHZhciB2aWV3TW9kZWwgPSBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKCdpbml0aWFsaXplVmlld21vZGVsJywgaW5pdGlhbGl6ZVZpZXdtb2RlbC5iaW5kKHRoaXMsIGNvbnRlbnQsIGJsb2NrRGVmcywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGdhbGxlcnlVcmwpKTtcblxuICB2aWV3TW9kZWwubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgLy8gbGV0J3MgcnVuIHNvbWUgdmVyc2lvbiBjaGVjayBvbiB0ZW1wbGF0ZSBhbmQgZWRpdG9yIHVzZWQgdG8gYnVpbGQgdGhlIG1vZGVsIGJlaW5nIGxvYWRlZC5cbiAgdmFyIGVkaXR2ZXIgPSAnMC4xNS4wJztcbiAgaWYgKHR5cGVvZiB2aWV3TW9kZWwubWV0YWRhdGEuZWRpdG9ydmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgdmlld01vZGVsLm1ldGFkYXRhLmVkaXRvcnZlcnNpb24gIT09IGVkaXR2ZXIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgbW9kZWwgYmVpbmcgbG9hZGVkIGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBhbiBvbGRlciBlZGl0b3IgdmVyc2lvblwiLCB2aWV3TW9kZWwubWV0YWRhdGEuZWRpdG9ydmVyc2lvbiwgXCJ2c1wiLCBlZGl0dmVyKTtcbiAgfVxuICB2aWV3TW9kZWwubWV0YWRhdGEuZWRpdG9ydmVyc2lvbiA9IGVkaXR2ZXI7XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZURlZi52ZXJzaW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2Ygdmlld01vZGVsLm1ldGFkYXRhLnRlbXBsYXRldmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgdmlld01vZGVsLm1ldGFkYXRhLnRlbXBsYXRldmVyc2lvbiAhPT0gdGVtcGxhdGVEZWYudmVyc2lvbikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBtb2RlbCBiZWluZyBsb2FkZWQgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIGEgZGlmZmVyZW50IHRlbXBsYXRlIHZlcnNpb25cIiwgdGVtcGxhdGVEZWYudmVyc2lvbiwgXCJ2c1wiLCB2aWV3TW9kZWwubWV0YWRhdGEudGVtcGxhdGV2ZXJzaW9uKTtcbiAgICB9XG4gICAgdmlld01vZGVsLm1ldGFkYXRhLnRlbXBsYXRldmVyc2lvbiA9IHRlbXBsYXRlRGVmLnZlcnNpb247XG4gIH1cblxuICB0ZW1wbGF0ZVN5c3RlbS5pbml0KCk7XG5cbiAgLy8gZXZlcnl0aGluZydzIHJlYWR5LCBzdGFydCBrbm9ja291dCBiaW5kaW5ncy5cbiAgcGx1Z2lucy5wdXNoKGJpbmRpbmdQbHVnaW5NYWtlcihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKSk7XG5cbiAgcGx1Z2luc0NhbGwocGx1Z2lucywgJ3ZpZXdNb2RlbCcsIFt2aWV3TW9kZWxdKTtcblxuICBpZiAoaW5jb21wYXRpYmxlVGVtcGxhdGUpIHtcbiAgICAkKCcjaW5jb21wYXRpYmxlLXRlbXBsYXRlJykuZGlhbG9nKHtcbiAgICAgIG1vZGFsOiB0cnVlLFxuICAgICAgYXBwZW5kVG86ICcjbW8tYm9keScsXG4gICAgICBidXR0b25zOiB7XG4gICAgICAgIE9rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkKHRoaXMpLmRpYWxvZyhcImNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1vZGVsOiB2aWV3TW9kZWwsXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBwbHVnaW5zQ2FsbChwbHVnaW5zLCAnaW5pdCcsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHBsdWdpbnNDYWxsKHBsdWdpbnMsICdkaXNwb3NlJywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbn07XG5cblxudmFyIGNoZWNrRmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIGZ1bmMpIHtcbiAgaWYgKCFmdW5jKCkpIHtcbiAgICBjb25zb2xlLndhcm4oXCJNaXNzaW5nIGZlYXR1cmVcIiwgZmVhdHVyZSk7XG4gICAgdGhyb3cgXCJNaXNzaW5nIGZlYXR1cmUgXCIgKyBmZWF0dXJlO1xuICB9XG59O1xuXG52YXIgaXNDb21wYXRpYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gd2luZG93Lm1zTWF0Y2hNZWRpYSB3b3VsZCBtYXRjaCBhbHNvIElFOVxuICAgIC8vIElFOSB3b3VsZG4ndCBiZSBzbyBoYXJkIHRvIHN1cHBvcnQsIGJ1dCBpdCBkb2Vzbid0IHdvcnRoIGl0LiAocHJldmlldyBpZnJhbWUgYW5kIGF1dG9tYXRpYyBzY3JvbGwgYXJlIDIgdGhpbmdzIG5vdCB3b3JraW5nIGluIElFOSlcbiAgICBjaGVja0ZlYXR1cmUoJ21hdGNoTWVkaWEnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsLm1hdGNoTWVkaWEgIT0gJ3VuZGVmaW5lZCc7XG4gICAgfSk7XG4gICAgY2hlY2tGZWF0dXJlKCdYTUxIdHRwUmVxdWVzdCAyJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ1hNTEh0dHBSZXF1ZXN0JyBpbiBnbG9iYWwgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH0pO1xuICAgIGNoZWNrRmVhdHVyZSgnRVM1IHN0cmljdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvKiBcInVzZSBzdHJpY3RcIjsqL1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ3VuZGVmaW5lZCc7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gICAgY2hlY2tGZWF0dXJlKCdDU1MgYm9yZGVyUmFkaXVzJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGdsb2JhbC5kb2N1bWVudC5ib2R5LnN0eWxlWydib3JkZXJSYWRpdXMnXSAhPSAndW5kZWZpbmVkJztcbiAgICB9KTtcbiAgICBjaGVja0ZlYXR1cmUoJ0NTUyBib3hTaGFkb3cnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LmJvZHkuc3R5bGVbJ2JveFNoYWRvdyddICE9ICd1bmRlZmluZWQnO1xuICAgIH0pO1xuICAgIGNoZWNrRmVhdHVyZSgnQ1NTIGJveFNpemluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQuYm9keS5zdHlsZVsnYm94U2l6aW5nJ10gIT0gJ3VuZGVmaW5lZCc7XG4gICAgfSk7XG4gICAgY2hlY2tGZWF0dXJlKCdDU1MgYmFja2dyb3VuZFNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LmJvZHkuc3R5bGVbJ2JhY2tncm91bmRTaXplJ10gIT0gJ3VuZGVmaW5lZCc7XG4gICAgfSk7XG4gICAgY2hlY2tGZWF0dXJlKCdDU1MgYmFja2dyb3VuZE9yaWdpbicsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQuYm9keS5zdHlsZVsnYmFja2dyb3VuZE9yaWdpbiddICE9ICd1bmRlZmluZWQnO1xuICAgIH0pO1xuICAgIGNoZWNrQmFkQnJvd3NlckV4dGVuc2lvbnMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2hlY2tCYWRCcm93c2VyRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWQgPSAnY2hlY2tiYWRicm93c2Vyc2ZyYW1lJztcbiAgdmFyIG9yaWdUcGwgPSBrby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZS50cGw7XG4gIGtvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lLnRwbCA9IFwiPCFET0NUWVBFIGh0bWw+XFxyXFxuPGh0bWw+XFxyXFxuPGhlYWQ+PHRpdGxlPkE8L3RpdGxlPlxcclxcbjwvaGVhZD5cXHJcXG48Ym9keT48cCBzdHlsZT1cXFwiY29sb3I6IGJsdWVcXFwiIGFsaWduPVxcXCJyaWdodFxcXCIgZGF0YS1iaW5kPVxcXCJzdHlsZTogeyBjb2xvcjogJ3JlZCcgfVxcXCI+QjwvcD48ZGl2IGRhdGEtYmluZD1cXFwidGV4dDogY29udGVudFxcXCI+PC9kaXY+PC9ib2R5PlxcclxcbjwvaHRtbD5cXHJcXG5cIjtcbiAgJCgnYm9keScpLmFwcGVuZCgnPGlmcmFtZSBpZD1cIicgKyBpZCArICdcIiBkYXRhLWJpbmQ9XCJiaW5kSWZyYW1lOiAkZGF0YVwiPjwvaWZyYW1lPicpO1xuICB2YXIgZnJhbWVFbCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gIGtvLmFwcGx5QmluZGluZ3MoeyBjb250ZW50OiBcImR1bW15IGNvbnRlbnRcIiB9LCBmcmFtZUVsKTtcbiAgLy8gT2Jzb2xldGUgbWV0aG9kIGRpZG4ndCB3b3JrIG9uIElFMTEgd2hlbiB1c2luZyBcIkhUTUw1IGRvY3R5cGVcIjpcbiAgLy8gdmFyIGRvY1R5cGUgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKGdsb2JhbC5kb2N1bWVudC5kb2N0eXBlKTtcbiAgdmFyIG5vZGUgPSBmcmFtZUVsLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdHlwZTtcbiAgdmFyIGRvY1R5cGUgPSBcIjwhRE9DVFlQRSBcIiArIG5vZGUubmFtZSArXG4gICAgKG5vZGUucHVibGljSWQgPyAnIFBVQkxJQyBcIicgKyBub2RlLnB1YmxpY0lkICsgJ1wiJyA6ICcnKSArXG4gICAgKCFub2RlLnB1YmxpY0lkICYmIG5vZGUuc3lzdGVtSWQgPyAnIFNZU1RFTScgOiAnJykgK1xuICAgIChub2RlLnN5c3RlbUlkID8gJyBcIicgKyBub2RlLnN5c3RlbUlkICsgJ1wiJyA6ICcnKSArICc+JztcbiAgdmFyIGNvbnRlbnQgPSBkb2NUeXBlICsgXCJcXG5cIiArIGZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICBrby5jbGVhbk5vZGUoZnJhbWVFbCk7XG4gIGtvLnJlbW92ZU5vZGUoZnJhbWVFbCk7XG4gIGtvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lLnRwbCA9IG9yaWdUcGw7XG5cbiAgdmFyIGV4cGVjdGVkID0gXCI8IURPQ1RZUEUgaHRtbD5cXG48aHRtbD48aGVhZD48dGl0bGU+QTwvdGl0bGU+XFxuPC9oZWFkPlxcbjxib2R5PjxwIGFsaWduPVxcXCJyaWdodFxcXCIgc3R5bGU9XFxcImNvbG9yOiByZWQ7XFxcIiBkYXRhLWJpbmQ9XFxcInN0eWxlOiB7IGNvbG9yOiAncmVkJyB9XFxcIj5CPC9wPjxkaXYgZGF0YS1iaW5kPVxcXCJ0ZXh0OiBjb250ZW50XFxcIj5kdW1teSBjb250ZW50PC9kaXY+XFxuXFxuPC9ib2R5PjwvaHRtbD5cIjtcbiAgdmFyIGV4cGVjdGVkMiA9IFwiPCFET0NUWVBFIGh0bWw+XFxuPGh0bWw+PGhlYWQ+PHRpdGxlPkE8L3RpdGxlPlxcbjwvaGVhZD5cXG48Ym9keT48cCBzdHlsZT1cXFwiY29sb3I6IHJlZDtcXFwiIGRhdGEtYmluZD1cXFwic3R5bGU6IHsgY29sb3I6ICdyZWQnIH1cXFwiIGFsaWduPVxcXCJyaWdodFxcXCI+QjwvcD48ZGl2IGRhdGEtYmluZD1cXFwidGV4dDogY29udGVudFxcXCI+ZHVtbXkgY29udGVudDwvZGl2PlxcblxcbjwvYm9keT48L2h0bWw+XCI7XG4gIHZhciBleHBlY3RlZDMgPSBcIjwhRE9DVFlQRSBodG1sPlxcbjxodG1sPjxoZWFkPjx0aXRsZT5BPC90aXRsZT5cXG48L2hlYWQ+XFxuPGJvZHk+PHAgc3R5bGU9XFxcImNvbG9yOiByZWQ7XFxcIiBhbGlnbj1cXFwicmlnaHRcXFwiIGRhdGEtYmluZD1cXFwic3R5bGU6IHsgY29sb3I6ICdyZWQnIH1cXFwiPkI8L3A+PGRpdiBkYXRhLWJpbmQ9XFxcInRleHQ6IGNvbnRlbnRcXFwiPmR1bW15IGNvbnRlbnQ8L2Rpdj5cXG5cXG48L2JvZHk+PC9odG1sPlwiO1xuICBpZiAoZXhwZWN0ZWQgIT09IGNvbnRlbnQgJiYgZXhwZWN0ZWQyICE9PSBjb250ZW50ICYmIGV4cGVjdGVkMyAhPT0gY29udGVudCkge1xuICAgIGNvbnNvbGUubG9nKFwiQmFkQnJvd3Nlci5GcmFtZUNvbnRlbnRDaGVja1wiLCBjb250ZW50Lmxlbmd0aCwgZXhwZWN0ZWQubGVuZ3RoLCBleHBlY3RlZDIubGVuZ3RoLCBleHBlY3RlZDMubGVuZ3RoLCBjb250ZW50ID09IGV4cGVjdGVkLCBjb250ZW50ID09IGV4cGVjdGVkMiwgY29udGVudCA9PSBleHBlY3RlZDMpO1xuICAgIGNvbnNvbGUubG9nKGNvbnRlbnQpO1xuICAgIHRocm93IFwiVW5leHBlY3RlZCBmcmFtZSBjb250ZW50LiBNaXNiZWhhdmluZyBicm93c2VyOiBcIitjb250ZW50Lmxlbmd0aCtcIi9cIitleHBlY3RlZC5sZW5ndGgrXCIvXCIrZXhwZWN0ZWQyLmxlbmd0aCtcIi9cIitleHBlY3RlZDMubGVuZ3RoO1xuICB9XG59O1xuXG52YXIgZml4UGFnZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIGlzIGdsb2JhbCBjb2RlIHRvIHByZXZlbnQgZHJhZ2dpbmcvZHJvcHBpbmcgaW4gdGhlIHBhZ2Ugd2hlcmUgd2UgZG9uJ3QgZGVhbCB3aXRoIGl0LlxuICAvLyBJRTggZG9lc24ndCBoYXZlIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyLCBidXQgZG9lc24ndCBzdXBwb3J0IGRyYWcmZHJvcCB0b28uXG4gIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIC8vIHByZXZlbnQgZ2VuZXJpYyBmaWxlIGRyb3BwcGluZyBpbiB0aGUgcGFnZVxuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImJyb3dzZXIgaXMgdXNpbmcgZHJhZyBsaXN0ZW5lciBvbiB3aW5kb3dcIik7XG4gICAgICBlID0gZSB8fCBnbG9iYWwuZXZlbnQ7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiYnJvd3NlciBpcyB1c2luZyBkcmFnc3RhcnQgbGlzdGVuZXIgb24gd2luZG93XCIpO1xuICAgICAgZSA9IGUgfHwgZ2xvYmFsLmV2ZW50O1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIHRoaXMgaXMgY2FsbGVkIG9uIG1vdXNlIG1vdmUgb24gZXZlcnkgc3VwcG9ydGVkIGJyb3dzZXIuXG4gICAgICAvLyBjb25zb2xlLmxvZyhcImJyb3dzZXIgaXMgdXNpbmcgZHJhZ292ZXIgbGlzdGVuZXIgb24gd2luZG93XCIpO1xuICAgICAgZSA9IGUgfHwgZ2xvYmFsLmV2ZW50O1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJicm93c2VyIGlzIHVzaW5nIGRyb3AgbGlzdGVuZXIgb24gd2luZG93XCIpO1xuICAgICAgZSA9IGUgfHwgZ2xvYmFsLmV2ZW50O1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gSSBicm93c2VyIHN1cHBvcnRhdGkgZW50cmF0byB0dXR0aSBxdWkgcXVhbmRvIHNpIGRyb3BwYSBxdWFsY29zYSBzdWwgYm9keVxuICAgICAgLy8gY29uc29sZS5sb2coXCJicm93c2VyIGlzIHVzaW5nIGRyb3AgbGlzdGVuZXIgb24gYm9keSB0YWdcIik7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG4gIGlmIChnbG9iYWwuZG9jdW1lbnQub25kcmFnc3RhcnQpIHtcbiAgICBnbG9iYWwuZG9jdW1lbnQub25kcmFnc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiYnJvd3NlciBjYWxsZWQgb25kcmFnc3RhcnQuIHJldHVybiBmYWxzZSFcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBpbGU6IHRlbXBsYXRlQ29tcGlsZXIsXG4gIGxvYWQ6IHRlbXBsYXRlTG9hZGVyLFxuICBpc0NvbXBhdGlibGU6IGlzQ29tcGF0aWJsZSxcbiAgZml4UGFnZUV2ZW50czogZml4UGFnZUV2ZW50c1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG52YXIgX2NhbGwgPSBmdW5jdGlvbih3aGF0VG9DYWxsKSB7XG4gIHJldHVybiB3aGF0VG9DYWxsKCk7XG59O1xuXG52YXIgbG9ncyA9IFtdO1xuXG52YXIgX3RpbWVkQ2FsbCA9IGZ1bmN0aW9uKG5hbWUsIHdoYXRUb0NhbGwpIHtcbiAgdmFyIHJlcztcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGlmICh0eXBlb2YgY29uc29sZSA9PSAnb2JqZWN0JyAmJiBjb25zb2xlLnRpbWUpIGNvbnNvbGUudGltZShuYW1lKTtcbiAgcmVzID0gX2NhbGwod2hhdFRvQ2FsbCk7XG4gIGlmICh0eXBlb2YgY29uc29sZSA9PSAnb2JqZWN0JyAmJiBjb25zb2xlLnRpbWUpIGNvbnNvbGUudGltZUVuZChuYW1lKTtcbiAgdmFyIGRpZmYgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0O1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gJ29iamVjdCcgJiYgIWNvbnNvbGUudGltZSkgY29uc29sZS5sb2cobmFtZSwgXCJ0b29rXCIsIGRpZmYsIFwibXNcIik7XG4gIGxvZ3MucHVzaCh7XG4gICAgbmFtZTogbmFtZSxcbiAgICB0aW1lOiBkaWZmXG4gIH0pO1xuICAvLyBtYXggbG9nc1xuICBpZiAobG9ncy5sZW5ndGggPiAxMDApIGxvZ3MudW5zaGlmdCgpO1xuICByZXR1cm4gcmVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRpbWVkQ2FsbDogX3RpbWVkQ2FsbCxcbiAgbG9nczogbG9nc1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgdW5kb01hbmFnZXIgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2tub2Nrb3V0LXVuZG9tYW5hZ2VyL2tub2Nrb3V0LXVuZG9tYW5hZ2VyLmpzXCIpO1xudmFyIHVuZG9zZXJpYWxpemVyID0gcmVxdWlyZShcIi4vdW5kb3NlcmlhbGl6ZXIuanNcIik7XG5cbnZhciBhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlciA9IGZ1bmN0aW9uKHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuXG4gICAgdmlld01vZGVsLmNvbnRlbnRMaXN0ZW5lcnModmlld01vZGVsLmNvbnRlbnRMaXN0ZW5lcnMoKSArIDIpO1xuXG4gICAgLy8gVE9ETyB0aGUgbGFiZWxzIHNob3VsZCBiZSBjb21wdXRlZCBvYnNlcnZhYmxlcyAobmVlZHMgY2hhbmdlcyBpbiB1bmRvbWFuYWdlciBwcm9qZWN0cylcbiAgICB2YXIgdW5kb1JlZG9TdGFjayA9IHVuZG9NYW5hZ2VyKHZpZXdNb2RlbC5jb250ZW50LCB7XG4gICAgICBsZXZlbHM6IDEwMCxcbiAgICAgIHVuZG9MYWJlbDoga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7IHJldHVybiB2aWV3TW9kZWwudChcIlVuZG8gKCNDT1VOVCMpXCIpOyB9KSxcbiAgICAgIHJlZG9MYWJlbDoga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7IHJldHVybiB2aWV3TW9kZWwudChcIlJlZG9cIik7IH0pXG4gICAgfSk7XG4gICAgdmlld01vZGVsLnVuZG8gPSB1bmRvUmVkb1N0YWNrLnVuZG9Db21tYW5kO1xuICAgIHZpZXdNb2RlbC51bmRvLmV4ZWN1dGUgPSBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyLmJpbmQodmlld01vZGVsLCAndW5kbycsIHZpZXdNb2RlbC51bmRvLmV4ZWN1dGUpO1xuICAgIHZpZXdNb2RlbC5yZWRvID0gdW5kb1JlZG9TdGFjay5yZWRvQ29tbWFuZDtcbiAgICB2aWV3TW9kZWwucmVkby5leGVjdXRlID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlci5iaW5kKHZpZXdNb2RlbCwgJ3JlZG8nLCB2aWV3TW9kZWwucmVkby5leGVjdXRlKTtcbiAgICB2aWV3TW9kZWwudW5kb1Jlc2V0ID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlci5iaW5kKHZpZXdNb2RlbCwgJ3VuZG9SZXNldCcsIHVuZG9SZWRvU3RhY2sucmVzZXQpO1xuICAgIHZpZXdNb2RlbC5zZXRVbmRvTW9kZU1lcmdlID0gdW5kb1JlZG9TdGFjay5zZXRNb2RlTWVyZ2U7XG4gICAgdmlld01vZGVsLnNldFVuZG9Nb2RlT25jZSA9IHVuZG9SZWRvU3RhY2suc2V0TW9kZU9uY2U7XG4gICAgdW5kb1JlZG9TdGFjay5zZXRNb2RlSWdub3JlKCk7XG4gICAgdW5kb1JlZG9TdGFjay5zZXRVbmRvQWN0aW9uTWFrZXIodW5kb3NlcmlhbGl6ZXIubWFrZVVuZG9BY3Rpb24uYmluZCh1bmRlZmluZWQsIHZpZXdNb2RlbC5jb250ZW50KSk7XG4gICAgdW5kb3NlcmlhbGl6ZXIud2F0Y2hFbmFibGVkKHRydWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdW5kb1JlZG9TdGFjay5zZXRNb2RlSWdub3JlKCk7XG4gICAgICB9LFxuICAgICAgcnVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdW5kb1JlZG9TdGFjay5zZXRNb2RlT25jZSgpO1xuICAgICAgfSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB1bmRvUmVkb1N0YWNrLnNldE1vZGVPbmNlKCk7XG4gICAgICB9LFxuICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZpZXdNb2RlbC5jb250ZW50TGlzdGVuZXJzKHZpZXdNb2RlbC5jb250ZW50TGlzdGVuZXJzKCkgLSAyKTtcbiAgICAgICAgdW5kb3NlcmlhbGl6ZXIud2F0Y2hFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgdW5kb1JlZG9TdGFjay5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlcjsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbi8vIFRoaXMgbW9kdWxlIGRlYWxzIHdpdGggc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb24gb2YgYSBcInRyZWUtcGF0aFwiIHJlcHJlc2VudGluZyB0aGUgcGF0aCB0byByZWFjaCB0aGUgZ2l2ZW4gbGVhZi5cbi8vIEluIG9yZGVyIHRvIGJlIGNvcnJlY3RseSBzZXJpYWxpemVkIHdlIGhhdmUgdG8gbW92ZSBmcm9tIFwicmVmZXJlbmNlXCIgdG8gXCJzdHJpbmdcIiBhbmQgdmljZXZlcnNhLlxuXG52YXIgX3JlZmVyZW5jZSA9IGZ1bmN0aW9uKG1vZGVsLCBwYXRoKSB7XG4gIHZhciBwID0gMDtcbiAgdmFyIHAxLCBwMjtcbiAgdmFyIG0gPSBtb2RlbDtcbiAgd2hpbGUgKHAgPCBwYXRoLmxlbmd0aCkge1xuICAgIHN3aXRjaCAocGF0aC5jaGFyQXQocCkpIHtcbiAgICAgIGNhc2UgJygnOlxuICAgICAgICBpZiAocGF0aC5jaGFyQXQocCArIDEpID09ICcpJykge1xuICAgICAgICAgIG0gPSBtKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHAgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgcDIgPSBwYXRoLmluZGV4T2YoJ10nLCBwKTtcbiAgICAgICAgbSA9IG1bcGF0aC5zdWJzdHJpbmcocCArIDEsIHAyKV07XG4gICAgICAgIHAgPSBwMiArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnLic6XG4gICAgICAgIHAxID0gcGF0aC5pbmRleE9mKCcoJywgcCk7XG4gICAgICAgIGlmIChwMSA9PSAtMSkgcDEgPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgcDIgPSBwYXRoLmluZGV4T2YoJ1snLCBwKTtcbiAgICAgICAgaWYgKHAyID09IC0xKSBwMiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICBwMiA9IE1hdGgubWluKHAxLCBwMik7XG4gICAgICAgIG0gPSBtW3BhdGguc3Vic3RyaW5nKHAgKyAxLCBwMildO1xuICAgICAgICBwID0gcDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVE9ETyBlcnJvclxuICAgIH1cbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbnZhciBfZ2V0UGF0aCA9IGZ1bmN0aW9uKHBhcmVudHMsIGNoaWxkKSB7XG4gIHZhciBwYXRoID0gXCJcIjtcbiAgdmFyIHA7XG4gIGZvciAodmFyIGsgPSAwOyBrIDw9IHBhcmVudHMubGVuZ3RoOyBrKyspIHtcbiAgICBwID0gayA8IHBhcmVudHMubGVuZ3RoID8gcGFyZW50c1trXSA6IGNoaWxkO1xuICAgIGlmIChrby5pc09ic2VydmFibGUocCkpIHBhdGggKz0gJygpJztcbiAgICBpZiAodHlwZW9mIHAuX2ZpZWxkTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhdGggKz0gXCIuXCIgKyBwLl9maWVsZE5hbWU7XG4gICAgfSBlbHNlIGlmIChrID4gMCAmJiB0eXBlb2YgcGFyZW50c1trIC0gMV0ucG9wID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRBcnJheSA9IGtvLmlzT2JzZXJ2YWJsZShwYXJlbnRzW2sgLSAxXSkgPyBrby51dGlscy5wZWVrT2JzZXJ2YWJsZShwYXJlbnRzW2sgLSAxXSkgOiBwYXJlbnRzW2sgLSAxXTtcbiAgICAgIHZhciBwb3MgPSBrby51dGlscy5hcnJheUluZGV4T2YocGFyZW50QXJyYXksIHApO1xuICAgICAgaWYgKHBvcyAhPSAtMSkge1xuICAgICAgICBwYXRoICs9IFwiW1wiICsgcG9zICsgXCJdXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOT1RFIHRoaXMgaGFwcGVuLCBzb21ldGltZXMgd2hlbiBUaW55TUNFIHNlbmRzIHVwZGF0ZXMgZm9yIG9iamVjdHMgYWxyZWFkeSByZW1vdmVkLlxuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBvYmplY3Qgbm90IGZvdW5kIGluIHBhcmVudCBhcnJheVwiLCBwYXJlbnRBcnJheSwgcCwgaywgcGFyZW50cy5sZW5ndGgsIGtvLnRvSlMocGFyZW50QXJyYXkpLCBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHApKTtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIG9iamVjdCBub3QgZm91bmQgaW4gcGFyZW50IGFycmF5XCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIHBhcmVudCB3aXRoIG5vIF9maWVsZE5hbWUgYW5kIG5vIHBhcmVudCBhcnJheVwiLCBrLCBwYXJlbnRzKTtcbiAgICAgIHRocm93IFwiVW5leHBlY3RlZCBwYXJlbnQgd2l0aCBubyBfZmllbGROYW1lIGFuZCBubyBwYXJlbnQgYXJyYXlcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG52YXIgbWFrZURlcmVmZXJlbmNlZFVuZG9BY3Rpb24gPSBmdW5jdGlvbih1bmRvRnVuYywgbW9kZWwsIHBhdGgsIHZhbHVlLCBpdGVtKSB7XG4gIHZhciBjaGlsZCA9IF9yZWZlcmVuY2UobW9kZWwsIHBhdGgpO1xuICB1bmRvRnVuYyhjaGlsZCwgdmFsdWUsIGl0ZW0pO1xufTtcblxudmFyIGxpc3RlbmVyO1xuXG52YXIgX3NldExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZnVuYykge1xuICBsaXN0ZW5lciA9IGxpc3RlbmZ1bmM7XG59O1xuXG4vKiBkZXJlZmVyZW5jaW5nIHBhdGggYW5kIGNoYW5naW5nIHZhbHVlIHdpdGggXCJ0b0pTXCIgKi9cbnZhciBtYWtlVW5kb0FjdGlvbkRlcmVmZXJlbmNlZCA9IGZ1bmN0aW9uKG1vZGVsLCB1bmRvRnVuYywgcGFyZW50cywgY2hpbGQsIG9sZFZhbCwgaXRlbSkge1xuICB0cnkge1xuICAgIHZhciBwYXRoID0gX2dldFBhdGgocGFyZW50cywgY2hpbGQpO1xuXG4gICAgLy8gVHJhbnNmb3JtIGFjdGlvbnMgaW4gc2ltcGxlIEpTIG9iamVjdHMuXG4gICAgaWYgKHR5cGVvZiBvbGRWYWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvbGRWYWwgPT09ICdmdW5jdGlvbicpIG9sZFZhbCA9IGtvLnRvSlMob2xkVmFsKTtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGl0ZW0udmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB2YXIgbmV3SXRlbSA9IGtvLnRvSlMoaXRlbSk7XG4gICAgICBpdGVtID0gbmV3SXRlbTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIocGF0aCwgY2hpbGQsIG9sZFZhbCwgaXRlbSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5kb3NlcmlhbGl6ZXIgaWdub3JpbmcgZXhjZXB0aW9uIGluIGxpc3RlbmVyIGNhbGxiYWNrXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlRGVyZWZlcmVuY2VkVW5kb0FjdGlvbi5iaW5kKHVuZGVmaW5lZCwgdW5kb0Z1bmMsIG1vZGVsLCBwYXRoLCBvbGRWYWwsIGl0ZW0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTk9URSB0aGlzIGhhcHBlbnMsIGZyb20gdGltZSB0byB0aW1lLCB3aGVuIFRpbnlNQ0Ugc2VuZHMgdXBkYXRlcyBmb3IgZGVsZXRlZCBjb250ZW50LlxuICAgIGNvbnNvbGUuZXJyb3IoXCJFeGNlcHRpb24gcHJvY2Vzc2luZyB1bmRvXCIsIGUsIHBhcmVudHMsIGNoaWxkLCBpdGVtKTtcbiAgfVxufTtcblxudmFyIHdhdGNoRW5hYmxlZDtcbnZhciBfd2F0Y2hFbmFibGVkID0gZnVuY3Rpb24obmV3VmFsKSB7XG4gIGlmICh0eXBlb2YgbmV3VmFsICE9PSAndW5kZWZpbmVkJylcbiAgICB3YXRjaEVuYWJsZWQgPSBuZXdWYWw7XG4gIGVsc2VcbiAgICByZXR1cm4gd2F0Y2hFbmFibGVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlcmVmZXJlbmNlOiBfZ2V0UGF0aCxcbiAgcmVmZXJlbmNlOiBfcmVmZXJlbmNlLFxuICBtYWtlVW5kb0FjdGlvbjogbWFrZVVuZG9BY3Rpb25EZXJlZmVyZW5jZWQsXG4gIHNldExpc3RlbmVyOiBfc2V0TGlzdGVuZXIsXG4gIHdhdGNoRW5hYmxlZDogX3dhdGNoRW5hYmxlZFxufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyID0gcmVxdWlyZShcIi4vdGltZWQtY2FsbC5qc1wiKS50aW1lZENhbGw7XG5cbnZhciB0b2FzdHIgPSByZXF1aXJlKFwiLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL3RvYXN0ci90b2FzdHIuanNcIik7XG50b2FzdHIub3B0aW9ucyA9IHtcbiAgXCJjbG9zZUJ1dHRvblwiOiBmYWxzZSxcbiAgXCJkZWJ1Z1wiOiBmYWxzZSxcbiAgXCJwb3NpdGlvbkNsYXNzXCI6IFwidG9hc3QtYm90dG9tLWZ1bGwtd2lkdGhcIixcbiAgXCJ0YXJnZXRcIjogXCIjbW8tYm9keVwiLFxuICBcIm9uY2xpY2tcIjogbnVsbCxcbiAgXCJzaG93RHVyYXRpb25cIjogXCIzMDBcIixcbiAgXCJoaWRlRHVyYXRpb25cIjogXCIxMDAwXCIsXG4gIFwidGltZU91dFwiOiBcIjUwMDBcIixcbiAgXCJleHRlbmRlZFRpbWVPdXRcIjogXCIxMDAwXCIsXG4gIFwic2hvd0Vhc2luZ1wiOiBcInN3aW5nXCIsXG4gIFwiaGlkZUVhc2luZ1wiOiBcImxpbmVhclwiLFxuICBcInNob3dNZXRob2RcIjogXCJmYWRlSW5cIixcbiAgXCJoaWRlTWV0aG9kXCI6IFwiZmFkZU91dFwiXG59O1xuXG4vKiBOT1RFOiB0cmFuc2xhdGlvbnMgbW92ZWQgdG8gXCJwbHVnaW5cIlxudmFyIHN0cmluZ3MgPSB7XG4gICdzaG93IHByZXZpZXcgYW5kIHNlbmQgdGVzdCc6ICdWaXN1YWxpenphIHVuYSBhbnRlcHJpbWEgZSBmYWkgdW4gaW52aW8gZGkgdGVzdCcsXG4gIC8vIFN0cmluZ3MgZm9yIGFwcC5qc1xuICAnRG93bmxvYWQnOiAnRG93bmxvYWQnLFxuICAnVGVzdCc6ICdUZXN0JyxcbiAgJ1NhdmUnOiAnU2FsdmEnLFxuICAnRG93bmxvYWRpbmcuLi4nOiBcIkRvd25sb2FkIGluIGNvcnNvLi4uXCIsXG4gICdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnOiBcIkluZGlyaXp6byBlbWFpbCBpbnZhbGlkb1wiLFxuICBcIlRlc3QgZW1haWwgc2VudC4uLlwiOiBcIkVtYWlsIGRpIHRlc3QgaW52aWF0YS4uLlwiLFxuICAnVW5leHBlY3RlZCBlcnJvciB0YWxraW5nIHRvIHNlcnZlcjogY29udGFjdCB1cyEnOiAnRXJyb3JlIGRpIGNvbXVuaWNhemlvbmUgY29uIGlsIHNlcnZlcjogY29udGF0dGFjaSEnLFxuICAnSW5zZXJ0IGhlcmUgdGhlIHJlY2lwaWVudCBlbWFpbCBhZGRyZXNzJzogJ0luc2VyaXNjaSBxdWkgbFxcJ2luZGlyaXp6byBlbWFpbCBhIGN1aSBzcGVkaXJlJyxcbiAgXCJUZXN0IGVtYWlsIGFkZHJlc3NcIjogXCJJbmRpcml6em8gZW1haWwgZGkgdGVzdFwiLFxuICAvLyB2aWV3TW9kZWxcbiAgJ0Jsb2NrIHJlbW92ZWQ6IHVzZSB1bmRvIGJ1dHRvbiB0byByZXN0b3JlIGl0Li4uJzogJ0Jsb2NjbyBlbGltaW5hdG86IHVzYSBpbCBwdWxzYW50ZSBhbm51bGxhIHBlciByZWN1cGVyYXJsby4uLicsXG4gICdOZXcgYmxvY2sgYWRkZWQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG9uZSAoX19wb3NfXyknOiAnTnVvdm8gYmxvY2NvIGFnZ2l1bnRvIHNvdHRvIGEgcXVlbGxvIHNlbGV6aW9uYXRvIChfX3Bvc19fKScsXG4gICdOZXcgYmxvY2sgYWRkZWQgYXQgdGhlIG1vZGVsIGJvdHRvbSAoX19wb3NfXyknOiAnTnVvdm8gYmxvY2NvIGFnZ2l1bnRvIGluIGZvbmRvIGFsIG1vZGVsbG8gKF9fcG9zX18pJyxcbiAgLy8gdW5kb21haW4uanNcbiAgJ1VuZG8gKCNDT1VOVCMpJzogJ0FubnVsbGEgKCNDT1VOVCMpJyxcbiAgJ1JlZG8nOiAnUmlwcmlzdGluYScsXG4gIC8vIGVkaXRvci5qc1xuICAnU2VsZWN0ZWQgZWxlbWVudCBoYXMgbm8gZWRpdGFibGUgcHJvcGVydGllcyc6ICdMXFwnZWxlbWVudG8gc2VsZXppb25hdG8gbm9uIGZvcm5pc2NlIHByb3ByaWV0w6AgZWRpdGFiaWxpJyxcbiAgJ1RoaXMgc3R5bGUgaXMgc3BlY2lmaWMgZm9yIHRoaXMgYmxvY2s6IGNsaWNrIGhlcmUgdG8gcmVtb3ZlIHRoZSBjdXN0b20gc3R5bGUgYW5kIHJldmVydCB0byB0aGUgdGhlbWUgdmFsdWUnOiAnUXVlc3RvIHN0aWxlIMOoIHNwZWNpZmljbyBkaSBxdWVzdG8gYmxvY2NvOiBjbGljY2EgcXVpIHBlciBhbm51bGxhcmUgbG8gc3RpbGUgcGVyc29uYWxpenphdG8nLFxuICAnU3dpdGNoIGJldHdlZW4gZ2xvYmFsIGFuZCBibG9jayBsZXZlbCBzdHlsZXMgZWRpdGluZyc6ICdQZXJtZXR0ZSBkaSBzcGVjaWZpY2FyZSBzZSBzaSB2dW9sZSBtb2RpZmljYXJlIGxvIHN0aWxlIGdlbmVyYWxlIG8gc29sYW1lbnRlIHF1ZWxsbyBzcGVjaWZpY28gZGVsIGJsb2NjbyBzZWxlemlvbmF0bycsXG4gIC8vIG1haW4udHBsLmh0bWxcbiAgJ1VuZG8gbGFzdCBvcGVyYXRpb24nOiAnQW5udWxsYSB1bHRpbWEgb3BlcmF6aW9uZScsXG4gICdSZWRvIGxhc3Qgb3BlcmF0aW9uJzogJ1JpcGV0aSBvcGVyYXppb25lIGFubnVsbGF0YScsXG4gICdTaG93IGltYWdlIGdhbGxlcnknOiAnVmlzdWFsaXp6YSBnYWxsZXJpYSBpbW1hZ2luaScsXG4gICdHYWxsZXJ5JzogJ0dhbGxlcmlhJyxcbiAgJ1ByZXZpZXcnOiAnQW50ZXByaW1hJyxcbiAgJ1Nob3cgbGl2ZSBwcmV2aWV3JzogJ01vc3RyYSBhbnRlcHJpbWEgbGl2ZScsXG4gICdMYXJnZSBzY3JlZW4nOiAnU2NoZXJtbyBncmFuZGUnLFxuICAnVGFibGV0JzogJ1RhYmxldCcsXG4gICdTbWFydHBob25lJzogJ1NtYXJ0cGhvbmUnLFxuICAnU2hvdyBwcmV2aWV3IGFuZCBzZW5kIHRlc3QnOiAnVmlzdWFsaXp6YSB1bmEgYW50ZXByaW1hIGUgZmFpIHVuIGludmlvIGRpIHRlc3QnLFxuICAnRG93bmxvYWQgdGVtcGxhdGUnOiAnU2NhcmljYSBpbCB0ZW1wbGF0ZScsXG4gICdTYXZlIHRlbXBsYXRlJzogJ1NhbHZhIGlsIHRlbXBsYXRlJyxcbiAgJ1NhdmVkIG1vZGVsIGlzIG9ic29sZXRlJzogJ01vZGVsbG8gc2FsdmF0byBvYnNvbGV0bycsXG4gICc8cD5UaGUgc2F2ZWQgbW9kZWwgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIGEgcHJldmlvdXMsIG5vbiBjb21wbGV0ZWx5IGNvbXBhdGlibGUgdmVyc2lvbiwgb2YgdGhlIHRlbXBsYXRlPC9wPjxwPlNvbWUgY29udGVudCBvciBzdHlsZSBpbiB0aGUgbW9kZWwgPGI+Q09VTEQgQkUgTE9TVDwvYj4gaWYgeW91IHdpbGwgPGI+c2F2ZTwvYj48L3A+PHA+Q29udGFjdCB1cyBmb3IgbW9yZSBpbmZvcm1hdGlvbnMhPC9wPic6ICc8cD5JbCBtb2RlbGxvIHNhbHZhdG8gw6ggc3RhdG8gY3JlYXRvIGNvbiB1bmEgdmVyc2lvbmUgcHJlY2VkZW50ZSBkZWwgdGVtcGxhdGUgbm9uIGRlbCB0dXR0byBjb21wYXRpYmlsZTwvcD48cD5BbGN1bmkgY29udGVudXRpIG8gc3RpbGkgZGVsIG1vZGVsbG8gPGI+UE9UUkVCQkVSTyBFU1NFUkUgUEVSU0k8L2I+IHNlIHByb2NlZGVyYWkgZSBkZWNpZGVyYWkgZGkgPGI+c2FsdmFyZTwvYj48L3A+PHA+Q29udGF0dGFjaSBzZSBoYWkgZGVpIGR1YmJpITwvcD4nLFxuXG4gIC8vIFRPRE8gdGhpcyBjYW5ub3QgYmUgZG9uZSBpbiBrbm9ja291dCBhcyB3aXRoIHVuY29tcGF0aWJsZSBicm93c2VycyB3ZSBkb24ndCBpbml0aWFsaXplXG4gIC8vICdVc3VwcG9ydGVkIGJyb3dzZXInOiAnQnJvd3NlciBub24gY29tcGF0aWJpbGUnLFxuICAvLyAnPHA+WW91ciBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuPC9wPjxwPlVzZSBhIGRpZmZlcmVudCBicm93c2VyIG9yIHRyeSB1cGRhcmluZyB5b3VyIGJyb3dzZXIuPC9wPjxwPlN1cHBvcnRlZCBicm93c2VyczogPHVsPjxsaT5JbnRlcm5ldCBFeHBsb3JlciAmZ3Q7PSAxMDwvbGk+PGxpPkdvb2dsZSBDaHJvbWUgJmd0Oz0gMzA8L2xpPjxsaT5BcHBsZSBTYWZhcmkgJmd0Oz0gNTwvbGk+PGxpPk1vemlsbGEgRmlyZWZpeCAmZ3Q7PSAyMDwvbGk+PC91bD48L3A+JzogJzxwPklsIHR1byBicm93c2VyIG5vbiDDqCBzdXBwb3J0YXRvLjwvcD48cD5BY2NlZGkgY29uIHVuIGJyb3dzZXIgZGlmZmVyZW50ZSBvIHByb3ZhIGFkIGFnZ2lvcm5hcmUgaWwgdHVvIGJyb3dzZXIuPC9wPjxwPkJyb3dzZXIgc3VwcG9ydGF0aTogPHVsPjxsaT5JbnRlcm5ldCBFeHBsb3JlciAmZ3Q7PSAxMDwvbGk+PGxpPkdvb2dsZSBDaHJvbWUgJmd0Oz0gMzA8L2xpPjxsaT5BcHBsZSBTYWZhcmkgJmd0Oz0gNTwvbGk+PGxpPk1vemlsbGEgRmlyZWZpeCAmZ3Q7PSAyMDwvbGk+PC91bD48L3A+JyxcblxuICAvLyB0b29sYm94XG4gICdCbG9ja3MnOiAnQmxvY2NoaScsXG4gICdCbG9ja3MgcmVhZHkgdG8gYmUgYWRkZWQgdG8gdGhlIHRlbXBsYXRlJzogJ0VsZW5jbyBjb250ZW51dGkgYWdnaXVuZ2liaWxpIGFsIG1lc3NhZ2dpbycsXG4gICdDb250ZW50JzogJ0NvbnRlbnV0bycsXG4gICdFZGl0IGNvbnRlbnQgb3B0aW9ucyc6ICdNb2RpZmljYSBvcHppb25pIGNvbnRlbnV0aScsXG4gICdTdHlsZSc6ICdTdGlsZScsXG4gICdFZGl0IHN0eWxlIG9wdGlvbnMnOiAnTW9kaWZpY2Egb3B6aW9uaSBncmFmaWNoZScsXG4gICdCbG9jayBfX25hbWVfXyc6ICdCbG9jY28gX19uYW1lX18nLFxuICAnQ2xpY2sgb3IgZHJhZyB0byBhZGQgdGhpcyBibG9jayB0byB0aGUgdGVtcGxhdGUnOiAnQ2xpY2NhIG8gdHJhc2NpbmEgcGVyIGFnZ2l1bmdlcmUgYWwgbWVzc2FnZ2lvJyxcbiAgJ0FkZCc6ICdBZ2dpdW5naScsXG4gICdCeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBjb250ZW50IG9wdGlvbnMsIGlmIGFueSwgd2lsbCBzaG93IGhlcmUnOiAnQ2xpY2NhbmRvIHN1IGFsY3VuZSBwYXJ0aSBkZWwgbWVzc2FnZ2lvIHNlbGV6aW9uZXJhaSB1biBibG9jY28gZSBsZSBvcHppb25pIGNvbnRlbnV0aXN0aWNoZSwgc2UgZGlzcG9uaWJpbGksIGNvbXBhcmlyYW5ubyBxdWknLFxuICAnQnkgY2xpY2tpbmcgb24gbWVzc2FnZSBwYXJ0cyB5b3Ugd2lsbCBzZWxlY3QgYSBibG9jayBhbmQgc3R5bGUgb3B0aW9ucywgaWYgYXZhaWxhYmxlLCB3aWxsIHNob3cgaGVyZSc6ICdDbGljY2FuZG8gc3UgYWxjdW5lIHBhcnRpIGRlbCBtZXNzYWdnaW8gc2VsZXppb25lcmFpIHVuIGJsb2NjbyBlIGxlIG9wemlvbmkgZGkgc3RpbGUsIHNlIGRpc3BvbmliaWxpLCBjb21wYXJpcmFubm8gcXVpJyxcbiAgJ0NsaWNrIG9yIGRyYWcgZmlsZXMgaGVyZSc6ICdDbGljY2EgbyB0cmFzY2luYSBpIGZpbGUgcXVpIScsXG4gICdObyBpbWFnZXMgdXBsb2FkZWQsIHlldCc6ICdOb24gaGFpIGFuY29yYSBjYXJpY2F0byBpbW1hZ2luaScsXG4gICdTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5JzogJ1Zpc3VhbGl6emEgbGUgaW1tYWdpbmkgY2FyaWNhdGUgbmVsbGEgdHVhIGFyZWEnLFxuICAnTG9hZGluZy4uLic6ICdDYXJpY2FtZW50by4uLicsXG4gICdMb2FkIGdhbGxlcnknOiAnQ2FyaWNhIGdhbGxlcmlhJyxcbiAgJ0xvYWRpbmcgZ2FsbGVyeS4uLic6ICdDYXJpY2FtZW50byBpbiBjb3Jzby4uLicsXG4gICdUaGUgZ2FsbGVyeSBpcyBlbXB0eSc6ICdOZXNzdW5hIGltbWFnaW5lIG5lbGxhIGdhbGxlcmlhJyxcbiAgLy8gaW1nLXd5c2l3eWcudG1scFxuICAnUmVtb3ZlIGltYWdlJzogJ1JpbXVvdmkgaW1tYWdpbmUnLFxuICAnT3BlbiB0aGUgaW1hZ2UgZWRpdGluZyB0b29sJzogJ0F2dmlhIHN0cnVtZW50byBtb2RpZmljYSBpbW1hZ2luZScsXG4gICdVcGxvYWQgYSBuZXcgaW1hZ2UnOiAnQ2FyaWNhIHVuYSBudW92YSBpbW1hZ2luZScsXG4gICdEcm9wIGFuIGltYWdlIGhlcmUnOiAnVHJhc2NpbmEgdW5hIGltbWFnaW5lIHF1aScsXG4gICdEcm9wIGFuIGltYWdlIGhlcmUgb3IgY2xpY2sgdGhlIHVwbG9hZCBidXR0b24nOiAnVHJhc2NpbmEgdW5hIGltbWFnaW5lIHF1aSBvIGNsaWNjYSBzdWwgcHVsc2FudGUgZGkgY2FyaWNhbWVudG8nLFxuICAvLyBnYWxsZXJ5XG4gICdEcmFnIHRoaXMgaW1hZ2UgYW5kIGRyb3AgaXQgb24gYW55IHRlbXBsYXRlIGltYWdlIHBsYWNlaG9sZGVyJzogJ1RyYXNjaW5hIHF1ZXN0YSBpbW1hZ2luZSBzdWxsYSBwb3NpemlvbmUgaW4gY3VpIHZ1b2kgaW5zZXJpcmxhJyxcbiAgJ0dhbGxlcnk6JzogJ0dhbGxlcmlhOicsXG4gICdTZXNzaW9uIGltYWdlcyc6ICdJbW1hZ2luaSBkaSBzZXNzaW9uZScsXG4gICdSZWNlbnRzJzogJ1JlY2VudGknLFxuICAnUmVtb3RlIGdhbGxlcnknOiAnR2FsbGVyaWEgcmVtb3RhJyxcblxuICAvLyBjdXN0b21zdHlsZVxuICAnQ3VzdG9taXplZCBibG9jay48dWw+PGxpPkluIHRoaXMgc3RhdHVzIGNoYW5nZXMgdG8gcHJvcGVydGllcyB3aWxsIGJlIHNwZWNpZmljIHRvIHRoZSBjdXJyZW50IGJsb2NrIChpbnN0ZWFkIG9mIGJlaW5nIGdsb2JhbCB0byBhbGwgYmxvY2tzIGluIHRoZSBzYW1lIHNlY3Rpb24pPC9saT48bGk+QSA8c3BhbiBjbGFzcz1cImN1c3RvbVN0eWxlZFwiPjxzcGFuPlwic21hbGwgY3ViZVwiIDwvc3Bhbj48L3NwYW4+IGljb24gYmVzaWRlIHRoZSBwcm9wZXJ0eSB3aWxsIG1hcmsgdGhlIGN1c3RvbWl6YXRpb24uIEJ5IGNsaWNraW5nIHRoaXMgaWNvbiB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSByZXZlcnRlZCB0byB0aGUgdmFsdWUgZGVmaW5lZCBmb3IgdGhlIHNlY3Rpb24uPC9saT48L3VsPic6ICdCbG9jY28gcGVyc29uYWxpenphdG8uPHVsPjxsaT5JbiBxdWVzdGEgbW9kYWxpdMOgIHNlIGNhbWJpIHVuYSBwcm9wcmlldMOgIHZlcnLDoCBtb2RpZmljYXRhIHNvbGFtZW50ZSBwZXIgcXVlc3RvIHNwZWNpZmljbyBibG9jY28gKGludmVjZSBjaGUgcGVyIHR1dHRpIGkgYmxvY2NoaSBkZWxsYSBzdGVzc2Egc2V6aW9uZSkuPC9saT48bGk+UGVyIHNlZ25hbGFyZSBsYSBwZXJzb25hbGl6emF6aW9uZSBhcHBhcmlyw6AgbFxcJ2ljb25hIDxzcGFuIGNsYXNzPVwiY3VzdG9tU3R5bGVkXCI+PHNwYW4+IGRlbCBcImN1YmV0dG9cIjwvc3Bhbj48L3NwYW4+IGEgZmlhbmNvIGRlbGxlIHByb3ByaWV0w6AuIENsaWNjYW5kbyBxdWVzdGEgaWNvbmEgdG9ybmVyYWkgYWwgdmFsb3JlIGNvbXVuZS48L2xpPjwvdWw+JyxcbiAgLy8gYmxvY2tzLXd5c2l3eWdcbiAgJ0Ryb3AgaGVyZSBibG9ja3MgZnJvbSB0aGUgXCJCbG9ja3NcIiB0YWInOiAnVHJhc2NpbmEgcXVpIGkgYmxvY2NoaSBkYWxsYSBzY2hlZGEgXFwnQmxvY2NoaVxcJycsXG4gIC8vIGJsb2NrLXd5c2l3eWdcbiAgJ0RyYWcgdGhpcyBoYW5kbGUgdG8gbW92ZSB0aGUgYmxvY2snOiAnVHJhc2NpbmEgcGVyIHNwb3N0YXJlIGlsIGJsb2NjbyBhbHRyb3ZlJyxcbiAgJ01vdmUgdGhpcyBibG9jayB1cHNpZGUnOiAnU3Bvc3RhIGlsIGJsb2NjbyBpbiBzdScsXG4gICdNb3ZlIHRoaXMgYmxvY2sgZG93bnNpZGUnOiAnU3Bvc3RhIGlsIGJsb2NjbyBpbiBnaXUnLFxuICAnRGVsZXRlIGJsb2NrJzogJ0VsaW1pbmEgYmxvY2NvJyxcbiAgJ0R1cGxpY2F0ZSBibG9jayc6ICdEdXBsaWNhIGJsb2NjbycsXG4gICdTd2l0Y2ggYmxvY2sgdmFyaWFudCc6ICdDYW1iaWEgdmFyaWFudGUgYmxvY2NvJyxcbiAgLy8gY29sb3JwaWNrZXJcbiAgJ1RoZW1lIENvbG9ycyxTdGFuZGFyZCBDb2xvcnMsV2ViIENvbG9ycyxUaGVtZSBDb2xvcnMsQmFjayB0byBQYWxldHRlLEhpc3RvcnksTm8gaGlzdG9yeSB5ZXQuJzogJ0NvbG9yaSBUZW1hLENvbG9yaSBTdGFuZGFyZCxDb2xvcmkgV2ViLENvbG9yaSBUZW1hLFRvcm5hIGFsbGEgdGF2b2xvenphLFN0b3JpY28sc3RvcmljbyBjb2xvcmkgdnVvdG8nLFxuXG4gICdEcm9wIGhlcmUnOiAnUmlsYXNjaWEgcXVpJyxcblxufTtcbiovXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVFZGl0b3IoY29udGVudCwgYmxvY2tEZWZzLCB0aHVtYlBhdGhDb252ZXJ0ZXIsIGdhbGxlcnlVcmwpIHtcblxuICB2YXIgdmlld01vZGVsID0ge1xuICAgIGdhbGxlcnlSZWNlbnQ6IGtvLm9ic2VydmFibGVBcnJheShbXSkuZXh0ZW5kKHtcbiAgICAgIHBhZ2luZzogMTZcbiAgICB9KSxcbiAgICBnYWxsZXJ5UmVtb3RlOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLmV4dGVuZCh7XG4gICAgICBwYWdpbmc6IDE2XG4gICAgfSksXG4gICAgc2VsZWN0ZWRCbG9jazoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICBzZWxlY3RlZEl0ZW06IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgc2VsZWN0ZWRUb29sOiBrby5vYnNlcnZhYmxlKDApLFxuICAgIHNlbGVjdGVkSW1hZ2VUYWI6IGtvLm9ic2VydmFibGUoMCksXG4gICAgZHJhZ2dpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIGRyYWdnaW5nSW1hZ2U6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIGdhbGxlcnlMb2FkZWQ6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHNob3dQcmV2aWV3RnJhbWU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHByZXZpZXdNb2RlOiBrby5vYnNlcnZhYmxlKCdtb2JpbGUnKSxcbiAgICBzaG93VG9vbGJveDoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICBzaG93VGhlbWU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHNob3dHYWxsZXJ5OiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICBkZWJ1Zzoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgY29udGVudExpc3RlbmVyczoga28ub2JzZXJ2YWJsZSgwKSxcblxuICAgIGxvZ29QYXRoOiAnZGlzdC9pbWcvbW9zYWljbzMyLnBuZycsXG4gICAgbG9nb1VybDogJy4nLFxuICAgIGxvZ29BbHQ6ICdtb3NhaWNvJ1xuICB9O1xuXG4gIC8vIHZpZXdNb2RlbC5jb250ZW50ID0gY29udGVudC5faW5zdHJ1bWVudChrbywgY29udGVudCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgdmlld01vZGVsLmNvbnRlbnQgPSBjb250ZW50O1xuICB2aWV3TW9kZWwuYmxvY2tEZWZzID0gYmxvY2tEZWZzO1xuXG4gIHZpZXdNb2RlbC5ub3RpZmllciA9IHRvYXN0cjtcblxuICAvLyBEb2VzIHRva2VuIHN1YnN0aXR1dGlvbiBpbiBpMThuZXh0IHN0eWxlXG4gIHZpZXdNb2RlbC50dCA9IGZ1bmN0aW9uKGtleSwgcGFyYW1PYmopIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtT2JqICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGZvciAodmFyIHByb3AgaW4gcGFyYW1PYmopXG4gICAgICAgIGlmIChwYXJhbU9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKG5ldyBSZWdFeHAoJ19fJyArIHByb3AgKyAnX18nLCAnZycpLCBwYXJhbU9ialtwcm9wXSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9O1xuXG4gIC8vIFNpbXBseSBtYXBzIHRvIHR0OiBsYW5ndWFnZSBwbHVnaW5zIGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBkZWZpbmUgdGhlaXIgb3duIGxhbmd1YWdlXG4gIC8vIGhhbmRsaW5nLlxuICAvLyBJZiB0aGlzIG1ldGhvZCBpbnZva2VzIGFuIG9ic2VydmFibGUgKGUuZzogdmlld01vZGVsLmxhbmcoKSkgdGhlbiB0aGUgVUkgbGFuZ3VhZ2Ugd2lsbCBhdXRvbWF0aWNhbGx5XG4gIC8vIHVwZGF0ZSB3aGVuIHRoZSBcImxhbmdcIiBvYnNlcnZhYmxlIGNoYW5nZXMuXG4gIHZpZXdNb2RlbC50ID0gdmlld01vZGVsLnR0O1xuXG4gIC8vIGN1cnJlbnRseSBjYWxsZWQgYnkgZWRpdG9yLmh0bWwgdG8gdHJhbnNsYXRlIHRlbXBsYXRlLWRlZmluZWQga2V5cyAobGFiZWwsIGhlbHAsIGRlc2NyaXB0aW9ucylcbiAgLy8gdGhlIGVkaXRvciBhbHdheXMgdXNlcyB0aGUgXCJ0ZW1wbGF0ZVwiIGNhdGVnb3J5IGZvciB0aGF0IHN0cmluZ3MuXG4gIC8vIHlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgYXMgeW91IGxpa2UgaW4gb3JkZXIgdG8gcHJvdmlkZSB0cmFuc2xhdGlvbiBvciBjaGFuZ2UgdGhlIHN0cmluZ3MgaW4gYW55IHdheS5cbiAgdmlld01vZGVsLnV0ID0gZnVuY3Rpb24oY2F0ZWdvcnksIGtleSkge1xuICAgIHJldHVybiBrZXk7XG4gIH07XG5cbiAgdmlld01vZGVsLnRlbXBsYXRlUGF0aCA9IHRodW1iUGF0aENvbnZlcnRlcjtcblxuICB2aWV3TW9kZWwucmVtb3RlVXJsUHJvY2Vzc29yID0gZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfTtcblxuICB2aWV3TW9kZWwucmVtb3RlRmlsZVByb2Nlc3NvciA9IGZ1bmN0aW9uKGZpbGVPYmopIHtcbiAgICBpZiAodHlwZW9mIGZpbGVPYmoudXJsICE9PSAndW5kZWZpbmVkJykgZmlsZU9iai51cmwgPSB2aWV3TW9kZWwucmVtb3RlVXJsUHJvY2Vzc29yKGZpbGVPYmoudXJsKTtcbiAgICBpZiAodHlwZW9mIGZpbGVPYmoudGh1bWJuYWlsVXJsICE9PSAndW5kZWZpbmVkJykgZmlsZU9iai50aHVtYm5haWxVcmwgPSB2aWV3TW9kZWwucmVtb3RlVXJsUHJvY2Vzc29yKGZpbGVPYmoudGh1bWJuYWlsVXJsKTtcbiAgICAvLyBkZWxldGVVcmw/XG4gICAgcmV0dXJuIGZpbGVPYmo7XG4gIH07XG5cbiAgLy8gdG9vbGJveC50bXBsLmh0bWxcbiAgdmlld01vZGVsLmxvYWRHYWxsZXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmlld01vZGVsLmdhbGxlcnlMb2FkZWQoJ2xvYWRpbmcnKTtcbiAgICB2YXIgdXJsID0gZ2FsbGVyeVVybCA/IGdhbGxlcnlVcmwgOiAnL3VwbG9hZC8nO1xuICAgIC8vIHJldHJpZXZlIHRoZSBmdWxsIGxpc3Qgb2YgcmVtb3RlIGZpbGVzXG4gICAgJC5nZXRKU09OKHVybCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZpbGVzLmxlbmd0aDsgaSsrKSBkYXRhLmZpbGVzW2ldID0gdmlld01vZGVsLnJlbW90ZUZpbGVQcm9jZXNzb3IoZGF0YS5maWxlc1tpXSk7XG4gICAgICB2aWV3TW9kZWwuZ2FsbGVyeUxvYWRlZChkYXRhLmZpbGVzLmxlbmd0aCk7XG4gICAgICAvLyBUT0RPIGRvIEkgd2FudCB0aGlzIGNhbGwgdG8gcmV0dXJuIHJlbGF0aXZlIHBhdGhzPyBPciBqdXN0IGFic29sdXRlIHBhdGhzP1xuICAgICAgdmlld01vZGVsLmdhbGxlcnlSZW1vdGUoZGF0YS5maWxlcy5yZXZlcnNlKCkpO1xuICAgIH0pLmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICB2aWV3TW9kZWwuZ2FsbGVyeUxvYWRlZChmYWxzZSk7XG4gICAgICB2aWV3TW9kZWwubm90aWZpZXIuZXJyb3Iodmlld01vZGVsLnQoJ1VuZXhwZWN0ZWQgZXJyb3IgbGlzdGluZyBmaWxlcycpKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBpbWctd3lzaXd5Zy50bXBsLmh0bWxcbiAgdmlld01vZGVsLmZpbGVUb0ltYWdlID0gZnVuY3Rpb24ob2JqLCBldmVudCwgdWkpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcImZpbGVUb0ltYWdlXCIsIG9iaik7XG4gICAgcmV0dXJuIG9iai51cmw7XG4gIH07XG5cbiAgLy8gYmxvY2std3lzaXd5Zy50bXBsLmh0bWxcbiAgdmlld01vZGVsLnJlbW92ZUJsb2NrID0gZnVuY3Rpb24oZGF0YSwgcGFyZW50KSB7XG4gICAgLy8gbGV0J3MgdW5zZWxlY3QgdGhlIGJsb2NrXG4gICAgaWYgKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmlld01vZGVsLnNlbGVjdGVkQmxvY2spID09IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZGF0YSkpIHtcbiAgICAgIHZpZXdNb2RlbC5zZWxlY3RCbG9jayhudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHBhcmVudC5ibG9ja3MucmVtb3ZlKGRhdGEpO1xuICAgIC8vIFRPRE8gVGhpcyBtZXNzYWdlIHNob3VsZCBiZSBkaWZmZXJlbnQgZGVwZW5kaW5nIG9uIHVuZG8gcGx1Z2luIHByZXNlbmNlLlxuICAgIHZpZXdNb2RlbC5ub3RpZmllci5pbmZvKHZpZXdNb2RlbC50KCdCbG9jayByZW1vdmVkOiB1c2UgdW5kbyBidXR0b24gdG8gcmVzdG9yZSBpdC4uLicpKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIGJsb2NrLXd5c2l3eWcudG1wbC5odG1sXG4gIHZpZXdNb2RlbC5kdXBsaWNhdGVCbG9jayA9IGZ1bmN0aW9uKGluZGV4LCBwYXJlbnQpIHtcbiAgICB2YXIgaWR4ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShpbmRleCk7XG4gICAgLy8gRGVpbnN0cnVtZW50L2Rlb2JzZXJ2ZSB0aGUgb2JqZWN0XG4gICAgdmFyIHVud3JhcHBlZCA9IGtvLnRvSlMoa28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShwYXJlbnQuYmxvY2tzKVtpZHhdKTtcbiAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgaWQgc28gdGhhdCBhIG5ldyBvbmUgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgY2xvbmVcbiAgICBpZiAodHlwZW9mIHVud3JhcHBlZC5pZCAhPT0gJ3VuZGVmaW5lZCcpIHVud3JhcHBlZC5pZCA9ICcnO1xuICAgIC8vIGluc2VydCB0aGUgY2xvbmVkIGJsb2NrXG4gICAgcGFyZW50LmJsb2Nrcy5zcGxpY2UoaWR4ICsgMSwgMCwgdW53cmFwcGVkKTtcbiAgfTtcblxuICAvLyBibG9jay13eXNpd3lnLnRtcGwuaHRtbFxuICB2aWV3TW9kZWwubW92ZUJsb2NrID0gZnVuY3Rpb24oaW5kZXgsIHBhcmVudCwgdXApIHtcbiAgICB2YXIgaWR4ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShpbmRleCk7XG4gICAgdmFyIHBhcmVudEJsb2NrcyA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUocGFyZW50LmJsb2Nrcyk7XG4gICAgaWYgKCh1cCAmJiBpZHggPiAwKSB8fCAoIXVwICYmIGlkeCA8IHBhcmVudEJsb2Nrcy5sZW5ndGggLSAxKSkge1xuICAgICAgdmFyIGRlc3RJbmRleCA9IGlkeCArICh1cCA/IC0xIDogMSk7XG4gICAgICB2YXIgZGVzdEJsb2NrID0gcGFyZW50QmxvY2tzW2Rlc3RJbmRleF07XG4gICAgICB2aWV3TW9kZWwuc3RhcnRNdWx0aXBsZSgpO1xuICAgICAgcGFyZW50LmJsb2Nrcy5zcGxpY2UoZGVzdEluZGV4LCAxKTtcbiAgICAgIHBhcmVudC5ibG9ja3Muc3BsaWNlKGlkeCwgMCwgZGVzdEJsb2NrKTtcbiAgICAgIHZpZXdNb2RlbC5zdG9wTXVsdGlwbGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gdGVzdCBtZXRob2QsIGNvbW1hbmQgbGluZSB1c2Ugb25seVxuICB2aWV3TW9kZWwubG9hZERlZmF1bHRCbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjbG9uaW5nIHRoZSB3aG9sZSBcIm1haW5CbG9ja3NcIiBvYmplY3Qgc28gdGhhdCB1bmRvbWFuYWdlciB3aWxsXG4gICAgLy8gc2VlIGl0IGFzIGEgc2luZ2xlIG9wZXJhdGlvbiAobWF5YmUgSSBjb3VsZCB1c2UgXCJzdGFydE11bHRpcGxlXCIvXCJzdG9wTXVsdGlwbGVcIi5cbiAgICB2YXIgcmVzID0ga28udG9KUyh2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MpO1xuICAgIHJlcy5ibG9ja3MgPSBbXTtcbiAgICB2YXIgaW5wdXQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZpZXdNb2RlbC5ibG9ja0RlZnMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYmogPSBrby50b0pTKGlucHV0W2ldKTtcbiAgICAgIC8vIGdlbmVyYXRpbmcgaWRzIGZvciBibG9ja3MsIG1heWJlIHRoaXMgd291bGQgd29yayBhbHNvIGxlYXZpbmcgaXQgZW1wdHkuXG4gICAgICBvYmouaWQgPSAnYmxvY2tfJyArIGk7XG4gICAgICByZXMuYmxvY2tzLnB1c2gob2JqKTtcbiAgICB9XG4gICAgcGVyZm9ybWFuY2VBd2FyZUNhbGxlcignc2V0TWFpbkJsb2NrcycsIHZpZXdNb2RlbC5jb250ZW50KCkubWFpbkJsb2Nrcy5fd3JhcC5iaW5kKHZpZXdNb2RlbC5jb250ZW50KCkubWFpbkJsb2NrcywgcmVzKSk7XG4gIH07XG5cbiAgLy8gZ2FsbGVyeS1pbWFnZXMudG1wbC5odG1sXG4gIHZpZXdNb2RlbC5hZGRJbWFnZSA9IGZ1bmN0aW9uKGltZykge1xuICAgIHZhciBzZWxlY3RlZEltZyA9ICQoJyNtYWluLXd5c2l3eWctYXJlYSAuc2VsZWN0YWJsZS1pbWcuc2VsZWN0ZWRpdGVtJyk7XG4gICAgaWYgKHNlbGVjdGVkSW1nLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBpbWcgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGltZy51cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBrby5jb250ZXh0Rm9yKHNlbGVjdGVkSW1nWzBdKS5fc3JjKGltZy51cmwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gdG9vbGJveC50bXBsLmh0bWxcbiAgdmlld01vZGVsLmFkZEJsb2NrID0gZnVuY3Rpb24ob2JqLCBldmVudCkge1xuICAgIC8vIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgYmxvY2sgd2UgdHJ5IHRvIGFkZCB0aGUgYmxvY2sganVzdCBhZnRlciB0aGUgc2VsZWN0ZWQgb25lLlxuICAgIHZhciBzZWxlY3RlZCA9IHZpZXdNb2RlbC5zZWxlY3RlZEJsb2NrKCk7XG4gICAgLy8gc2VhcmNoIHRoZSBzZWxlY3RlZCBibG9jayBwb3NpdGlvbi5cbiAgICB2YXIgZm91bmQ7XG4gICAgaWYgKHNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPIFwibWFpbkJsb2Nrc1wiIGlzIGFuIGhhcmRjb2RlZCB0aGluZy5cbiAgICAgIGZvciAodmFyIGkgPSB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MoKS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodmlld01vZGVsLmNvbnRlbnQoKS5tYWluQmxvY2tzKCkuYmxvY2tzKClbaV0oKSA9PSBzZWxlY3RlZCkge1xuICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcG9zO1xuICAgIGlmICh0eXBlb2YgZm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwb3MgPSBmb3VuZCArIDE7XG4gICAgICB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3Muc3BsaWNlKHBvcywgMCwgb2JqKTtcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5pbmZvKHZpZXdNb2RlbC50KCdOZXcgYmxvY2sgYWRkZWQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG9uZSAoX19wb3NfXyknLCB7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXdNb2RlbC5jb250ZW50KCkubWFpbkJsb2NrcygpLmJsb2Nrcy5wdXNoKG9iaik7XG4gICAgICBwb3MgPSB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MoKS5sZW5ndGggLSAxO1xuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmluZm8odmlld01vZGVsLnQoJ05ldyBibG9jayBhZGRlZCBhdCB0aGUgbW9kZWwgYm90dG9tIChfX3Bvc19fKScsIHtcbiAgICAgICAgcG9zOiBwb3NcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgbmV3bHkgYWRkZWQgYmxvY2sgYW5kIHNlbGVjdCBpdCFcbiAgICB2YXIgYWRkZWQgPSB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MoKVtwb3NdKCk7XG4gICAgdmlld01vZGVsLnNlbGVjdEJsb2NrKGFkZGVkLCB0cnVlKTtcbiAgICAvLyBwcmV2ZW50IGNsaWNrIHByb3BhZ2F0aW9uIChsb3NpbmcgdXJsIGhhc2ggLSBzZWUgIzQzKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBVc2VkIGJ5IHN0eWxlc2hlZXQuanMgdG8gY3JlYXRlIG11bHRpcGxlIHN0eWxlc1xuICB2aWV3TW9kZWwuZmluZE9iamVjdHNPZlR5cGUgPSBmdW5jdGlvbihkYXRhLCB0eXBlKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBvYmogPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEpO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB2YXIgdmFsID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvYmpbcHJvcF0pO1xuICAgICAgICAvLyBUT0RPIHRoaXMgaXMgbm90IHRoZSByaWdodCB3YXkgdG8gZGVhbCB3aXRoIFwiYmxvY2sgbGlzdFwiIG9iamVjdHMuXG4gICAgICAgIGlmIChwcm9wLm1hdGNoKC9CbG9ja3MkLykpIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbC5ibG9ja3MpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShjb250ZW50c1tpXSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGMudHlwZSkgPT0gdHlwZSkgcmVzLnB1c2goYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8gaW52ZXN0aWdhdGUgd2hpY2ggY29uZGl0aW9uIHByb3ZpZGUgYSBudWxsIHZhbHVlLlxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwgfHwga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWwudHlwZSkgPT0gdHlwZSkgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLypcbiAgdmlld01vZGVsLnBsYWNlaG9sZGVySGVscGVyID0gJ3NvcnRhYmxlLXBsYWNlaG9sZGVyJztcbiAgaWYgKGZhbHNlKSB7XG4gICAgdmlld01vZGVsLnBsYWNlaG9sZGVySGVscGVyID0ge1xuICAgICAgZWxlbWVudDogZnVuY3Rpb24oY3VycmVudEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICQoJzxkaXYgLz4nKS5yZW1vdmVDbGFzcygndWktZHJhZ2dhYmxlJykuYWRkQ2xhc3MoJ3NvcnRhYmxlLXBsYWNlaG9sZGVyJykuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpLmNzcygnd2lkdGgnLCAnMTAwJScpLmNzcygnaGVpZ2h0JywgY3VycmVudEl0ZW0uY3NzKCdoZWlnaHQnKSkuY3NzKCdvcGFjaXR5JywgJy44JylbMF07XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihjb250YWluZXIsIHApIHtcbiAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAqL1xuXG4gIC8vIEF0dGVtcHQgdG8gaW5zZXJ0IHRoZSBibG9jayBpbiB0aGUgZGVzdGluYXRpb24gbGF5b3V0IGR1cmluZyBkcmFnZ2luZ1xuICB2aWV3TW9kZWwucGxhY2Vob2xkZXJIZWxwZXIgPSB7XG4gICAgZWxlbWVudDogZnVuY3Rpb24oY3VycmVudEl0ZW0pIHtcbiAgICAgIHJldHVybiAkKGN1cnJlbnRJdGVtWzBdLm91dGVySFRNTCkucmVtb3ZlQ2xhc3MoJ3VpLWRyYWdnYWJsZScpLmFkZENsYXNzKCdzb3J0YWJsZS1wbGFjZWhvbGRlcicpLmNzcygnZGlzcGxheScsICdibG9jaycpLmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKS5jc3MoJ3dpZHRoJywgJzEwMCUnKS5jc3MoJ2hlaWdodCcsICdhdXRvJykuY3NzKCdvcGFjaXR5JywgJy44JylbMF07XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGNvbnRhaW5lciwgcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPIHRoZSB1bmR1bWFuYWdlciBzaG91bGQgYmUgcGx1Z2dhYmxlLlxuICAvLyBVc2VkIGJ5IFwibW92ZUJsb2NrXCIgYW5kIGJsb2Nrcy13eXNpd3lnLnRtcGwuaHRtbCB0byBcIm1lcmdlXCIgZHJhZy9kcm9wIG9wZXJhdGlvbnMgaW50byBhIHNpbmdsZSB1bmRvL3JlZG8gb3AuXG4gIHZpZXdNb2RlbC5zdGFydE11bHRpcGxlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3TW9kZWwuc2V0VW5kb01vZGVNZXJnZSAhPT0gJ3VuZGVmaW5lZCcpIHZpZXdNb2RlbC5zZXRVbmRvTW9kZU1lcmdlKCk7XG4gIH07XG4gIHZpZXdNb2RlbC5zdG9wTXVsdGlwbGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHZpZXdNb2RlbC5zZXRVbmRvTW9kZU9uY2UgIT09ICd1bmRlZmluZWQnKSB2aWV3TW9kZWwuc2V0VW5kb01vZGVPbmNlKCk7XG4gIH07XG5cbiAgLy8gVXNlZCBieSBjb2RlIGdlbmVyYXRlZCBieSBlZGl0b3IuanNcbiAgdmlld01vZGVsLmxvY2FsR2xvYmFsU3dpdGNoID0gZnVuY3Rpb24ocHJvcCwgZ2xvYmFsUHJvcCkge1xuICAgIHZhciBjdXJyZW50ID0gcHJvcCgpO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSBwcm9wKGdsb2JhbFByb3AoKSk7XG4gICAgZWxzZSBwcm9wKG51bGwpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBVc2VkIGJ5IGVkaXRvciBhbmQgbWFpbiBcImNvbnZlcnRlclwiIHRvIHN1cHBvcnQgaXRlbSBzZWxlY3Rpb25cbiAgdmlld01vZGVsLnNlbGVjdEl0ZW0gPSBmdW5jdGlvbih2YWx1ZUFjY2Vzc29yLCBpdGVtLCBibG9jaykge1xuICAgIHZhciB2YWwgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKTtcbiAgICBpZiAodHlwZW9mIGJsb2NrICE9PSAndW5kZWZpbmVkJykgdmlld01vZGVsLnNlbGVjdEJsb2NrKGJsb2NrLCBmYWxzZSwgdHJ1ZSk7XG4gICAgaWYgKHZhbCAhPSBpdGVtKSB7XG4gICAgICB2YWx1ZUFjY2Vzc29yKGl0ZW0pO1xuICAgICAgLy8gT24gc2VsZWN0SXRlbSBpZiB3ZSB3ZXJlIG9uIFwiQmxvY2tzXCIgdG9vbGJveCB0YWIgd2UgbW92ZSB0byBcIkNvbnRlbnRcIiB0b29sYm94IHRhYi5cbiAgICAgIGlmIChpdGVtICE9PSBudWxsICYmIHZpZXdNb2RlbC5zZWxlY3RlZFRvb2woKSA9PT0gMCkgdmlld01vZGVsLnNlbGVjdGVkVG9vbCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LmJpbmQodmlld01vZGVsLCB2aWV3TW9kZWwuc2VsZWN0ZWRJdGVtKTtcblxuICB2aWV3TW9kZWwuaXNTZWxlY3RlZEl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIHZpZXdNb2RlbC5zZWxlY3RlZEl0ZW0oKSA9PSBpdGVtO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5zZWxlY3RCbG9jayA9IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IsIGl0ZW0sIGRvTm90U2VsZWN0LCBkb05vdFVuc2VsZWN0SXRlbSkge1xuICAgIHZhciB2YWwgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKTtcbiAgICBpZiAoIWRvTm90VW5zZWxlY3RJdGVtKSB2aWV3TW9kZWwuc2VsZWN0SXRlbShudWxsKTtcbiAgICBpZiAodmFsICE9IGl0ZW0pIHtcbiAgICAgIHZhbHVlQWNjZXNzb3IoaXRlbSk7XG4gICAgICAvLyBoaWRlIGdhbGxlcnkgb24gYmxvY2sgc2VsZWN0aW9uXG4gICAgICB2aWV3TW9kZWwuc2hvd0dhbGxlcnkoZmFsc2UpO1xuICAgICAgaWYgKGl0ZW0gIT09IG51bGwgJiYgIWRvTm90U2VsZWN0ICYmIHZpZXdNb2RlbC5zZWxlY3RlZFRvb2woKSA9PT0gMCkgdmlld01vZGVsLnNlbGVjdGVkVG9vbCgxKTtcbiAgICB9XG4gIH0uYmluZCh2aWV3TW9kZWwsIHZpZXdNb2RlbC5zZWxlY3RlZEJsb2NrKTtcblxuICAvLyBERUJVR1xuICB2aWV3TW9kZWwuY291bnRTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24obW9kZWwsIGRlYnVnKSB7XG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBtb2RlbClcbiAgICAgIGlmIChtb2RlbC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB2YXIgcCA9IG1vZGVsW3Byb3BdO1xuICAgICAgICBpZiAoa28uaXNPYnNlcnZhYmxlKHApKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwLl9kZWZhdWx0Q29tcHV0ZWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVidWcgIT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUubG9nKGRlYnVnICsgXCIvXCIgKyBwcm9wICsgXCIvX1wiLCBwLl9kZWZhdWx0Q29tcHV0ZWQuZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkpO1xuICAgICAgICAgICAgcmVzICs9IHAuX2RlZmF1bHRDb21wdXRlZC5nZXRTdWJzY3JpcHRpb25zQ291bnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBkZWJ1ZyAhPSAndW5kZWZpbmVkJykgY29uc29sZS5sb2coZGVidWcgKyBcIi9cIiArIHByb3AgKyBcIi8tXCIsIHAuZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkpO1xuICAgICAgICAgIHJlcyArPSBwLmdldFN1YnNjcmlwdGlvbnNDb3VudCgpO1xuICAgICAgICAgIHAgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcCA9PSAnb2JqZWN0JyAmJiBwICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHRvdCA9IHZpZXdNb2RlbC5jb3VudFN1YnNjcmlwdGlvbnMocCwgdHlwZW9mIGRlYnVnICE9ICd1bmRlZmluZWQnID8gZGVidWcgKyAnLycgKyBwcm9wICsgXCJAXCIgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGVidWcgIT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUubG9nKGRlYnVnICsgXCIvXCIgKyBwcm9wICsgXCJAXCIsIHRvdCk7XG4gICAgICAgICAgcmVzICs9IHRvdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gREVCVUdcbiAgdmlld01vZGVsLmxvb3BTdWJzY3JpcHRpb25zQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnQgPSB2aWV3TW9kZWwuY291bnRTdWJzY3JpcHRpb25zKHZpZXdNb2RlbC5jb250ZW50KCkpO1xuICAgIGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3Vic2NyaXB0aW9uc0NvdW50JykuaW5uZXJIVE1MID0gY291bnQ7XG4gICAgZ2xvYmFsLnNldFRpbWVvdXQodmlld01vZGVsLmxvb3BTdWJzY3JpcHRpb25zQ291bnQsIDEwMDApO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGVudCA9IHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoXCJleHBvcnRIVE1MXCIsIHZpZXdNb2RlbC5leHBvcnRIVE1MKTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfTtcblxuICBmdW5jdGlvbiBjb25kaXRpb25hbF9yZXN0b3JlKGh0bWwpIHtcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88cmVwbGFjZWRjY1tePl0qIGNvbmRpdGlvbj1cIihbXlwiXSopXCJbXj5dKj4oW1xcc1xcU10qPyk8XFwvcmVwbGFjZWRjYz4vZywgZnVuY3Rpb24obWF0Y2gsIGNvbmRpdGlvbiwgYm9keSkge1xuICAgICAgdmFyIGRkID0gJzwhLS1baWYgJytjb25kaXRpb24ucmVwbGFjZSgvJmFtcDsvLCAnJicpKyddPic7XG4gICAgICBkZCArPSBib2R5LnJlcGxhY2UoLzwhLS0gY2M6YmM6KFtBLVphLXo6XSopIC0tPig8XFwvY2M+KT88IS0tIGNjOmFjOlxcMSAtLT4vZywgJzwvJDE+JykgLy8gcmVzdG9yZSBjbG9zaW5nIHRhZ3MgKGluY2x1ZGluZyBsb3N0IHRhZ3MpXG4gICAgICAgICAgICAucmVwbGFjZSgvPjxcXC9jYz48IS0tIGNjOnNjIC0tPi9nLCAnLz4nKSAvLyByZXN0b3JlIHNlbGZjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tIGNjOmJvOihbQS1aYS16Ol0qKSAtLT48Y2MvZywgJzwkMScpIC8vIHJlc3RvcmUgb3BlbiB0YWdzXG4gICAgICAgICAgICAucmVwbGFjZSgvXi4qPCEtLSBjYzpzdGFydCAtLT4vLCcnKSAvLyByZW1vdmUgY29udGVudCBiZWZvcmUgc3RhcnRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tIGNjOmVuZCAtLT4uKiQvLCcnKTsgLy8gcmVtb3ZlIGNvbnRlbnQgYWZ0ZXIgZW5kXG4gICAgICBkZCArPSAnPCFbZW5kaWZdLS0+JztcbiAgICAgIHJldHVybiBkZDtcbiAgICB9KTtcbiAgfVxuXG4gIHZpZXdNb2RlbC5leHBvcnRIVE1MID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coJ3ZpZXdNb2RlbC5leHBvcnRIVE1MJylcbiAgICB2YXIgaWQgPSAnZXhwb3J0ZnJhbWUnO1xuICAgICQoJ2JvZHknKS5hcHBlbmQoJzxpZnJhbWUgaWQ9XCInICsgaWQgKyAnXCIgZGF0YS1iaW5kPVwiYmluZElmcmFtZTogJGRhdGFcIj48L2lmcmFtZT4nKTtcbiAgICB2YXIgZnJhbWVFbCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAga28uYXBwbHlCaW5kaW5ncyh2aWV3TW9kZWwsIGZyYW1lRWwpO1xuXG4gICAga28uY2xlYW5Ob2RlKGZyYW1lRWwpO1xuICAgIGlmICh2aWV3TW9kZWwuaW5saW5lKSB2aWV3TW9kZWwuaW5saW5lKGZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudCk7XG5cbiAgICAvLyBPYnNvbGV0ZSBtZXRob2QgZGlkbid0IHdvcmsgb24gSUUxMSB3aGVuIHVzaW5nIFwiSFRNTDUgZG9jdHlwZVwiOlxuICAgIC8vIHZhciBkb2NUeXBlID0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhnbG9iYWwuZG9jdW1lbnQuZG9jdHlwZSk7XG4gICAgdmFyIG5vZGUgPSBmcmFtZUVsLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdHlwZTtcbiAgICB2YXIgZG9jVHlwZSA9IFwiPCFET0NUWVBFIFwiICsgbm9kZS5uYW1lICtcbiAgICAgIChub2RlLnB1YmxpY0lkID8gJyBQVUJMSUMgXCInICsgbm9kZS5wdWJsaWNJZCArICdcIicgOiAnJykgK1xuICAgICAgKCFub2RlLnB1YmxpY0lkICYmIG5vZGUuc3lzdGVtSWQgPyAnIFNZU1RFTScgOiAnJykgK1xuICAgICAgKG5vZGUuc3lzdGVtSWQgPyAnIFwiJyArIG5vZGUuc3lzdGVtSWQgKyAnXCInIDogJycpICsgJz4nO1xuICAgIHZhciBjb250ZW50ID0gZG9jVHlwZSArIFwiXFxuXCIgKyBmcmFtZUVsLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICBrby5yZW1vdmVOb2RlKGZyYW1lRWwpO1xuXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvPHNjcmlwdCAoW14+XSogKT90eXBlPVwidGV4dFxcL2h0bWxcIltePl0qPltcXHNcXFNdKj88XFwvc2NyaXB0Pi9nbSwgJycpO1xuICAgIC8vIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzwhLS0ga28gLio/IC0tPi9nLCAnJyk7IC8vIHNvbWV0aW1lcyB3ZSBoYXZlIGV4cHJlc3Npb25zIGxpa2UgKDwhLS0ga28gdmFyID4gMiAtLT4pXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvPCEtLSBrbyAoKD8hLS0pLikqPyAtLT4vZywgJycpOyAvLyB0aGlzIHJlcGxhY2VzIHRoZSBhYm92ZSB3aXRoIGEgbW9yZSBmb3JtYWwgKGJ1dCBzbG93ZXIpIHNvbHV0aW9uXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvPCEtLSBcXC9rbyAtLT4vZywgJycpO1xuICAgIC8vIFJlbW92ZSBkYXRhLWJpbmQvZGF0YS1ibG9jayBhdHRyaWJ1dGVzXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvIGRhdGEtYmluZD1cIlteXCJdKlwiL2dtLCAnJyk7XG4gICAgLy8gUmVtb3ZlIHRyYXNoIGxlZnRvdmVyIGJ5IFRpbnlNQ0VcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gZGF0YS1tY2UtKGhyZWZ8c3JjKT1cIlteXCJdKlwiL2dtLCAnJyk7XG5cbiAgICAvLyBSZXBsYWNlIFwicmVwbGFjZWRzdHlsZVwiIHRvIFwic3R5bGVcIiBhdHRyaWJ1dGVzIChjaHJvbWUgcHV0cyByZXBsYWNlZHN0eWxlIGFmdGVyIHN0eWxlKVxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyBzdHlsZT1cIlteXCJdKlwiKFtePl0qKSByZXBsYWNlZChzdHlsZT1cIlteXCJdKlwiKS9nbSwgJyQxICQyJyk7XG4gICAgLy8gUmVwbGFjZSBcInJlcGxhY2Vkc3R5bGVcIiB0byBcInN0eWxlXCIgYXR0cmlidXRlcyAoaWUvZmYgaGF2ZSByZXZlcnNlIG9yZGVyKVxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyByZXBsYWNlZChzdHlsZT1cIlteXCJdKlwiKShbXj5dKikgc3R5bGU9XCJbXlwiXSpcIi9nbSwgJyAkMSQyJyk7XG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvIHJlcGxhY2VkKHN0eWxlPVwiW15cIl0qXCIpL2dtLCAnICQxJyk7XG5cbiAgICAvLyBzYW1lIGFzIHN0eWxlLCBidXQgZm9yIGh0dHAtZXF1aXYgKHNvbWUgYnJvd3NlciBicmVhayBpdCBpZiB3ZSBkb24ndCByZXBsYWNlLCBidXQgdGhlbiB3ZSBmaW5kIGl0IGR1cGxpY2F0ZWQpXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvIGh0dHAtZXF1aXY9XCJbXlwiXSpcIihbXj5dKikgcmVwbGFjZWQoaHR0cC1lcXVpdj1cIlteXCJdKlwiKS9nbSwgJyQxICQyJyk7XG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvIHJlcGxhY2VkKGh0dHAtZXF1aXY9XCJbXlwiXSpcIikoW14+XSopIGh0dHAtZXF1aXY9XCJbXlwiXSpcIi9nbSwgJyAkMSQyJyk7XG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvIHJlcGxhY2VkKGh0dHAtZXF1aXY9XCJbXlwiXSpcIikvZ20sICcgJDEnKTtcblxuICAgIC8vIEJBRFNFTkRFUjogUmVzdG9yZSBFU1AgdGFnc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29kZW5vdWdoL21vc2FpY28vaXNzdWVzLzJcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8mbHQ7JS9nLCAnPCUnKTtcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8lJmd0Oy9nLCAnJT4nKTtcblxuICAgIC8vIFdlIGFscmVhZHkgcmVwbGFjZSBzdHlsZSBhbmQgaHR0cC1lcXVpdiBhbmQgd2UgZG9uJ3QgbmVlZCB0aGlzLlxuICAgIC8vIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyByZXBsYWNlZChbXj0gXSo9KS9nbSwgJyAkMScpO1xuICAgIC8vIFJlc3RvcmUgY29uZGl0aW9uYWwgY29tbWVudHNcbiAgICBjb250ZW50ID0gY29uZGl0aW9uYWxfcmVzdG9yZShjb250ZW50KTtcbiAgICB2YXIgdHJhc2ggPSBjb250ZW50Lm1hdGNoKC8gZGF0YS1bXiA9XSsoPVwiW15cIl0rXCIpPyAvKSB8fCBjb250ZW50Lm1hdGNoKC8gcmVwbGFjZWQoW149IF0qPSkvKTtcbiAgICBpZiAodHJhc2gpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk91dHB1dCBIVE1MIGNvbnRhaW5zIHVuZXhwZWN0ZWQgZGF0YS0gYXR0cmlidXRlcyBvciByZXBsYWNlZCBhdHRyaWJ1dGVzXCIsIHRyYXNoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudDtcbiAgfTtcblxuICB2aWV3TW9kZWwuZXhwb3J0SFRNTHRvVGV4dGFyZWEgPSBmdW5jdGlvbih0ZXh0YXJlYWlkKSB7XG4gICAgJCh0ZXh0YXJlYWlkKS52YWwodmlld01vZGVsLmV4cG9ydEhUTUwoKSk7XG4gIH07XG5cbiAgdmlld01vZGVsLmV4cG9ydEpTT050b1RleHRhcmVhID0gZnVuY3Rpb24odGV4dGFyZWFpZCkge1xuICAgICQodGV4dGFyZWFpZCkudmFsKHZpZXdNb2RlbC5leHBvcnRKU09OKCkpO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5pbXBvcnRKU09OZnJvbVRleHRhcmVhID0gZnVuY3Rpb24odGV4dGFyZWFpZCkge1xuICAgIHZpZXdNb2RlbC5pbXBvcnRKU09OKCQodGV4dGFyZWFpZCkudmFsKCkpO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnRNZXRhZGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBqc29uID0ga28udG9KU09OKHZpZXdNb2RlbC5tZXRhZGF0YSk7XG4gICAgcmV0dXJuIGpzb247XG4gIH07XG5cbiAgdmlld01vZGVsLmV4cG9ydEpTT04gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIganNvbiA9IGtvLnRvSlNPTih2aWV3TW9kZWwuY29udGVudCk7XG4gICAgcmV0dXJuIGpzb247XG4gIH07XG5cbiAgdmlld01vZGVsLmV4cG9ydEpTID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGtvLnRvSlModmlld01vZGVsLmNvbnRlbnQpO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5pbXBvcnRKU09OID0gZnVuY3Rpb24oanNvbikge1xuICAgIHZhciB1bndyYXBwZWQgPSBrby51dGlscy5wYXJzZUpzb24oanNvbik7XG4gICAgdmlld01vZGVsLmNvbnRlbnQuX3dyYXAodW53cmFwcGVkKTtcbiAgfTtcblxuICB2aWV3TW9kZWwuZXhwb3J0VGhlbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmxhdCA9IHt9O1xuICAgIHZhciBtb2QgPSB2aWV3TW9kZWwuY29udGVudCgpLnRoZW1lKCk7XG5cbiAgICB2YXIgX2V4cG9ydCA9IGZ1bmN0aW9uKHByZWZpeCwgZmxhdCwgbW9kKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG1vZClcbiAgICAgICAgaWYgKG1vZC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIHZhciBhID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtb2RbcHJvcF0pO1xuICAgICAgICAgIGlmIChhICE9PSBudWxsICYmIHR5cGVvZiBhID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBfZXhwb3J0KHByb3AgKyAnLicsIGZsYXQsIGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGF0W3ByZWZpeCArIHByb3BdID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX2V4cG9ydCgnJywgZmxhdCwgbW9kKTtcblxuICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICBmb3IgKHZhciBwcm9wIGluIGZsYXQpXG4gICAgICBpZiAoZmxhdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBwcm9wICE9ICd0eXBlJykge1xuICAgICAgICBvdXRwdXQgKz0gcHJvcCArIFwiOiBcIiArIGZsYXRbcHJvcF0gKyBcIjtcIiArIFwiXFxuXCI7XG4gICAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIG1veGllbWFuYWdlciAob3IgZmlsZSBicm93c2VyL2ltYWdlZWRpdG9yKSBleHRlbnNpb24gcG9pbnRzLlxuICAvLyBKdXN0IGltcGxlbWVudCBlZGl0SW1hZ2Ugb3IgbGlua0RpYWxvZyBtZXRob2RzXG4gIC8vIHZpZXdNb2RlbC5lZGl0SW1hZ2UgPSBmdW5jdGlvbihzcmMsIGRvbmUpIHt9IDogaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIGVuYWJsZSBpbWFnZSBlZGl0aW5nIChzcmMgaXMgYSB3aXJ0YWJsZU9ic2VydmFibGUpLlxuICAvLyB2aWV3TW9kZWwubGlua0RpYWxvZyA9IGZ1bmN0aW9uKCkge306IGltcGxlbWVudCB0aGlzIG1ldGhvZCB1c2luZyBcInRoaXNcIiB0byBmaW5kIHRoZSBpbnB1dCBlbGVtZW50ICQodGhpcykudmFsIGlzIGEgd3JpdGFibGVPYnNlcnZhYmxlLlxuXG4gIHZpZXdNb2RlbC5sb2FkSW1hZ2UgPSBmdW5jdGlvbihpbWcpIHtcbiAgICAvLyBwdXNoIGltYWdlIGF0IHRvcCBvZiBcInJlY2VudFwiIGdhbGxlcnlcbiAgICB2aWV3TW9kZWwuZ2FsbGVyeVJlY2VudC51bnNoaWZ0KGltZyk7XG4gICAgLy8gc2VsZWN0IHJlY2VudCBnYWxsZXJ5IHRhYlxuICAgIHZpZXdNb2RlbC5zZWxlY3RlZEltYWdlVGFiKDApO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5kaWFsb2cgPSBmdW5jdGlvbihzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICQoc2VsZWN0b3IpLmRpYWxvZyhvcHRpb25zKTtcbiAgfTtcblxuICAvLyBEdW1teSBsb2cgbWV0aG9kIG92ZXJyaWRkZW4gYnkgZXh0ZW5zaW9uc1xuICB2aWV3TW9kZWwubG9nID0gZnVuY3Rpb24oY2F0ZWdvcnksIG1zZykge1xuICAgIC8vIGNvbnNvbGUubG9nKFwidmlld01vZGVsLmxvZ1wiLCBjYXRlZ29yeSwgbXNnKTtcbiAgfTtcblxuICAvLyBhdXRvbWF0aWNhbGx5IGxvYWQgdGhlIGdhbGxlcnkgd2hlbiB0aGUgZ2FsbGVyeSB0YWIgaXMgc2VsZWN0ZWRcbiAgdmlld01vZGVsLnNlbGVjdGVkSW1hZ2VUYWIuc3Vic2NyaWJlKGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgaWYgKG5ld1ZhbHVlID09IDEgJiYgdmlld01vZGVsLmdhbGxlcnlMb2FkZWQoKSA9PT0gZmFsc2UpIHtcbiAgICAgIHZpZXdNb2RlbC5sb2FkR2FsbGVyeSgpO1xuICAgIH1cbiAgfSwgdmlld01vZGVsLCAnY2hhbmdlJyk7XG5cbiAgcmV0dXJuIHZpZXdNb2RlbDtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRpYWxpemVFZGl0b3I7XG4iXX0=
