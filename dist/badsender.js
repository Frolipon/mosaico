(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Badsender = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/*global window, global*/
var util = require("util")
var assert = require("assert")

var slice = Array.prototype.slice
var console
var times = {}

if (typeof global !== "undefined" && global.console) {
    console = global.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"]
    , [info, "info"]
    , [warn, "warn"]
    , [error, "error"]
    , [time, "time"]
    , [timeEnd, "timeEnd"]
    , [trace, "trace"]
    , [dir, "dir"]
    , [assert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = Date.now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    var duration = Date.now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function assert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"assert":14,"util":18}],2:[function(require,module,exports){
/*
   evol.colorpicker 3.2.2
   (c) 2015 Olivier Giulieri
   http://evoluteur.github.io/colorpicker/
*/
!function(a,b){var c=0,d=window.navigator.userAgent,e=d.indexOf("MSIE ")>0,f=e?"-ie":"",g=e?!1:/mozilla/.test(d.toLowerCase())&&!/webkit/.test(d.toLowerCase()),h=[],i=["ffffff","000000","eeece1","1f497d","4f81bd","c0504d","9bbb59","8064a2","4bacc6","f79646"],j=["f2f2f2","7f7f7f","ddd9c3","c6d9f0","dbe5f1","f2dcdb","ebf1dd","e5e0ec","dbeef3","fdeada","d8d8d8","595959","c4bd97","8db3e2","b8cce4","e5b9b7","d7e3bc","ccc1d9","b7dde8","fbd5b5","bfbfbf","3f3f3f","938953","548dd4","95b3d7","d99694","c3d69b","b2a2c7","92cddc","fac08f","a5a5a5","262626","494429","17365d","366092","953734","76923c","5f497a","31859b","e36c09","7f7f7f","0c0c0c","1d1b10","0f243e","244061","632423","4f6128","3f3151","205867","974806"],k=["c00000","ff0000","ffc000","ffff00","92d050","00b050","00b0f0","0070c0","002060","7030a0"],l=[["003366","336699","3366cc","003399","000099","0000cc","000066"],["006666","006699","0099cc","0066cc","0033cc","0000ff","3333ff","333399"],["669999","009999","33cccc","00ccff","0099ff","0066ff","3366ff","3333cc","666699"],["339966","00cc99","00ffcc","00ffff","33ccff","3399ff","6699ff","6666ff","6600ff","6600cc"],["339933","00cc66","00ff99","66ffcc","66ffff","66ccff","99ccff","9999ff","9966ff","9933ff","9900ff"],["006600","00cc00","00ff00","66ff99","99ffcc","ccffff","ccccff","cc99ff","cc66ff","cc33ff","cc00ff","9900cc"],["003300","009933","33cc33","66ff66","99ff99","ccffcc","ffffff","ffccff","ff99ff","ff66ff","ff00ff","cc00cc","660066"],["333300","009900","66ff33","99ff66","ccff99","ffffcc","ffcccc","ff99cc","ff66cc","ff33cc","cc0099","993399"],["336600","669900","99ff33","ccff66","ffff99","ffcc99","ff9999","ff6699","ff3399","cc3399","990099"],["666633","99cc00","ccff33","ffff66","ffcc66","ff9966","ff6666","ff0066","d60094","993366"],["a58800","cccc00","ffff00","ffcc00","ff9933","ff6600","ff0033","cc0066","660033"],["996633","cc9900","ff9900","cc6600","ff3300","ff0000","cc0000","990033"],["663300","996600","cc3300","993300","990000","800000","993333"]],m="#0000ffff",n=function(a){var b=a.toString(16);return 1==b.length&&(b="0"+b),b},o=function(a){return n(Number(a))},p=function(a){var b=n(a);return b+b+b},q=function(a){if(a.length>10){var b=1+a.indexOf("("),c=a.indexOf(")"),d=a.substring(b,c).split(",");return["#",o(d[0]),o(d[1]),o(d[2])].join("")}return a};a.widget("evol.colorpicker",{version:"3.2.1",options:{color:null,showOn:"both",hideButton:!1,displayIndicator:!0,transparentColor:!1,history:!0,defaultPalette:"theme",strings:"Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet."},_active:!1,_create:function(){var b=this;switch(this._paletteIdx="theme"==this.options.defaultPalette?1:2,this._id="evo-cp"+c++,this._enabled=!0,this.options.showOn=this.options.hideButton?"focus":this.options.showOn,this.element.get(0).tagName){case"INPUT":var d=this.options.color,h=this.element,i=("focus"===this.options.showOn?"":"evo-pointer ")+"evo-colorind"+(g?"-ff":f)+(this.options.hideButton?" evo-hidden-button":""),j="";if(this._isPopup=!0,this._palette=null,null!==d)h.val(d);else{var k=h.val();""!==k&&(d=this.options.color=k)}d===m?i+=" evo-transparent":j=null!==d?"background-color:"+d:"",h.addClass("colorPicker "+this._id).wrap('<div style="width:'+(this.options.hideButton?this.element.width():this.element.width()+32)+"px;"+(e?"margin-bottom:-21px;":"")+(g?"padding:1px 0;":"")+'"></div>').after('<div class="'+i+'" style="'+j+'"></div>').on("keyup onpaste",function(c){var d=a(this).val();d!=b.options.color&&b._setValue(d,!0)});var l=this.options.showOn;("both"===l||"focus"===l)&&h.on("focus",function(){b.showPalette()}),("both"===l||"button"===l)&&h.next().on("click",function(a){return a.stopPropagation(),b.showPalette(),!1});break;default:this._isPopup=!1,this._palette=this.element.html(this._paletteHTML()).attr("aria-haspopup","true"),this._bindColors()}if(this.options.history&&(d&&this._add2History(d),this.options.initialHistory)){var n=this.options.initialHistory;for(var o in n)this._add2History(n[o])}},_paletteHTML:function(){var a=this._paletteIdx=Math.abs(this._paletteIdx),b=this.options,c=b.strings.split(","),d='<div class="evo-pop'+f+' ui-widget ui-widget-content ui-corner-all"'+(this._isPopup?' style="position:absolute"':"")+"><span>"+this["_paletteHTML"+a]()+'</span><div class="evo-more"><a href="javascript:void(0)">'+c[1+a]+"</a>";return b.history&&(d+='<a href="javascript:void(0)" class="evo-hist">'+c[5]+"</a>"),d+="</div>",b.displayIndicator&&(d+=this._colorIndHTML(this.options.color)+this._colorIndHTML("")),d+="</div>"},_colorIndHTML:function(a){var b=e?"evo-colorbox-ie ":"",c="";return a?a===m?b+="evo-transparent":c="background-color:"+a:c="display:none",'<div class="evo-color" style="float:left"><div style="'+c+'" class="'+b+'"></div><span>'+(a?a:"")+"</span></div>"},_paletteHTML1:function(){for(var a=this.options,b=a.strings.split(","),c='<td style="background-color:#',d=e?'"><div style="width:2px;"></div></td>':'"><span/></td>',g='<tr><th colspan="10" class="ui-widget-content">',h='<table class="evo-palette'+f+'">'+g+b[0]+"</th></tr><tr>",l=0;10>l;l++)h+=c+i[l]+d;for(h+="</tr>",e||(h+='<tr><th colspan="10"></th></tr>'),h+='<tr class="top">',l=0;10>l;l++)h+=c+j[l]+d;for(var m=1;4>m;m++)for(h+='</tr><tr class="in">',l=0;10>l;l++)h+=c+j[10*m+l]+d;for(h+='</tr><tr class="bottom">',l=40;50>l;l++)h+=c+j[l]+d;for(h+="</tr>"+g,a.transparentColor&&(h+='<div class="evo-transparent evo-tr-box"></div>'),h+=b[1]+"</th></tr><tr>",l=0;10>l;l++)h+=c+k[l]+d;return h+="</tr></table>"},_paletteHTML2:function(){for(var a,b,c='<td style="background-color:#',d=e?'"><div style="width:5px;"></div></td>':'"><span/></td>',g='<table class="evo-palette2'+f+'"><tr>',h="</tr></table>",i='<div class="evo-palcenter">',j=0,k=l.length;k>j;j++){i+=g;var m=l[j];for(a=0,b=m.length;b>a;a++)i+=c+m[a]+d;i+=h}i+='<div class="evo-sep"/>';var n="";for(i+=g,a=255;a>10;a-=10)i+=c+p(a)+d,a-=10,n+=c+p(a)+d;return i+=h+g+n+h+"</div>"},_switchPalette:function(b){if(this._enabled){var c,d,e,f=this.options.strings.split(",");if(a(b).hasClass("evo-hist")){var g=['<table class="evo-palette"><tr><th class="ui-widget-content">',f[5],"</th></tr></tr></table>",'<div class="evo-cHist">'];if(0===h.length)g.push("<p>&nbsp;",f[6],"</p>");else for(var i=h.length-1;i>-1;i--)9===h[i].length?g.push('<div class="evo-transparent"></div>'):g.push('<div style="background-color:',h[i],'"></div>');g.push("</div>"),c=-this._paletteIdx,d=g.join(""),e=f[4]}else this._paletteIdx<0?(c=-this._paletteIdx,this._palette.find(".evo-hist").show()):c=2==this._paletteIdx?1:2,d=this["_paletteHTML"+c](),e=f[c+1],this._paletteIdx=c;this._paletteIdx=c;var j=this._palette.find(".evo-more").prev().html(d).end().children().eq(0).html(e);0>c&&j.next().hide()}},_downOrUpPositioning:function(){for(var a=this.element,b=0;null!==a&&100>b;){if("visible"!=a.css("overflow")){var c=this._palette.offset().top+this._palette.height(),d=a.offset().top+a.height(),e=this._palette.offset().top-this._palette.height()-this.element.outerHeight(),f=a.offset().top,g=c>d&&e>f;g?this._palette.css({bottom:this.element.outerHeight()+"px"}):this._palette.css({bottom:"auto"});break}if("HTML"==a[0].tagName)break;a=a.offsetParent(),b++}},showPalette:function(){if(this._enabled&&(this._active=!0,a(".colorPicker").not("."+this._id).colorpicker("hidePalette"),null===this._palette)){this._palette=this.element.next().after(this._paletteHTML()).next().on("click",function(a){return a.stopPropagation(),!1}),this._bindColors();var b=this;this._isPopup&&(this._downOrUpPositioning(),a(document.body).on("click."+b._id,function(a){a.target!=b.element.get(0)&&b.hidePalette()}).on("keyup."+b._id,function(a){27===a.keyCode&&b.hidePalette()}))}return this},hidePalette:function(){if(this._isPopup&&this._palette){a(document.body).off("click."+this._id);var b=this;this._palette.off("mouseover click","td,.evo-transparent").fadeOut(function(){b._palette.remove(),b._palette=b._cTxt=null}).find(".evo-more a").off("click")}return this},_bindColors:function(){var b=this,c=this.options,d=this._palette.find("div.evo-color"),e=c.history?"td,.evo-cHist>div":"td";c.transparentColor&&(e+=",.evo-transparent"),this._cTxt1=d.eq(0).children().eq(0),this._cTxt2=d.eq(1).children().eq(0),this._palette.on("click",e,function(c){if(b._enabled){var d=a(this);b._setValue(d.hasClass("evo-transparent")?m:q(d.attr("style").substring(17))),b._active=!1}}).on("mouseover",e,function(c){if(b._enabled){var d=a(this),e=d.hasClass("evo-transparent")?m:q(d.attr("style").substring(17));b.options.displayIndicator&&b._setColorInd(e,2),b._active&&b.element.trigger("mouseover.color",e)}}).find(".evo-more a").on("click",function(){b._switchPalette(this)})},val:function(a){return"undefined"==typeof a?this.options.color:(this._setValue(a),this)},_setValue:function(a,b){a=a.replace(/ /g,""),this.options.color=a,this._isPopup?(b||this.hidePalette(),this._setBoxColor(this.element.val(a).next(),a)):this._setColorInd(a,1),this.options.history&&this._paletteIdx>0&&this._add2History(a),this.element.trigger("change.color",a)},_setColorInd:function(a,b){var c=this["_cTxt"+b];this._setBoxColor(c,a),c.next().html(a)},_setBoxColor:function(a,b){b===m?a.addClass("evo-transparent").removeAttr("style"):a.removeClass("evo-transparent").attr("style","background-color:"+b)},_setOption:function(a,b){"color"==a?this._setValue(b,!0):this.options[a]=b},_add2History:function(a){for(var b=h.length,c=0;b>c;c++)if(a==h[c])return;b>27&&h.shift(),h.push(a)},clear:function(){this.hidePalette().val("")},enable:function(){var a=this.element;return this._isPopup?a.removeAttr("disabled"):a.css({opacity:"1","pointer-events":"auto"}),"focus"!==this.options.showOn&&this.element.next().addClass("evo-pointer"),a.removeAttr("aria-disabled"),this._enabled=!0,this},disable:function(){var a=this.element;return this._isPopup?a.attr("disabled","disabled"):(this.hidePalette(),a.css({opacity:"0.3","pointer-events":"none"})),"focus"!==this.options.showOn&&this.element.next().removeClass("evo-pointer"),a.attr("aria-disabled","true"),this._enabled=!1,this},isDisabled:function(){return!this._enabled},destroy:function(){a(document.body).off("click."+this._id),this._palette&&(this._palette.off("mouseover click","td,.evo-cHist>div,.evo-transparent").find(".evo-more a").off("click"),this._isPopup&&this._palette.remove(),this._palette=this._cTxt=null),this._isPopup&&this.element.next().off("click").remove().end().off("focus").unwrap(),this.element.removeClass("colorPicker "+this.id).empty(),a.Widget.prototype.destroy.call(this)}})}(jQuery);
},{}],3:[function(require,module,exports){
//     JavaScript Expression Parser (JSEP) <%= version %>
//     JSEP may be freely distributed under the MIT License
//     http://jsep.from.so/

/*global module: true, exports: true, console: true */
(function (root) {
	'use strict';
	// Node Types
	// ----------
	
	// This is the full set of types that any JSEP node can be.
	// Store them here to save space when minified
	var COMPOUND = 'Compound',
		IDENTIFIER = 'Identifier',
		MEMBER_EXP = 'MemberExpression',
		LITERAL = 'Literal',
		THIS_EXP = 'ThisExpression',
		CALL_EXP = 'CallExpression',
		UNARY_EXP = 'UnaryExpression',
		BINARY_EXP = 'BinaryExpression',
		LOGICAL_EXP = 'LogicalExpression',
		CONDITIONAL_EXP = 'ConditionalExpression',
		ARRAY_EXP = 'ArrayExpression',

		PERIOD_CODE = 46, // '.'
		COMMA_CODE  = 44, // ','
		SQUOTE_CODE = 39, // single quote
		DQUOTE_CODE = 34, // double quotes
		OPAREN_CODE = 40, // (
		CPAREN_CODE = 41, // )
		OBRACK_CODE = 91, // [
		CBRACK_CODE = 93, // ]
		QUMARK_CODE = 63, // ?
		SEMCOL_CODE = 59, // ;
		COLON_CODE  = 58, // :

		throwError = function(message, index) {
			var error = new Error(message + ' at character ' + index);
			error.index = index;
			error.description = message;
			throw error;
		},

	// Operations
	// ----------
	
	// Set `t` to `true` to save space (when minified, not gzipped)
		t = true,
	// Use a quickly-accessible map to store all of the unary operators
	// Values are set to `true` (it really doesn't matter)
		unary_ops = {'-': t, '!': t, '~': t, '+': t},
	// Also use a map for the binary operations but set their values to their
	// binary precedence for quick reference:
	// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
		binary_ops = {
			'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,
			'==': 6, '!=': 6, '===': 6, '!==': 6,
			'<': 7,  '>': 7,  '<=': 7,  '>=': 7, 
			'<<':8,  '>>': 8, '>>>': 8,
			'+': 9, '-': 9,
			'*': 10, '/': 10, '%': 10
		},
	// Get return the longest key length of any object
		getMaxKeyLen = function(obj) {
			var max_len = 0, len;
			for(var key in obj) {
				if((len = key.length) > max_len && obj.hasOwnProperty(key)) {
					max_len = len;
				}
			}
			return max_len;
		},
		max_unop_len = getMaxKeyLen(unary_ops),
		max_binop_len = getMaxKeyLen(binary_ops),
	// Literals
	// ----------
	// Store the values to return for the various literals we may encounter
		literals = {
			'true': true,
			'false': false,
			'null': null
		},
	// Except for `this`, which is special. This could be changed to something like `'self'` as well
		this_str = 'this',
	// Returns the precedence of a binary operator or `0` if it isn't a binary operator
		binaryPrecedence = function(op_val) {
			return binary_ops[op_val] || 0;
		},
	// Utility function (gets called from multiple places)
	// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
		createBinaryExpression = function (operator, left, right) {
			var type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;
			return {
				type: type,
				operator: operator,
				left: left,
				right: right
			};
		},
		// `ch` is a character code in the next three functions
		isDecimalDigit = function(ch) {
			return (ch >= 48 && ch <= 57); // 0...9
		},
		isIdentifierStart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122); // a...z
		},
		isIdentifierPart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
					(ch >= 48 && ch <= 57); // 0...9
		},

		// Parsing
		// -------
		// `expr` is a string with the passed in expression
		jsep = function(expr) {
			// `index` stores the character number we are currently at while `length` is a constant
			// All of the gobbles below will modify `index` as we move along
			var index = 0,
				charAtFunc = expr.charAt,
				charCodeAtFunc = expr.charCodeAt,
				exprI = function(i) { return charAtFunc.call(expr, i); },
				exprICode = function(i) { return charCodeAtFunc.call(expr, i); },
				length = expr.length,

				// Push `index` up to the next non-space character
				gobbleSpaces = function() {
					var ch = exprICode(index);
					// space or tab
					while(ch === 32 || ch === 9) {
						ch = exprICode(++index);
					}
				},
				
				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function() {
					var test = gobbleBinaryExpression(),
						consequent, alternate;
					gobbleSpaces();
					if(exprICode(index) === QUMARK_CODE) {
						// Ternary expression: test ? consequent : alternate
						index++;
						consequent = gobbleExpression();
						if(!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if(exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if(!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},

				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function() {
					gobbleSpaces();
					var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
					while(tc_len > 0) {
						if(binary_ops.hasOwnProperty(to_check)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},

				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function() {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if(!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop)};

					right = gobbleToken();
					if(!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while((biop = gobbleBinaryOp())) {
						prec = binaryPrecedence(biop);

						if(prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						// Reduce: make a binary expression from the three topmost entries.
						while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if(!node) {
							throwError("Expected expression after " + biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while(i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node); 
						i -= 2;
					}
					return node;
				},

				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function() {
					var ch, to_check, tc_len;
					
					gobbleSpaces();
					ch = exprICode(index);

					if(isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if(isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis
						// `foo`, `bar.baz`
						return gobbleVariable();
					} else if (ch === OBRACK_CODE) {
						return gobbleArray();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while(tc_len > 0) {
							if(unary_ops.hasOwnProperty(to_check)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}
						
						return false;
					}
				},
				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function() {
					var number = '', ch, chCode;
					while(isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker
						number += exprI(index++);

						while(isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}
					
					ch = exprI(index);
					if(ch === 'e' || ch === 'E') { // exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if(ch === '+' || ch === '-') { // exponent sign
							number += exprI(index++);
						}
						while(isDecimalDigit(exprICode(index))) { //exponent itself
							number += exprI(index++);
						}
						if(!isDecimalDigit(exprICode(index-1)) ) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}
					

					chCode = exprICode(index);
					// Check to make sure this isn't a variable name that start with a number (123abc)
					if(isIdentifierStart(chCode)) {
						throwError('Variable names cannot start with a number (' +
									number + exprI(index) + ')', index);
					} else if(chCode === PERIOD_CODE) {
						throwError('Unexpected period', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},

				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function() {
					var str = '', quote = exprI(index++), closed = false, ch;

					while(index < length) {
						ch = exprI(index++);
						if(ch === quote) {
							closed = true;
							break;
						} else if(ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch(ch) {
								case 'n': str += '\n'; break;
								case 'r': str += '\r'; break;
								case 't': str += '\t'; break;
								case 'b': str += '\b'; break;
								case 'f': str += '\f'; break;
								case 'v': str += '\x0B'; break;
							}
						} else {
							str += ch;
						}
					}

					if(!closed) {
						throwError('Unclosed quote after "'+str+'"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},
				
				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function() {
					var ch = exprICode(index), start = index, identifier;

					if(isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while(index < length) {
						ch = exprICode(index);
						if(isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if(literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if(identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},

				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function(termination) {
					var ch_i, args = [], node;
					while(index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if(ch_i === termination) { // done parsing
							index++;
							break;
						} else if (ch_i === COMMA_CODE) { // between expressions
							index++;
						} else {
							node = gobbleExpression();
							if(!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					return args;
				},

				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function() {
					var ch_i, node;
					ch_i = exprICode(index);
						
					if(ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if(ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if(ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if(ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if(ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},

				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function() {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if(exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},

				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function() {
					index++;
					return {
						type: ARRAY_EXP,
						elements: gobbleArguments(CBRACK_CODE)
					};
				},

				nodes = [], ch_i, node;
				
			while(index < length) {
				ch_i = exprICode(index);

				// Expressions can be separated by semicolons, commas, or just inferred without any
				// separators
				if(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
					index++; // ignore separators
				} else {
					// Try to gobble each expression individually
					if((node = gobbleExpression())) {
						nodes.push(node);
					// If we weren't able to find a binary expression and are out of room, then
					// the expression passed in probably has too much
					} else if(index < length) {
						throwError('Unexpected "' + exprI(index) + '"', index);
					}
				}
			}

			// If there's only one expression just try returning the expression
			if(nodes.length === 1) {
				return nodes[0];
			} else {
				return {
					type: COMPOUND,
					body: nodes
				};
			}
		};

	// To be filled in by the template
	jsep.version = '<%= version %>';
	jsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };

	/**
	 * @method jsep.addUnaryOp
	 * @param {string} op_name The name of the unary op to add
	 * @return jsep
	 */
	jsep.addUnaryOp = function(op_name) {
		unary_ops[op_name] = t; return this;
	};

	/**
	 * @method jsep.addBinaryOp
	 * @param {string} op_name The name of the binary op to add
	 * @param {number} precedence The precedence of the binary op (can be a float)
	 * @return jsep
	 */
	jsep.addBinaryOp = function(op_name, precedence) {
		max_binop_len = Math.max(op_name.length, max_binop_len);
		binary_ops[op_name] = precedence;
		return this;
	};

	/**
	 * @method jsep.removeUnaryOp
	 * @param {string} op_name The name of the unary op to remove
	 * @return jsep
	 */
	jsep.removeUnaryOp = function(op_name) {
		delete unary_ops[op_name];
		if(op_name.length === max_unop_len) {
			max_unop_len = getMaxKeyLen(unary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeBinaryOp
	 * @param {string} op_name The name of the binary op to remove
	 * @return jsep
	 */
	jsep.removeBinaryOp = function(op_name) {
		delete binary_ops[op_name];
		if(op_name.length === max_binop_len) {
			max_binop_len = getMaxKeyLen(binary_ops);
		}
		return this;
	};

	// In desktop environments, have a way to restore the old value for `jsep`
	if (typeof exports === 'undefined') {
		var old_jsep = root.jsep;
		// The star of the show! It's a function!
		root.jsep = jsep;
		// And a courteous function willing to move out of the way for other similarly-named objects!
		jsep.noConflict = function() {
			if(root.jsep === jsep) {
				root.jsep = old_jsep;
			}
			return jsep;
		};
	} else {
		// In Node.JS environments
		if (typeof module !== 'undefined' && module.exports) {
			exports = module.exports = jsep;
		} else {
			exports.parse = jsep;
		}
	}
}(this));

},{}],4:[function(require,module,exports){
(function (global){
// knockout-sortable 0.11.0 | (c) 2015 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
!function(a){if("function"==typeof define&&define.amd)define(["knockout","jquery","jquery-ui/sortable","jquery-ui/draggable"],a);else if("function"==typeof require&&"object"==typeof exports&&"object"==typeof module){var b=(typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null),c=(typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);(typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null),(typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null),a(b,c)}else a(window.ko,window.jQuery)}(function(a,b){var c="ko_sortItem",d="ko_sourceIndex",e="ko_sortList",f="ko_parentList",g="ko_dragItem",h=a.utils.unwrapObservable,i=a.utils.domData.get,j=a.utils.domData.set,k=b.ui&&b.ui.version,l=k&&k.indexOf("1.6.")&&k.indexOf("1.7.")&&(k.indexOf("1.8.")||"1.8.24"===k),m=function(b,d){a.utils.arrayForEach(b,function(a){1===a.nodeType&&(j(a,c,d),j(a,f,i(a.parentNode,e)))})},n=function(b,c){var d,e={},f=h(b())||{};return f.data?(e[c]=f.data,e.name=f.template):e[c]=b(),a.utils.arrayForEach(["afterAdd","afterRender","as","beforeRemove","includeDestroyed","templateEngine","templateOptions","nodes"],function(b){f.hasOwnProperty(b)?e[b]=f[b]:a.bindingHandlers.sortable.hasOwnProperty(b)&&(e[b]=a.bindingHandlers.sortable[b])}),"foreach"===c&&(e.afterRender?(d=e.afterRender,e.afterRender=function(a,b){m.call(b,a,b),d.call(b,a,b)}):e.afterRender=m),e},o=function(a,b){var c=h(b);if(c)for(var d=0;a>d;d++)c[d]&&h(c[d]._destroy)&&a++;return a},p=function(c,d){var e,f;d?(f=document.getElementById(d),f&&(e=new a.templateSources.domElement(f),e.text(b.trim(e.text())))):b(c).contents().each(function(){this&&1!==this.nodeType&&c.removeChild(this)})};a.bindingHandlers.sortable={init:function(k,m,q,r,s){var t,u,v=b(k),w=h(m())||{},x=n(m,"foreach"),y={};p(k,x.name),b.extend(!0,y,a.bindingHandlers.sortable),w.options&&y.options&&(a.utils.extend(y.options,w.options),delete w.options),a.utils.extend(y,w),y.connectClass&&(a.isObservable(y.allowDrop)||"function"==typeof y.allowDrop)?a.computed({read:function(){var b=h(y.allowDrop),c="function"==typeof b?b.call(this,x.foreach):b;a.utils.toggleDomNodeCssClass(k,y.connectClass,c)},disposeWhenNodeIsRemoved:k},this):a.utils.toggleDomNodeCssClass(k,y.connectClass,y.allowDrop),a.bindingHandlers.template.init(k,function(){return x},q,r,s),t=y.options.start,u=y.options.update;var z=setTimeout(function(){var m;v.sortable(a.utils.extend(y.options,{start:function(b,c){var e=c.item[0];j(e,d,a.utils.arrayIndexOf(c.item.parent().children(),e)),c.item.find("input:focus").change(),t&&t.apply(this,arguments)},receive:function(a,b){m=i(b.item[0],g),m&&(m.clone&&(m=m.clone()),y.dragged&&(m=y.dragged.call(this,m,a,b)||m))},update:function(g,h){var k,n,p,q,r,s=h.item[0],t=h.item.parent()[0],v=i(s,c)||m;if(m=null,v&&this===t||!l&&b.contains(this,t)){if(k=i(s,f),p=i(s,d),n=i(s.parentNode,e),q=a.utils.arrayIndexOf(h.item.parent().children(),s),x.includeDestroyed||(p=o(p,k),q=o(q,n)),(y.beforeMove||y.afterMove)&&(r={item:v,sourceParent:k,sourceParentNode:k&&h.sender||s.parentNode,sourceIndex:p,targetParent:n,targetIndex:q,cancelDrop:!1},y.beforeMove&&y.beforeMove.call(this,r,g,h)),k?b(k===n?this:h.sender||this).sortable("cancel"):b(s).remove(),r&&r.cancelDrop)return;q>=0&&(k&&(k.splice(p,1),a.processAllDeferredBindingUpdates&&a.processAllDeferredBindingUpdates()),n.splice(q,0,v)),j(s,c,null),a.processAllDeferredBindingUpdates&&a.processAllDeferredBindingUpdates(),y.afterMove&&y.afterMove.call(this,r,g,h)}u&&u.apply(this,arguments)},connectWith:y.connectClass?"."+y.connectClass:!1})),void 0!==y.isEnabled&&a.computed({read:function(){v.sortable(h(y.isEnabled)?"enable":"disable")},disposeWhenNodeIsRemoved:k})},0);return a.utils.domNodeDisposal.addDisposeCallback(k,function(){(v.data("ui-sortable")||v.data("sortable"))&&v.sortable("destroy"),a.utils.toggleDomNodeCssClass(k,y.connectClass,!1),clearTimeout(z)}),{controlsDescendantBindings:!0}},update:function(b,c,d,f,g){var h=n(c,"foreach");j(b,e,h.foreach),a.bindingHandlers.template.update(b,function(){return h},d,f,g)},connectClass:"ko_container",allowDrop:!0,afterMove:null,beforeMove:null,options:{}},a.bindingHandlers.draggable={init:function(c,d,e,f,i){var k=h(d())||{},l=k.options||{},m=a.utils.extend({},a.bindingHandlers.draggable.options),o=n(d,"data"),p=k.connectClass||a.bindingHandlers.draggable.connectClass,q=void 0!==k.isEnabled?k.isEnabled:a.bindingHandlers.draggable.isEnabled;return k="data"in k?k.data:k,j(c,g,k),a.utils.extend(m,l),m.connectToSortable=p?"."+p:!1,b(c).draggable(m),void 0!==q&&a.computed({read:function(){b(c).draggable(h(q)?"enable":"disable")},disposeWhenNodeIsRemoved:c}),a.utils.domNodeDisposal.addDisposeCallback(c,function(){b(c).draggable("destroy")}),a.bindingHandlers.template.init(c,function(){return o},e,f,i)},update:function(b,c,d,e,f){var g=n(c,"data");return a.bindingHandlers.template.update(b,function(){return g},d,e,f)},connectClass:a.bindingHandlers.sortable.connectClass,options:{helper:"clone"}}});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
(function (global){
// Knockout UndoManager v0.2 | (c) 2015 Stefano Bagnara
// License: MIT (http://www.opensource.org/licenses/mit-license) 
// requires "ko.watch" method from knockout.reactor
(function (factory) {
  // Module systems magic dance.
  if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
    // CommonJS or Node: hard-coded dependency on "knockout"
    module.exports = factory((typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null), require("./../knockoutjs-reactor/dist/ko-reactor.min.js"));
  } else if (typeof define === "function" && define["amd"]) {
    // AMD anonymous module with hard-coded dependency on "knockout"
    define(["knockout", "knockoutjs-reactor", "exports"], factory);
  } else {
    // <script> tag: use the global `ko` object
    factory(ko, ko.watch);
  }
}(function (ko, reactor) { 

  /// <summary>
  ///     Track last "levels" changes within the chained observable down to any given level and
  ///     supports undoing/redoing the changes.
  /// </summary>
  /// <param name="options" type="object">
  ///     { levels: 2 } -> Remember only last "levels" changes<br/>
  ///     { undoLabel: "Undo it (#COUNT)!" } -> Define a label for the undo command. "#COUNT#" sequence will be replaced with the stack length.<br/>
  ///     { redoLabel: "Redo it (#COUNT)!" } -> Define a label for the redo command. "#COUNT#" sequence will be replaced with the stack length.<br/>
  /// </param>
  var undoManager = function (model, options) {
    var undoStack = ko.observableArray();
    var redoStack = ko.observableArray();
    var lastPushedStack;
    var STATE_DOING = 0;
    var STATE_UNDOING = 1;
    var STATE_REDOING = 2;
    var state = STATE_DOING;

    var MODE_NORMAL = 0; // add to stack every change
    var MODE_IGNORE = 1; // do not add anything to the stack
    var MODE_ONCE = 2; // only one sequential change for each property is added to the stack
    var MODE_MERGE = 3; // merge next change with the last one
    var mode = MODE_NORMAL;

    var defaultOptions = {
      levels: 100,
      undoLabel: "undo (#COUNT#)",
      redoLabel: "redo (#COUNT#)"
    };
    
    if (typeof options == 'object') {
      options = ko.utils.extend(defaultOptions, options);
    } else {
      options = defaultOptions;
    }
  
    var _push = function (action) {
      // durante UNDO/REDO lavoriamo sempre in normale
      if (state == STATE_UNDOING) {
        _pushInt(action, redoStack);
      } else if (state == STATE_REDOING) {
        _pushInt(action, undoStack);
      } else if (state == STATE_DOING) {
        _pushInt(action, undoStack);
        redoStack.removeAll();
      }
    };
    
    var _tryMerge = function (prev, newAction) {
      if (typeof prev.mergedAction !== 'undefined') {
        return prev.mergedAction(newAction);
      } else return null;
    };

    var _pushInt = function (action, myStack) {
      /* gestione del merge di azioni: se l'ultima azione nello stack ha un metodo "mergedAction"
         proviamo ad invocarlo e se ci restituisce una funzione la usiamo al posto di entrambe */
      // console.log("UR", "_pushInt", myStack().length > 0 ? typeof myStack()[myStack().length - 1].mergedAction : "EMPTY");
      if (myStack().length > 0) {
        var merged = _tryMerge(myStack()[myStack().length - 1], action);
        // console.log("UR", "_pushInt.merged", merged, "MV", typeof action.mergeableMove, "MA", typeof action.mergeableAction, "MM", typeof action.mergeMe);
        if (merged !== null) {
          myStack()[myStack().length - 1] = merged;
          return;
        }
      }
      if (myStack().length >= options.levels) myStack.shift();
      lastPushedStack = myStack;
      myStack.push(action);
    };
    
    var _xdoCommand = function(label, workState, stack) {
      return {
        name: ko.computed(function() {
          return ko.utils.unwrapObservable(label).replace(/#COUNT#/, stack().length);
        }),
        enabled: ko.computed(function() {
          return stack().length !== 0;
        }),
        execute: function() {
          var action = stack.pop();
          if (action) {
            var prevState = state;
            state = workState;
            var oldMode = mode;
            mode = MODE_MERGE;
            // console.log("XDO", "before", label);
            action();
            // console.log("XDO", "after", label);
            _removeMergedAction(lastPushedStack);
            mode = oldMode;
            state = prevState;
          }
          return true;
        }
      };
    };

    var _removeMergedAction = function(myStack) {
      if (typeof myStack == 'undefined') throw "Unexpected operation: stack cleaner called with undefined stack";
      
      if (myStack().length > 0 && typeof myStack()[myStack().length - 1].mergedAction !== 'undefined') {
        // console.log("Removing mergedAction from stack");
        delete myStack()[myStack().length - 1].mergedAction;
      }
    };

    var _combinedFunction = function(first, second) {
      var res = (function(f1, f2) {
        f1();
        f2();
      }).bind(undefined, first, second);
      if (typeof first.mergedAction !== 'undefined') {
        res.mergedAction = first.mergedAction;
      }
      return res;
    };

    var executeUndoAction = function(child, value, item) {
      // console.log("executeUndoAction", child, value, item);
      if (typeof value !== 'undefined') {
        child(value);
      } else if (item) {
        if (item.status == 'deleted') {
          child.splice(item.index, 0, item.value);
        } else if (item.status == 'added') {
          child.splice(item.index, 1);
        } else {
          throw "Unsupproted item.status: "+item.status;
        }
      } else {
        throw "Unexpected condition: no item and no child.oldValues!";
      }
    };

    var makeUndoActionDefault = function(undoFunc, parents, child, oldVal, item) {
      return undoFunc.bind(undefined, child, oldVal, item);
    };

    var makeUndoAction = makeUndoActionDefault;

    var changePusher = function(parents, child, item) {
      var oldVal = typeof child.oldValues != 'undefined' ? child.oldValues[0] : undefined;
      var act = makeUndoAction(executeUndoAction, parents, child, oldVal, item);

      if (mode == MODE_IGNORE) return;

      if (mode == MODE_MERGE) {
        // console.log("UR", "mergemode");
        if (typeof act !== 'undefined') {
          act.mergedAction = function(newAction) {
            if (typeof newAction.mergeMe !== 'undefined' && newAction.mergeMe) {
              return _combinedFunction(newAction, this);
            } else return null;
          };
          act.mergeMe = true;
        }
      } else {
        if (typeof act !== 'undefined') {
          if (child.oldValues && mode == MODE_ONCE) {
            act.mergedAction = function(oldChild, oldItem, newAction) {
              if (typeof newAction.mergeableAction == 'object' && oldChild == newAction.mergeableAction.child) {
                // console.log("UR", "ignore update for property in MODE_ONCE");
                return this;
              } else return null;
            }.bind(act, child, item);
            act.mergeableAction = { child: child, item: item };
          }
          // console.log("UR", "item.status", item.status);
          // "item" is valued when an item is added/removed/reteined in an array
          // sometimes KO detect "moves" and add a "moved" property with the index but
          // this doesn't happen for example using knockout-sortable or when moving objects
          // between arrays.
          // So this ends up handling this with "mergeableMove" and "mergedAction": 
          if (item && item.status == 'deleted') {
            // TODO se sono in MODE = MERGE devo metteer una funzione di merge che accetta tutto.
            // altrimenti lascio questa.
            act.mergedAction = function(oldChild, oldItem, newAction) {
              // console.log("UR", "act.mergedAction", typeof newAction.mergeableMove);
              // a deleted action is able to merge with a added action if they apply to the same
              // object.
              if (typeof newAction.mergeableMove == 'object' && oldItem.value == newAction.mergeableMove.item.value) {
                // in this case I simply return a single action running both actions in sequence,
                // this way the "undo" will need to undo only once for a "move" operation.
                return _combinedFunction(newAction, this);
              } else {
                console.log("UR", "not mergeable", typeof newAction.mergeableMove);
              }

              return null;
            }.bind(act, child, item);
          }
          if (item && item.status == 'added') {
            // add a mergeableMove property that will be used by the next action "mergedAction" to see if this action
            // can be merged.
            act.mergeableMove = { child: child, item: item };
          }
        }
      }
      if (typeof act !== 'undefined') _push(act);
    };

    var reactorOptions = { depth: -1, oldValues: 1, mutable: true, /* tagParentsWithName: true */ tagFields: true };

    var context = {};
    var react = typeof reactor == 'function' ? reactor : ko.watch;
    var res = react(model, reactorOptions, changePusher, context);

    return {
      push: _push, 
      undoCommand: _xdoCommand(options.undoLabel, STATE_UNDOING, undoStack),
      redoCommand: _xdoCommand(options.redoLabel, STATE_REDOING, redoStack),
      reset: function() { undoStack.removeAll(); redoStack.removeAll(); },
      // setMode: function(newMode) { mode = newMode; _removeMergedAction(undoStack); },
      setModeOnce: function() { mode = MODE_ONCE; _removeMergedAction(undoStack); },
      setModeMerge: function() { mode = MODE_MERGE; _removeMergedAction(undoStack); },
      setModeNormal: function() { mode = MODE_NORMAL; _removeMergedAction(undoStack); },
      setModeIgnore: function() { mode = MODE_IGNORE; _removeMergedAction(undoStack); },
      setUndoActionMaker: function(maker) { makeUndoAction = maker; },
      dispose: function() { /* ko.unwatch(model, reactorOptions, changePusher); */ res.dispose(); }
    };
  };

  return undoManager;
  
}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../knockoutjs-reactor/dist/ko-reactor.min.js":7}],6:[function(require,module,exports){
(function (global){
// Knockout Fast Mapping v0.1
// License: MIT (http://www.opensource.org/licenses/mit-license.php)

(function (factory) {
	// Module systems magic dance.

	if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
		// CommonJS or Node: hard-coded dependency on "knockout"
		factory((typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null), exports);
	} else if (typeof define === "function" && define["amd"]) {
		// AMD anonymous module with hard-coded dependency on "knockout"
		define(["knockout", "exports"], factory);
	} else {
		// <script> tag: use the global `ko` object, attaching a `wrap` property
		factory(ko, ko.wrap = {});
	}
}(function (ko, exports) {
    
    // this function mimics ko.mapping
    exports.fromJS = function(jsObject, computedFunctions, observableObjects)
    {
        reset();
	return wrap(jsObject, computedFunctions, observableObjects);
    }

    // this function unwraps the outer for assigning the result to an observable
    // see https://github.com/SteveSanderson/knockout/issues/517
    exports.updateFromJS = function(observable, jsObject, computedFunctions, observableObjects)
    {
        reset();
	return observable(ko.utils.unwrapObservable(wrap(jsObject, computedFunctions, observableObjects)));
    }

    exports.fromJSON = function (jsonString, computedFunctions, observableObjects) {
	var parsed = ko.utils.parseJson(jsonString);
	arguments[0] = parsed;
	return exports.fromJS.apply(this, computedFunctions, observableObjects);
    };
    
    exports.toJS = function (observable) {
	return unwrap(observable);
    }

    exports.toJSON = function (observable) {
	var plainJavaScriptObject = exports.toJS(observable);
	return ko.utils.stringifyJson(plainJavaScriptObject);
    };

    function typeOf(value) {
	var s = typeof value;
	if (s === 'object') {
            if (value) {
                if (value.constructor == Date)
                    s = 'date';
		else if (Object.prototype.toString.call(value) == '[object Array]')
                    s = 'array';
            } else {
		s = 'null';
            }
	}
	return s;
    }

    // unwrapping
    function unwrapObject(o)
    {
	var t = {};

	for (var k in o)
	{
	    var v = o[k];

	    if (ko.isComputed(v))
		continue;

	    t[k] = unwrap(v);
	}

	return t;
    }

    function unwrapArray(a)
    {
	var r = [];

	if (!a || a.length == 0)
	    return r;
	
	for (var i = 0, l = a.length; i < l; ++i)
	    r.push(unwrap(a[i]));

	return r;
    }

    function unwrap(v)
    {
	var isObservable = ko.isObservable(v);

	if (isObservable)
	{
	    var val = v();

	    return unwrap(val);
	}
	else
	{
	    if (typeOf(v) == "array")
	    {
		return unwrapArray(v);
	    }
	    else if (typeOf(v) == "object")
	    {
		return unwrapObject(v);
	    }
	    else
	    {
		return v;
	    }
	}
    }

    function reset()
    {
        parents = [{obj: null, wrapped: null, lvl: ""}];
    }    
    
    // wrapping

    function wrapObject(o, computedFunctions, observableObjects)
    {
        // check for infinite recursion
        for (var i = 0; i < parents.length; ++i) {
            if (parents[i].obj === o) {
                return parents[i].wrapped;
            }
        }

	var t = {};

	for (var k in o)
	{
	    var v = o[k];

            parents.push({obj: o, wrapped: t, lvl: currentLvl() + "/" + k});

	    t[k] = wrap(v, computedFunctions, observableObjects);

            parents.pop();
	}

	if (computedFunctions && computedFunctions[currentLvl()])
	    t = computedFunctions[currentLvl()](t);

        if (hasES5Plugin())
            ko.track(t);

	if (observableObjects) return ko.observable(t);
	return t;
    }

    function wrapArray(a, computedFunctions, observableObjects)
    {
	var r = ko.observableArray();

	if (!a || a.length == 0)
	    return r;

	for (var i = 0, l = a.length; i < l; ++i)
	    r.push(wrap(a[i], computedFunctions, observableObjects));

	return r;
    }

    // a stack, used for two purposes:
    //  - circular reference checking
    //  - computed functions
    var parents;

    function currentLvl()
    {
	return parents[parents.length-1].lvl;
    }

    function wrap(v, computedFunctions, observableObjects)
    {
	if (typeOf(v) == "array")
	{
	    return wrapArray(v, computedFunctions, observableObjects);
	}
	else if (typeOf(v) == "object")
	{
	    return wrapObject(v, computedFunctions, observableObjects);
	}
	else
	{
            if (!hasES5Plugin() && typeof v !== 'function')
            {
	        var t = ko.observable();
	        t(v);
	        return t;
            } else
                return v;
	}
    }

    function hasES5Plugin()
    {
        return ko.track != null;
    }
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],7:[function(require,module,exports){
ko.subscribable.fn.watch=function(a,b,c,d){var e=typeof a;return"boolean"===e||"undefined"===e?ko.watch(this,{enabled:a!==!1}):"function"!==e||ko.isSubscribable(a)?ko.watch(a,b,c,d||this):ko.watch(this,b||{},a,d||this),this},ko.watch=function(a,b,c,d){function e(h,i,j,k,l,m){if(h&&0!==b.depth&&(-1===b.depth||j.length<(b.depth||1))){if(b.watchedOnly&&!h.watchable&&h!=a)return;if((b.enabled===!1||b.enabled===!0)&&(h.watchable=b.enabled),h.watchable===!1)return;b.seal===!0&&(h.watchable=!1);var n=typeof h;if("object"===n||"function"===n){if(h._watcher===d)return;if(b.hide&&ko.utils.arrayIndexOf(b.hide,h)>-1)return;var o=[].concat(j,i&&i!==a?i:[]);if("function"!==n){if("[object Object]"===Object.prototype.toString.call(h))ko.utils.objectForEach(h,function(a,c){if(c=b.getter?b.getter.call(d,o,h,a):c){if(b.wrap){var f=Object.prototype.toString.call(c);"[object Function]"!==f&&"[object Object]"!==f&&(b.beforeWrap&&b.beforeWrap.call(d,o,h,c)===!1||(c=h[a]="[object Array]"===f?ko.observableArray(c):ko.observable(c)))}b.unloop&&(c._watcher=k?void 0:d);var g=e(c,l?null:h,o,k,null,a);b.tagFields&&void 0===c._fieldName&&(g||"parentsOnly"!==b.tagFields&&"function"==typeof c||"object"==typeof c)&&(c._fieldName=a)}});else if(b.hideArrays!==!0)for(var p=0;p<h.length;p++)e(h[p],l?null:h,o,k);return!0}if("function"==typeof h.notifySubscribers&&c){if(b.enabled===!0&&h.watchable===!1)return;if(k||!b.beforeWatch||b.beforeWatch.call(d,o,h,m)!==!1){var q="function"==typeof h.pop;if(k?f(h):g(h,q,o,l),q)return e(h(),l?null:h,o,k,!0),!0;if(b.hideWrappedValues!==!0)return e(h(),l?null:h,o,k,!0)}}}}}function f(a){var c=a[h];if(!c)throw"Subscriptions field (."+h+") not defined for observable child "+(a._fieldName||"");if(c.change)for(var e=c.change.length-1;e>=0;e--)c.change[e]._watcher===d&&c.change[e].dispose();if(c.beforeChange&&(b.mutable||b.oldValues>0))for(var e=c.beforeChange.length-1;e>=0;e--)c.beforeChange[e]._watcher===d&&c.beforeChange[e].dispose();if(c.arrayChange)for(var e=c.arrayChange.length-1;e>=0;e--)c.arrayChange[e]._watcher===d&&c.arrayChange[e].dispose()}function g(a,f,g,h){f?a.subscribe(function(b){ko.utils.arrayForEach(b,function(b){var f=c.call(d,g,a,b);void 0!==f&&d(f),b.moved||setTimeout(function(){e(b.value,h?null:a,g,"deleted"===b.status)},0)})},void 0,"arrayChange")._watcher=d:(a.subscribe(function(){if(a.watchable!==!1){var f=c.call(d,g,a);void 0!==f&&d(f),b.mutable&&"object"==typeof a()&&e(a(),h?null:a,g)}},null,"change")._watcher=d,(b.oldValues>0||b.mutable)&&(a.subscribe(function(c){if(b.oldValues>0){var d=a.oldValues?a.oldValues:a.oldValues=[];for(d.unshift(c);d.length>b.oldValues;)d.pop()}b.mutable&&"object"==typeof c&&e(c,h?null:a,g,!1,!0)},null,"beforeChange")._watcher=d))}"function"==typeof b&&(d=d||c,c=b,b={}),d=d||this;var h;switch(ko.DEBUG||ko.version){case!0:h="_subscriptions";break;case"3.0.0":h="F";break;case"3.1.0":h="H";break;case"3.2.0":h="M";break;case"3.3.0":h="G";case"3.4.0":h="K";break;default:throw"Unsupported Knockout version. Only v3.0.0 to v3.4.0 are supported when minified. Current version is "+ko.version}return"function"!=typeof a||ko.isSubscribable(a)?(e(a,null,[]),{dispose:function(){e(a,null,[],!0)}}):ko.computed(a,c,b)};window.foo = "1.3.6";
},{}],8:[function(require,module,exports){
(function (process){
exports = module.exports = debug;

function debug(label) {
  return _debug.bind(null, label);
}

function _debug(label) {
  var args = [].slice.call(arguments, 1);
  args.unshift('[' + label + ']');
  process.stderr.write(args.join(' ') + '\n');
}
}).call(this,require('_process'))

},{"_process":16}],9:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `lex()` and print the results.

var debug = require('./debug')('lex');

exports = module.exports = lex;

/**
 * Convert a CSS string into an array of lexical tokens.
 *
 * @param {String} css CSS
 * @returns {Array} lexical tokens
 */
function lex(css) {
  var start; // Debug timer start.

  var buffer = '';      // Character accumulator
  var ch;               // Current character
  var column = 0;       // Current source column number
  var cursor = -1;      // Current source cursor position
  var depth = 0;        // Current nesting depth
  var line = 1;         // Current source line number
  var state = 'before-selector'; // Current state
  var stack = [state];  // State stack
  var token = {};       // Current token
  var tokens = [];      // Token accumulator

  // Supported @-rules, in roughly descending order of usage probability.
  var atRules = [
    'media',
    'keyframes',
    { name: '-webkit-keyframes', type: 'keyframes', prefix: '-webkit-' },
    { name: '-moz-keyframes', type: 'keyframes', prefix: '-moz-' },
    { name: '-ms-keyframes', type: 'keyframes', prefix: '-ms-' },
    { name: '-o-keyframes', type: 'keyframes', prefix: '-o-' },
    'font-face',
    { name: 'import', state: 'before-at-value' },
    { name: 'charset', state: 'before-at-value' },
    'supports',
    'viewport',
    { name: 'namespace', state: 'before-at-value' },
    'document',
    { name: '-moz-document', type: 'document', prefix: '-moz-' },
    'page'
  ];

  // -- Functions ------------------------------------------------------------

  /**
   * Advance the character cursor and return the next character.
   *
   * @returns {String} The next character.
   */
  function getCh() {
    skip();
    return css[cursor];
  }

  /**
   * Return the state at the given index in the stack.
   * The stack is LIFO so indexing is from the right.
   *
   * @param {Number} [index=0] Index to return.
   * @returns {String} state
   */
  function getState(index) {
    return index ? stack[stack.length - 1 - index] : state;
  }

  /**
   * Look ahead for a string beginning from the next position. The string
   * being looked for must start at the next position.
   *
   * @param {String} str The string to look for.
   * @returns {Boolean} Whether the string was found.
   */
  function isNextString(str) {
    var start = cursor + 1;
    return (str === css.slice(start, start + str.length));
  }

  /**
   * Find the start position of a substring beginning from the next
   * position. The string being looked for may begin anywhere.
   *
   * @param {String} str The substring to look for.
   * @returns {Number|false} The position, or `false` if not found.
   */
  function find(str) {
    var pos = css.slice(cursor).indexOf(str);

    return pos > 0 ? pos : false;
  }

  /**
   * Determine whether a character is next.
   *
   * @param {String} ch Character.
   * @returns {Boolean} Whether the character is next.
   */
  function isNextChar(ch) {
    return ch === peek(1);
  }

  /**
   * Return the character at the given cursor offset. The offset is relative
   * to the cursor, so negative values move backwards.
   *
   * @param {Number} [offset=1] Cursor offset.
   * @returns {String} Character.
   */
  function peek(offset) {
    return css[cursor + (offset || 1)];
  }

  /**
   * Remove the current state from the stack and set the new current state.
   *
   * @returns {String} The removed state.
   */
  function popState() {
    var removed = stack.pop();
    state = stack[stack.length - 1];

    return removed;
  }

  /**
   * Set the current state and add it to the stack.
   *
   * @param {String} newState The new state.
   * @returns {Number} The new stack length.
   */
  function pushState(newState) {
    state = newState;
    stack.push(state);

    return stack.length;
  }

  /**
   * Replace the current state with a new state.
   *
   * @param {String} newState The new state.
   * @returns {String} The replaced state.
   */
  function replaceState(newState) {
    var previousState = state;
    stack[stack.length - 1] = state = newState;

    return previousState;
  }

  /**
   * Move the character cursor. Positive numbers move the cursor forward.
   * Negative numbers are not supported!
   *
   * @param {Number} [n=1] Number of characters to skip.
   */
  function skip(n) {
    if ((n || 1) == 1) {
      if (css[cursor] == '\n') {
        line++;
        column = 1;
      } else {
        column++;
      }
      cursor++;
    } else {
      var skipStr = css.slice(cursor, cursor + n).split('\n');
      if (skipStr.length > 1) {
        line += skipStr.length - 1;
        column = 1;
      }
      column += skipStr[skipStr.length - 1].length;
      cursor = cursor + n;
    }
  }

  /**
   * Add the current token to the pile and reset the buffer.
   */
  function addToken() {
    token.end = {
      line: line,
      col: column
    };

    DEBUG && debug('addToken:', JSON.stringify(token, null, 2));

    tokens.push(token);

    buffer = '';
    token = {};
  }

  /**
   * Set the current token.
   *
   * @param {String} type Token type.
   */
  function initializeToken(type) {
    token = {
      type: type,
      start: {
        line: line,
        col : column
      }
    };
  }

  // -- Main Loop ------------------------------------------------------------

  /*
  The main loop is a state machine that reads in one character at a time,
  and determines what to do based on the current state and character.
  This is implemented as a series of nested `switch` statements and the
  case orders have been mildly optimized based on rough probabilities
  calculated by processing a small sample of real-world CSS.

  Further optimization (such as a dispatch table) shouldn't be necessary
  since the total number of cases is very low.
  */

  TIMER && (start = Date.now());

  while (ch = getCh()) {
    DEBUG && debug(ch, getState());

    // column += 1;

    switch (ch) {
    // Space
    case ' ':
      switch (getState()) {
      case 'selector':
      case 'value':
      case 'value-paren':
      case 'at-group':
      case 'at-value':
      case 'comment':
      case 'double-string':
      case 'single-string':
        buffer += ch;
        break;
      }
      break;

    // Newline or tab
    case '\n':
    case '\t':
    case '\r':
    case '\f':
      switch (getState()) {
      case 'value':
      case 'value-paren':
      case 'at-group':
      case 'comment':
      case 'single-string':
      case 'double-string':
      case 'selector':
        buffer += ch;
        break;

      case 'at-value':
        // Tokenize an @-rule if a semi-colon was omitted.
        if ('\n' === ch) {
          token.value = buffer.trim();
          addToken();
          popState();
        }
        break;
      }

      // if ('\n' === ch) {
      //   column = 0;
      //   line += 1;
      // }
      break;

    case ':':
      switch (getState()) {
      case 'name':
        token.name = buffer.trim();
        buffer = '';

        replaceState('before-value');
        break;

      case 'before-selector':
        buffer += ch;

        initializeToken('selector');
        pushState('selector');
        break;

      default:
        buffer += ch;
        break;
      }
      break;

    case ';':
      switch (getState()) {
      case 'name':
      case 'before-value':
      case 'value':
        // Tokenize a declaration
        // if value is empty skip the declaration
        if (buffer.trim().length > 0) {
          token.value = buffer.trim(),
          addToken();
        }
        replaceState('before-name');
        break;

      case 'value-paren':
        // Insignificant semi-colon
        buffer += ch;
        break;

      case 'at-value':
        // Tokenize an @-rule
        token.value = buffer.trim();
        addToken();
        popState();
        break;

      case 'before-name':
        // Extraneous semi-colon
        break;

      default:
        buffer += ch;
        break;
      }
      break;

    case '{':
      switch (getState()) {
      case 'selector':
        // If the sequence is `\{` then assume that the brace should be escaped.
        if (peek(-1) === '\\') {
            buffer += ch;
            break;
        }

        // Tokenize a selector
        token.text = buffer.trim();
        addToken();
        replaceState('before-name');
        depth = depth + 1;
        break;

      case 'at-group':
        // Tokenize an @-group
        token.name = buffer.trim();

        // XXX: @-rules are starting to get hairy
        switch (token.type) {
        case 'font-face':
        case 'viewport' :
        case 'page'     :
          pushState('before-name');
          break;

        default:
          pushState('before-selector');
        }

        addToken();
        depth = depth + 1;
        break;

      case 'name':
      case 'at-rule':
        // Tokenize a declaration or an @-rule
        token.name = buffer.trim();
        addToken();
        pushState('before-name');
        depth = depth + 1;
        break;

      case 'comment':
      case 'double-string':
      case 'single-string':
        // Ignore braces in comments and strings
        buffer += ch;
        break;
      }

      break;

    case '}':
      switch (getState()) {
      case 'before-name':
      case 'name':
      case 'before-value':
      case 'value':
        // If the buffer contains anything, it is a value
        if (buffer) {
          token.value = buffer.trim();
        }

        // If the current token has a name and a value it should be tokenized.
        if (token.name && token.value) {
          addToken();
        }

        // Leave the block
        initializeToken('end');
        addToken();
        popState();

        // We might need to leave again.
        // XXX: What about 3 levels deep?
        if ('at-group' === getState()) {
          initializeToken('at-group-end');
          addToken();
          popState();
        }
        
        if (depth > 0) {
          depth = depth - 1;
        }

        break;

      case 'at-group':
      case 'before-selector':
      case 'selector':
        // If the sequence is `\}` then assume that the brace should be escaped.
        if (peek(-1) === '\\') {
            buffer += ch;
            break;
        }

        if (depth > 0) {
          // Leave block if in an at-group
          if ('at-group' === getState(1)) {
            initializeToken('at-group-end');
            addToken();
          }
        }

        if (depth > 1) {
          popState();
        }

        if (depth > 0) {
          depth = depth - 1;
        }
        break;

      case 'double-string':
      case 'single-string':
      case 'comment':
        // Ignore braces in comments and strings.
        buffer += ch;
        break;
      }

      break;

    // Strings
    case '"':
    case "'":
      switch (getState()) {
      case 'double-string':
        if ('"' === ch && '\\' !== peek(-1)) {
          popState();
        }
        break;

      case 'single-string':
        if ("'" === ch && '\\' !== peek(-1)) {
          popState();
        }
        break;

      case 'before-at-value':
        replaceState('at-value');
        pushState('"' === ch ? 'double-string' : 'single-string');
        break;

      case 'before-value':
        replaceState('value');
        pushState('"' === ch ? 'double-string' : 'single-string');
        break;

      case 'comment':
        // Ignore strings within comments.
        break;

      default:
        if ('\\' !== peek(-1)) {
          pushState('"' === ch ? 'double-string' : 'single-string');
        }
      }

      buffer += ch;
      break;

    // Comments
    case '/':
      switch (getState()) {
      case 'comment':
      case 'double-string':
      case 'single-string':
        // Ignore
        buffer += ch;
        break;

      case 'before-value':
      case 'selector':
      case 'name':
      case 'value':
        if (isNextChar('*')) {
          // Ignore comments in selectors, properties and values. They are
          // difficult to represent in the AST.
          var pos = find('*/');

          if (pos) {
            skip(pos + 1);
          }
        } else {
          buffer += ch;
        }
        break;

      default:
        if (isNextChar('*')) {
          // Create a comment token
          initializeToken('comment');
          pushState('comment');
          skip();
        }
        else {
          buffer += ch;
        }
        break;
      }
      break;

    // Comment end or universal selector
    case '*':
      switch (getState()) {
      case 'comment':
        if (isNextChar('/')) {
          // Tokenize a comment
          token.text = buffer; // Don't trim()!
          skip();
          addToken();
          popState();
        }
        else {
          buffer += ch;
        }
        break;

      case 'before-selector':
        buffer += ch;
        initializeToken('selector');
        pushState('selector');
        break;

      default:
        buffer += ch;
      }
      break;

    // @-rules
    case '@':
      switch (getState()) {
      case 'comment':
      case 'double-string':
      case 'single-string':
        buffer += ch;
        break;

      default:
        // Iterate over the supported @-rules and attempt to tokenize one.
        var tokenized = false;
        var name;
        var rule;

        for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {
          rule = atRules[j];
          name = rule.name || rule;

          if (!isNextString(name)) { continue; }

          tokenized = true;

          initializeToken(name);
          pushState(rule.state || 'at-group');
          skip(name.length);

          if (rule.prefix) {
            token.prefix = rule.prefix;
          }

          if (rule.type) {
            token.type = rule.type;
          }
        }

        if (!tokenized) {
          // Keep on truckin' America!
          buffer += ch;
        }
        break;
      }
      break;

    // Parentheses are tracked to disambiguate semi-colons, such as within a
    // data URI.
    case '(':
      switch (getState()) {
      case 'value':
        pushState('value-paren');
        break;
      }

      buffer += ch;
      break;

    case ')':
      switch (getState()) {
      case 'value-paren':
        popState();
        break;
      }

      buffer += ch;
      break;

    default:
      switch (getState()) {
      case 'before-selector':
        initializeToken('selector');
        pushState('selector');
        break;

      case 'before-name':
        initializeToken('property');
        replaceState('name');
        break;

      case 'before-value':
        replaceState('value');
        break;

      case 'before-at-value':
        replaceState('at-value');
        break;
      }

      buffer += ch;
      break;
    }
  }

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return tokens;
}

},{"./debug":8}],10:[function(require,module,exports){
var DEBUG = false; // `true` to print debugging info.
var TIMER = false; // `true` to time calls to `parse()` and print the results.

var debug = require('./debug')('parse');
var lex = require('./lexer');

exports = module.exports = parse;

var _comments;   // Whether comments are allowed.
var _depth;      // Current block nesting depth.
var _position;   // Whether to include line/column position.
var _tokens;     // Array of lexical tokens.

/**
 * Convert a CSS string or array of lexical tokens into a `stringify`-able AST.
 *
 * @param {String} css CSS string or array of lexical token
 * @param {Object} [options]
 * @param {Boolean} [options.comments=false] allow comment nodes in the AST
 * @returns {Object} `stringify`-able AST
 */
function parse(css, options) {
  var start; // Debug timer start.

  options || (options = {});
  _comments = !!options.comments;
  _position = !!options.position;

  _depth = 0;

  // Operate on a copy of the given tokens, or the lex()'d CSS string.
  _tokens = Array.isArray(css) ? css.slice() : lex(css);

  var rule;
  var rules = [];
  var token;

  TIMER && (start = Date.now());

  while ((token = next())) {
    rule = parseToken(token);
    rule && rules.push(rule);
  }

  TIMER && debug('ran in', (Date.now() - start) + 'ms');

  return {
    type: "stylesheet",
    stylesheet: {
      rules: rules
    }
  };
}

// -- Functions --------------------------------------------------------------

/**
 * Build an AST node from a lexical token.
 *
 * @param {Object} token lexical token
 * @param {Object} [override] object hash of properties that override those
 *   already in the token, or that will be added to the token.
 * @returns {Object} AST node
 */
function astNode(token, override) {
  override || (override = {});

  var key;
  var keys = ['type', 'name', 'value'];
  var node = {};

  // Avoiding [].forEach for performance reasons.
  for (var i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (token[key]) {
      node[key] = override[key] || token[key];
    }
  }

  keys = Object.keys(override);

  for (i = 0; i < keys.length; ++i) {
    key = keys[i];

    if (!node[key]) {
      node[key] = override[key];
    }
  }

  if (_position) {
    node.position = {
      start: token.start,
      end: token.end
    };
  }

  DEBUG && debug('astNode:', JSON.stringify(node, null, 2));

  return node;
}

/**
 * Remove a lexical token from the stack and return the removed token.
 *
 * @returns {Object} lexical token
 */
function next() {
  var token = _tokens.shift();
  DEBUG && debug('next:', JSON.stringify(token, null, 2));
  return token;
}

// -- Parse* Functions ---------------------------------------------------------

/**
 * Convert an @-group lexical token to an AST node.
 *
 * @param {Object} token @-group lexical token
 * @returns {Object} @-group AST node
 */
function parseAtGroup(token) {
  _depth = _depth + 1;

  // As the @-group token is assembled, relevant token values are captured here
  // temporarily. They will later be used as `tokenize()` overrides.
  var overrides = {};

  switch (token.type) {
  case 'font-face':
  case 'viewport' :
    overrides.declarations = parseDeclarations();
    break;

  case 'page':
    overrides.prefix = token.prefix;
    overrides.declarations = parseDeclarations();
    break;

  default:
    overrides.prefix = token.prefix;
    overrides.rules = parseRules();
  }

  return astNode(token, overrides);
}

/**
 * Convert an @import lexical token to an AST node.
 *
 * @param {Object} token @import lexical token
 * @returns {Object} @import AST node
 */
function parseAtImport(token) {
  return astNode(token);
}

/**
 * Convert an @charset token to an AST node.
 *
 * @param {Object} token @charset lexical token
 * @returns {Object} @charset node
 */
function parseCharset(token) {
  return astNode(token);
}

/**
 * Convert a comment token to an AST Node.
 *
 * @param {Object} token comment lexical token
 * @returns {Object} comment node
 */
function parseComment(token) {
  return astNode(token, {text: token.text});
}

function parseNamespace(token) {
  return astNode(token);
}

/**
 * Convert a property lexical token to a property AST node.
 *
 * @returns {Object} property node
 */
function parseProperty(token) {
  return astNode(token);
}

/**
 * Convert a selector lexical token to a selector AST node.
 *
 * @param {Object} token selector lexical token
 * @returns {Object} selector node
 */
function parseSelector(token) {
  function trim(str) {
    return str.trim();
  }

  return astNode(token, {
    type: 'rule',
    selectors: token.text.split(',').map(trim),
    declarations: parseDeclarations(token)
  });
}

/**
 * Convert a lexical token to an AST node.
 *
 * @returns {Object|undefined} AST node
 */
function parseToken(token) {
  switch (token.type) {
  // Cases are listed in roughly descending order of probability.
  case 'property': return parseProperty(token);

  case 'selector': return parseSelector(token);

  case 'at-group-end': _depth = _depth - 1; return;

  case 'media'     :
  case 'keyframes' :return parseAtGroup(token);

  case 'comment': if (_comments) { return parseComment(token); } break;

  case 'charset': return parseCharset(token);
  case 'import': return parseAtImport(token);

  case 'namespace': return parseNamespace(token);

  case 'font-face':
  case 'supports' :
  case 'viewport' :
  case 'document' :
  case 'page'     : return parseAtGroup(token);
  }

  DEBUG && debug('parseToken: unexpected token:', JSON.stringify(token));
}

// -- Parse Helper Functions ---------------------------------------------------

/**
 * Iteratively parses lexical tokens from the stack into AST nodes until a
 * conditional function returns `false`, at which point iteration terminates
 * and any AST nodes collected are returned.
 *
 * @param {Function} conditionFn
 *   @param {Object} token the lexical token being parsed
 *   @returns {Boolean} `true` if the token should be parsed, `false` otherwise
 * @return {Array} AST nodes
 */
function parseTokensWhile(conditionFn) {
  var node;
  var nodes = [];
  var token;

  while ((token = next()) && (conditionFn && conditionFn(token))) {
    node = parseToken(token);
    node && nodes.push(node);
  }

  // Place an unused non-`end` lexical token back onto the stack.
  if (token && token.type !== 'end') {
    _tokens.unshift(token);
  }

  return nodes;
}

/**
 * Convert a series of tokens into a sequence of declaration AST nodes.
 *
 * @returns {Array} declaration nodes
 */
function parseDeclarations() {
  return parseTokensWhile(function (token) {
    return (token.type === 'property' || token.type === 'comment');
  });
}

/**
 * Convert a series of tokens into a sequence of rule nodes.
 *
 * @returns {Array} rule nodes
 */
function parseRules() {
  return parseTokensWhile(function () { return _depth; });
}

},{"./debug":8,"./lexer":9}],11:[function(require,module,exports){
// TinyColor v1.2.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function() {

var trimLeft = /^[\s,#]+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    math = Math,
    mathRound = math.round,
    mathMin = math.min,
    mathMax = math.max,
    mathRandom = math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function() {
        return rgbaToHex(this._r, this._g, this._b, this._a);
    },
    toHex8String: function() {
        return '#' + this.toHex8();
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = s.toHex8String();
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
            color.s = convertToPercentage(color.s);
            color.v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, color.s, color.v);
            ok = true;
            format = "hsv";
        }
        else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
            color.s = convertToPercentage(color.s);
            color.l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, color.s, color.l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b and a are contained in the set [0, 255]
// Returns an 8 character hex
function rgbaToHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (mathRound(hsl.h) + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;
    var w = p * 2 - 1;
    var a = rgb2.a - rgb1.a;

    var w1;

    if (w * a == -1) {
        w1 = w;
    } else {
        w1 = (w + a) / (1 + w * a);
    }

    w1 = (w1 + 1) / 2;

    var w2 = 1 - w1;

    var rgba = {
        r: rgb2.r * w1 + rgb1.r * w2,
        g: rgb2.g * w1 + rgb1.g * w2,
        b: rgb2.b * w1 + rgb1.b * w2,
        a: rgb2.a * p  + rgb1.a * (1 - p)
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            a: convertHexToDecimal(match[1]),
            r: parseIntFromHex(match[2]),
            g: parseIntFromHex(match[3]),
            b: parseIntFromHex(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})();

},{}],12:[function(require,module,exports){
(function (global){
/*
 * Toastr
 * Copyright 2012-2015
 * Authors: John Papa, Hans Fjllemark, and Tim Ferrell.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * ARIA Support: Greta Krafsig
 *
 * Project: https://github.com/CodeSeven/toastr
 */
/* global define */
; (function (define) {
    define(['jquery'], function ($) {
        return (function () {
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: 'error',
                info: 'info',
                success: 'success',
                warning: 'warning'
            };

            var toastr = {
                clear: clear,
                remove: remove,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {},
                subscribe: subscribe,
                success: success,
                version: '2.1.2',
                warning: warning
            };

            var previousToast;

            return toastr;

            ////////////////

            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function getContainer(options, create) {
                if (!options) { options = getOptions(); }
                $container = $('#' + options.containerId);
                if ($container.length) {
                    return $container;
                }
                if (create) {
                    $container = createContainer(options);
                }
                return $container;
            }

            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function subscribe(callback) {
                listener = callback;
            }

            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }

            function clear($toastElement, clearOptions) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if (!clearToast($toastElement, options, clearOptions)) {
                    clearContainer(options);
                }
            }

            function remove($toastElement) {
                var options = getOptions();
                if (!$container) { getContainer(options); }
                if ($toastElement && $(':focus', $toastElement).length === 0) {
                    removeToast($toastElement);
                    return;
                }
                if ($container.children().length) {
                    $container.remove();
                }
            }

            // internal functions

            function clearContainer (options) {
                var toastsToClear = $container.children();
                for (var i = toastsToClear.length - 1; i >= 0; i--) {
                    clearToast($(toastsToClear[i]), options);
                }
            }

            function clearToast ($toastElement, options, clearOptions) {
                var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function () { removeToast($toastElement); }
                    });
                    return true;
                }
                return false;
            }

            function createContainer(options) {
                $container = $('<div/>')
                    .attr('id', options.containerId)
                    .addClass(options.positionClass)
                    .attr('aria-live', 'polite')
                    .attr('role', 'alert');

                $container.appendTo($(options.target));
                return $container;
            }

            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: 'toast',
                    containerId: 'toast-container',
                    debug: false,

                    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                    showDuration: 300,
                    showEasing: 'swing', //swing and linear are built into jQuery
                    onShown: undefined,
                    hideMethod: 'fadeOut',
                    hideDuration: 1000,
                    hideEasing: 'swing',
                    onHidden: undefined,
                    closeMethod: false,
                    closeDuration: false,
                    closeEasing: false,

                    extendedTimeOut: 1000,
                    iconClasses: {
                        error: 'toast-error',
                        info: 'toast-info',
                        success: 'toast-success',
                        warning: 'toast-warning'
                    },
                    iconClass: 'toast-info',
                    positionClass: 'toast-top-right',
                    timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                    titleClass: 'toast-title',
                    messageClass: 'toast-message',
                    escapeHtml: false,
                    target: 'body',
                    closeHtml: '<button type="button">&times;</button>',
                    newestOnTop: true,
                    preventDuplicates: false,
                    progressBar: false
                };
            }

            function publish(args) {
                if (!listener) { return; }
                listener(args);
            }

            function notify(map) {
                var options = getOptions();
                var iconClass = map.iconClass || options.iconClass;

                if (typeof (map.optionsOverride) !== 'undefined') {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }

                if (shouldExit(options, map)) { return; }

                toastId++;

                $container = getContainer(options, true);

                var intervalId = null;
                var $toastElement = $('<div/>');
                var $titleElement = $('<div/>');
                var $messageElement = $('<div/>');
                var $progressElement = $('<div/>');
                var $closeElement = $(options.closeHtml);
                var progressBar = {
                    intervalId: null,
                    hideEta: null,
                    maxHideTime: null
                };
                var response = {
                    toastId: toastId,
                    state: 'visible',
                    startTime: new Date(),
                    options: options,
                    map: map
                };

                personalizeToast();

                displayToast();

                handleEvents();

                publish(response);

                if (options.debug && console) {
                    console.log(response);
                }

                return $toastElement;

                function escapeHtml(source) {
                    if (source == null)
                        source = "";

                    return new String(source)
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }

                function personalizeToast() {
                    setIcon();
                    setTitle();
                    setMessage();
                    setCloseButton();
                    setProgressBar();
                    setSequence();
                }

                function handleEvents() {
                    $toastElement.hover(stickAround, delayedHideToast);
                    if (!options.onclick && options.tapToDismiss) {
                        $toastElement.click(hideToast);
                    }

                    if (options.closeButton && $closeElement) {
                        $closeElement.click(function (event) {
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                event.cancelBubble = true;
                            }
                            hideToast(true);
                        });
                    }

                    if (options.onclick) {
                        $toastElement.click(function (event) {
                            options.onclick(event);
                            hideToast();
                        });
                    }
                }

                function displayToast() {
                    $toastElement.hide();

                    $toastElement[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                    );

                    if (options.timeOut > 0) {
                        intervalId = setTimeout(hideToast, options.timeOut);
                        progressBar.maxHideTime = parseFloat(options.timeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                        if (options.progressBar) {
                            progressBar.intervalId = setInterval(updateProgress, 10);
                        }
                    }
                }

                function setIcon() {
                    if (map.iconClass) {
                        $toastElement.addClass(options.toastClass).addClass(iconClass);
                    }
                }

                function setSequence() {
                    if (options.newestOnTop) {
                        $container.prepend($toastElement);
                    } else {
                        $container.append($toastElement);
                    }
                }

                function setTitle() {
                    if (map.title) {
                        $titleElement.append(!options.escapeHtml ? map.title : escapeHtml(map.title)).addClass(options.titleClass);
                        $toastElement.append($titleElement);
                    }
                }

                function setMessage() {
                    if (map.message) {
                        $messageElement.append(!options.escapeHtml ? map.message : escapeHtml(map.message)).addClass(options.messageClass);
                        $toastElement.append($messageElement);
                    }
                }

                function setCloseButton() {
                    if (options.closeButton) {
                        $closeElement.addClass('toast-close-button').attr('role', 'button');
                        $toastElement.prepend($closeElement);
                    }
                }

                function setProgressBar() {
                    if (options.progressBar) {
                        $progressElement.addClass('toast-progress');
                        $toastElement.prepend($progressElement);
                    }
                }

                function shouldExit(options, map) {
                    if (options.preventDuplicates) {
                        if (map.message === previousToast) {
                            return true;
                        } else {
                            previousToast = map.message;
                        }
                    }
                    return false;
                }

                function hideToast(override) {
                    var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                    var duration = override && options.closeDuration !== false ?
                        options.closeDuration : options.hideDuration;
                    var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                    if ($(':focus', $toastElement).length && !override) {
                        return;
                    }
                    clearTimeout(progressBar.intervalId);
                    return $toastElement[method]({
                        duration: duration,
                        easing: easing,
                        complete: function () {
                            removeToast($toastElement);
                            if (options.onHidden && response.state !== 'hidden') {
                                options.onHidden();
                            }
                            response.state = 'hidden';
                            response.endTime = new Date();
                            publish(response);
                        }
                    });
                }

                function delayedHideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                        progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                        progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                    }
                }

                function stickAround() {
                    clearTimeout(intervalId);
                    progressBar.hideEta = 0;
                    $toastElement.stop(true, true)[options.showMethod](
                        {duration: options.showDuration, easing: options.showEasing}
                    );
                }

                function updateProgress() {
                    var percentage = ((progressBar.hideEta - (new Date().getTime())) / progressBar.maxHideTime) * 100;
                    $progressElement.width(percentage + '%');
                }
            }

            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }

            function removeToast($toastElement) {
                if (!$container) { $container = getContainer(); }
                if ($toastElement.is(':visible')) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                    previousToast = undefined;
                }
            }

        })();
    });
}(typeof define === 'function' && define.amd ? define : function (deps, factory) {
    if (typeof module !== 'undefined' && module.exports) { //Node
        module.exports = factory((typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null));
    } else {
        window.toastr = factory(window.jQuery);
    }
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
var templateSystem = require('../src/js/bindings/choose-template.js');
document.addEventListener('DOMContentLoaded', function(event) {
  templateSystem.addTemplate("array", "<!-- ko foreach: $data --><!-- ko block: $data --><!-- /ko --><!-- /ko -->");
  templateSystem.addTemplate("block-show", "<!-- ko block: $data, scrollIntoView: $root.selectedBlock() === $data --><!-- /ko -->");
  templateSystem.addTemplate("block-wysiwyg", "<div class=\x22editable block\x22 data-drop-content=\x22Drop here\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here') }, click: function(obj, evt) { $root.selectBlock(obj); return true }, clickBubble: false, css: { selected: $root.selectedBlock() === $data }, scrollIntoView: $root.selectedBlock() === $data\x22>  <div class=\x22mo-blockselectionhelper\x22></div>  <div class=\x22tools\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: typeof $index != 'undefined' -->    <div title=\x22Drag this handle to move the block\x22 data-bind=\x22attr: { title: $root.t('Drag this handle to move the block') }\x22 class=\x22tool handle\x22><i class=\x22fa fa-fw fa-sort\x22></i></div>    <!-- ko if: $index() > 0 -->    <div title=\x22Move this block upside\x22 data-bind=\x22attr: { title: $root.t('Move this block upside') }\x22 class=\x22tool moveup\x22><i class=\x22fa fa-fw fa-sort-asc\x22 data-bind='click: $root.moveBlock.bind($element, $index, $parent, true)'></i></div>    <!-- /ko -->    <!-- ko if: $index() < $parent.blocks().length -1 -->    <div title=\x22Move this block downside\x22 data-bind=\x22attr: { title: $root.t('Move this block downside') }\x22 class=\x22tool movedown\x22><i class=\x22fa fa-fw fa-sort-desc\x22 data-bind='click: $root.moveBlock.bind($element, $index, $parent, false)'></i></div>    <!-- /ko -->    <div title=\x22Delete block\x22 class=\x22tool delete\x22 data-bind=\x22attr: { title: $root.t('Delete block') }, click: $root.removeBlock.bind($element, $rawData, $parent)\x22><i class=\x22fa fa-fw fa-trash-o\x22></i></div>    <div title=\x22Duplicate block\x22 class=\x22tool clone\x22 data-bind=\x22attr: { title: $root.t('Duplicate block') }, click: $root.duplicateBlock.bind($element, $index, $parent)\x22><i class=\x22fa fa-fw fa-files-o\x22></i></div>    <!-- /ko -->    <!-- ko if: typeof $data._nextVariant != 'undefined' --><div title=\x22Switch block variant\x22 class=\x22tool variant\x22 data-bind=\x22attr: { title: $root.t('Switch block variant') }, click: $data._nextVariant\x22><i class=\x22fa fa-fw fa-magic\x22></i></div><!-- /ko -->  </div>  <!-- ko block: $data --><!-- /ko --></div>");
  templateSystem.addTemplate("blocks-show", "<!-- ko template: { name: 'block-show', foreach: blocks } --><!-- /ko -->");
  templateSystem.addTemplate("blocks-wysiwyg", "<div class=\x22sortable-blocks-edit\x22 data-drop-content=\x22Drop here\x22 data-empty-content=\x22Drop here blocks from the Blocks tab\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here'), 'data-empty-content': $root.t('Drop here blocks from the &quot;Blocks&quot; tab') }, css: { 'empty': ko.utils.unwrapObservable(blocks).length == 0 }, extsortable: { connectClass: 'sortable-blocks-edit', template: 'block-wysiwyg', data: blocks, dragging: $root.dragging, beforeMove: $root.startMultiple, afterMove: $root.stopMultiple, options: { handle: '.handle', placeholder: $root.placeholderHelper } }\x22></div>");
  templateSystem.addTemplate("customstyle", "<div class=\x22customStyleHelp\x22 data-bind=\x22html: $root.t('Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class=&quot;customStyled&quot;><span>&quot;small cube&quot; </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul>')\x22>Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class=\x22customStyled\x22><span>\x22small cube\x22 </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul></div>");
  templateSystem.addTemplate("empty", "");
  templateSystem.addTemplate("error", "[<div style=\x22background-color: #fff0f0\x22 data-bind=\x22text: ko.toJS($data)\x22></div>]");
  templateSystem.addTemplate("gallery-images", "<div data-bind=\x22foreach: items.currentPageData\x22>  <div class=\x22draggable-item\x22 data-bind=\x22if: typeof thumbnailUrl != 'undefined'\x22>    <div class=\x22draggable image\x22 data-bind=\x22click: $root.addImage, extdraggable: { data: $data, dropContainer: '#main-wysiwyg-area', dragging: $root.draggingImage, 'options': { 'appendTo': '#page' } }, style: { backgroundImage: 'url(\\'' + thumbnailUrl + '\\')' }\x22>      <img title=\x22Trascina questa immagine sulla posizione in cui vuoi inserirla\x22 style=\x22display: block;\x22 data-bind=\x22tooltips: {}, attr: { src: thumbnailUrl }\x22/>    </div>  </div></div><!-- ko if: items.pageCount() > 1 --><div class=\x22galleryPager\x22 data-bind=\x22buttonset: {}\x22>  <a href=\x22#\x22 data-bind=\x22click: items.moveFirst, button: { disabled: items.currentPage() == 1, icons: { primary: 'fa fa-fast-backward' }, text: false }\x22>First</a>  <a href=\x22#\x22 data-bind=\x22click: items.movePrevious, button: { disabled: items.currentPage() == 1, icons: { primary: 'fa fa-backward' }, text: false }\x22>Previous</a>  <span data-bind=\x22button: { disabled: true, text: true, label: ' '+items.currentPage()+' di '+items.pageCount()+' ' }\x22> X di Y </span>  <a href=\x22#\x22 data-bind=\x22click: items.moveNext, button: { disabled: items.currentPage() == items.pageCount(), icons: { primary: 'fa fa-forward' }, text: false }\x22>Next</a>  <a href=\x22#\x22 data-bind=\x22click: items.moveLast, button: { disabled: items.currentPage() == items.pageCount(), icons: { primary: 'fa fa-fast-forward' }, text: false }\x22>Last</a></div><!-- /ko -->");
  templateSystem.addTemplate("img-wysiwyg", "<table tabfocus=\x220\x22 cellspacing=\x220\x22 cellpadding=\x220\x22 data-drop-content=\x22Drop here\x22 data-bind=\x22style: _stylebind, click: function(obj, evt) { $root.selectItem(_item, _data); return true; }, clickBubble: false, fudroppable: { activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }, droppable: { options: { accept: '.image', activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }, data: _src, dragged: $root.fileToImage }, css: { selecteditem: $root.isSelectedItem(_item) }, scrollIntoView: $root.isSelectedItem(_item), attr: { 'data-drop-content': $root.t('Drop here'), width: _width, height: _height, align: _align }\x22  class=\x22img-wysiwyg selectable-img\x22 style=\x22display: table;\x22><tr><td class=\x22uploadzone\x22>  <div class=\x22mo-imgselectionhelper\x22></div>  <div class=\x22mo-uploadzone\x22></div>  <div class=\x22img-size\x22 data-bind=\x22text: _size\x22>size</div>  <div class=\x22midtools\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: _src() != '' -->    <div title=\x22Remove image\x22 class=\x22tool delete\x22 data-bind=\x22attr: { title: $root.t('Remove image') }, click: _src.bind(_src, ''), clickBubble: false\x22><i class=\x22fa fa-fw fa-trash-o\x22></i></div>    <!-- ko if: typeof $root.editImage !== 'undefined' -->    <div title=\x22Open the image editing tool\x22 class=\x22tool edit\x22 data-bind=\x22attr: { title: $root.t('Open the image editing tool') }, click: $root.editImage.bind($element, _src), clickBubble: false\x22><i class=\x22fa fa-fw fa-pencil\x22></i></div>    <!-- /ko -->    <!-- /ko -->    <!-- ko if: _src() == '' -->    <div title=\x22Upload a new image\x22 data-bind=\x22attr: { title: $root.t('Upload a new image') }\x22 class=\x22tool upload\x22 style=\x22position: relative; overflow: hidden;\x22><i class=\x22fa fa-fw fa-upload\x22></i>      <input class=\x22fileupload nofile\x22 type=\x22file\x22 name=\x22files[]\x22 data-bind=\x22fileupload: { data: _src, onerror: $root.notifier.error, onfile: $root.loadImage, canvasPreview: true }\x22 style=\x22z-index: 20; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-size: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block\x22>    </div>    <!-- /ko -->  </div>  <!-- ko template: _template --><!-- /ko -->  <!-- ko if: _src() == '' -->    <!--    <img style=\x22display: block;\x22 class=\x22imgplaceholder\x22 width=\x22200\x22 src=\x22\x22 alt=\x22Insert an image here\x22 data-bind=\x22wysiwygSrc: { src: _src.preloaded, placeholder: _placeholdersrc, width: _width, height: _height, method: _method }\x22 />    -->    <span class=\x22fileuploadtext\x22 style=\x22text-align: center; display: -ms-flexbox; display: flex; align-items: center; flex-align: center; justify-content: center; padding: 1em; position: absolute; top: 0; left: 0; right: 0; bottom: 0;\x22><span class=\x22textMiddle\x22 style=\x22 text-shadow: 1px 1px 0 #FFFFFF, 0 0 10px #FFFFFF; font-weight: bold;\x22 data-bind=\x22text: $root.t('Drop an image here')\x22>Drop an image here</span></span>  <!-- /ko -->  <!-- ko if: _src() != '' -->  <!--    <img style=\x22display: block;\x22 width=\x22200\x22 src=\x22\x22 data-bind=\x22preloader: _src, wysiwygSrc: { src: _src.preloaded, placeholder: _placeholdersrc, width: _width, height: _height, method: _method }\x22 />    -->  <!-- /ko -->  <!-- pulsante per la cancellazione -->  <div title=\x22Drop an image here or click the upload button\x22 data-bind=\x22attr: { title: $root.t('Drop an image here or click the upload button') }, tooltips: {}\x22 class=\x22workzone\x22 style=\x22position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden;\x22>    <!-- ko if: _src.preloaded && _src() != _src.preloaded() -->PRELOADING....<!-- /ko -->    <!-- ko if: _src() != '' -->      <input class=\x22fileupload withfile\x22 type=\x22file\x22 name=\x22files[]\x22 data-bind=\x22fileupload: { data: _src, onerror: $root.notifier.error, onfile: $root.galleryRecent.unshift.bind($root.galleryRecent), canvasPreview: true }\x22 style=\x22z-index: -20; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-zie: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block\x22>    <!-- /ko -->    <div class=\x22progress\x22 style=\x22opacity: .5; width: 80%; margin-left: 10%; position: absolute; bottom: 30%; height: 20px; border: 2px solid black;\x22>      <div class=\x22progress-bar progress-bar-success\x22 style=\x22height: 20px; background-color: black; \x22></div>    </div>  </div></table>");
  templateSystem.addTemplate("main", "<div id=\x22page\x22 style=\x22display: none;\x22 data-bind=\x22visible: true, css: { withToolbox: $root.showToolbox, withPreviewFrame: showPreviewFrame }\x22>  <div id=\x22main-edit-area\x22 data-bind=\x22click: function(obj, evt) { $root.selectBlock(null); return true; }, clickBubble: false\x22>    <!-- ko withProperties: { templateMode: 'wysiwyg', templateModeFallback: 'show' } -->    <div id=\x22main-wysiwyg-area\x22 data-bind=\x22wysiwygScrollfix: true, scrollable: true, fudroppable: { active: draggingImage }, css: { isdragging: dragging, isdraggingimg: draggingImage }, block: content\x22></div>    <!-- /ko -->  </div>  <div id=\x22toolbar\x22 class=\x22mo\x22 data-bind=\x22tooltips: {}\x22>    <!-- ko if: typeof $root.undo != 'undefined' -->    <span data-bind=\x22buttonset: { }\x22 class=\x22leftButtons\x22>    <a title=\x22Undo last operation\x22 href=\x22#\x22 data-bind=\x22attr: { title: $root.t('Undo last operation') }, click: $root.undo.execute, clickBubble: false, button: { disabled: !$root.undo.enabled(), icons: { primary: 'fa fa-reply' }, label: $root.undo.name, text: true }\x22>UNDO</a>    <a title=\x22Redo last operation\x22 href=\x22#\x22 data-bind=\x22attr: { title: $root.t('Redo last operation') }, click: $root.redo.execute, clickBubble: false, button: { disabled: !$root.redo.enabled(), icons: { primary: 'fa fa-share' }, label: $root.redo.name, text: true }\x22>REDO</a>    </span>    <!-- ko if: $root.debug -->    <a href=\x22#\x22 data-bind=\x22click: $root.undoReset, clickBubble: false, button: { disabled: !$root.undo.enabled() && !$root.redo.enabled(), label: 'reset', text: true }\x22>RESET</a>    <!-- /ko -->    <!-- /ko -->    <span>    <input id=\x22showGallery\x22 type=\x22checkbox\x22 data-bind=\x22checked: $root.showGallery, button: { refreshOn: $root.showGallery,     icons: { primary: 'fa fa-fw fa-picture-o', secondary: null }, text: true, label: $root.t('Gallery') }\x22><label title=\x22Show image gallery\x22 for=\x22showGallery\x22 data-bind=\x22attr: { title: $root.t('Show image gallery') }\x22>show gallery</label></input>    </span>    <input id=\x22previewFrameToggle\x22 type=\x22checkbox\x22 data-bind=\x22checked: $root.showPreviewFrame, button: { refreshOn: $root.showPreviewFrame, icons: { primary: 'fa fa-fw fa-tablet', secondary: null }, text: false, label: $root.t('Preview') }\x22><label title=\x22Show live preview\x22 for=\x22previewFrameToggle\x22 data-bind=\x22attr: { title: $root.t('Show live preview') }\x22>PREVIEW</label></input>    <!-- ko if: $root.debug -->    <a href=\x22#\x22 data-bind=\x22click: $root.export, clickBubble: false, button: { label: 'export', text: true }\x22>EXPORT</a>    <input type=\x22checkbox\x22 data-bind=\x22checked: $root.debug\x22 /> debug    <a href=\x22#\x22 data-bind=\x22click: $root.loadDefaultBlocks, clickBubble: false, button: { icons: { primary: 'fa fa-fw fa-upload' }, label: 'Default', text: true }\x22>LOAD BLOCKS</a>    [<a id=\x22subscriptionsCount\x22 href=\x22javascript:viewModel.loopSubscriptionsCount()\x22>subs</a>]    <!-- /ko -->    <span data-bind=\x22visible: false\x22>    <input type=\x22checkbox\x22 data-bind=\x22checked: $root.showToolbox\x22 /> toolbox    </span>    <div class=\x22rightButtons\x22>    <!-- ko if: typeof $root.save !== 'undefined' -->    <a title=\x22Save template\x22 href=\x22#\x22 data-bind=\x22attr: { title: $root.t('Save template') }, click: $root.save.execute, clickBubble: false, button: { disabled: !$root.save.enabled(), icons: { primary: 'fa fa-fw fa-cloud-upload' }, label: $root.t($root.save.name), text: true }\x22>SALVA</a>    <!-- /ko -->    <!-- ko if: typeof $root.test !== 'undefined' -->    <a title=\x22Show preview and send test\x22 href=\x22#\x22 data-bind=\x22attr: { title: $root.t('Show preview and send test') }, click: $root.test.execute, clickBubble: false, button: { disabled: !$root.test.enabled(), icons: { primary: 'fa fa-fw fa-paper-plane' }, label: $root.t($root.test.name), text: true }\x22>TEST</a>    <!-- /ko -->    <!-- ko if: typeof $root.download !== 'undefined' -->    <form id=\x22downloadForm\x22 action=\x22#\x22 method=\x22POST\x22>    <input type=\x22hidden\x22 name=\x22action\x22 value=\x22download\x22 />    <input type=\x22hidden\x22 name=\x22filename\x22 value=\x22email.html\x22 />    <input type=\x22hidden\x22 name=\x22html\x22 id=\x22downloadHtmlTextarea\x22 />    <a title=\x22Download template\x22 href=\x22#\x22 data-bind=\x22attr: { title: $root.t('Download template') }, click: $root.download.execute, clickBubble: false, button: { disabled: !$root.download.enabled(), icons: { primary: 'fa fa-fw fa-download' }, label: $root.t($root.download.name), text: true }\x22>DOWNLOAD</a>    </form>    <!-- /ko -->    </div>  </div>  <!-- ko if: $root.showToolbox -->  <div id=\x22main-toolbox\x22 class=\x22mo\x22 data-bind=\x22scrollable: true, withProperties: { templateMode: 'edit' }\x22>    <div data-bind=\x22template: { name: 'toolbox' }\x22></div>  </div>  <!-- /ko -->    <div id=\x22main-preview\x22 class=\x22mo\x22 data-bind=\x22scrollable: true, if: $root.showPreviewFrame\x22>    <div id=\x22preview-toolbar\x22>      <div data-bind=\x22visible: $root.showPreviewFrame, buttonset: { }\x22 style=\x22display: inline-block\x22>        <input id=\x22previewLarge\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22large\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'large', icons: { primary: 'fa fa-fw fa-desktop' } }\x22 />        <label for=\x22previewLarge\x22 title=\x22Large screen\x22 data-bind=\x22attr: { title: $root.t('Large screen') }\x22>Large screen</label>        <input id=\x22previewDesktop\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22desktop\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'desktop', icons: { primary: 'fa fa-fw fa-tablet' } }\x22 />        <label for=\x22previewDesktop\x22 title=\x22Tablet\x22 data-bind=\x22attr: { title: $root.t('Tablet') }\x22>Tablet</label>        <input id=\x22previewMobile\x22 type=\x22radio\x22 name=\x22previewMode\x22 value=\x22mobile\x22 data-bind=\x22checked: $root.previewMode, button: { text: false, label: 'mobile', icons: { primary: 'fa fa-fw fa-mobile' } }\x22 />        <label for=\x22previewMobile\x22 title=\x22Smartphone\x22 data-bind=\x22attr: { title: $root.t('Smartphone') }\x22>Smartphone</label>      </div>    </div>    <div id=\x22frame-container\x22 data-bind=\x22css: { desktop: $root.previewMode() == 'desktop', mobile: $root.previewMode() == 'mobile', large: $root.previewMode() == 'large' }\x22>      <iframe data-bind=\x22bindIframe: $data\x22></iframe>    </div>  </div>  <div class=\x22mo\x22 id=\x22mo-body\x22></div>  <!-- TODO REMOVE ME  <div id=\x22incompatible-browser\x22 title=\x22Unsupported browser\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Usupported browser') }, html: '<p>Your browser is not supported.</p><p>Use a different browser or try updaring your browser.</p><p>Supported browsers: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>'\x22>    Unsupported browser  </div>  -->  <div id=\x22incompatible-template\x22 title=\x22Saved model is obsolete\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Saved model is obsolete') }, html: $root.t('<p>The saved model has been created with a previous, non completely compatible version, of the template</p><p>Some content or style in the model <b>COULD BE LOST</b> if you will <b>save</b></p><p>Contact us for more informations!</p>')\x22>    Incompatible template  </div>  <div id=\x22fake-image-editor\x22 title=\x22Fake image editor\x22 style=\x22display: none\x22 data-bind=\x22attr: { title: $root.t('Fake image editor') }, html: $root.t('<p>Fake image editor</p>')\x22>    <p>Fake image editor</p>  </div></div><!-- ko if: $root.logoPath --><div id=\x22loading\x22 class=\x22loading\x22 style=\x22display: block; width: 300px; text-align: center; height: 32px; position: absolute; top:0; bottom: 0; left: 0; right: 0;  margin: auto;\x22 data-bind=\x22attr: { style: 'position: absolute; top: 5px; left: 6px; z-index: 150;'}, css: { loading: false }\x22>  <a href=\x22/\x22 data-bind=\x22attr: { href: $root.logoUrl, alt: $root.logoAlt }\x22><img data-bind=\x22attr: { src: $root.logoPath }\x22 width=\x2232\x22 height=\x2232\x22 alt=\x22mosaico\x22 border=\x220\x22 /></a>  <div style=\x22opacity: 0\x22 data-bind=\x22visible: false\x22>Oppps... !!</div></div><!-- /ko -->");
  templateSystem.addTemplate("toolbox", "<div id=\x22tooltabs\x22 class=\x22tabs_horizontal button_color\x22 data-bind=\x22tabs: { active: $root.selectedTool }\x22>  <ul>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Blocks ready to be added to the template\x22 data-local=\x22true\x22 href=\x22#toolblocks\x22 data-bind=\x22attr: { title: $root.t('Blocks ready to be added to the template') }\x22><i class=\x22fa fa-fw fa-cubes\x22></i> <span data-bind=\x22html: $root.t('Blocks')\x22>Blocks</span></a></li>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Edit content options\x22 href=\x22#toolcontents\x22 data-local=\x22true\x22 data-bind=\x22attr: { title: $root.t('Edit content options') }\x22><i class=\x22fa fa-fw fa-pencil\x22></i> <span data-bind=\x22html: $root.t('Content')\x22>Content</span></a></li>    <li data-bind=\x22tooltips: {}\x22><a title=\x22Edit style options\x22 href=\x22#toolstyles\x22 data-local=\x22true\x22 data-bind=\x22attr: { title: $root.t('Edit style options') }\x22><i class=\x22fa fa-fw fa-paint-brush\x22></i> <span data-bind=\x22html: $root.t('Style')\x22>Style</span></a></li>  </ul>  <div id=\x22toolblocks\x22 data-bind=\x22scrollable: true\x22>    <div class=\x22block-list\x22 data-bind=\x22foreach: blockDefs\x22 style=\x22text-align: center\x22>      <div class=\x22draggable-item\x22 data-bind=\x22withProperties: { templateMode: 'show' }\x22>        <div class=\x22block\x22 data-bind=\x22extdraggable: { connectClass: 'sortable-blocks-edit', data: $data, dropContainer: '#main-wysiwyg-area', dragging: $root.dragging, 'options': { handle: '.handle', distance: 10, 'appendTo': '#page' } }, click: $root.addBlock\x22 style=\x22position: relative;\x22>          <div title=\x22Click or drag to add this block to the template\x22 class=\x22handle\x22 data-bind=\x22attr: { title: $root.t('Click or drag to add this block to the template') }, tooltips: {}\x22></div>          <img data-bind=\x22attr: { alt: $root.t('Block __name__', { name: ko.utils.unwrapObservable(type) }), src: $root.templatePath('edres/'+ko.utils.unwrapObservable(type)+'.png') }\x22 alt=\x22Block __name__\x22 />        </div>        <a href=\x22#\x22 class=\x22addblockbutton\x22 data-bind=\x22click: $root.addBlock, button: { label: $root.t('Add') }\x22>Add</a>      </div>    </div>  </div>  <div id=\x22toolcontents\x22 data-bind=\x22scrollable: true\x22>    <!-- ko if: $root.selectedBlock() !== null -->    <div data-bind=\x22block: $root.selectedBlock\x22></div>    <!-- /ko -->    <!-- ko if: $root.selectedBlock() == null -->    <div class=\x22noSelectedBlock\x22 data-bind=\x22text: $root.t('By clicking on message parts you will select a block and content options, if any, will show here')\x22>By clicking on message parts you will select a block and content options, if any, will show here</div>    <!-- /ko -->    <!-- ko block: content --><!-- /ko -->  </div>    <div id=\x22toolstyles\x22 data-bind=\x22scrollable: true, withProperties: { templateMode: 'styler' }\x22>    <!-- ko if: typeof $root.content().theme === 'undefined' || typeof $root.content().theme().scheme === 'undefined' || $root.content().theme().scheme() === 'custom' -->      <!-- ko if: $root.selectedBlock() !== null -->      <div data-bind=\x22block: $root.selectedBlock, css: { workLocal: $root.selectedBlock().customStyle, workGlobal: typeof $root.selectedBlock().customStyle === 'undefined' || !$root.selectedBlock().customStyle() }\x22></div>      <!-- /ko -->      <!-- ko if: $root.selectedBlock() == null -->      <div class=\x22noSelectedBlock\x22 data-bind=\x22text: $root.t('By clicking on message parts you will select a block and style options, if available, will show here')\x22>By clicking on message parts you will select a block and style options, if available, will show here</div>      <!-- /ko -->      <div class=\x22workGlobalContent\x22>      <!-- ko block: content --><!-- /ko -->      </div>    <!-- /ko -->  </div></div>        <div id=\x22toolimages\x22 class=\x22slidebar\x22 data-bind=\x22scrollable: true, css: { hidden: $root.showGallery() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.showGallery.bind($element, false);\x22>X</div>  <span class=\x22pane-title\x22 data-bind=\x22text: $root.t('Gallery:')\x22>Gallery:</span>  <div data-drop-content=\x22Drop here\x22 class=\x22img-dropzone pane uploadzone\x22 data-bind=\x22attr: { 'data-drop-content': $root.t('Drop here') }, fudroppable: { activeClass: 'ui-state-highlight', hoverClass: 'ui-state-draghover' }\x22>  <div class=\x22mo-uploadzone\x22 style=\x22position: relative; padding: 2em; border: 2px dotted #808080\x22>     <input class=\x22fileupload\x22 type=\x22file\x22 multiple name=\x22files[]\x22 data-bind=\x22fileupload: { onerror: $root.notifier.error, onfile: $root.loadImage }\x22 style=\x22z-index: 10; position: absolute; top: 0; left: 0; right: 0; bottom: 0; min-width: 100%; min-height: 100%; font-zie: 999px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; cursor: inherit; display: block\x22>     <span data-bind=\x22text: $root.t('Click or drag files here')\x22>Click or drag files here</span>     <div class=\x22workzone\x22 style=\x22position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden;\x22>       <div class=\x22progress\x22 style=\x22opacity: .5; width: 80%; margin-left: 10%; position: absolute; bottom: 30%; height: 20px; border: 2px solid black;\x22>         <div class=\x22progress-bar progress-bar-success\x22 style=\x22height: 20px; background-color: black; \x22></div>       </div>     </div>  </div>  </div>  <!-- ko if: $root.showGallery() -->  <div id=\x22toolimagestab\x22 class=\x22tabs_horizontal\x22 data-bind=\x22tabs: { active: $root.selectedImageTab }\x22>    <ul>      <li data-bind=\x22tooltips: {}\x22><a title=\x22Session images\x22 data-local=\x22true\x22 href=\x22#toolimagesrecent\x22 data-bind=\x22attr: { title: $root.t('Session images') }, text: $root.t('Recents')\x22>Recents</a></li>      <li data-bind=\x22tooltips: {}\x22><a title=\x22Remote gallery\x22 data-local=\x22true\x22 href=\x22#toolimagesgallery\x22 data-bind=\x22attr: { title: $root.t('Remote gallery') }, text: $root.t('Gallery')\x22>Gallery</a></li>    </ul>    <div id=\x22toolimagesrecent\x22>      <!-- ko if: galleryRecent().length == 0 --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('No images uploaded, yet')\x22>No images uploaded, yet</div><!-- /ko -->      <!-- ko template: {name: 'gallery-images', data: { items: galleryRecent } } --># recent gallery #<!-- /ko -->    </div>    <div id=\x22toolimagesgallery\x22 style=\x22text-align: center\x22>    <!-- ko if: $root.galleryLoaded() === false --><a class=\x22loadbutton\x22 title=\x22Show images from the gallery\x22 href=\x22#\x22 data-bind=\x22attr: { title: $root.t('Show images from the gallery') }, click: $root.loadGallery, button: { disabled: $root.galleryLoaded, icons: { primary: 'fa fa-fw fa-picture-o' }, label: $root.galleryLoaded() == 'loading' ? $root.t('Loading...') : $root.t('Load gallery'), text: true }\x22># load gally #</a><!-- /ko -->    <!-- ko if: $root.galleryLoaded() === 'loading' --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('Loading gallery...')\x22>Loading gallery...</div><!-- /ko -->    <!-- ko if: $root.galleryLoaded() === 0 --><div class=\x22galleryEmpty\x22 data-bind=\x22text: $root.t('The gallery is empty')\x22>The gallery is empty</div><!-- /ko -->    <!-- ko template: {name: 'gallery-images', data: { items: galleryRemote } } --># remote gallery #<!-- /ko -->    </div>  </div>  <!-- /ko --></div><div id=\x22tooldebug\x22 class=\x22slidebar\x22 data-bind=\x22css: { hidden: $root.debug() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.debug.bind($element, false);\x22>X</div>    <!-- ko if: $root.debug -->  Content:  <pre data-bind='text: ko.toJSON(content, null, 2)' style=\x22overflow: auto; height: 20%\x22></pre>  BlockDefs:  <pre data-bind='text: ko.toJSON(blockDefs, null, 2)' style=\x22overflow: auto; height: 20%\x22></pre>  <!-- /ko -->  <a href=\x22#\x22 data-bind=\x22click: $root.exportHTMLtoTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Generate' }\x22>Output</a>  <a href=\x22#\x22 data-bind=\x22click: $root.exportJSONtoTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Export' }\x22>Export</a>  <a href=\x22#\x22 data-bind=\x22click: $root.importJSONfromTextarea.bind($element, '#outputhtml'); clickBubble: false, button: { text: true, label:'Import' }\x22>Import</a>  <textarea id=\x22outputhtml\x22 rows=\x2210\x22 style=\x22width: 100%;\x22></textarea></div><div id=\x22tooltheme\x22 class=\x22ui-widget slidebar\x22 data-bind=\x22css: { hidden: $root.showTheme() === false }\x22>  <div class=\x22close\x22 data-bind=\x22click: $root.showTheme.bind($element, false);\x22>X</div>    <!-- ko withProperties: { templateMode: 'styler' } -->    <!-- ko if: $root.showTheme -->      <!-- ko block: $root.content().theme --><!-- /ko -->    <!-- /ko -->  <!-- /ko --></div>");
});

},{"../src/js/bindings/choose-template.js":22}],14:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":18}],15:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],16:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],17:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],18:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":17,"_process":16,"inherits":15}],19:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */
/* global XMLHttpRequest: false */

var templateLoader = require('./template-loader.js');
var console = require("./../../bower_components/console-browserify/index.js");
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
require("./ko-bindings.js");
var performanceAwareCaller = require("./timed-call.js").timedCall;

var addUndoStackExtensionMaker = require("./undomanager/undomain.js");
var colorPlugin = require("./ext/color.js");

var localStorageLoader = require("./ext/localstorage.js");

function _canonicalize(url) {
  var div = global.document.createElement('div');
  div.innerHTML = "<a></a>";
  div.firstChild.href = url; // Ensures that the href is properly escaped
  div.innerHTML = div.innerHTML; // Run the current innerHTML back through the parser
  return div.firstChild.href;
}

var applyBindingOptions = function(options, ko) {
  // push "convertedUrl" method to the wysiwygSrc binding
  ko.bindingHandlers.wysiwygSrc.convertedUrl = function(src, method, width, height) {
    var imgProcessorBackend = options.imgProcessorBackend ? options.imgProcessorBackend : './upload';
    var backEndMatch = imgProcessorBackend.match(/^(https?:\/\/[^\/]*\/).*$/);
    var srcMatch = src.match(/^(https?:\/\/[^\/]*\/).*$/);
    if (backEndMatch === null || (srcMatch !== null && backEndMatch[1] == srcMatch[1])) {
      return imgProcessorBackend + "?src=" + encodeURIComponent(src) + "&method=" + encodeURIComponent(method) + "&params=" + encodeURIComponent(width + "," + height);
    } else {
      console.log("Cannot apply backend image resizing to non-local resources ", src, method, width, height, backEndMatch, srcMatch);
      return src + "?method=" + method + "&width=" + width + (height !== null ? "&height=" + height : '');
    }
  };

  ko.bindingHandlers.wysiwygSrc.placeholderUrl = function(width, height, text) {
    return options.imgProcessorBackend + "?method=" + 'placeholder' + "&params=" + width + encodeURIComponent(",") + height;
  };

  // pushes custom tinymce configurations from options to the binding
  if (options && options.tinymceConfig)
    ko.bindingHandlers.wysiwyg.standardOptions = options.tinymceConfig;
  if (options && options.tinymceConfigFull)
    ko.bindingHandlers.wysiwyg.fullOptions = options.tinymceConfigFull;
};

var start = function(options, templateFile, templateMetadata, jsorjson, customExtensions) {

  templateLoader.fixPageEvents();

  var fileUploadMessagesExtension = function(vm) {
    var fileuploadConfig = {
      messages: {
        unknownError: vm.t('Unknown error'),
        uploadedBytes: vm.t('Uploaded bytes exceed file size'),
        maxNumberOfFiles: vm.t('Maximum number of files exceeded'),
        acceptFileTypes: vm.t('File type not allowed'),
        maxFileSize: vm.t('File is too large'),
        minFileSize: vm.t('File is too small'),
        post_max_size: vm.t('The uploaded file exceeds the post_max_size directive in php.ini'),
        max_file_size: vm.t('File is too big'),
        min_file_size: vm.t('File is too small'),
        accept_file_types: vm.t('Filetype not allowed'),
        max_number_of_files: vm.t('Maximum number of files exceeded'),
        max_width: vm.t('Image exceeds maximum width'),
        min_width: vm.t('Image requires a minimum width'),
        max_height: vm.t('Image exceeds maximum height'),
        min_height: vm.t('Image requires a minimum height'),
        abort: vm.t('File upload aborted'),
        image_resize: vm.t('Failed to resize image'),
        generic: vm.t('Unexpected upload error')
      }
    };
    // fileUpload options.
    if (options && options.fileuploadConfig)
      fileuploadConfig = $.extend(true, fileuploadConfig, options.fileuploadConfig);

    ko.bindingHandlers['fileupload'].extendOptions = fileuploadConfig;

  };

  var simpleTranslationPlugin = function(vm) {
    if (options && options.strings) {
      vm.t = function(key, objParam) {
        var res = options.strings[key];
        if (typeof res == 'undefined') {
          console.warn("Missing translation string for",key,": using default string");
          res = key;
        }
        return vm.tt(res, objParam);
      };
    }
  };

  var extensions = [addUndoStackExtensionMaker(performanceAwareCaller), colorPlugin, simpleTranslationPlugin];
  if (typeof customExtensions !== 'undefined')
    for (var k = 0; k < customExtensions.length; k++) extensions.push(customExtensions[k]);
  extensions.push(fileUploadMessagesExtension);

  var galleryUrl = options.fileuploadConfig ? options.fileuploadConfig.url : '/upload/';
  applyBindingOptions(options, ko);

  // TODO what about appending to another element?
  $("<!-- ko template: 'main' --><!-- /ko -->").appendTo(global.document.body);

  // templateFile may override the template path in templateMetadata
  if (typeof templateFile == 'undefined' && typeof templateMetadata != 'undefined') {
    templateFile = templateMetadata.template;
  }
  // TODO canonicalize templateFile to absolute or relative depending on "relativeUrlsException" plugin

  templateLoader.load(performanceAwareCaller, templateFile, templateMetadata, jsorjson, extensions, galleryUrl);

};

var initFromLocalStorage = function(options, hash_key, customExtensions) {
  try {
    var lsData = localStorageLoader(hash_key, options.emailProcessorBackend);
    var extensions = typeof customExtensions !== 'undefined' ? customExtensions : [];
    extensions.push(lsData.extension);
    var template = _canonicalize(lsData.metadata.template);
    start(options, template, lsData.metadata, lsData.model, extensions);
  } catch (e) {
    console.error("TODO not found ", hash_key, e);
  }
};

var init = function(options, customExtensions) {

  var hash = global.location.hash ? global.location.href.split("#")[1] : undefined;

  // Loading from configured template or configured metadata
  if (options && (options.template || options.data)) {
    if (options.data) {
      var data = JSON.parse(options.data);
      start(options, undefined, data.metadata, data.content, customExtensions);
    } else {
      start(options, options.template, undefined, undefined, customExtensions);
    }
    // Loading from LocalStorage (if url hash has a 7chars key)
  } else if (hash && hash.length == 7) {
    initFromLocalStorage(options, hash, customExtensions);
    // Loading from template url as hash (if hash is not a valid localstorage key)
  } else if (hash) {
    start(options, _canonicalize(hash), undefined, undefined, customExtensions);
  } else {
    return false;
  }
  return true;
};

module.exports = {
  isCompatible: templateLoader.isCompatible,
  init: init,
  start: start
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./ext/color.js":51,"./ext/localstorage.js":52,"./ko-bindings.js":53,"./template-loader.js":54,"./timed-call.js":55,"./undomanager/undomain.js":56}],20:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// @see also script-template.js pushTemplate
var addScriptTemplate = function(doc, templateName, templateMarkup) {
  var scriptTag = doc.createElement('script');
  scriptTag.setAttribute('type', 'text/html');
  scriptTag.setAttribute('id', templateName);
  scriptTag.text = templateMarkup;
  doc.body.appendChild(scriptTag);
  return scriptTag;
  // $('<script type="text/html"></sc' + 'ript>').text(templateMarkup).attr('id', templateName).appendTo($('body'));
};

// used for live preview in iframe.
ko.bindingHandlers.bindIframe = {
  // tpl will be overriden with the structure parsed by the input template.
  tpl: "<!DOCTYPE html>\r\n<html>\r\n<head>\r\n</head>\r\n<body><div data-bind=\"block: content\"></div></body>\r\n</html>\r\n",
  init: function(element, valueAccessor) {
    function bindIframe(local) {
      try {
        var iframe = element.contentDocument;
        iframe.open();
        iframe.write(ko.bindingHandlers.bindIframe.tpl);
        iframe.close();

        try {
          var iframedoc = iframe.body;
          if (iframedoc) {
            // scripts have to be duplicated (maybe this is not needed anymore since using string-templates)
            var templates = element.contentWindow.parent.document.getElementsByTagName('script');
            for (var i = 0; i < templates.length; i++) {
              if (templates[i].getAttribute('type') == 'text/html' && templates[i].getAttribute('id')) {
                addScriptTemplate(iframe, templates[i].getAttribute('id'), templates[i].innerHTML);
              }
            }

            var html = iframe.getElementsByTagName("HTML");

            ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
              ko.cleanNode(html[0] || iframedoc);
            });

            ko.applyBindings(valueAccessor(), html[0] || iframedoc);
          } else {
            console.log("no iframedoc", local);
          }
        } catch (e) {
          console.log("error reading iframe.body", e, local);
          throw e;
        }
      } catch (e) {
        console.log("error reading iframe contentDocument", e, local);
        throw e;
        // ignored
      }
    }
    bindIframe("first call");
    // older browsers needed this
    // ko.utils.registerEventHandler(element, 'load', bindIframe);
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],21:[function(require,module,exports){
(function (global){
"use strict";
/* globals global:false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");


ko.bindingHandlers['withProperties'] = {
  init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    // Make a modified binding context, with a extra properties, and apply it to descendant elements
    var childBindingContext = bindingContext.createChildContext(
      bindingContext.$rawData,
      null, // Optionally, pass a string here as an alias for the data item in descendant contexts
      function(context) {
        ko.utils.extend(context, valueAccessor());
      }
    );
    ko.applyBindingsToDescendants(childBindingContext, element);

    // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice
    return {
      controlsDescendantBindings: true
    };
  }
};
ko.virtualElements.allowedBindings['withProperties'] = true;

ko.bindingHandlers['log'] = {
  init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    console.log("log", valueAccessor());
  }
};


ko.bindingHandlers['block'] = {

  templateExists: function(id) {
    var el = global.document.getElementById(id);
    if (el) return true;
    else return false;
  },

  _chooseTemplate: function(isArray, prefix, action, fallback) {
    var id = prefix + '-' + action;
    if (ko.bindingHandlers['block'].templateExists(id)) return id;
    if (typeof fallback != 'undefined' && fallback !== null) return ko.bindingHandlers['block']._chooseTemplate(isArray, prefix, fallback);
    else {
      var fallBackId = isArray ? 'array' : 'object-' + action;
      if (ko.bindingHandlers['block'].templateExists(fallBackId)) return fallBackId;
      else throw "cannot find template for " + id + "/" + fallBackId;
    }
  },

  // compute displayMode depending on templateMode set using "withProperties" binding.
  _displayMode: function(unwrapped, bindingContext) {
    var prefix = typeof unwrapped.type != 'undefined' ? ko.utils.unwrapObservable(unwrapped.type) : 'notablock-' + typeof(unwrapped);
    var isArray = typeof unwrapped.splice !== 'undefined';
    var templateMode = bindingContext.templateMode ? bindingContext.templateMode : 'show';
    return ko.bindingHandlers['block']._chooseTemplate(isArray, prefix, templateMode, bindingContext.templateModeFallback);
  },

  _makeTemplateValueAccessor: function(valueAccessor, bindingContext) {
    return function() {
      var value = valueAccessor(),
        unwrappedValue = ko.utils.peekObservable(value); // Unwrap without setting a dependency here

      // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
      var modelValue;
      var template;

      if ((!unwrappedValue) || (typeof unwrappedValue.data != 'object' && typeof unwrappedValue.data != 'function')) {
        modelValue = value;
      } else {
        modelValue = unwrappedValue.data;
        if (typeof unwrappedValue.template != 'undefined') {
          var templateParam = ko.utils.unwrapObservable(unwrappedValue.template);
          var templateMode = bindingContext.templateMode ? bindingContext.templateMode : 'show';
          template = ko.bindingHandlers['block']._chooseTemplate(false, templateParam, templateMode, bindingContext.templateModeFallback);
        }
      }

      var unwrappedModelValue = ko.utils.unwrapObservable(modelValue);
      if (ko.isObservable(unwrappedModelValue)) console.log("doubleObservable", unwrappedModelValue);

      if (typeof template == 'undefined') {
        // NOTE IE8 used to break here, but we don't support it anymore, so maybe this is not needed.
        if (modelValue === undefined) {
          template = 'empty';
        } else {
          try {
            template = ko.bindingHandlers['block']._displayMode(unwrappedModelValue, bindingContext);
          } catch (e) {
            console.log(e, unwrappedModelValue, bindingContext['$data'], bindingContext.templateMode);
            throw e;
          }
        }
      }

      return {
        'name': template,
        'data': modelValue,
        'templateEngine': ko.nativeTemplateEngine.instance
      };
    };
  },

  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    if (typeof valueAccessor() === 'undefined') console.log("found a null block: check ending commas in arrays defs in IE");
    var newValueAccessor = ko.bindingHandlers['block']._makeTemplateValueAccessor(valueAccessor, bindingContext);
    return ko.bindingHandlers['template']['init'](element, newValueAccessor);
  },
  'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var newValueAccessor = ko.bindingHandlers['block']._makeTemplateValueAccessor(valueAccessor, bindingContext);
    return ko.bindingHandlers['template']['update'](element, newValueAccessor, allBindings, viewModel, bindingContext);
  }
};
ko.expressionRewriting.bindingRewriteValidators['block'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['block'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],22:[function(require,module,exports){
"use strict";

// script template is the one provided by KO and deals with tempaltes defined as <script type=text/html.
// string template defines them in memory and avoids polluting the HTML: seems to work better in Mosaico.

module.exports = require('./string-template.js');
// module.exports = require('./script-template.js');

},{"./string-template.js":36}],23:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

require("./../../../bower_components/evol-colorpicker/js/evol.colorpicker.min.js");

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null);


var ColorPicker = function() {
  kojqui.BindingHandler.call(this, 'colorpicker');
};
ColorPicker.prototype = kojqui.utils.createObject(kojqui.BindingHandler.prototype);
ColorPicker.prototype.constructor = ColorPicker;

ColorPicker.prototype.init = function(element, valueAccessor, allBindings) {
  var va = valueAccessor();
  var value = va.color;

  // In order to have a correct dependency tracking in "ifSubs" we have to ensure we use a single computer for each editable
  // property. Given this binding needs 2 of them, we create a computed so to "proxy" the dependencies.
  var newDO = ko.computed({
    read: value,
    write: value,
    disposeWhenNodeIsRemoved: element
  });
  var newVA = function() {
    return newDO;
  };

  ko.bindingHandlers.value.init(element, newVA, allBindings);

  var changePropagator = function(event, color) {
    if (typeof color !== 'undefined') newDO(color);
  };
  $(element).on('change.color', changePropagator);

  ko.computed({
    read: function() {
      var opt = {
        color: ko.utils.unwrapObservable(newDO),
        showOn: 'button'
      };
      for (var prop in va)
        if (prop !== 'color' && va.hasOwnProperty(prop)) opt[prop] = ko.utils.unwrapObservable(va[prop]);
      $(element).colorpicker(opt);
    },
    disposeWhenNodeIsRemoved: element
  });

  ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
    $(element).off('change.color', changePropagator);
    $(element).colorpicker('destroy');
  });

};
kojqui.utils.register(ColorPicker);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/evol-colorpicker/js/evol.colorpicker.min.js":2}],24:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

/* https://github.com/knockout/knockout/issues/1171 */
ko.bindingHandlers.cssText = {
  'update': function(node, valueAccessor, allBindings) {
    var text = ko.utils.unwrapObservable(valueAccessor());
    try {
      node.innerText = text;
    } catch (e) {
      if (!node.styleSheet) node.innerHTML = "a{}";
      node.styleSheet.cssText = text;
    }
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],25:[function(require,module,exports){
(function (global){
"use strict";

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

/* knockout droppable, with simplified UMD */
;(function(factory) {
  factory(ko, $);
})(function(ko, $) {
  var ITEMKEY = "ko_sortItem",
    INDEXKEY = "ko_sourceIndex",
    LISTKEY = "ko_sortList",
    PARENTKEY = "ko_parentList",
    DRAGKEY = "ko_dragItem",
    unwrap = ko.utils.unwrapObservable,
    dataGet = ko.utils.domData.get,
    dataSet = ko.utils.domData.set;

  ko.bindingHandlers.droppable = {
    init: function(element, valueAccessor, allBindingsAccessor, data, context) {
      var $element = $(element),
        value = ko.utils.unwrapObservable(valueAccessor()) || {},
        droppable = {},
        dropActual;

      $.extend(true, droppable, ko.bindingHandlers.droppable);
      if (value.data) {
        if (value.options && droppable.options) {
          ko.utils.extend(droppable.options, value.options);
          delete value.options;
        }
        ko.utils.extend(droppable, value);
      } else {
        droppable.data = value;
      }

      dropActual = droppable.options.drop;

      $element.droppable(ko.utils.extend(droppable.options, {
        drop: function(event, ui) {

          var el = ui.draggable[0],
            item = dataGet(el, ITEMKEY) || dataGet(el, DRAGKEY);

          if (item) {

            if (item.clone) {
              item = item.clone();
            }

            if (droppable.dragged) {
              item = droppable.dragged.call(this, item, event, ui) || item;
            }

            if (droppable.data) {
              droppable.data(item);
            }

          }

          if (dropActual) {
            dropActual.apply(this, arguments);
          }

        }
      }));

      //handle enabling/disabling
      if (droppable.isEnabled !== undefined) {
        ko.computed({
          read: function() {
            $element.droppable(ko.utils.unwrapObservable(droppable.isEnabled) ? "enable" : "disable");
          },
          disposeWhenNodeIsRemoved: element
        });
      }

    },
    update: function(element, valueAccessor, allBindingsAccessor, data, context) {

    },
    targetIndex: null,
    afterMove: null,
    beforeMove: null,
    options: {}
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],26:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

/* utility for togetherjs */
ko.bindingHandlers.focusable = {
  'focus': function() {},
  'blur': function() {},
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("focusin", ko.bindingHandlers.focusable.focus);
      $(element).off("focusout", ko.bindingHandlers.focusable.blur);
    });

    $(element).on("focusin", ko.bindingHandlers.focusable.focus);
    $(element).on("focusout", ko.bindingHandlers.focusable.blur);

  }
};

ko.bindingHandlers.scrollable = {
  'scroll': function() {},
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("scroll", ko.bindingHandlers.scrollable.scroll);
    });

    $(element).on("scroll", ko.bindingHandlers.scrollable.scroll);

  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],27:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);

ko.extenders.paging = function(target, pageSize) {
  var _pageSize = ko.observable(pageSize || 10),
    // default pageSize to 10
    _currentPage = ko.observable(1); // default current page to 1
  target.pageSize = ko.computed({
    read: _pageSize,
    write: function(newValue) {
      if (newValue > 0) {
        _pageSize(newValue);
      } else {
        _pageSize(10);
      }
    }
  });

  target.currentPage = ko.computed({
    read: _currentPage,
    write: function(newValue) {
      if (newValue > target.pageCount()) {
        _currentPage(target.pageCount());
      } else if (newValue <= 0) {
        _currentPage(1);
      } else {
        _currentPage(newValue);
      }
    }
  });

  target.pageCount = ko.computed(function() {
    return Math.ceil(target().length / target.pageSize()) || 1;
  });

  target.currentPageData = ko.computed(function() {
    var pageSize = _pageSize(),
      pageIndex = _currentPage(),
      startIndex = pageSize * (pageIndex - 1),
      endIndex = pageSize * pageIndex;

    return target().slice(startIndex, endIndex);
  });

  target.moveFirst = function() {
    target.currentPage(1);
  };
  target.movePrevious = function() {
    target.currentPage(target.currentPage() - 1);
  };
  target.moveNext = function() {
    target.currentPage(target.currentPage() + 1);
  };
  target.moveLast = function() {
    target.currentPage(target.pageCount());
  };

  return target;
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],28:[function(require,module,exports){
(function (global){
"use strict";
/* globals global: true */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
require("./../../../bower_components/knockout-sortable/build/knockout-sortable.min.js");

var isDraggingHelper = function(writable, e) {
  if (writable()) {
    if (e.type == writable() + 'stop') writable(false);
  } else {
    if (e.type == 'dragstart' || e.type == 'sortstart') writable(e.type.substring(0, 4));
  }
};

var makeExtendedValueAccessor = function(valueAccessor) {
  return function() {
    var modelValue = valueAccessor(),
      unwrappedValue = ko.utils.peekObservable(modelValue); // Unwrap without setting a dependency here

    ko.utils.unwrapObservable(modelValue);

    if (modelValue.options == 'undefined') {
      modelValue.options = {};
    }



    var origStart = modelValue.options.start;
    modelValue.options.start = function(e, ui) {
      if (typeof modelValue.dragging != 'undefined' && ko.isWritableObservable(modelValue.dragging)) isDraggingHelper(modelValue.dragging, e);
      if (typeof modelValue.dropContainer != 'undefined') {
        modelValue.scrollInterval = global.setInterval(function() {
          var foo = $(modelValue.dropContainer).scrollTop();
          $(modelValue.dropContainer).scrollTop(foo + modelValue.adding);
        }, 20);
      }
      if (typeof origStart != 'undefined') return origStart(e, ui);
    };
    var origStop = modelValue.options.stop;
    modelValue.options.stop = function(e, ui) {
      if (typeof modelValue.dragging != 'undefined' && ko.isWritableObservable(modelValue.dragging)) isDraggingHelper(modelValue.dragging, e);
      if (typeof modelValue.dropContainer != 'undefined') {
        global.clearInterval(modelValue.scrollInterval);
      }
      if (typeof origStop != 'undefined') return origStop(e, ui);
    };
    var origDrag = modelValue.options.drag;
    modelValue.options.drag = function(e, ui) {
      if (typeof modelValue.dropContainer != 'undefined') {
        var top = e.pageY - $(modelValue.dropContainer).offset().top;
        var bottom = top - $(modelValue.dropContainer).height();
        // Handle scrolling speed depending on distance from border.
        if (top < -20) {
          modelValue.adding = -20;
          // console.log("<<<");
        } else if (top < 0) {
          modelValue.adding = -10;
          // console.log("<<");
        } else if (top < 10) {
          modelValue.adding = -5;
          // console.log("<");
        } else if (bottom > 20) {
          modelValue.adding = 20;
          // console.log(">>>");
        } else if (bottom > 0) {
          modelValue.adding = 10;
          // console.log(">>");
        } else if (bottom > -10) {
          modelValue.adding = 5;
          // console.log(">");
        } else {
          modelValue.adding = 0;
        }
      }
      if (typeof origDrag != 'undefined') return origDrag(e, ui);
    };

    return modelValue;
  };
};

ko.bindingHandlers.extsortable = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.sortable.init(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.sortable.update(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  }
};

ko.bindingHandlers.extdraggable = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.draggable.init(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    return ko.bindingHandlers.draggable.update(element, makeExtendedValueAccessor(valueAccessor), allBindingsAccessor, data, context);
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/knockout-sortable/build/knockout-sortable.min.js":4}],29:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false, Image: false */

// This module depends on those files, but it doesn't have a direct dependency, so we don't require them here.

//require("blueimp-canvas-to-blob");
//require("jquery-file-upload/js/jquery.iframe-transport.js");
//require("jquery-file-upload/js/jquery.fileupload.js");
//require("jquery-file-upload/js/jquery.fileupload-process.js");
//require("jquery-file-upload/js/jquery.fileupload-image.js");
//require("jquery-file-upload/js/jquery.fileupload-validate.js");

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// experimental image preloading.
ko.bindingHandlers['preloader'] = {
  init: function(element, valueAccessor) {
    var value = valueAccessor();
    if (typeof value.preloaded == 'undefined') {
      value.preloaded = ko.observable("");

      var preloader = function(newValue) {
        if (newValue != value.preloaded()) {
          if (newValue !== '') {
            var img = new Image();
            img.onload = function() {
              value.preloaded(newValue);
            };
            img.onerror = function() {
              value.preloaded(newValue);
            };
            img.src = newValue;
          } else {
            value.preloaded(newValue);
          }
        }
      };

      value.subscribe(preloader);
      preloader(value());
    }
  }
};

// TODO we don't use advattr and advstyle, maybe we should simply remove this code.
ko.bindingHandlers['advattr'] = {
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(attrName, attrValueAccessor) {
      var attrValue = element.getAttribute(attrName);

      if (ko.isWriteableObservable(attrValueAccessor)) {
        var oldValue = attrValueAccessor();
        if (oldValue != attrValue) {
          attrValueAccessor(attrValue);
          if (oldValue !== null) {
            console.log("AdvAttr found a value different from the default", attrName, oldValue, attrValue);
          }
        }
      }
    });
  },
  'update': function(element, valueAccessor, allBindings) {
    var value = ko.utils.unwrapObservable(valueAccessor()) || {};
    ko.utils.objectForEach(value, function(attrName, attrValue) {
      attrValue = ko.utils.unwrapObservable(attrValue);
      // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
      // when someProp is a "no value"-like value (strictly null, false, or undefined)
      // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
      var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
      if (toRemove) element.removeAttribute(attrName);
      else element.setAttribute(attrName, attrValue.toString());
    });
  }
};
ko.bindingHandlers['advstyle'] = {
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(styleName, styleValueAccessor) {
      var styleValue;
      if (styleName.match(/Px$/)) {
        styleName = styleName.substr(0, styleName.length - 2);
        styleValue = element.style[styleName];
        if (styleValue.match(/px$/)) {
          styleValue = styleValue.replace(/px$/, '');
        } else {
          console.log("AdvStyle binding found an unexpected default value", styleName, styleValue, element);
        }
      } else {
        styleValue = element.style[styleName];
      }

      if (ko.isWriteableObservable(styleValueAccessor)) {
        var oldValue = styleValueAccessor();
        if (oldValue != styleValue) {
          styleValueAccessor(styleValue);
          if (oldValue !== null) {
            console.log("AdvStyle found a value different from the default", styleName, oldValue, styleValue);
          }
        }
      }
    });
  },
  'update': function(element, valueAccessor) {
    var value = ko.utils.unwrapObservable(valueAccessor() || {});
    ko.utils.objectForEach(value, function(styleName, styleValue) {
      styleValue = ko.utils.unwrapObservable(styleValue);

      if (styleValue === null || typeof styleValue === 'undefined' || styleValue === false) {
        styleValue = "";
      }

      if (styleName.match(/Px$/)) {
        styleName = styleName.substr(0, styleName.length - 2);
        styleValue = styleValue + "px";
      }

      element.style[styleName] = styleValue;
    });
  }
};

// Utility to log inizialization and disposal of DOM elements.
ko.bindingHandlers['domlog'] = {
  init: function(element, valueAccessor) {
    console.log("initialized", element);
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      console.log("disposed", element);
    });
  }
};

ko.bindingHandlers['fudroppable'] = {
  init: function(element, valueAccessor) {
    var opt = valueAccessor() || {};
    var timeoutsObj = {};

    var over = function(timeouts, dropZoneTimeout, element, className, observable, event) {

      if (!timeouts[dropZoneTimeout]) {
        if (typeof className !== 'undefined') {
          element.classList.add(className);
        }
        if (ko.isWriteableObservable(observable) && !observable()) {
          observable(true);
        }
      } else {
        global.clearTimeout(timeouts[dropZoneTimeout]);
      }

      var stop = function() {
        timeouts[dropZoneTimeout] = null;
        if (typeof className !== 'undefined') {
          element.classList.remove(className);
        }
        if (ko.isWriteableObservable(observable) && observable()) {
          observable(false);
        }
      };

      if (event.type == 'dragleave') stop();
      else {
        // Using 100 it doens't work fine on Linux (chome/firefox), using 200 still shows issues on slow Linux boxes
        timeouts[dropZoneTimeout] = global.setTimeout(stop, 500);
      }

    };

    if (opt.active || opt.activeClass) {
      ko.utils.registerEventHandler(global, 'dragover', over.bind(undefined, timeoutsObj, 'activeTimeout', element, opt.activeClass, opt.active));
    }
    if (opt.hoverClass) {
      // dragenter and dragleave are not required but they speedup feedback when used.
      ko.utils.registerEventHandler(element, 'dragover dragenter dragleave', over.bind(undefined, timeoutsObj, 'hoverTimeout', element, opt.hoverClass, undefined));
    }
  }
};

ko.bindingHandlers['fileupload'] = {
  extendOptions: {},
  remoteFilePreprocessor: function(url) { return url; },
  init: function(element, valueAccessor) {
    // TODO domnodedisposal doesn't work when the upload is done by "clicking"
    // Probably jquery-fileupload moves the DOM somewhere else so that KO doesn't 
    // detect the removal anymore.
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).fileupload('destroy');
    });

    // if we leave the title the native control will show us a tooltip we don't want.
    // In WebKit the right way to remove it is leaving a "whitespace".
    // In Gecko we have to set it empty.
    if (global.webkitURL)
      $(element).attr('title', ' ');
    else
      $(element).attr('title', '');
  },

  update: function(element, valueAccessor) {
    var options = valueAccessor() || {};

    var $fu = $(element);
    var $parent = $fu.parents('.uploadzone');

    var dataValue = options.data;
    options.data = undefined;

    var canvasPreview = options.canvasPreview;

    // TODO remove hardcoded url
    ko.utils.extend(options, {
      url: '/upload/',
      dataType: 'json',
      dropZone: $parent.find('.mo-uploadzone')[0],
      autoUpload: true,
      acceptFileTypes: /(\.|\/)(gif|jpe?g|png)$/i,
      maxFileSize: 1024 * 1024,
      // Enable image resizing, except for Android and Opera,
      // which actually support image resizing, but fail to
      // send Blob objects via XHR requests:
      disableImageResize: /Android(?!.*Chrome)|Opera/.test(global.navigator.userAgent),
      previewMaxWidth: 200,
      previewMaxHeight: 200,
      previewCrop: false,
      replaceFileInput: false, // replaceFileInput true breaks after uploading using "input" (using mouse clic instead of dropping)

      messages: {
        // client side
        unknownError: 'Unknown error',
        uploadedBytes: 'Uploaded bytes exceed file size',
        maxNumberOfFiles: 'Maximum number of files exceeded',
        acceptFileTypes: 'File type not allowed',
        maxFileSize: 'File is too large',
        minFileSize: 'File is too small',
        // server side
        post_max_size: 'The uploaded file exceeds the post_max_size directive in php.ini',
        max_file_size: 'File is too big',
        min_file_size: 'File is too small',
        accept_file_types: 'Filetype not allowed',
        max_number_of_files: 'Maximum number of files exceeded',
        max_width: 'Image exceeds maximum width',
        min_width: 'Image requires a minimum width',
        max_height: 'Image exceeds maximum height',
        min_height: 'Image requires a minimum height',
        abort: 'File upload aborted',
        image_resize: 'Failed to resize image',
        generic: 'Unexpected upload error'
      }
    });

    ko.utils.extend(options, ko.bindingHandlers['fileupload'].extendOptions);

    var working = 0;
    var firstWorked = '';

    var cleanup = function() {
      if (--working === 0) {
        if (dataValue) {
          dataValue(firstWorked);
        }
        firstWorked = '';
        if (canvasPreview) {
          $parent.find('img').show();
          $parent.find('canvas').remove();
        }
        $parent.removeClass("uploading");
        $parent.find('.progress-bar').css('width', 0);
      }
    };

    var translatedMessage = function(text) {
      if (typeof options.messages == 'object' && options.messages !== null) {
        var match = text.match(/^([^ ]+)(.*)$/);
        if (match) {
          if (typeof options.messages[match[1]] !== 'undefined') {
            return options.messages[match[1]] + match[2];
          }
        }
      }
      return text;
    };

    $fu.fileupload(options);

    var events = ['fileuploadadd', 'fileuploadprocessalways', 'fileuploadprogressall', 'fileuploaddone', 'fileuploadfail'];
    var eventHandler = function(e, data) {
      if (e.type == 'fileuploadadd') {
        working++;
      }
      if (e.type == 'fileuploadfail') {
        console.log("fileuploadfail", e, data);
        if (options.onerror) {
          if (data.errorThrown === '' && data.textStatus == 'error') {
            options.onerror(translatedMessage('generic'));
          } else {
            options.onerror(translatedMessage('generic (' + data.errorThrown + ')'));
          }
        }
        cleanup();
      }
      if (e.type == 'fileuploaddone') {
        if (typeof data.result.files[0].url !== 'undefined') {
          if (options.onfile) {
            for (var i = 0; i < data.result.files.length; i++) {
              data.result.files[i] = ko.bindingHandlers['fileupload'].remoteFilePreprocessor(data.result.files[i]);
              options.onfile(data.result.files[i]);
            }
          }

          if (firstWorked === '') firstWorked = data.result.files[0].url;

          if (canvasPreview) {
            var img = new Image();
            img.onload = cleanup;
            img.onerror = cleanup;
            img.src = data.result.files[0].url;
          } else {
            cleanup();
          }
        } else if (typeof data.result.files[0].error !== 'undefined') {
          console.log("remote error", e, data);
          if (options.onerror) {
            options.onerror(translatedMessage(data.result.files[0].error));
          }
          cleanup();
        } else {
          console.log("unexpected error", e, data);
          if (options.onerror) {
            options.onerror(translatedMessage('generic (Unexpected Error retrieving uploaded file)'));
          }
          cleanup();
        }
      }
      if (e.type == 'fileuploadprocessalways') {
        var index = data.index,
          file = data.files[index];
        if (file.preview && index === 0) {
          // if we have a canvas we had multiple uploaded files
          if ($parent.find('canvas').length === 0) {
            if (canvasPreview) {
              var el = $(file.preview).css('width', '100%'); // .css('position', 'absolute').css('left', '0');
              $parent.find('img').hide();
              $parent.prepend(el);
            }
            $parent.addClass("uploading");
            $parent.find('.progress-bar').css('width', 0);
          }
        }
        if (file.error) {
          // File type not allowed
          // File is too large
          if (options.onerror) {
            options.onerror(translatedMessage(file.error));
          }
          cleanup();
        }
      }
      if (e.type == 'fileuploadprogressall') {
        var progress = parseInt(data.loaded / data.total * 100, 10);
        $parent.find('.progress-bar').css('width', progress + '%');
      }
    };
    for (var i = events.length - 1; i >= 0; i--) {
      var eventName = events[i];
      $fu.on(eventName, eventHandler);
    }
    if (!$.support.fileInput) {
      $fu.prop('disabled', true).parent().addClass('disabled');
    }
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],30:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

ko.bindingHandlers['ifSubs'] = {
  // cloneNodes from ko.utils.cloneNodes (missing in minimized KO)
  cloneNodes: function(nodesArray, shouldCleanNodes) {
    for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
      var clonedNode = nodesArray[i].cloneNode(true);
      newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
    }
    return newNodesArray;
  },
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    var didDisplayOnLastUpdate,
      savedNodes,
      valueAcc = valueAccessor();
    if (typeof valueAcc.data.subsCount === 'undefined') {
      ko.extenders['subscriptionsCount'](valueAcc.data);
      // NOTE I can't simply listen on "thresholds" because multiple bindings to the same observable could use different thresholds.
    }
    ko.computed(function() {
      var dataValue = ko.utils.unwrapObservable(valueAccessor().data.subsCount),
        isFirstRender = !savedNodes,
        shouldDisplay, needsRefresh, gutter;

      gutter = -(typeof valueAccessor().gutter !== 'undefined' ? valueAccessor().gutter : 1);
      shouldDisplay = dataValue + (didDisplayOnLastUpdate ? gutter : 0) >= ko.utils.unwrapObservable(valueAcc.threshold);
      if (typeof valueAccessor().not !== 'undefined' && valueAccessor().not) {
        shouldDisplay = !shouldDisplay;
      }
      needsRefresh = isFirstRender || (shouldDisplay !== didDisplayOnLastUpdate);

      if (needsRefresh) {
        // Save a copy of the inner nodes on the initial update, but only if we have dependencies.
        if (isFirstRender && ko.computedContext.getDependenciesCount()) {
          savedNodes = ko.bindingHandlers['ifSubs'].cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */ );
        }

        if (shouldDisplay) {
          if (!isFirstRender) {
            ko.virtualElements.setDomNodeChildren(element, ko.bindingHandlers['ifSubs'].cloneNodes(savedNodes));
          }
          ko.applyBindingsToDescendants(bindingContext, element);
        } else {
          ko.virtualElements.emptyNode(element);
        }

        didDisplayOnLastUpdate = shouldDisplay;
      }
    }, null, {
      disposeWhenNodeIsRemoved: element
    });
    return {
      'controlsDescendantBindings': true
    };
  }
};
ko.virtualElements.allowedBindings['ifSubs'] = true;

// ko.isWritableObservable (without "e") has been introduced in 3.2.0, that is also our min requirement.
// minimized knockout "obfuscate" the beforeSubscriptionAdd and afterSubscriptionRemove methods that we hack here.
// so we have to explicitly know that.
var beforeSubscriptionProp;
var afterSubscriptionProp;
if (typeof ko.DEBUG !== 'undefined' && typeof ko.isWritableObservable !== 'undefined') {
  beforeSubscriptionProp = 'beforeSubscriptionAdd';
  afterSubscriptionProp = 'afterSubscriptionRemove';
} else if (ko.version == "3.2.0") {
  beforeSubscriptionProp = 'va';
  afterSubscriptionProp = 'nb';
} else if (ko.version == "3.3.0") {
  beforeSubscriptionProp = 'ja';
  afterSubscriptionProp = 'ua';
} else if (ko.version == "3.4.0") {
  beforeSubscriptionProp = 'sa';
  afterSubscriptionProp = 'Ia';
}
else throw "Unsupported minimized Knockout version " + ko.version + " (supported DEBUG or minimized 3.2.0 ... 3.4.0)";

// internally used by ifsubs binding.
// WARNING this break when used with pureComputed or deferredEvaluated
ko.extenders['subscriptionsCount'] = function(target, l1, l2) {
  if (typeof target.subsCount === 'undefined') {
    target.subsCount = ko.observable(target.getSubscriptionsCount()).extend({
      notify: 'always'
    });
    var underlyingBeforeSubscriptionAddFunction = target[beforeSubscriptionProp];
    var underlyingAfterSubscriptionRemoveFunction = target[afterSubscriptionProp];
    target[beforeSubscriptionProp] = function(event) {
      if (underlyingBeforeSubscriptionAddFunction) underlyingBeforeSubscriptionAddFunction.call(target, event);
      var c = target.getSubscriptionsCount() + 1;
      if (typeof l1 === 'undefined' || c == l1 || typeof l2 === 'undefined' || c == l2) target.subsCount(c);
    };
    target[afterSubscriptionProp] = function(event) {
      if (underlyingAfterSubscriptionRemoveFunction) underlyingAfterSubscriptionRemoveFunction.call(target, event);
      var c = target.getSubscriptionsCount();
      if (typeof l1 === 'undefined' || c == l1 || typeof l2 === 'undefined' || c == l2) target.subsCount(c);
    };
  } else {
    console.log("already applied subscriptionCount to observable");
  }
  return null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],31:[function(require,module,exports){
(function (global){
"use strict";

// Overrides native jQuery spinner to avoid validation of the "step".
// We wants to use the step but also wants to leave the user the ability to select specific values.

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
$.widget("ui.spinner", $.ui.spinner, {
  _adjustValue: function(value) {
    var adj = this._super(value);

    var options = this.options;

    // fix precision from bad JS floating point math
    value = parseFloat(value.toFixed(this._precision()));

    // clamp the value
    if (options.max !== null && value > options.max) {
      return options.max;
    }
    if (options.min !== null && value < options.min) {
      return options.min;
    }

    return value;
  }
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],32:[function(require,module,exports){
(function (global){
"use strict";

// Overrides native jQuery tabs to make tabs working also when using a base tag
// in order to avoid conflicts you have to add a data-local="true" attribute to your tab links.

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
$.widget("ui.tabs", $.ui.tabs, {
  _isLocal: function( anchor ) {
    if (anchor.getAttribute('data-local') == "true") return true;
    else return this._superApply( arguments );
  }
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],33:[function(require,module,exports){
(function (global){
"use strict";
/* globals global: false */

function pushTemplate(templateName, templateText) {
  var scriptTag = global.document.createElement('script');
  scriptTag.setAttribute('type', 'text/html');
  scriptTag.setAttribute('id', templateName);
  scriptTag.text = templateText;
  global.document.body.appendChild(scriptTag);
}

function removeTemplate(templateName) {
  var el = global.document.getElementById(templateName);
  if (el) el.parentNode.removeChild(el);
}

function init() {}

function getTemplateContent(id) {
  var el = global.document.getElementById(id);
  if (el) return el.innerHTML;
  else return undefined;
}

module.exports = {
  init: init,
  addTemplate: pushTemplate,
  removeTemplate: removeTemplate,
  getTemplateContent: getTemplateContent
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],34:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
var tinymce = (typeof window !== "undefined" ? window['tinymce'] : typeof global !== "undefined" ? global['tinymce'] : null);

var timeout;

var render = function() {

  timeout = undefined;

  if (typeof tinymce.activeEditor !== 'undefined' && typeof tinymce.activeEditor.theme !== 'undefined' && typeof tinymce.activeEditor.theme.panel !== 'undefined' && typeof tinymce.activeEditor.theme.panel.visible !== 'undefined') {
    // @see FloatPanel.js function repositionPanel(panel)
    // First condition group is for Tinymce 4.0/4.1
    // Second condition group is for Tinymce 4.2/4.3 where "._property" are now available as ".state.get('property')".
    if ((typeof tinymce.activeEditor.theme.panel._visible !== 'undefined' && tinymce.activeEditor.theme.panel._visible && tinymce.activeEditor.theme.panel._fixed) || 
        (typeof tinymce.activeEditor.theme.panel.state !== 'undefined' && tinymce.activeEditor.theme.panel.state.get('visible') && tinymce.activeEditor.theme.panel.state.get('fixed'))) {
      tinymce.activeEditor.theme.panel.fixed(false);
    }

    tinymce.activeEditor.nodeChanged();
    tinymce.activeEditor.theme.panel.visible(true);
    if (tinymce.activeEditor.theme.panel.layoutRect().y <= 40)
      tinymce.activeEditor.theme.panel.moveBy(0, 40 - tinymce.activeEditor.theme.panel.layoutRect().y);

  }
};

ko.bindingHandlers.wysiwygScrollfix = {
  'scroll': function(event) {
    if (timeout) global.clearTimeout(timeout);
    timeout = global.setTimeout(render, 50);
  },
  'init': function(element) {
    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      $(element).off("scroll", ko.bindingHandlers.wysiwygScrollfix.scroll);
    });

    $(element).on("scroll", ko.bindingHandlers.wysiwygScrollfix.scroll);

  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],35:[function(require,module,exports){
(function (global){
"use strict";

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

var _scrollIntoView = function($element, alignTop, scrollParent, moveBy) {
  var currentScrollTop = scrollParent.scrollTop();
  var newScrollTop = currentScrollTop - moveBy - (alignTop ? 20 : -20);
  // iframe scrolls the window and animation is not supported
  var animate = typeof scrollParent[0].nodeType !== 'undefined';
  if (animate) {
    var action = {
      'scrollTop': "" + Math.round(newScrollTop) + "px"
    };
    var time = Math.round(Math.abs(newScrollTop - currentScrollTop));
    scrollParent.stop().animate(action, time);
  } else {
    scrollParent.scrollTop(newScrollTop);
  }
  // native scrollIntoView is not well supported and doesn't work fine.
  // element.scrollIntoView(alignTop);
};

ko.bindingHandlers.scrollIntoView = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var selected = ko.utils.unwrapObservable(valueAccessor());
    if (!selected) return;
    try {

      while (element.nodeType === 8) {
        // element is a comment, move to the next sibling...
        element = element.nextSibling;
      }
      if (element.nodeType !== 8) {
        var scrollParent = $(element).scrollParent();

        var parentTop;
        var relativeOffset = false;
        if (scrollParent[0].nodeType == 9) {
          // scrollparent is document, replacing with body...
          scrollParent = $(scrollParent[0].defaultView);
          parentTop = 0;
          relativeOffset = true;
        } else {
          parentTop = scrollParent.offset().top;
        }

        var parentHeight = scrollParent.height();
        var parentScroll = scrollParent.scrollTop();
        var parentBottom = parentTop + parentHeight;

        // scrollParent is the document.
        var $element = $(element);
        var elTop = $element.offset().top;
        // when we are in "iframe" with scrollbar everythijng changes.
        if (relativeOffset) elTop = elTop - parentScroll;
        var elHeight = $element.height();
        var elBottom = elTop + elHeight;
        if (elTop > parentTop && elTop + elHeight < parentBottom) {
          // both borders are visible => don't do anything.
        } else if (elHeight < parentHeight) {
          // if the block is smaller than the viewPort
          if (elTop < parentTop) _scrollIntoView(element, true, scrollParent, parentTop - elTop);
          // -> if the upper border is higher than the top, then I move it to the top.
          if (elBottom > parentBottom) _scrollIntoView(element, false, scrollParent, parentBottom - elBottom);
          // -> if the bottom border is lower than the bottom then I move it to the bottom.
        } else {
          // if the block is larger than the viewPort we do the opposite!
          // -> if the upper border is higher than the top and the lower is higher than the bottom I move the lower it to the bottom.
          if (elTop < parentTop && elBottom < parentBottom) _scrollIntoView(element, false, scrollParent, parentBottom - elBottom);
          // -> if the bottom border il lower than bottom and the upper is lower than the top I move the upper border to the viewport top
          if (elTop > parentTop && elBottom > parentBottom) _scrollIntoView(element, true, scrollParent, parentTop - elTop);
        }

        // element.scrollIntoView(true);
      }
    } catch (e) {
      console.log("TODO exception scrolling into view", e);
    }
  }
};
ko.virtualElements.allowedBindings['scrollIntoView'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],36:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var origTemplateSystem = require("./script-template.js");

var templates = {};

//define a template source that simply treats the template name as its content
ko.templateSources.stringTemplate = function(templateName, template) {
  this.templateName = templateName;
  this.template = template;
  this._data = {};
};

ko.utils.extend(ko.templateSources.stringTemplate.prototype, {
  data: function(key, value) {
    // console.log("data", key, value, this.templateName);
    if (arguments.length === 1) {
      return this._data[key];
    }

    this._data[key] = value;
  },
  text: function(value) {
    // console.log("text", value, this.templateName)
    if (arguments.length === 0) {
      return this.template;
    }
    this.template = value;
  }
});


//modify an existing templateEngine to work with string templates
function createStringTemplateEngine(templateEngine) {
  var orig = templateEngine.makeTemplateSource;
  templateEngine.makeTemplateSource = function(templateName) {
    if (typeof templates[templateName] !== 'undefined') {
      return new ko.templateSources.stringTemplate(templateName, templates[templateName]);
    } else {
      return orig(templateName);
    }
  };
  return templateEngine;
}

function pushTemplate(templateName, templateText) {
  templates[templateName] = templateText;
}

function removeTemplate(templateName) {
  if (typeof templates[templateName] !== 'undefined') {
    templates[templateName] = undefined;
  } else {
    origTemplateSystem.removeTemplate(templateName);
  }
}

function init() {
  ko.setTemplateEngine(createStringTemplateEngine(new ko.nativeTemplateEngine()));
}

function getTemplateContent(id) {
  if (typeof templates[id] !== 'undefined') {
    return templates[id];
  } else {
    return origTemplateSystem.getTemplateContent(id);
  }
}

module.exports = {
  init: init,
  addTemplate: pushTemplate,
  removeTemplate: removeTemplate,
  getTemplateContent: getTemplateContent
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./script-template.js":33}],37:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

var extendValueAccessor = function(valueAccessor, obj) {
  return function() {
    ko.utils.extend(obj, valueAccessor());
    return obj;
  };
};

var options = {
  show: {
    delay: 500
  },
  track: true,
  items: '[title][title!=""][title!=" "]'
};

ko.bindingHandlers.tooltips = {
  init: function(element, valueAccessor, allBindingsAccessor, data, context) {
    if (typeof $.fn.tooltip !== 'undefined' && typeof ko.bindingHandlers.tooltip !== 'undefined') {
      // position: { my: "left+15 top+15", at: "center+30 center+30" }
      // NOTE title with "" and " " is needed to avoid default tooltips in native file upload controls
      return ko.bindingHandlers.tooltip.init(element, extendValueAccessor(valueAccessor, options), allBindingsAccessor, data, context);
    }
  },
  update: function(element, valueAccessor, allBindingsAccessor, data, context) {
    if (typeof $.fn.tooltip !== 'undefined' && typeof ko.bindingHandlers.tooltip !== 'undefined') {
      return ko.bindingHandlers.tooltip.update(element, extendValueAccessor(valueAccessor, options), allBindingsAccessor, data, context);
    }
  },
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],38:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

// equals to "value" binding but apply "invalid" class if "pattern" attribute is defined and value matches the rule
ko.bindingHandlers['validatedValue'] = {
	init: function(element, valueAccessor, allBindings) {
		var newValueAccessor = valueAccessor;
		if (typeof element.pattern !== 'undefined') {
			var re = new RegExp('^(?:' + element.pattern + ')$');
			var computed = ko.computed({
				read: function() {
					var res = ko.utils.unwrapObservable(valueAccessor());
					// TODO support for element.required ?
					var valid = res === null || res === '' || re.test(res);
					// IE11 doesn't support classList.toggle('invalid', state)
					if (valid) {
						element.classList.remove('invalid');
					} else {
						element.classList.add('invalid');
					}
					return res;
				},
				write: ko.isWriteableObservable(valueAccessor()) && function(value) {
					valueAccessor()(value);
				},
				disposeWhenNodeIsRemoved: element
			});
			newValueAccessor = function() {
				return computed;
			};
		}
		ko.bindingHandlers['value'].init(element, newValueAccessor, allBindings);
	}
};
ko.expressionRewriting._twoWayBindings['validatedValue'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],39:[function(require,module,exports){
(function (global){
"use strict";
/* globals global:false */

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");

ko.bindingHandlers['uniqueId'] = {
  currentIndex: 0,
  'init': function(element, valueAccessor) {
    var data = ko.utils.unwrapObservable(valueAccessor()) || {};
    if (data.id() === '') {
      var id, el, prefix;
      // TODO we need a better prefix
      prefix = 'ko_' + (typeof data.type !== 'undefined' ? ko.utils.unwrapObservable(data.type) : 'block');
      // when loading an exising model, IDs could be already assigned.
      do {
        id = prefix + '_' + (++ko.bindingHandlers['uniqueId'].currentIndex);
        el = global.document.getElementById(id);
        if (el) {
          // when loading an existing model my "currentIndex" is empty.
          // but we have existing blocks, so I must be sure I don't reuse their IDs.
          // We use different prefixes (per block type) so that a hidden block 
          // (for which we have no id in the page, e.g: preheader in versafix-1)
          // will break everthing once we reuse its name.
        }
      } while (el);
      data.id(id);
    }
  }
};
ko.virtualElements.allowedBindings['uniqueId'] = true;

ko.bindingHandlers['virtualAttr'] = {
  update: function(element, valueAccessor) {
    if (element.nodeType !== 8) {
      ko.bindingHandlers['attr'].update(element, valueAccessor);
    }
  }
};
ko.virtualElements.allowedBindings['virtualAttr'] = true;

ko.bindingHandlers['virtualAttrStyle'] = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      // In "preview" we also set "replacedstyle" so to have an attribute to be used by IE (IE breaks the STYLE) to do the export.
      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      var attrs = ["style"];
      if (isNotWysiwygMode) attrs.push("replacedstyle");
      var attrValue = ko.utils.unwrapObservable(valueAccessor());
      for (var i = 0; i < attrs.length; i++) {
        var attrName = attrs[i];
        var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
        if (toRemove)
          element.removeAttribute(attrName);
        else
          element.setAttribute(attrName, attrValue.toString());
      }
    }
  }
};
ko.virtualElements.allowedBindings['virtualAttrStyle'] = true;

ko.bindingHandlers['virtualStyle'] = {
  update: function(element, valueAccessor) {
    if (element.nodeType !== 8) {
      ko.bindingHandlers['style'].update(element, valueAccessor);
    }
  }
};
ko.virtualElements.allowedBindings['virtualStyle'] = true;


ko.bindingHandlers['virtualHtml'] = {
  init: ko.bindingHandlers['html'].init,
  update: function(element, valueAccessor) {
    if (element.nodeType === 8) {
      var html = ko.utils.unwrapObservable(valueAccessor());

      ko.virtualElements.emptyNode(element);
      if ((html !== null) && (html !== undefined)) {
        if (typeof html !== 'string') {
          html = html.toString();
        }

        var parsedNodes = ko.utils.parseHtmlFragment(html);
        if (parsedNodes) {
          var endCommentNode = element.nextSibling;
          for (var i = 0, j = parsedNodes.length; i < j; i++)
            endCommentNode.parentNode.insertBefore(parsedNodes[i], endCommentNode);
        }
      }
    } else { // plain node
      ko.bindingHandlers['html'].update(element, valueAccessor);
    }

    // Content for virtualHTML must not be parsed by KO, it is simple content.
    return {
      controlsDescendantBindings: true
    };
  }
};
ko.virtualElements.allowedBindings['virtualHtml'] = true;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],40:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var tinymce = (typeof window !== "undefined" ? window['tinymce'] : typeof global !== "undefined" ? global['tinymce'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
require("./eventable.js");

ko.bindingHandlers.wysiwygOrHtml = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');

    if (isNotWysiwygMode)
      return ko.bindingHandlers['virtualHtml'].init();
    else
      return ko.bindingHandlers.wysiwyg.init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (isNotWysiwygMode)
      return ko.bindingHandlers['virtualHtml'].update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
    //else 
    //  return ko.bindingHandlers.wysiwyg.update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygOrHtml'] = true;

ko.bindingHandlers.wysiwygHref = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      var v = valueAccessor();

      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      // console.log("XXX", bindingContext.templateMode, isNotWysiwygMode, element.getAttribute("href"));
      if (isNotWysiwygMode) {
        element.setAttribute('target', '_new');
      } else {
        /*jshint scripturl:true*/
        // 20150226: removed href to work around FF issues with <a href=""><div contenteditable="true">..</div></a>
        // element.setAttribute('href', 'javascript:void(0)');
        // 20150309: on IE, an editable <a href="" data-editable=""> prevent tinymce toolbar to be shown.
        //           so I change behaviour based on the use of "wysiwygOrHtml"
        // @see: http://www.tinymce.com/develop/bugtracker_view.php?id=7432
        var allbindings = allBindingsAccessor();
        if (typeof allbindings.wysiwygOrHtml !== 'undefined') {
          element.setAttribute('href', 'javascript:void(0)');
        } else {
          element.removeAttribute('href');
          element.setAttribute('disabledhref', '#');
        }
      }
    }
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    if (element.nodeType !== 8) {
      var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
      // NOTE this unwrap is needed also in "wysiwyg" mode, otherwise dependency tracking dies.
      var attrValue = ko.utils.unwrapObservable(valueAccessor());
      if (isNotWysiwygMode) {
        if ((attrValue === false) || (attrValue === null) || (attrValue === undefined))
          element.removeAttribute('href');
        else
          element.setAttribute('href', attrValue.toString());
      }
    }
  }
};
ko.virtualElements.allowedBindings['wysiwygHref'] = true;

ko.bindingHandlers.wysiwygSrc = {
  convertedUrl: function(src, method, width, height) {
    var res = src + "?method=" + method + "&width=" + width + (height !== null ? "&height=" + height : '');
    console.log("basic converterUrl", res);
    return res;
  },
  placeholderUrl: function(plwidth, plheight, pltext) {
    var placeholdersrc = "'http://lorempixel.com/g/'+" + plwidth + "+'/'+" + plheight + "+'/abstract/'+encodeURIComponent(" + pltext + ")";
    // http://placehold.it/200x150.png/cccccc/333333&text=placehold.it#sthash.nA3r26vR.dpuf
    // placeholdersrc = "'http://placehold.it/'+"+width+"+'x'+"+height+"+'.png/cccccc/333333&text='+"+size;
    // placeholdersrc = "'"+converterUtils.addSlashes(defaultValue)+"'";
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var value = ko.utils.unwrapObservable(valueAccessor());
    var attrValue = ko.utils.unwrapObservable(value.src);
    var placeholderValue = ko.utils.unwrapObservable(value.placeholder);
    var width = ko.utils.unwrapObservable(value.width);
    var height = ko.utils.unwrapObservable(value.height);
    if ((attrValue === false) || (attrValue === null) || (attrValue === undefined) || (attrValue === '')) {
      if (typeof placeholderValue == 'object' && placeholderValue !== null) element.setAttribute('src', ko.bindingHandlers.wysiwygSrc.placeholderUrl(placeholderValue.width, placeholderValue.height, placeholderValue.text));
      else element.removeAttribute('src');
    } else {
      var method = ko.utils.unwrapObservable(value.method);
      if (!method) method = width > 0 && height > 0 ? 'cover' : 'resize';
      var src = ko.bindingHandlers.wysiwygSrc.convertedUrl(attrValue.toString(), method, width, height);
      element.setAttribute('src', src);
    }
    if (typeof width !== 'undefined' && width !== null) element.setAttribute("width", width);
    else element.removeAttribute("width");
    if (typeof height !== 'undefined' && height !== null) element.setAttribute("height", height);
    else element.removeAttribute("height");
  }
};

ko.bindingHandlers.wysiwygId = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      element.setAttribute('id', ko.utils.unwrapObservable(valueAccessor()));
  },
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      element.setAttribute('id', ko.utils.unwrapObservable(valueAccessor()));
  }
};
ko.virtualElements.allowedBindings['wysiwygId'] = true;

// used on editable "item" so to bind clicks only in wysiwyg mode.
ko.bindingHandlers.wysiwygClick = {
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      ko.bindingHandlers.click.init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygClick'] = true;

// used on editable "item" so to bind css only in wysiwyg mode.
ko.bindingHandlers.wysiwygCss = {
  update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    var isNotWysiwygMode = (typeof bindingContext.templateMode == 'undefined' || bindingContext.templateMode != 'wysiwyg');
    if (!isNotWysiwygMode)
      ko.bindingHandlers.css.update(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygCss'] = true;

ko.bindingHandlers.wysiwygImg = {
  makeTemplateValueAccessor: function(valueAccessor, bindingContext) {
    return function() {
      var isWysiwygMode = (typeof bindingContext.templateMode != 'undefined' && bindingContext.templateMode == 'wysiwyg');

      var modelValue = valueAccessor(),
        unwrappedValue = ko.utils.peekObservable(modelValue); // Unwrap without setting a dependency here

      // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
      ko.utils.unwrapObservable(modelValue);

      return {
        'name': isWysiwygMode ? unwrappedValue['_editTemplate'] : unwrappedValue['_template'],
        'templateEngine': ko.nativeTemplateEngine.instance
      };
    };
  },
  'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['wysiwygImg'].makeTemplateValueAccessor(valueAccessor, bindingContext));
  },
  'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
    bindingContext = bindingContext['extend'](valueAccessor());
    return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['wysiwygImg'].makeTemplateValueAccessor(valueAccessor, bindingContext), allBindings, viewModel, bindingContext);
  }
};
ko.virtualElements.allowedBindings['wysiwygImg'] = true;

// NOTE: there are issues with the "raw" format and trash left around by tinymce workarounds for contenteditable issues.
// setting "forced_root_block: false" disable the default behaviour of adding a wrapper <p> when needed and this seems to fix many issues in IE.
// also, maybe we should use the "raw" only for the "before SetContent" and instead read the "non-raw" content (the raw content sometimes have data- attributes and too many ending <br> in the code)
ko.bindingHandlers.wysiwyg = {
  currentIndex: 0,
  standardOptions: {},
  fullOptions: {
    toolbar1: 'bold italic forecolor backcolor hr styleselect removeformat | link unlink | pastetext code',
    //toolbar1: "bold italic | forecolor backcolor | link unlink | hr | pastetext code", // | newsletter_profile newsletter_optlink newsletter_unsubscribe newsletter_showlink";
    //toolbar2: "formatselect fontselect fontsizeselect | alignleft aligncenter alignright alignjustify | bullist numlist",
    plugins: ["link hr paste lists textcolor code"],
    // valid_elements: 'strong/b,em/i,*[*]',
    // extended_valid_elements: 'strong/b,em/i,*[*]',
    // Removed: image fullscreen contextmenu 
    // download custom:
    // jquery version con legacyoutput, anchor, code, importcss, link, paste, textcolor, hr, lists
  },
  init: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
    // TODO ugly, but works...
    ko.bindingHandlers.focusable.init(element);

    ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
      tinymce.remove('#' + element.getAttribute('id'));
    });

    var value = valueAccessor();

    if (!ko.isObservable(value)) throw "Wysiwyg binding called with non observable";
    if (element.nodeType === 8) throw "Wysiwyg binding called on virtual node, ignoring...." + element.innerHTML;

    var selectorId = element.getAttribute('id');
    if (!selectorId) {
      selectorId = 'wysiwyg_' + (++ko.bindingHandlers['wysiwyg'].currentIndex);
      element.setAttribute('id', selectorId);
    }

    var fullEditor = element.tagName == 'DIV' || element.tagName == 'TD';
    var isSubscriberChange = false;
    var thisEditor;
    var isEditorChange = false;

    var options = {
      selector: '#' + selectorId,
      inline: true,
      // maybe not needed, but won't hurt.
      hidden_input: false,
      plugins: ["paste"],
      toolbar1: "bold italic",
      toolbar2: "",
      // we have to disable preview_styles otherwise tinymce push inline every style he things will be applied and this makes the style menu to inherit color/font-family and more.
      preview_styles: false,
      paste_as_text: true,
      language: 'en',
      schema: "html5",
      extended_valid_elements: 'strong/b,em/i,*[*]',
      menubar: false,
      skin: 'gray-flat',
      setup: function(editor) {
        // TODO change sometimes doesn't trigger (we have to document when)
        // listening on keyup would increase correctness but we would need a rateLimit to avoid flooding.
        editor.on('change redo undo', function() {
          if (!isSubscriberChange) {
            isEditorChange = true;
            // we failed with other ways to do this:
            // value($(element).html());
            // value(element.innerHTML);
            value(editor.getContent({
              format: 'raw'
            }));
            isEditorChange = false;
          }
        });
        // Clicking on the element on focus change allow the "clic" code to be triggered and propagate the selection.
        // Not elegant, maybe we have better options.
        editor.on('focus', function() {
          // Used by scrollfix.js (maybe this is not needed by new scrollfix.js)
          editor.nodeChanged();
          editor.getElement().click();
        });

        // NOTE: this fixes issue with "leading spaces" in default content that were lost during initialization.
        editor.on('BeforeSetContent', function(args) {
          if (args.initial) args.format = 'raw';
        });

        /* NOTE: disabling "ENTER" in tiny editor, not a good thing but may be needed to work around contenteditable issues
        if (!fullEditor) {
          // se non abbiamo il "full Editor", disabilitiamo l'invio. (vari bug)
          editor.on('keydown', function(e) {
            if (e.keyCode == 13) { e.preventDefault(); }
          });
        }
        */

        thisEditor = editor;

      }
    };

    ko.utils.extend(options, ko.bindingHandlers.wysiwyg.standardOptions);
    if (fullEditor) ko.utils.extend(options, ko.bindingHandlers.wysiwyg.fullOptions);

    // we have to put initialization in a settimeout, otherwise switching from "1" to "2" columns blocks
    // will start the new editors before disposing the old ones and IDs get temporarily duplicated.
    // using setTimeout the dispose/create order is correct on every browser tested.
    global.setTimeout(function() {
      tinymce.init(options);
    });

    ko.computed(function() {
      var content = ko.utils.unwrapObservable(valueAccessor());
      if (!isEditorChange) {
        try {
          isSubscriberChange = true;
          // we failed setting contents in other ways...
          // $(element).html(content);
          if (typeof thisEditor !== 'undefined') {
            thisEditor.setContent(content, {
              format: 'raw'
            });
          } else {
            ko.utils.setHtml(element, content);
          }
        } catch (e) {
          console.log("TODO exception setting content to editable element", typeof thisEditor, e);
        }
        isSubscriberChange = false;
      }
    }, null, {
      disposeWhenNodeIsRemoved: element
    });

    // do not parse html content for KO bindings!!
    return {
      controlsDescendantBindings: true
    };

  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./eventable.js":26}],41:[function(require,module,exports){
"use strict";
var console = require("./../../../bower_components/console-browserify/index.js");

// returns 0 if equal (0.0.x release), 1 with backward compatible additions (0.x.0 release), 2 on lost data or incompatible data (x.0.0 release)
var checkModel = function(reference, blockDefs, model, origPrefix, reverse) {
  var blockDefsObj, i, prefix;
  var valid = 0;
  if (typeof reverse == 'undefined') reverse = false;
  if (typeof blockDefs !== 'undefined' && typeof blockDefs.splice == 'function') {
    blockDefsObj = {};
    for (i = 0; i < blockDefs.length; i++) blockDefsObj[blockDefs[i].type] = blockDefs[i];
  } else {
    blockDefsObj = blockDefs;
  }
  for (var prop in reference)
    if (reference.hasOwnProperty(prop)) {
      prefix = typeof origPrefix !== 'undefined' ? origPrefix + "." + prop : prop;
      if (!model.hasOwnProperty(prop)) {
        if (reverse) {
          console.warn("WARN Property ", prefix, "found in model is not defined by template: removing it!");
          valid = Math.max(valid, 2);
          delete reference[prop];
        } else {
          console.log("INFO Property ", prefix, "missing in model, cloning from reference!");
          valid = Math.max(valid, 1);
          model[prop] = reference[prop];
        }
      } else if (typeof model[prop] != typeof reference[prop]) {
        // se sono di tipo diverso allora provo a vedere se l'altro, convertito di tipo mantiene un valore equivalente.
        if (model[prop] !== null && reference[prop] !== null) {
          if (typeof model[prop] == 'string') {
            if (String(reference[prop]) != reference[prop]) {
              console.log("TODO Different type 1 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
              valid = Math.max(valid, 2);
            }
          } else if (typeof model[prop] == 'number') {
            if (Number(reference[prop]) != reference[prop]) {
              console.log("TODO Different type 2 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
              valid = Math.max(valid, 2);
            }
          } else {
            console.log("TODO Different type 3 ", prefix, typeof model[prop], typeof reference[prop], model[prop], reference[prop]);
            valid = Math.max(valid, 2);
          }
        }
      } else if (typeof reference[prop] == 'object') {
        if (reference[prop] !== null) {
          if (typeof reference[prop].splice !== 'undefined') {
            if (reference[prop].length > 0) {
              if (model[prop].length > 0) {
                // TODO needs sorting?
                var j = 0;
                for (i = 0; i < model[prop].length; i++) {
                  if (typeof model[prop][i].type == 'string') {
                    while (j < reference[prop].length && reference[prop][j].type !== model[prop][i].type) {
                      console.log("ignoring ", prefix, reference[prop][j].type, " block type in reference not found in model");
                      j++;
                    }
                    if (j >= reference[prop].length) {
                      console.log("WARN cannot find ", prefix, model[prop][i].type, " block in reference");
                      valid = Math.max(valid, 2);
                      break;
                    }
                    // reverse condition so to skip "deep traversing" on error
                    valid = Math.max(valid, checkModel(reference[prop][j], undefined, model[prop][i], prefix + "[" + i + "." + model[prop][i].type + "]"));
                  }
                }
              } else {
                // in the case of different array we check blockDefs
                for (i = 0; i < reference[prop].length; i++) {
                  if (typeof reference[prop][i].type !== 'string') {
                    console.log("TODO found an object with no type", prefix, reference[prop][i]);
                    valid = Math.max(valid, 2);
                  } else if (!blockDefsObj.hasOwnProperty(reference[prop][i].type)) {
                    console.warn("TODO the model uses a block type not defined by the template. REMOVING IT!!", prefix, reference[prop][i]);
                    reference[prop].splice(i, 1);
                    i--;
                    valid = Math.max(valid, 2);
                  } else {
                    valid = Math.max(valid, checkModel(blockDefsObj[reference[prop][i].type], blockDefsObj, reference[prop][i], prefix + "[" + i + "." + reference[prop][i].type + "]"));
                  }
                }
              }
            }
          } else {
            if (model[prop] === null) {
              if (reverse) {
                console.log("WARN Null object in model ", prefix, "instead of", reference[prop], "deleting it");
                valid = Math.max(valid, 2);
                delete reference[prop];
              } else {
                console.log("INFO Null object in model ", prefix, "instead of", reference[prop], "cloning it from the reference");
                valid = Math.max(valid, 1);
                model[prop] = reference[prop];
              }
            } else {
              valid = Math.max(valid, checkModel(reference[prop], blockDefsObj, model[prop], prefix, reverse));
            }
          }
        } else if (model[prop] !== null) {
          console.log("TODO Null in reference but not null in model", prefix, model[prop]);
          valid = Math.max(valid, 2);
        }
      } else if (typeof reference[prop] !== 'string' && typeof reference[prop] !== 'boolean' && typeof reference[prop] !== 'number') {
        console.log("TODO unsupported type", prefix, typeof reference[prop]);
        valid = Math.max(valid, 2);
      }

    }
  if (!reverse) valid = Math.max(valid, checkModel(model, blockDefs, reference, typeof origPrefix !== 'undefined' ? origPrefix + "!R" : "!R", true));
  return valid;
};

module.exports = checkModel;
},{"./../../../bower_components/console-browserify/index.js":1}],42:[function(require,module,exports){
"use strict";

// Parses CSS declarations and supports the property language (-ko-*) found between them.
// Create KO bindings but doesn't depend on KO.
// Needs a bindingProvider.

var converterUtils = require("./utils.js");
var cssParse = require("./../../../bower_components/mensch/lib/parser.js");
var console = require("./../../../bower_components/console-browserify/index.js");
var domutils = require("./domutils.js");

var _declarationValueLookup = function(declarations, propertyname, templateUrlConverter) {
  for (var i = declarations.length - 1; i >= 0; i--) {
    if (declarations[i].type == 'property' && declarations[i].name == propertyname) {
      return _declarationValueUrlPrefixer(declarations[i].value, templateUrlConverter);
    }
  }
  return null;
};

var _propToCamelCase = function(propName) {
  return propName.replace(/-([a-z])/g, function(match, contents, offset, s) {
    return contents.toUpperCase();
  });
};

var _declarationValueUrlPrefixer = function(value, templateUrlConverter) {
  if (value.match(/url\(.*\)/)) {
    var replaced = value.replace(/(url\()([^\)]*)(\))/g, function(matched, prefix, url, postfix) {
      var trimmed = url.trim();
      var apice = url.trim().charAt(0);
      if (apice == '\'' || apice == '"') {
        trimmed = trimmed.substr(1, trimmed.length - 2);
      } else {
        apice = '';
      }
      var newUrl = templateUrlConverter(trimmed);
      if (newUrl !== null) {
        return prefix + apice + newUrl + apice + postfix;
      } else {
        return matched;
      }
    });
    return replaced;
  } else {
    return value;
  }
};

var elaborateDeclarations = function(style, declarations, templateUrlConverter, bindingProvider, element, basicBindings, removeDisplayNone) {
  var newBindings = typeof basicBindings == 'object' && basicBindings !== null ? basicBindings : {};
  var newStyle = null;
  var skipLines = 0;
  if (typeof declarations == 'undefined') {
    var styleSheet = cssParse("#{\n" + style + "}", {
      comments: true,
      position: true
    });
    declarations = styleSheet.stylesheet.rules[0].declarations;
    skipLines = 1;
  }
  for (var i = declarations.length - 1; i >= 0; i--)
    if (declarations[i].type == 'property') {
      if (removeDisplayNone === true && declarations[i].name == 'display' && declarations[i].value == 'none') {
        if (newStyle === null) newStyle = style;
        newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, '');
      } else {
        var decl = declarations[i].name.match(/^-ko-(bind-|attr-)?([a-z0-9-]*?)(-if|-ifnot)?$/);
        if (decl !== null) {
          // rimozione dello stile -ko- dall'attributo style.
          if (newStyle === null && typeof style != 'undefined') newStyle = style;

          var isAttr = decl[1] == 'attr-';
          var isBind = decl[1] == 'bind-';
          var propName = decl[2];

          var isIf = decl[3] == '-if' || decl[3] == '-ifnot';
          var condDecl;
          var bindValue;
          var propDefaultValue;

          if (isIf) {
            condDecl = declarations[i].name.substr(0, declarations[i].name.length - decl[3].length);
            var conditionedDeclaration = _declarationValueLookup(declarations, condDecl, templateUrlConverter);
            if (conditionedDeclaration === null) throw "Unable to find declaration " + condDecl + " for " + declarations[i].name;
          } else {

            if ((isAttr || isBind) && (typeof element == 'undefined' && typeof style != 'undefined')) throw "Attributes and bind declarations are only allowed in inline styles!";

            var needDefaultValue = true;
            var bindType;
            if (isAttr) {
              propDefaultValue = domutils.getAttribute(element, propName);
              needDefaultValue = false;
              bindType = 'virtualAttr';
            } else if (!isBind) {
              needDefaultValue = typeof style !== 'undefined';
              if (needDefaultValue) propDefaultValue = _declarationValueLookup(declarations, propName, templateUrlConverter);
              bindType = 'virtualStyle';
            } else {
              bindType = null;
              if (propName == 'text') {
                if (typeof element !== 'undefined') {
                  propDefaultValue = domutils.getInnerText(element);
                } else {
                  needDefaultValue = false;
                }
              } else if (propName == 'html') {
                if (typeof element !== 'undefined') {
                  propDefaultValue = domutils.getInnerHtml(element);
                } else {
                  needDefaultValue = false;
                }
              } else {
                needDefaultValue = false;
              }
            }

            if (needDefaultValue && propDefaultValue === null) {
              console.error("Cannot find default value for", declarations[i].name, declarations);
              throw "Cannot find default value for " + declarations[i].name + ": " + declarations[i].value + " in " + element + " (" + typeof style + "/" + propName + ")";
            }
            var bindDefaultValue = propDefaultValue;

            var bindName = _propToCamelCase(propName);

            try {
              bindValue = converterUtils.expressionBinding(declarations[i].value, bindingProvider, bindDefaultValue);
            } catch (e) {
              console.error("Model ensure path failed", e.stack, "name", declarations[i].name, "value", declarations[i].value, "default", propDefaultValue, "element", element);
              throw e;
            }

            if (bindType !== null && typeof newBindings[bindType] == 'undefined') newBindings[bindType] = {};


            // Special handling for HREFs
            if (bindType == 'virtualAttr' && bindName == 'href') {
              bindType = null;
              bindName = 'wysiwygHref';
              // We have to remove it, otherwise we ends up with 2 rules writing it.
              if (typeof element != 'undefined' && element !== null) {
                domutils.removeAttribute(element, "href");
              }
            }

            // TODO evaluate the use of "-then" (and -else) postfixes to complete the -if instead of relaying
            // on the same basic sintax (or maybe it is better to support ternary operator COND ? THEN : ELSE).
            var declarationCondition = _declarationValueLookup(declarations, declarations[i].name + '-if', templateUrlConverter);
            var not = false;
            if (declarationCondition === null) {
              declarationCondition = _declarationValueLookup(declarations, declarations[i].name + '-ifnot', templateUrlConverter);
              not = true;
            } else {
              if (_declarationValueLookup(declarations, declarations[i].name + '-ifnot', templateUrlConverter) !== null) {
                throw "Unexpected error: cannot use both -if and -ifnot property conditions";
              }
            }
            if (declarationCondition !== null) {
              try {
                var bindingCond = converterUtils.conditionBinding(declarationCondition, bindingProvider);
                bindValue = (not ? '!' : '') + "(" + bindingCond + ") ? " + bindValue + " : null";
              } catch (e) {
                console.error("Unable to deal with -ko style binding condition", declarationCondition, declarations[i].name);
                throw e;
              }
            }

            if (bindType !== null) newBindings[bindType][bindName] = bindValue;
            else newBindings[bindName] = bindValue;
          }

          // parsing @supports :preview
          if (newStyle !== null) {

            try {
              // if "element" is defined then we are parsing an "inline" style and we want to remove it.
              if (typeof element != 'undefined' && element !== null) {
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, '');
              } else {
                // otherwise we are parsing a full stylesheet.. let's rewrite the full "prop: value" without caring about the original syntax.
                var replacedWith = '';
                // if it is an "if" we simply have to remove it, otherwise we replace the input code with "prop: value" generating expression.
                if (!isIf) replacedWith = propName + ': <!-- ko text: ' + bindValue + ' -->' + propDefaultValue + '<!-- /ko -->';
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, replacedWith);
              }
            } catch (e) {
              console.warn("Remove style failed", e, "name", declarations[i]);
              throw e;
            }

          }

        } else {
          // prefixing urls
          var replacedValue = _declarationValueUrlPrefixer(declarations[i].value, templateUrlConverter);
          if (replacedValue != declarations[i].value) {
            if (newStyle === null && typeof style !== 'undefined') newStyle = style;
            if (newStyle !== null) {
              try {
                newStyle = converterUtils.removeStyle(newStyle, declarations[i].position.start, declarations[i].position.end, skipLines, 0, 0, declarations[i].name + ": " + replacedValue);
              } catch (e) {
                console.log("Remove style failed replacing url", e, "name", declarations[i]);
                throw e;
              }
            }
          }

          // Style handling by concatenated "style attribute" (worse performance but more stable than direct style handling)
          var bindName2 = _propToCamelCase(declarations[i].name);
          var bind = 'virtualAttrStyle';
          var bindVal2 = typeof newBindings['virtualStyle'] !== 'undefined' ? newBindings['virtualStyle'][bindName2] : undefined;

          var dist = ' ';
          if (typeof newBindings[bind] == 'undefined') {
            newBindings[bind] = "''";
            dist = '';
          }

          if (typeof bindVal2 !== 'undefined') {
            newBindings[bind] = "'" + declarations[i].name + ": '+(" + bindVal2 + ")+';" + dist + "'+" + newBindings[bind];
            delete newBindings['virtualStyle'][bindName2];
          } else {
            newBindings[bind] = "'" + declarations[i].name + ": " + converterUtils.addSlashes(replacedValue) + ";" + dist + "'+" + newBindings[bind];
          }

        }
      }
    }

  if (typeof element != 'undefined' && element !== null) {
    for (var prop in newBindings['virtualStyle'])
      if (newBindings['virtualStyle'].hasOwnProperty(prop)) {
        console.log("Unexpected virtualStyle binding after conversion to virtualAttr.style", prop, newBindings['virtualStyle'][prop], style);
        throw "Unexpected virtualStyle binding after conversion to virtualAttr.style for " + prop;
      }
    delete newBindings['virtualStyle'];

    var currentBindings = domutils.getAttribute(element, 'data-bind');
    var dataBind = (currentBindings !== null ? currentBindings + ", " : "") + _bindingSerializer(newBindings);
    domutils.setAttribute(element, 'data-bind', dataBind);
  }

  // TODO a function whose return type depends on the input parameters is very ugly.. please FIX ME.
  if (typeof style == 'undefined') {
    // clean virtualStyle if empty
    var hasVirtualStyle = false;
    for (var prop1 in newBindings['virtualStyle'])
      if (newBindings['virtualStyle'].hasOwnProperty(prop1)) {
        hasVirtualStyle = true;
        break;
      }
    if (!hasVirtualStyle) delete newBindings['virtualStyle'];
    else {
      // remove and add back virtualAttrStyle so it gets appended BEFORE virtualAttrStyle (_bindingSerializer reverse them...)
      if (typeof newBindings['virtualAttrStyle'] !== 'undefined') {
        var vs = newBindings['virtualAttrStyle'];
        delete newBindings['virtualAttrStyle'];
        newBindings['virtualAttrStyle'] = vs;
      }
    }
    // returns new serialized bindings
    return _bindingSerializer(newBindings);
  }

  return newStyle;
};

var _bindingSerializer = function(val) {
  var res = [];
  for (var prop in val)
    if (val.hasOwnProperty(prop)) {
      if (typeof val[prop] == 'object') res.push(prop + ": " + "{ " + _bindingSerializer(val[prop]) + " }");
      else res.push(prop + ": " + val[prop]);
    }
  return res.reverse().join(', ');
};

module.exports = elaborateDeclarations;
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/mensch/lib/parser.js":10,"./domutils.js":43,"./utils.js":49}],43:[function(require,module,exports){
(function (global){
"use strict";

// This deals with Cheerio/jQuery issues.
// Most of this could be done without jQuery, too, but jQuery is easier to be mocked with Cheerio
// Otherwise we would need jsDom to run the compiler in the server (without a real browser)

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);

function _extend(target, source) {
  if (source) {
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}

var objExtend = function(obj, extender) {
  if (typeof $.extend == 'function') {
    return $.extend(true, obj, extender);
  } else {
    return _extend(obj, JSON.parse(JSON.stringify(extender)));
  }
};

var getAttribute = function(element, attribute) {
  var res = $(element).attr(attribute);
  if (typeof res == 'undefined') res = null;
  return res;
  // return element.getAttribute(attribute);
};

var setAttribute = function(element, attribute, value) {
  $(element).attr(attribute, value);
  // element.setAttribute(attribute, value);
};

var removeAttribute = function(element, attribute) {
  $(element).removeAttr(attribute);
  // element.removeAttribute(attribute);
};

var getInnerText = function(element) {
  return $(element).text();
  // if (typeof element.innerText != 'undefined') return element.innerText;
  // else return element.textContent;
};

var getInnerHtml = function(element) {
  return $(element).html();
  // return element.innerHTML;
};

var getLowerTagName = function(element) {
  // sometimes cheerio doesn't have tagName but "name".
  // Browsers have "name" with empty string
  // Sometimes cheerio has tagName but no prop function.
  if (element.tagName === '' && typeof element.name == 'string') return element.name.toLowerCase();
  if (element.tagName !== '') return element.tagName.toLowerCase();
  return $(element).prop("tagName").toLowerCase();
  // return element.tagName.toLowerCase();
};

var setContent = function(element, content) {
  $(element).html(content);
  // element.innerHTML = content;
};

var replaceHtml = function(element, html) {
  $(element).replaceWith(html);
  // element.outerHTML = html;
};

var removeElements = function($elements, tryDetach) {
  if (tryDetach && typeof $elements.detach !== 'undefined') $elements.detach();
  // NOTE: we don't need an else, as detach is simply an optimization
  $elements.remove();
};

module.exports = {
  getAttribute: getAttribute,
  setAttribute: setAttribute,
  removeAttribute: removeAttribute,
  getInnerText: getInnerText,
  getInnerHtml: getInnerHtml,
  getLowerTagName: getLowerTagName,
  setContent: setContent,
  replaceHtml: replaceHtml,
  removeElements: removeElements,
  objExtend: objExtend
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
"use strict";

var console = require("./../../../bower_components/console-browserify/index.js");
var elaborateDeclarations = require("./declarations.js");
var utils = require('./utils.js');
var modelDef = require('./model.js');

var _getOptionsObject = function(options) {
  var optionsCouples = options.split('|');
  var opts = {};
  for (var i = 0; i < optionsCouples.length; i++) {
    var opt = optionsCouples[i].split('=');
    opts[opt[0]] = opt.length > 1 ? opt[1] : opt[0];
  }
  return opts;
};

// TODO this should not have hardcoded rules (we now have a way to declare them in the template definition)
// Category "style" is used by editType "styler"
// Cateogry "content" is used by editType "edit"
// TODO maybe we should use a common string here, and rely only on the original category.
var _filterProps = function(model, editType, level) {
  var res = [];
  for (var prop in model)
    if (!prop.match(/^customStyle$/) && !prop.match(/^_/) && model.hasOwnProperty(prop)) {
      var isStyleProp = model[prop] !== null && typeof model[prop]._category != 'undefined' && model[prop]._category == 'style';
      if (prop == 'id' || prop == 'type' || prop.match(/Blocks$/)) {} else if (editType == 'styler') {
        if (isStyleProp || level > 0) res.push(prop);
      } else if (editType == 'edit') {
        // Editing for properties in the "content" category but not defined in the context of a block
        var isContentProp = model[prop] !== null && typeof model[prop]._category != 'undefined' && model[prop]._category == 'content' &&
          (typeof model[prop]._context == 'undefined' || model[prop]._context != 'block');
        if (isContentProp) res.push(prop);
      } else if (typeof editType == 'undefined') {
        res.push(prop);
      }
    }
  return res;
};

var _propInput = function(model, prop, propAccessor, editType, widgets) {
  var html = "";
  var widget;
  if (model !== null && typeof model._widget != 'undefined') widget = model._widget;

  if (typeof widget == 'undefined') {
    throw "Unknown data type for " + prop;
  }

  // For content editors we deal with focusing (clicking is handled by the container DIV).
  var onfocusbinding = 'focusable: true';
  if (editType == 'edit') {
    onfocusbinding += ', event: { focus: function(ui, event) { $($element).click(); } } ';
  }

  html += '<label class="data-' + widget + '"' + (widget == 'boolean' ? ' data-bind="event: { mousedown: function(ui, evt) { if (evt.button == 0) { var input = $($element).find(\'input\'); var ch = input.prop(\'checked\'); setTimeout(function() { input.click(); input.prop(\'checked\', !ch); input.trigger(\'change\'); }, 0); } } }, click: function(ui, evt) { evt.preventDefault(); }, clickBubble: false"' : '') + '>';

  if (typeof widgets !== 'undefined' && typeof widgets[widget] !== 'undefined') {
    var w = widgets[widget];
    var parameters = {};
    if (typeof w.parameters !== 'undefined')
      for (var p in w.parameters)
        if (w.parameters.hasOwnProperty(p) && typeof model['_'+p] !== 'undefined')
          parameters[p] = model['_'+p];
    html += w.html(propAccessor, onfocusbinding, parameters);
  } else if (widget == 'boolean') {
    html += '<input type="checkbox" value="nothing" data-bind="checked: ' + propAccessor + ', ' + onfocusbinding + '" />';
    html += '<span class="checkbox-replacer" ></span>'; /* data-bind="css: { checked: '+propAccessor+' }" */
  } else if (widget == 'color') {
    html += '<input size="7" type="text" data-bind="colorpicker: { color: ' + propAccessor + ', strings: $root.t(\'Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet.\') }, ' + ', ' + onfocusbinding + '" />';
  } else if (widget == 'select') {
    if (typeof model._options != 'undefined') {
      var opts = _getOptionsObject(model._options);
      // var opts = model._options;
      html += '<select data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '">';
      for (var opt in opts)
        if (opts.hasOwnProperty(opt)) {
          html += '<option value="' + opt + '" data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(opts[opt]) + '\')">' + opts[opt] + '</option>';
        }
      html += '</select>';
    }
  } else if (widget == 'font') {
    html += '<select type="text" data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '">';
    html += '<optgroup label="Sans-Serif Fonts">';
    html += '<option value="Arial,Helvetica,sans-serif">Arial</option>';
    html += '<option value="\'Comic Sans MS\',cursive,sans-serif">Comic Sans MS</option>';
    html += '<option value="Impact,Charcoal,sans-serif">Impact</option>';
    html += '<option value="\'Trebuchet MS\',Helvetica,sans-serif">Trebuchet MS</option>';
    html += '<option value="Verdana,Geneva,sans-serif">Verdana</option>';
    html += '</optgroup>';
    html += '<optgroup label="Serif Fonts">';
    html += '<option value="Georgia,serif">Georgia</option>';
    html += '<option value="\'Times New Roman\',Times,serif">Times New Roman</option>';
    html += '</optgroup>';
    html += '<optgroup label="Monospace Fonts">';
    html += '<option value="\'Courier New\',Courier,monospace">Courier New</option>';
    html += '</optgroup>';
    html += '</select>';
  } else if (widget == 'url') {
    html += '<div class="ui-textbutton">';
    // <a class="ui-spinner-button ui-spinner-down ui-corner-br ui-button ui-widget ui-state-default ui-button-text-only" tabindex="-1" role="button"><span class="ui-button-text"><span class="ui-icon fa fa-fw caret-down"></span></span></a>
    html += '<input class="ui-textbutton-input" size="7" type="url" pattern="(mailto:.+@.+|https?://.+\\..+|\\[.*\\].*)" value="nothing" data-bind="css: { withButton: typeof $root.linkDialog !== \'undefined\' }, validatedValue: ' + propAccessor + ', ' + onfocusbinding + '" />';
    html += '<a class="ui-textbutton-button" data-bind="visible: typeof $root.linkDialog !== \'undefined\', click: typeof $root.linkDialog !== \'undefined\' ? $root.linkDialog.bind($element.previousSibling) : false, button: { icons: { primary: \'fa fa-fw fa-ellipsis-h\' }, label: \'Opzioni\', text: false }">Opzioni</a>';
    html += '</div>';
  } else if (widget == 'integer') {
    // at this time the "step" depends on max being greater than 100.
    // maybe we should expose "step" as a configuration, too
    var min = 0;
    var max = 1000;
    if (model !== null && typeof model._max !== 'undefined') max = model._max;
    if (model !== null && typeof model._min !== 'undefined') min = model._min;
    var step = (max - min) >= 100 ? 10 : 1;
    var page = step * 5;
    html += '<input class="number-spinner" size="7" step="' + step + '" type="number" value="-1" data-bind="spinner: { min: ' + min + ', max: ' + max + ', page: ' + page + ', value: ' + propAccessor + ' }, valueUpdate: [\'change\', \'spin\']' + ', ' + onfocusbinding + '" />';
  } else {
    html += '<input size="7" type="text" value="nothing" data-bind="value: ' + propAccessor + ', ' + onfocusbinding + '" />';
  }

  html += '</label>';

  return html;
};

var _getGlobalStyleProp = function(globalStyles, model, prop, path) {
  var globalStyleProp;
  if (typeof model !== 'object' || model === null || typeof model._widget !== 'undefined') {
    if (typeof prop !== 'undefined' && typeof path !== 'undefined' && path.length > 0 && typeof globalStyles == 'object' && typeof globalStyles[path] != 'undefined') {
      globalStyleProp = globalStyles[path];
    }
  }
  return globalStyleProp;
};

var _propEditor = function(withBindingProvider, widgets, templateUrlConverter, model, themeModel, path, prop, editType, level, baseThreshold, globalStyles, globalStyleProp, trackUsage, rootPreviewBinding, previewBackground) {
  if (typeof level == 'undefined') level = 0;

  if (typeof prop !== 'undefined' && typeof model == 'object' && model !== null && typeof model._usecount === 'undefined') {
    console.log("TODO EDITOR ignoring", path, "property because it is not used by the template", "prop:", prop, "type:", editType, "level:", level, withBindingProvider._templateName);
    return "";
  }

  var propAccessor = typeof globalStyleProp != 'undefined' ? prop + '._defaultComputed' : prop;

  var html = "";
  var title;
  var ifSubsProp = propAccessor;
  var ifSubsGutter = 1;
  // typeof globalStyleProp != 'undefined' ? 1 : 2;
  var ifSubsThreshold = 1;

  // The visibility handling is a PITA
  // 
  // Here are some "edge cases" to test whenever we change something here:
  // LM social footer: removing shareVisibile must be reflected in the booleans sub-checks
  // FLUID social block: multiple clicks on the "wand" should not make the editor invisible
  // BIS heroMenu - By changing the menu visibility it should be reflected in style editors for the menu links
  // FLUID almost every block with a color variant sometimes keeps showing style editor for the hidden variant.
  if (typeof model == 'object' && model !== null && typeof model._widget == 'undefined') {
    // Do nothing here
  } else {
    if (typeof globalStyleProp == 'undefined') {
      ifSubsGutter += 1;
    }
  }

  // NOTE baseThreshold is added only when globalStyle is not defined because when we have globalStyle
  // we're going to bind the computed values and not the original and this way we don't add ourserf to the dependency 
  // tracking (subscriptionCount)
  // NOTE baseThreshold is an "expression" and not a fixed number, so this is a concatenation
  if (typeof globalStyleProp == 'undefined' && typeof baseThreshold !== 'undefined') ifSubsThreshold += baseThreshold;

  if (typeof prop != 'undefined' && !!trackUsage) {
    html += '<!-- ko ifSubs: { data: ' + ifSubsProp + ', threshold: ' + ifSubsThreshold + ', gutter: ' + ifSubsGutter + ' } -->';
  }

  if (typeof prop != 'undefined' && (model === null || typeof model._name == 'undefined')) {
    // TODO throw exception?
    console.log("TODO WARN Missing label for property ", prop);
  }
  if (typeof prop == 'undefined' && model !== null && typeof model._name == 'undefined') {
    console.log("TODO WARN Missing label for object ", model.type /*, model */ );
  }

  if (typeof model == 'object' && model !== null && typeof model._widget == 'undefined') {
    var props = _filterProps(model, editType, level);

    var hasCustomStyle = editType == 'styler' && model !== null && typeof model.customStyle !== 'undefined' && typeof globalStyleProp !== 'undefined';
    var selectedItemBinding = '';
    var additionalClasses = '';
    if (typeof prop !== 'undefined' && editType == 'edit') {
      selectedItemBinding = ', click: function(obj, evt) { $root.selectItem(' + prop + ', $data); return false }, clickBubble: false, css: { selecteditem: $root.isSelectedItem(' + prop + ') }, scrollIntoView: $root.isSelectedItem(' + prop + '), ';
      additionalClasses += ' selectable';
    }
    if (hasCustomStyle) {
      additionalClasses += ' supportsCustomStyles';
    }
    html += '<div class="objEdit level' + level + additionalClasses + '" data-bind="tooltips: {}' + selectedItemBinding + '">';
    var modelName = (model !== null && typeof model._name != 'undefined' ? model._name : (typeof prop !== 'undefined' ? '[' + prop + ']' : ''));
    if (hasCustomStyle) {
      var themeSectionName = 'Stile';
      if (typeof themeModel !== 'undefined' && themeModel !== null && typeof themeModel._name !== 'undefined') {
        themeSectionName = themeModel._name;
      } else {
        console.log("TODO missing label for theme section ", prop, model !== null ? model.type : '-');
      }

      modelName = '<span class="blockSelectionMethod" data-bind="text: customStyle() ? $root.ut(\'template\', \'' + utils.addSlashes(modelName) + '\') : $root.ut(\'template\', \'' + utils.addSlashes(themeSectionName) + '\')">Block</span>';
    } else {
      modelName = '<span data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(modelName) + '\')">' + modelName + '</span>';
    }
    title = model !== null && typeof model._help !== 'undefined' ? ' title="' + utils.addSlashes(model._help) + '" data-bind="attr: { title: $root.ut(\'template\', \'' + utils.addSlashes(model._help) + '\') }"' : '';
    html += '<span' + title + ' class="objLabel level' + level + '">' + modelName + '</span>';

    if (editType == 'edit' && typeof model._blockDescription !== 'undefined') {
      html += '<div class="blockDescription" data-bind="html: $root.ut(\'template\', \'' + utils.addSlashes(model._blockDescription) + '\')">' + model._blockDescription + '</div>';
    }

    /* CUSTOM STYLE */
    if (hasCustomStyle) {
      html += '<label class="data-boolean blockCheck" data-bind="tooltips: { }">';
      html += '<input type="checkbox" value="nothing" data-bind="focusable: true, checked: customStyle" />';
      html += '<span title="Switch between global and block level styles editing" data-bind="attr: { title: $root.t(\'Switch between global and block level styles editing\') }" class="checkbox-replacer checkbox-replacer-onoff"></span>'; //  data-bind="tooltip: { content: \'personalizza tutti\' }"
      html += '</label>';
      html += '<!-- ko template: { name: \'customstyle\', if: customStyle } --><!-- /ko -->';
    }

    if (typeof prop != 'undefined') {
      html += '<!-- ko with: ' + prop + ' -->';

      /* PREVIEW */
      if (level == 1 && typeof prop != 'undefined') {
        if (typeof model._previewBindings != 'undefined' && typeof withBindingProvider != 'undefined') {
          if (typeof rootPreviewBinding != 'undefined') html += '<!-- ko with: $root.content() --><div class="objPreview" data-bind="' + rootPreviewBinding + '"></div><!-- /ko -->';
          if (typeof previewBackground != 'undefined') html += '<!-- ko with: $parent --><div class="objPreview" data-bind="' + previewBackground + '"></div><!-- /ko -->';
          var previewBindings = elaborateDeclarations(undefined, model._previewBindings, templateUrlConverter, withBindingProvider.bind(this, path + '.'));
          html += '<div class="objPreview"><div class="objPreviewInner" data-bind="' + previewBindings + '"></div></div>';
        }
      }
    }

    /* PREVIEW */
    var previewBG;
    if (level === 0) {
      if (typeof model._previewBindings != 'undefined') {
        previewBG = elaborateDeclarations(undefined, model._previewBindings, templateUrlConverter, withBindingProvider.bind(this, path.length > 0 ? path + '.' : ''));
      }
    }

    var i, newPath;

    var before = html.length;

    var newThemeModel;
    var newGlobalStyleProp;

    for (i = 0; i < props.length; i++) {
      newPath = path.length > 0 ? path + "." + props[i] : props[i];
      if (typeof model[props[i]] != 'object' || model[props[i]] === null || typeof model[props[i]]._widget != 'undefined') {
        newGlobalStyleProp = undefined;
        if (level === 0 && props[i] == 'theme')
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, 0, baseThreshold, undefined, undefined, trackUsage, rootPreviewBinding);
        else {
          newGlobalStyleProp = _getGlobalStyleProp(globalStyles, model[props[i]], props[i], newPath);
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, level + 1, baseThreshold, globalStyles, newGlobalStyleProp, trackUsage, rootPreviewBinding, previewBG);
        }
      }
    }
    for (i = 0; i < props.length; i++) {
      newPath = path.length > 0 ? path + "." + props[i] : props[i];
      if (!(typeof model[props[i]] != 'object' || model[props[i]] === null || typeof model[props[i]]._widget != 'undefined')) {
        newGlobalStyleProp = undefined;
        if (level === 0 && props[i] == 'theme')
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, 0, baseThreshold, undefined, undefined, trackUsage, rootPreviewBinding);
        else {
          newGlobalStyleProp = _getGlobalStyleProp(globalStyles, model[props[i]], props[i], newPath);
          html += _propEditor(withBindingProvider, widgets, templateUrlConverter, model[props[i]], newThemeModel, newPath, props[i], editType, level + 1, baseThreshold, globalStyles, newGlobalStyleProp, trackUsage, rootPreviewBinding, previewBG);
        }
      }
    }

    var added = html.length - before;
    if (added === 0) {
      // No editable content: if this is in context "template" we leave it empty, otherwise we show an help.
      if (typeof model == 'object' && model !== null && model._context == 'template') {
        return '';
      } else {
        // TODO move me to a tmpl?
        html += '<div class="objEmpty" data-bind="html: $root.t(\'Selected element has no editable properties\')">Selected element has no editable properties</div>';
      }
    }

    if (typeof prop != 'undefined') {
      html += '<!-- /ko -->';
    }
    html += '</div>';

  } else {
    var checkboxes = true;

    if (typeof globalStyles == 'undefined') checkboxes = false;

    if (model === null || typeof model != 'object' || typeof model._widget != 'undefined') {
      var bindings = [];

      if (typeof globalStyleProp != 'undefined') bindings.push('css: { notnull: ' + prop + '() !== null }');
      title = model !== null && typeof model._help !== 'undefined' ? ' title="' + utils.addSlashes(model._help) + '" data-bind="attr: { title: $root.ut(\'template\', \'' + utils.addSlashes(model._help) + '\') }"' : '';
      if (title.length > 0) bindings.push('tooltips: {}');
      var bind = bindings.length > 0 ? 'data-bind="' + utils.addSlashes(bindings.join()) + '"' : '';
      html += '<div class="propEditor ' + (checkboxes ? 'checkboxes' : '') + '"' + bind + '>';

      var modelName2 = (model !== null && typeof model._name != 'undefined' ? model._name : (typeof prop !== 'undefined' ? '[' + prop + ']' : ''));
      modelName2 = '<span data-bind="text: $root.ut(\'template\', \'' + utils.addSlashes(modelName2) + '\')">' + modelName2 + '</span>';
      html += '<span' + title + ' class="propLabel">' + modelName2 + '</span>';
      html += '<div class="propInput ' + (typeof globalStyles != 'undefined' ? 'local' : '') + '" data-bind="css: { default: ' + prop + '() === null }">';
      html += _propInput(model, prop, propAccessor, editType, widgets);
      html += '</div>';
      if (typeof globalStyleProp != 'undefined') {
        html += '<div class="propInput global" data-bind="css: { overridden: ' + prop + '() !== null }">';
        html += _propInput(model, prop, globalStyleProp, editType, widgets);
        html += '</div>';

        if (checkboxes) {
          html += '<div class="propCheck"><label data-bind="tooltips: {}"><input type="checkbox" data-bind="focusable: true, click: function(evt, obj) { $root.localGlobalSwitch(' + prop + ', ' + globalStyleProp + '); return true; }, checked: ' + prop + '() !== null">';
          html += '<span class="checkbox-replacer" data-bind="css: { checked: ' + prop + '() !== null }, attr: { title: $root.t(\'This style is specific for this block: click here to remove the custom style and revert to the theme value\') }"></span>';
          html += '</label></div>';
        }
      }
      html += '</div>';
    } else if (model === null || typeof model != 'object') {
      // TODO remove debug output
      html += '<div class="propEditor unknown">[A|' + prop + "|" + typeof model + ']</div>';
    } else {
      // TODO remove debug output
      html += '<div class="propEditor unknown">[B|' + prop + "|" + typeof model + ']</div>';
    }


  }

  if (typeof prop != 'undefined' && !!trackUsage) {
    html += '<!-- /ko -->';
    html += '<!-- ko ifSubs: { not: true, data: ' + ifSubsProp + ', threshold: ' + ifSubsThreshold + ', gutter: 0 } -->';
    html += '<span class="label notused">(' + prop + ')</span>';
    html += '<!-- /ko -->';
  }

  return html;
};


var createBlockEditor = function(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, editType, templateCreator, baseThreshold, trackGlobalStyles, trackUsage, fromLevel) {
  if (typeof trackUsage == 'undefined') trackUsage = true;
  var model = modelDef.getDef(defs, templateName);

  var rootModel = modelDef.getDef(defs, rootModelName);
  var rootPreviewBindings;
  if (typeof rootModel._previewBindings != 'undefined' && templateName != 'thaeme' && editType == 'styler') {
    rootPreviewBindings = elaborateDeclarations(undefined, rootModel._previewBindings, templateUrlConverter, modelDef.getBindValue.bind(undefined, defs, themeUpdater, rootModelName, rootModelName, ''));
  }

  var globalStyles = typeof trackGlobalStyles != 'undefined' && trackGlobalStyles ? defs[templateName]._globalStyles : undefined;
  var globalStyleProp = typeof trackGlobalStyles != 'undefined' && trackGlobalStyles ? defs[templateName]._globalStyle : undefined;


  var themeModel;
  if (typeof globalStyleProp !== 'undefined') {
    var mm = modelDef.getDef(defs, 'theme');
    // TODO remove deprecated $theme
    themeModel = mm[globalStyleProp.replace(/^(\$theme|_theme_)\./, '')];
  }


  var withBindingProvider = modelDef.getBindValue.bind(undefined, defs, themeUpdater, rootModelName, templateName);
  withBindingProvider._templateName = templateName;

  var html = '<div class="editor">';
  html += "<div class=\"blockType" + (typeof globalStyles != 'undefined' ? " withdefaults" : "") + "\">" + model.type + "</div>";

  var editorContent = _propEditor(withBindingProvider, widgets, templateUrlConverter, model, themeModel, "", undefined, editType, fromLevel, baseThreshold, globalStyles, globalStyleProp, trackUsage, rootPreviewBindings);
  if (editorContent.length > 0) {
    html += editorContent;
  }

  html += '</div>';

  templateCreator(html, templateName, editType);
};

var createBlockEditors = function(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, templateCreator, baseThreshold) {
  createBlockEditor(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, 'edit', templateCreator, baseThreshold);
  createBlockEditor(defs, widgets, themeUpdater, templateUrlConverter, rootModelName, templateName, 'styler', templateCreator, baseThreshold, true);
};

var generateEditors = function(templateDef, widgets, templateUrlConverter, templateCreator, baseThreshold) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;
  var blocks = templateDef._blocks;
  var idx;
  var blockDefs = [];
  for (idx = 0; idx < blocks.length; idx++) {
    if (typeof blocks[idx].container !== 'undefined') {
      blockDefs.push(modelDef.generateModel(defs, blocks[idx].block));
    }
    createBlockEditors(defs, widgets, undefined, templateUrlConverter, blocks[idx].root, blocks[idx].block, templateCreator, baseThreshold);
  }

  if (typeof defs['theme'] != 'undefined') createBlockEditor(defs, widgets, undefined, templateUrlConverter, templateName, 'theme', 'styler', templateCreator, undefined, false, false, -1);
  return blockDefs;
};

module.exports = generateEditors;

},{"./../../../bower_components/console-browserify/index.js":1,"./declarations.js":42,"./model.js":46,"./utils.js":49}],45:[function(require,module,exports){
"use strict";
/* global global: false */

var modelDef = require("./model.js");

var wrappedResultModel = function(templateDef) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;
  var finalModelContentDef = modelDef.getDef(defs, templateName);

  var finalModelContent = modelDef.generateResultModel(templateDef);

  var wrapper = require("./wrapper.js");
  var res = wrapper(finalModelContent, finalModelContentDef, defs);

  return res;
};

// requires only when imported
var translateTemplate = function() {
  var tt = require('./parser.js');
  return tt.apply(tt, arguments);
};

// requires only when imported
var generateEditors = function() {
  var ge = require('./editor.js');
  return ge.apply(ge, arguments);
};

var checkModel = function() {
  var cm = require('./checkmodel.js');
  return cm.apply(cm, arguments);
};

module.exports = {
  translateTemplate: translateTemplate,
  wrappedResultModel: wrappedResultModel,
  generateResultModel: modelDef.generateResultModel,
  generateEditors: generateEditors,
  checkModel: checkModel
};
},{"./checkmodel.js":41,"./editor.js":44,"./model.js":46,"./parser.js":47,"./wrapper.js":50}],46:[function(require,module,exports){
"use strict";

var objExtend = require("./domutils.js").objExtend;
var console = require("./../../../bower_components/console-browserify/index.js");

var _valueSet = function(defs, model, prop, value) {
  var dotPos = prop.indexOf('.');
  if (dotPos == -1) {
    if (typeof model[prop] == 'undefined') {
      console.log("Undefined prop " + prop + " while setting value " + value + " in model._valueSet");
    } else if (model[prop] === null) {
      if (typeof value == 'object' && value !== null && typeof value.push == 'undefined') console.log("nullpropobjectvalue", prop, value);
      model[prop] = value;
    } else if (typeof model[prop] == 'object' && typeof model[prop].push == 'function') {
      var values;
      if (typeof value === 'string') {
        var valuesString = value.match(/^\[(.*)\]$/);
        if (valuesString !== null) {
          values = valuesString[1].split(',');
        } else {
          throw "Unexpected default value for array property " + prop + ": " + value;
        }
      } else if (typeof value === 'object' && typeof value.push !== 'undefined') {
        values = value;
      } else {
        throw "Unexpected default value for array property " + prop + ": " + value + " typeof " + (typeof value);
      }
      var res = [];
      for (var i = 0; i < values.length; i++) {
        if (values[i].substr(0, 1) == '@') {
          // TODO remove this legacy support (@), so we can remove "defs" from this function, too.
          res.push(_generateModel(defs, values[i].substr(1)));
        } else if (values[i].length > 0) {
          res.push(values[i]);
        }
      }
      model[prop] = res;
    } else if (typeof model[prop] == 'string' || typeof model[prop] == 'boolean') {
      // TODO does this still happen? Debug/test me.
      model[prop] = value;
    } else if (typeof model[prop] == 'object' && model[prop] !== null && typeof model[prop]._widget != 'undefined') {
      if (typeof value == 'object' && value !== null) console.log("objectvalue", prop, model[prop]._widget, value);
      // _data is defined for primitive types
      model[prop] = value;
    } else {
      console.log("setting", typeof model[prop], model[prop], prop, value);
    }
  } else {
    var propName = prop.substr(0, dotPos);
    _valueSet(defs, model[propName], prop.substr(dotPos + 1), value);
  }
};

var _modelCreateOrUpdateBlockDef = function(defs, templateName, properties, namedProperties) {
  if (typeof defs[templateName] !== 'undefined' && defs[templateName]._initialized && !defs[templateName]._writeable) {
    console.log("_modelCreateOrUpdateBlockDef", defs, templateName, properties, namedProperties);
    throw "Trying to alter non writeable model: " + templateName + " / " + properties;
  }

  if (typeof defs[templateName] == 'undefined') {
    defs[templateName] = {
      _writeable: true
    };
    // Fallback computation of "category" depending on the property name
    // TODO remove me: this should be always defined in the template definition, no need to hardcode this stuff.
    if (typeof namedProperties == 'undefined') namedProperties = {};
    if (typeof namedProperties.category == 'undefined' && typeof defs[templateName]._category == 'undefined') {
      if (templateName.match(/(^t|.T)heme$/) || templateName.match(/(^s|.S)tyle$/) || templateName.match(/(^c|.C)olor$/) || templateName.match(/(^r|.R)adius$/)) {
        namedProperties.category = 'style';
      } else {
        namedProperties.category = 'content';
      }
    }
  }


  if (typeof namedProperties !== 'undefined') {
    // TODO check if this is needed before the ending namedProperty "loop" or not.
    if (typeof namedProperties.name != 'undefined') defs[templateName]._name = namedProperties.name;

    if (typeof namedProperties.themeOverride != 'undefined') {
      defs[templateName]._themeOverride = namedProperties.themeOverride;
    }
    if (typeof namedProperties.globalStyle != 'undefined') {
      defs[templateName]._globalStyle = namedProperties.globalStyle;
      // TODO remove deprecated $theme
      var globalStyleSub = namedProperties.globalStyle.replace(/^(\$theme|_theme_)\./, '');
      var p = globalStyleSub.indexOf('.');
      var gs = p != -1 ? globalStyleSub.substr(0, p) : globalStyleSub;
      _modelCreateOrUpdateBlockDef(defs, 'theme', gs);

      if (typeof defs[templateName]._themeOverride === 'undefined' || !!defs[templateName]._themeOverride) {
        _modelCreateOrUpdateBlockDef(defs, templateName, "customStyle=false");
      }
    }
    if (typeof namedProperties.contextName !== 'undefined') {
      defs[templateName]._context = namedProperties.contextName;
      // TODO is it correct to fallback to "bodyTheme" for blocks not declaring a default theme?
      // Maybe it would be better to simply declare it as mandatory but leave the default configutation
      // to the template definition.
      if (namedProperties.contextName == 'block' && typeof defs[templateName]._globalStyle == 'undefined') {
        defs[templateName]._globalStyle = '_theme_.bodyTheme';
        _modelCreateOrUpdateBlockDef(defs, 'theme', 'bodyTheme');

        if (typeof defs[templateName]._themeOverride == 'undefined' || defs[templateName]._themeOverride) {
          _modelCreateOrUpdateBlockDef(defs, templateName, "customStyle=false");
        }
      }
    }
    if (typeof namedProperties.extend != 'undefined') defs[templateName].type = namedProperties.extend;
  }

  for (var np in namedProperties) if (namedProperties.hasOwnProperty(np) && typeof namedProperties[np] !== 'undefined' && ['name', 'extend', 'contextName', 'globalStyle','themeOverride'].indexOf(np) == -1) {
    defs[templateName]['_'+np] = namedProperties[np];
  }

  if (typeof properties != 'undefined' && properties.length > 0) {
    defs[templateName]._props = typeof defs[templateName]._props != 'undefined' && defs[templateName]._props.length > 0 ? defs[templateName]._props + " " + properties : properties;
  }
};

// remove the first "sequence" in a camelcased word (e.g: myCamelCase => camelCase).
var _removePrefix = function(str) {
  var res = str.match(/^[^A-Z]+([A-Z])(.*)$/);
  return res !== null ? res[1].toLowerCase() + res[2] : null;
};

// TODO defs is needed only because _valueSet needs it.. we should remove it downstream.
var _generateModelFromDef = function(modelDef, defs) {
  var res = {};

  for (var prop in modelDef)
    if (!prop.match(/^_.*/) && modelDef.hasOwnProperty(prop)) {
      var value = modelDef[prop];
      if (typeof value == 'object' && value !== null && typeof value._complex != 'undefined' && value._complex) {
        res[prop] = _generateModelFromDef(value, defs);
      } else if (prop == 'type') {
        res[prop] = value;
      } else if (typeof value == 'object') {
        // most times this will be overwritten by _valueSet
        res[prop] = null;
        // for customStyle this is set to null.
      } else {
        console.error("Unexpected model def", prop, value, modelDef);
        throw "Unexpected model def [" + prop + "]=" + value;
      }
    }

  if (typeof modelDef._defaultValues != 'undefined') {
    var defaults = modelDef._defaultValues;
    for (var prop2 in defaults)
      if (defaults.hasOwnProperty(prop2)) {
        _valueSet(defs, res, prop2, defaults[prop2]);
      }
  }

  return res;
};

var _generateModel = function(defs, name) {
  var modelDef = _getModelDef(defs, name, false, true);
  return _generateModelFromDef(modelDef, defs);
};

var _getDef = function(defs, name) {
  return _getModelDef(defs, name, false, true);
};

var _getModelDef = function(defs, name, returnClone, readonly) {
  // lookup "name" in the template definition
  if (typeof defs[name] == 'undefined') {
    // if the name has a space then returns.
    if (name.indexOf(' ') != -1) return null;
    // otherwise try looking up using a deprefixed name.
    var res = _removePrefix(name);
    if (res !== null) {
      // TODO the deprefixing is powerful, but maybe not really needed.
      return _getModelDef(defs, res, returnClone, readonly);
    }
    // not a prefixed name
    // TODO should we raise an error?
    return null;
  } else {
    // when the name is already defined...
    var defObj = defs[name];
    if (typeof defObj != 'object') throw "Block definition must be an object: found " + defObj + " for " + name;

    if (typeof defObj._initialized == 'undefined') {
      // Populate "type" depending on name
      if (typeof defObj.type == 'undefined') {
        if (name.indexOf(' ') == -1) {
          defObj.type = name;
        } else {
          defObj.type = name.substr(name.indexOf(' ') + 1);
        }
      }

      // If it is not a "data" type then let's deal with inheritance
      if (defObj.type != name && typeof defObj._widget == 'undefined') {
        var typeDef = _getModelDef(defs, defObj.type, true);
        var extended = objExtend(typeDef, defObj);
        defObj = extended;
        defs[name] = defObj;
      } else if (typeof defObj._widget == 'undefined' && typeof defObj._props == 'undefined' && typeof defObj._complex == 'undefined') {
        // TODO here I tried to deal with inheritance for every object without a "type" by using a simple deprefix.
        // but this break on theme containing "pageTheme" that would inherit from is parent. (creating a loop)
        /*
        var superType = _removePrefix(defObj.type);
        if (superType !== null) {
          console.log("Extending", typeDef, name, superType, defObj.type);
          var typeDef = _getModelDef(defs, superType, true);
          
          var extended = jQuery.extend(true, typeDef, defObj);
          defObj = extended;
          defs[name] = defObj;
        }
        */
      }
      defObj._writeable = true;
      defObj._initialized = true;
    }

    if (typeof defObj._props != 'undefined') {
      var def = defObj._props;
      def = def.split(" ");

      if (def.length > 0 && typeof defObj._writeable == 'undefined') {
        console.error("Altering a non writable object ", name, def, defObj);
        throw "Altering a non writable object: " + name + " def: " + def;
      }

      if (typeof defObj._processedDefs == 'undefined') {
        defObj._processedDefs = {};
      }

      if (typeof defObj._globalStyles == 'undefined') {
        defObj._globalStyles = {};
      }

      if (typeof defObj._defaultValues == 'undefined') {
        defObj._defaultValues = {};
      }

      for (var i = 0; i < def.length; i++) {
        var prop = def[i];
        if (prop.length === 0) continue;
        var origProp = prop;
        var defValue = null;
        // parses  "prop" "prop=value" and "prop[]" declarations
        var propDef = prop.match(/^([^=\[\]]+)(\[\])?(=?)(.*)$/);
        if (propDef !== null) {
          prop = propDef[1];
          // TODO array definition should be done differently
          if (propDef[2] == '[]') {
            // TODO type should not be defined in this function
            if (typeof defObj[prop] == 'undefined') defObj[prop] = [];
            defValue = [];
          }
          if (propDef[3] == '=') {
            // TODO remove hardcoded "visible" matching (this should be defined in the template definition)
            if (prop.match(/(^v|V)isible$/)) defValue = String(propDef[4]).toLowerCase() == 'true';
            else if (prop.match(/^customStyle$/)) {
              defValue = String(propDef[4]).toLowerCase() == 'true';
            } else defValue = propDef[4];
          }
        }
        // default values found in "properties" are not being processed by "modelEnsureValue" and by consequence do not call "themeUpdater".
        // TODO document why this is needed, or remove.
        if (defValue !== null) {
          if (typeof defObj._defaultValues[prop] == 'undefined') {
            // if (prop.match(/^_/)) console.log("defValue for", prop, "in", name);
            defObj._defaultValues[prop] = defValue;
          }
        }

        if (typeof defObj[prop] == 'undefined') {
          var val = _getModelDef(defs, name + ' ' + prop, true);
          if (val === null) {
            val = _getModelDef(defs, prop, true);
          }
          defObj[prop] = val;
        }

        defObj._processedDefs[prop] = origProp;
        defObj._complex = true;
      }

      delete defObj._props;
    }

    if (returnClone) {
      defObj._writeable = false;
      var cloned = objExtend({}, defObj);
      return cloned;
    } else if (readonly) {
      defObj._writeable = false;
      return defObj;
    } else {
      if (typeof defObj._writeable == 'undefined' || defObj._writeable === false) throw "Retrieving non writeable object definition: " + name;
      return defObj;
    }
  }
};

var _increaseUseCount = function(readonly, model) {
  if (!readonly) {
    if (typeof model._usecount == 'undefined') model._usecount = 0;
    model._usecount++;
  } else if (typeof model._usecount == 'undefined') {
    console.error("ERROR trying to bind an unused property while readonly", model);
    throw "ERROR trying to bind an unused property";
  }
};

var ensureGlobalStyle = function(defs, readonly, gsBindingProvider, modelName, path, gsFullPath, defaultValue, overrideDefault) {

  var globalStyleBindingBindValue = gsBindingProvider(gsFullPath, defaultValue, overrideDefault);

  if (typeof defs[modelName]._globalStyles[path] == 'undefined') {
    if (readonly) throw "Cannot find _globalStyle for " + path + " in " + modelName + "!";
    if (path.indexOf('.') != -1 || (typeof defs[modelName][path] == 'object' && typeof defs[modelName][path]._widget !== 'undefined')) {
      defs[modelName]._globalStyles[path] = globalStyleBindingBindValue;
    }
  } else if (defs[modelName]._globalStyles[path] != globalStyleBindingBindValue) throw "Unexpected conflicting globalStyle [2] for " + modelName + "/" + path + ": old=" + defs[modelName]._globalStyles[path] + " new=" + globalStyleBindingBindValue;
};

// themeUpdater, defaultValue, overrideDefault, setcategory are only used in !readonly mode
var modelEnsurePathAndGetBindValue = function(readonly, defs, themeUpdater, rootModelName, templateName, within, fullPath, defaultValue, overrideDefault, setcategory) {
  var modelName;
  var res;
  var path;
  // TODO remove '$' and '#' handing
  if (fullPath.substr(0, 1) == '$') {
    console.warn("DEPRECATED $ in bindingProvider: ", fullPath, templateName);
    var p = fullPath.indexOf('.');
    if (p == -1) {
      throw "Unexpected fullPath: " + fullPath + "/" + within + "/" + templateName + "/" + defaultValue + "/" + overrideDefault;
    } else {
      modelName = fullPath.substr(1, p - 1);
      path = fullPath.substr(p + 1);
      // TODO refactor me please
      if (modelName == 'theme') {
        var p2 = path.indexOf('.');
        modelName = path.substr(0, p2);
        path = path.substr(p2 + 1);
      } else {
        throw "Unexpected $ sequence: " + modelName + " in " + fullPath;
      }
      res = "$root.content().theme()." + modelName + "()." + path.replace(new RegExp('\\.', 'g'), '().');
    }
  } else if (fullPath.substr(0, 1) == '#') {
    console.warn("DEPRECATED # in bindingProvider: ", fullPath, templateName);
    modelName = rootModelName;
    path = fullPath.substr(1);
    res = "$root.content()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else if (fullPath.substr(0, 8) == '_theme_.') {
    var p3 = fullPath.indexOf('.', 8);
    modelName = fullPath.substr(8, p3 - 8);
    path = fullPath.substr(p3 + 1);
    res = "$root.content().theme()." + modelName + "()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else if (fullPath.substr(0, 7) == '_root_.') {
    modelName = rootModelName;
    path = fullPath.substr(7);
    res = "$root.content()." + path.replace(new RegExp('\\.', 'g'), '().');
  } else {
    modelName = templateName;
    path = within + fullPath;
    res = fullPath.replace(new RegExp('\\.', 'g'), '().');
  }

  if (typeof defs[modelName] === 'undefined') throw "Cannot find model def for [" + modelName + "]";

  var propPos = path.indexOf('.');
  var propName = propPos == -1 ? path : path.substr(0, propPos);

  if (modelName.indexOf('-') != -1) {
    console.error("ERROR cannot use - for block names", modelName);
    throw "ERROR unexpected char in block name: " + modelName;
  }
  if (propName.indexOf('-') != -1) {
    console.error("ERROR cannot use - for property names", propName);
    throw "ERROR unexpected char in property name: " + modelName;
  }

  // Fastpath
  if (readonly) {
    if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] !== 'undefined' && defs[modelName][propName]._category == 'style') {
      res += '._defaultComputed';
    }
    return res;
  }

  // gets the writable model when "!readonly" or the readonly model otherwise
  var model;
  if (readonly) {
    if (typeof defaultValue !== 'undefined') throw "Cannot use defaultValue in readonly mode!";
    if (overrideDefault) throw "Cannot use overrideDefault in readonly mode for " + modelName + "/" + path + "/" + overrideDefault + "!";
    if (typeof setcategory !== 'undefined') throw "Cannot set category for " + modelName + "/" + path + "/" + setcategory + " in readonly mode!";
    model = _getModelDef(defs, modelName, false, true);
  } else {
    if (defs[modelName]._writeable === false) console.log("TODO debug use cases for this condition", modelName, path);
    model = _getModelDef(defs, modelName, defs[modelName]._writeable === false);
  }

  if (model === null) throw "Unexpected model for [" + modelName + "]";

  // if the property does not exists we have to create it.
  if (typeof model[propName] == 'undefined') {
    // when in readonly mode this cannot be done!
    if (readonly) throw "Cannot find path " + propName + " for " + modelName + "!";
    _modelCreateOrUpdateBlockDef(defs, modelName, propName);
    model = _getModelDef(defs, modelName, false);
  }

  // Needs to do this again, because "_modelCreateOrUpdateBlockDef" could have been just created the property (e.g: backgroundColor buttonBlock not getting defaultComputed in template-lm)
  if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] !== 'undefined' && defs[modelName][propName] !== null && defs[modelName][propName]._category == 'style') {
    res += '._defaultComputed';
  }

  var childModel = model;
  try {
    _increaseUseCount(readonly, childModel);
    if (propPos != -1) {
      var mypath = path;
      do {
        var prop = mypath.substr(0, propPos);
        if (typeof childModel[prop] == 'undefined') {
          throw "Found an unexpected prop " + prop + " for model " + modelName + " for " + path;
        }

        childModel = childModel[prop];
        _increaseUseCount(readonly, childModel);
        mypath = mypath.substr(propPos + 1);
        propPos = mypath.indexOf('.');
      } while (propPos != -1);

      if (typeof childModel[mypath] == 'undefined' || childModel[mypath] === null) {
        throw "Found an unexpected path termination " + mypath + " for model " + modelName + " for " + path;
      }
      childModel = childModel[mypath];
    } else {
      childModel = childModel[path];
    }

    if (typeof childModel === 'undefined' || childModel === null) throw "Unexpected null model for " + modelName + "/" + within + "/" + fullPath;

    if (typeof setcategory !== 'undefined') {
      childModel._category = setcategory;
    }

    _increaseUseCount(readonly, childModel);
  } catch (e) {
    console.error("TODO ERROR Property lookup exception", e, modelName, path, templateName, fullPath, defs);
    throw e;
  }

  if (typeof defs[modelName]._globalStyle !== 'undefined' && typeof defs[modelName][propName] == 'object' && defs[modelName][propName] !== null && typeof defs[modelName][propName]._category != 'undefined' && defs[modelName][propName]._category == 'style') {
    // TODO can I restrict this code to !readonly mode?
    var gsBindingProvider = modelEnsurePathAndGetBindValue.bind(undefined, readonly, defs, themeUpdater, rootModelName, templateName, '');

    var subPath = path.indexOf('.') != -1 ? path.substr(path.indexOf('.')) : '';

    // The next code supports only properties with one dot (object.property).
    if (subPath.indexOf('.', 1) != -1) throw "TODO unsupported object nesting! " + path;

    var gsPath = defs[modelName]._globalStyle + '.' + propName;
    if (typeof defs[modelName][propName] == 'object' && defs[modelName][propName] !== null && typeof defs[modelName][propName]._globalStyle != 'undefined') {
      gsPath = defs[modelName][propName]._globalStyle;
    }

    ensureGlobalStyle(defs, readonly, gsBindingProvider, modelName, propName, gsPath, undefined, false);

    var gsFullPath = gsPath + subPath;

    if (typeof defaultValue == 'undefined' && defs[modelName]._defaultValues[path] !== null) defaultValue = defs[modelName]._defaultValues[path];

    ensureGlobalStyle(defs, readonly, gsBindingProvider, modelName, path, gsFullPath, defaultValue, overrideDefault);

    if (typeof defaultValue !== 'undefined') {
      if (readonly) {
        console.error("Cannot set a new theme default value", gsFullPath.substr(7), defaultValue, "while in readonly mode");
        throw "Cannot set a new theme default value (" + defaultValue + ") for " + gsFullPath.substr(7) + " while in readonly mode!";
      }
      themeUpdater('default', gsFullPath.substr(7), defaultValue);
    }

    // TODO complex stuff. If the theme uses inheritance we enforce it using with the same value, but this is a limit.
    defaultValue = null;

  }

  if (typeof defaultValue != 'undefined') {
    if (typeof defs[modelName]._defaultValues[path] == 'undefined' || (typeof overrideDefault != 'undefined' && overrideDefault)) {
      if (readonly) throw "Cannot set new _defaultValues [1] for " + path + " in " + modelName + "!";
      defs[modelName]._defaultValues[path] = defaultValue;
    } else {
      if (defaultValue === null) {
        if (readonly && defs[modelName]._defaultValues[path] !== null) {
          throw "Cannot set new _defaultValues [2] for " + path + " in " + modelName + "!";
        }
        // This remove default value. Ugly. (Needs this for defaults in template-lm socialLinksIcon)
        defs[modelName]._defaultValues[path] = null;
      } else if (defs[modelName]._defaultValues[path] != defaultValue) {
        console.error("TODO error!!! Trying to set a new default value for " + modelName + " " + path + " while it already exists (current: " + defs[modelName]._defaultValues[path] + ", new: " + defaultValue + ")");
        throw "Trying to set a new default value for " + modelName + " " + path + " while it already exists (current: " + defs[modelName].defaultValues[path] + ", new: " + defaultValue + ")";
      }
    }
  }

  return res;
};

var generateResultModel = function(templateDef) {
  var defs = templateDef._defs;
  var templateName = templateDef.templateName;

  var finalModelContent = _generateModel(defs, templateName);

  // TODO ugly to add this manually
  if (typeof defs['theme'] !== 'undefined') {
    finalModelContent.theme = _generateModel(defs, 'theme');
  }

  return finalModelContent;
};

module.exports = {
  // used to compile the template
  ensurePathAndGetBindValue: modelEnsurePathAndGetBindValue.bind(undefined, false),
  // used in runtime the template
  getBindValue: modelEnsurePathAndGetBindValue.bind(undefined, true),
  generateModel: _generateModel,
  generateResultModel: generateResultModel,
  getDef: _getDef,
  createOrUpdateBlockDef: _modelCreateOrUpdateBlockDef
};
},{"./../../../bower_components/console-browserify/index.js":1,"./domutils.js":43}],47:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
var converterUtils = require("./utils.js");
var elaborateDeclarations = require("./declarations.js");
var processStylesheetRules = require("./stylesheet.js");
var modelDef = require("./model.js");
var domutils = require("./domutils.js");

var wrapElementWithCondition = function(attribute, element, bindingProvider) {
  var cond = domutils.getAttribute(element, attribute);

  try {
    var binding = converterUtils.conditionBinding(cond, bindingProvider);
    $(element).before('<!-- ko if: ' + binding + ' -->');
    $(element).after('<!-- /ko -->');
    domutils.removeAttribute(element, attribute);
  } catch (e) {
    console.warn("Model ensure path failed in if/variant", element, cond, attribute);
    throw e;
  }

};

var replacedAttributes = function(element, attributeName) {
  domutils.setAttribute(element, attributeName, domutils.getAttribute(element, "replaced" + attributeName));
};

var processStyle = function(element, templateUrlConverter, bindingProvider, addUniqueId) {
  var style = domutils.getAttribute(element, 'replacedstyle');
  var newStyle = null;
  var newBindings;
  if (addUniqueId) newBindings = {
    uniqueId: '$data',
    attr: {
      id: 'id'
    }
  };

  var removeDisplayNone = domutils.getAttribute(element, 'data-ko-display') !== null;

  newStyle = elaborateDeclarations(style, undefined, templateUrlConverter, bindingProvider, element, newBindings, removeDisplayNone);

  // only when using "replaced"
  if (newStyle === null) {
    newStyle = style;
  } else {
    // in case there are no bindings we keep replacedstyle to be used by IE during output
    // otherwise I remove it because it will be overwritten by virtualAttrStyle binding.
    // TODO maybe we better use different names for "replaced" used during template conversion
    // and the ones used to create the output.
    domutils.removeAttribute(element, 'replacedstyle');
  }

  if (newStyle !== null) {
    if (newStyle.trim().length > 0) {
      domutils.setAttribute(element, 'style', newStyle);
    } else domutils.removeAttribute(element, 'style');
  }
};


// TODO fixing URLs is also needed where styles uses path (e.g: background-image, @import)
var _fixRelativePath = function(attribute, templateUrlConverter, index, element) {
  var url = domutils.getAttribute(element, attribute);
  var newUrl = templateUrlConverter(url);
  if (newUrl !== null) {
    domutils.setAttribute(element, attribute, newUrl);
  }
};


var processBlock = function(element, defs, themeUpdater, blockPusher, templateUrlConverter, contextName, rootModelName, containerName, generateUniqueId, templateCreator) {

  try {

  var templateName;
  var variantName = '',
    variantDef = '';
  if (contextName == 'block') {
    templateName = domutils.getAttribute(element, 'data-ko-block');
    domutils.removeAttribute(element, 'data-ko-block');
  } else if (contextName == 'template') {
    templateName = rootModelName;
  } else {
    throw "Unexpected context name while processing block: " + contextName;
  }

  // console.log("processBlock", contextName, rootModelName, containerName, templateName);

  // Remove element
  $('[data-ko-remove]', element).remove();

  var fixedBlocks = $('[data-ko-block]', element).replaceWith('<replacedblock>');

  // Urls in these attributes needs "relativization"
  var urlattrs = ['href', 'src', 'data-ko-placeholder-src', 'background'];
  for (var i = 0; i < urlattrs.length; i++) {
    // faccio il bind per non definire funzioni in un loop (jshint)
    var func = _fixRelativePath.bind(undefined, urlattrs[i], templateUrlConverter);
    $('[' + urlattrs[i] + ']', element).each(func);
  }

  var dataDefs = domutils.getAttribute(element, 'data-ko-properties');
  if (dataDefs === null) dataDefs = "";
  $("[data-ko-properties]", element).each(function(index, element) {
    if (dataDefs.length > 0) dataDefs = dataDefs + " ";
    dataDefs = dataDefs + domutils.getAttribute(element, 'data-ko-properties');
    domutils.removeAttribute(element, 'data-ko-properties');
  });

  modelDef.createOrUpdateBlockDef(defs, templateName, dataDefs, { contextName: contextName });

  var bindingProvider = modelDef.ensurePathAndGetBindValue.bind(undefined, defs, themeUpdater, rootModelName, templateName, '');
  if (contextName == 'block') bindingProvider('id', '');

  $('style', element).each(function(index, element) {
    var style = domutils.getInnerHtml(element);

    var blockDefsUpdater = modelDef.createOrUpdateBlockDef.bind(undefined, defs);
    var localWithBindingProvider = modelDef.ensurePathAndGetBindValue.bind(undefined, defs, themeUpdater, rootModelName);
    var newStyle = processStylesheetRules(style, undefined, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName);

    if (newStyle != style) {
      if (newStyle.trim() !== '') {
        var tmpName = templateCreator(newStyle);
        domutils.setAttribute(element, 'data-bind', 'template: { name: \'' + tmpName + '\' }');
        // ho creato il template quindi posso svuotare il sorgente.
        domutils.setContent(element, '');
      } else {
        // remove empty styles blocks
        domutils.removeElements($(element));
      }
    }
  });

  processStyle(element, templateUrlConverter, bindingProvider, generateUniqueId);

  // TODO href should be supported. data-ko-display and data-ko-wrap should never happen in here.
  var notsupported = ['data-ko-display', 'data-ko-editable', 'data-ko-wrap', 'href'];
  for (var j = 0; j < notsupported.length; j++) {
    var attr = domutils.getAttribute(element, notsupported[j]);
    if (attr) {
      console.warn("ERROR: Unsupported " + notsupported[j] + " used together with data-ko-block", element);
      throw "ERROR: Unsupported " + notsupported[j] + " used together with data-ko-block";
    }
  }

  // simply preprocessed as data-ko-wrap + -ko-attr-href
  $("[data-ko-link]", element).each(function(index, element) {
    var urlVar = domutils.getAttribute(element, 'data-ko-link');
    var repStyle = domutils.getAttribute(element, 'replacedstyle');
    if (typeof repStyle == 'undefined' || repStyle === null) repStyle = '';
    if (repStyle !== '') repStyle = '-ko-attr-href: @' + urlVar + "; " + repStyle;
    else repStyle = '-ko-attr-href: @' + urlVar;
    domutils.setAttribute(element, 'replacedstyle', repStyle);
    domutils.setAttribute(element, 'data-ko-wrap', urlVar);
    domutils.removeAttribute(element, 'data-ko-link');
  });

  $("[replacedstyle]", element).each(function(index, element) {
    processStyle(element, templateUrlConverter, bindingProvider, false);
  });

  $("[replacedhttp-equiv]", element).each(function(index, element) {
    replacedAttributes(element, "http-equiv");
  });

  $("[data-ko-display]", element).each(function(index, element) {
    wrapElementWithCondition('data-ko-display', element, bindingProvider);
  });

  $("[data-ko-editable]", element).each(function(index, element) {
    var newBinding, defaultValue, model, currentBindings, dataBind;


    var dataEditable = domutils.getAttribute(element, "data-ko-editable");

    // TODO add validation of the editable

    var itemBindValue;
    var selectBinding;
    if (dataEditable.lastIndexOf('.') > 0) {
      var subs = dataEditable.substr(0, dataEditable.lastIndexOf('.'));
      itemBindValue = bindingProvider(subs);
    } else {
      itemBindValue = bindingProvider(dataEditable);
    }
    selectBinding = "wysiwygClick: function(obj, evt) { $root.selectItem(" + itemBindValue + ", $data); return false }, clickBubble: false, wysiwygCss: { selecteditem: $root.isSelectedItem(" + itemBindValue + ") }, scrollIntoView: $root.isSelectedItem(" + itemBindValue + ")";

    if (domutils.getLowerTagName(element) != 'img') {


      defaultValue = domutils.getInnerHtml(element);
      var modelBindValue = bindingProvider(dataEditable, defaultValue, true, 'wysiwyg');
      newBinding = "";

      if (!domutils.getAttribute(element, "id")) {
        newBinding += "wysiwygId: id()+'_" + dataEditable.replace('.', '_') + "', ";
      }

      if (typeof selectBinding !== 'undefined') {
        newBinding += selectBinding + ", ";
      }

      newBinding += "wysiwygOrHtml: " + modelBindValue;

      if (domutils.getLowerTagName(element) == 'td') {
        var wrappingDiv = $('<div data-ko-wrap="false" style="width: 100%; height: 100%"></div>')[0];
        domutils.setAttribute(wrappingDiv, 'data-bind', newBinding);
        var newContent = domutils.getInnerHtml($('<div></div>').append(wrappingDiv));
        domutils.setContent(element, newContent);
      } else {
        currentBindings = domutils.getAttribute(element, 'data-bind');
        dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
        domutils.setAttribute(element, 'data-bind', dataBind);
        domutils.setContent(element, '');
      }
      domutils.removeAttribute(element, 'data-ko-editable');
    } else {
      var width = domutils.getAttribute(element, 'width');
      if (width === '') width = null;
      if (width === null) {
        console.error("ERROR: data-ko-editable images must declare a WIDTH attribute!", element);
        throw "ERROR: data-ko-editable images must declare a WIDTH attribute!";
      }
      var height = domutils.getAttribute(element, 'height');
      if (height === '') height = null;

      var align = domutils.getAttribute(element, 'align');

      currentBindings = domutils.getAttribute(element, 'data-bind');

      // TODO this is ugly... maybe a better strategy is to pass this around using "data-" attributes
      var dynHeight = currentBindings && currentBindings.match(/virtualAttr: {[^}]* height: ([^,}]*)[,}]/);
      if (dynHeight) height = dynHeight[1];
      var dynWidth = currentBindings && currentBindings.match(/virtualAttr: {[^}]* width: ([^,}]*)[,}]/);
      if (dynWidth) width = dynWidth[1];

      var method;

      defaultValue = domutils.getAttribute(element, 'data-ko-placeholder-src');
      // TODO make sure this default value is the same as the one checked by img-wysiwyg template.
      var value = '';
      if (defaultValue) {
        value = domutils.getAttribute(element, 'src');
      } else {
        defaultValue = domutils.getAttribute(element, 'src');
      }

      var size;
      if (width && height) {
        size = width + "+'x'+" + height;
      } else if (!height) {
        size = "'w'+" + width + "+''";
      } else if (!width) {
        size = "'h'+" + height + "+''";
      }
      var placeholdersrc;
      var plheight = height || domutils.getAttribute(element, 'data-ko-placeholder-height');
      var plwidth = width || domutils.getAttribute(element, 'data-ko-placeholder-width');

      domutils.removeAttribute(element, 'src');
      domutils.removeAttribute(element, 'data-ko-editable');
      domutils.removeAttribute(element, 'data-ko-placeholder-height');
      domutils.removeAttribute(element, 'data-ko-placeholder-width');
      domutils.removeAttribute(element, 'data-ko-placeholder-src');

      if (defaultValue) {
        placeholdersrc = "{ width: " + plwidth + ", height: " + plheight + ", text: " + size + "}";
      }

      if (!plwidth || !plheight) {
        // TODO raise an exception?
        console.error("IMG data-ko-editable must declare width and height attributes, or their placeholder counterparts data-ko-placeholder-width/data-ko-placeholder-height", element);
        throw "ERROR: IMG data-ko-editable MUST declare width and height attributes, or their placeholder counterparts data-ko-placeholder-width/data-ko-placeholder-height";
      }

      var bindingValue = bindingProvider(dataEditable, value, false, 'wysiwyg');
      newBinding = "wysiwygSrc: { width: " + width + ", height: " + height + ", src: " + bindingValue + ", placeholder: " + placeholdersrc + " }";
      dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
      domutils.setAttribute(element, 'data-bind', dataBind);

      var tmplName = templateCreator(element);

      var containerBind = '{ width: ' + width;
      if (align == 'left') containerBind += ', float: \'left\'';
      else if (align == 'right') containerBind += ', float: \'right\'';
      else if (align == 'center') console.log('non so cosa fa align=center su una img e quindi non so come simularne l\'editing');
      else if (align == 'top') containerBind += ', verticalAlign: \'top\'';
      else if (align == 'middle') containerBind += ', verticalAlign: \'middle\'';
      else if (align == 'bottom') containerBind += ', verticalAlign: \'bottom\'';
      containerBind += '}';

      $(element).before('<!-- ko wysiwygImg: { _data: $data, _item: ' + itemBindValue + ', _template: \'' + tmplName + '\', _editTemplate: \'img-wysiwyg\', _src: ' + bindingValue + ', _width: ' + width + ', _height: ' + height + ', _align: ' + (align === null ? undefined : '\'' + align + '\'') + ', _size: ' + size + ', _method: ' + method + ', _placeholdersrc: ' + placeholdersrc + ', _stylebind: ' + containerBind + ' } -->');
      $(element).after('<!-- /ko -->');
    }

  });

  // Applied after the data-editable so to avoid processing hrefs for editable content
  $("[href]", element).each(function(index, element) {
    var attrValue = domutils.getAttribute(element, 'href');
    var newBinding = 'wysiwygHref: \'' + converterUtils.addSlashes(attrValue) + '\'';
    var currentBindings = domutils.getAttribute(element, 'data-bind');
    var dataBind = (currentBindings !== null ? currentBindings + ", " : "") + newBinding;
    domutils.setAttribute(element, 'data-bind', dataBind);
  });

  $("replacedblock", element).each(function(index, element) {
    var blockElement = fixedBlocks[index];

    var blockName = processBlock(blockElement, defs, themeUpdater, blockPusher, templateUrlConverter, 'block', templateName, containerName, true, templateCreator);
    // replaced blocks are defined in the model root
    var modelBindValue = modelDef.ensurePathAndGetBindValue(defs, themeUpdater, rootModelName, templateName, '', blockName);

    // this way we call block-wysiwyg or block-show and not directly the right block
    $(element).before('<!-- ko block: { data: ' + converterUtils.addSlashes(modelBindValue) + ', template: \'block\' } -->');
    $(element).after('<!-- /ko -->');
    $(element).remove();
  });

  // TODO do we really need to loop in reverse order?
  // data-ko-wrap have to be processed at the end, expecially after "replaceblocks"
  // otherwise a data-ko-wrap wrapping a data-ko-block would break everything.
  $($("[data-ko-wrap]", element).get().reverse(), element).each(function(index, element) {
    var cond = domutils.getAttribute(element, 'data-ko-wrap');
    if (typeof cond === 'undefined' || cond === '' || cond === 'true') {
      throw "Unsupported empty value for data-ko-wrap: use false value if you want to always remove the tag";
    }

    var condBinding = converterUtils.conditionBinding(cond, bindingProvider);

    /*
          var condBinding = false;
          if (typeof cond === 'undefined' || cond === '') {
            throw "Unsupported empty value for data-ko-wrap: use false value if you want to always remove the tag";
          } else if (cond === 'false') {
            condBinding = false;
          } else if (cond === 'true') {
            throw "Unsupported true value for data-ko-wrap. This makes no sense: use false or a variable";
          } else {
            condBinding = bindingProvider(cond)+'()';
          }
    */

    var dataBind = domutils.getAttribute(element, 'data-bind');

    var innerTmplName, outerTmplName;
    // TODO ugly hardcoded handling: at the very least this should be invoked by the data-container caller.
    if (dataBind !== '' && dataBind !== null && dataBind.match(/(block|wysiwygOrHtml):/)) {
      // we can't put the content in a template because it will be overwritten by the binding
      var innerTmplContent = '<!-- ko ' + dataBind + ' -->' + domutils.getInnerHtml(element) + '<!-- /ko -->';
      innerTmplName = templateCreator(innerTmplContent);
      domutils.removeAttribute(element, 'data-ko-wrap');
      outerTmplName = templateCreator(element);
      domutils.replaceHtml(element, '<!-- ko template: /* special */ (typeof templateMode != \'undefined\' && templateMode == \'wysiwyg\') || ' + condBinding + ' ? \'' + outerTmplName + '\' : \'' + innerTmplName + '\' --><!-- /ko -->');
    } else {
      // we put the content in a template and the frame in another template including this one.
      innerTmplName = templateCreator(domutils.getInnerHtml(element));
      domutils.removeAttribute(element, 'data-ko-wrap');
      domutils.setContent(element, '<!-- ko template: \'' + innerTmplName + '\' --><!-- /ko -->');
      outerTmplName = templateCreator(element);
      domutils.replaceHtml(element, '<!-- ko template: (typeof templateMode != \'undefined\' && templateMode == \'wysiwyg\') || ' + condBinding + ' ? \'' + outerTmplName + '\' : \'' + innerTmplName + '\' --><!-- /ko -->');
    }

  });

  templateCreator(element, templateName, 'show');

  blockPusher(rootModelName, templateName, contextName, containerName);

  return templateName;

  } catch (e) {
    console.error("Exception while parsing the template", e, element);
    throw e;
  }

};

function conditional_replace(html) {
  return html.replace(/<!--\[if ([^\]]*)\]>([\s\S]*?)<!\[endif\]-->/g, function(match, condition, body) {
    var dd = '<!-- cc:start -->';
    dd += body.replace(/<(\/?)([A-Za-z]*)/g, '<$1cc$2').replace(/<\/([^>]*)>/g,'<!-- cc:before:$1 --></$1><!-- cc:after:$1 -->');
    dd += '<!-- cc:end -->';
    var output = '<replacedcc condition="'+condition+'" style="display: none">';
    output += $('<div>').append($(dd)).html().replace(/<!-- cc:before:([^ ]*) --><\/\1><!-- cc:after:\1 -->/g, '</$1>')
      .replace(/^<!-- cc:start -->/, '')
      .replace(/<!-- cc:end -->$/, '');
    output += '</replacedcc>';
    // console.log("Returning empty string instead of", output);
    // if (true) return '';
    return output;
  });
}


var translateTemplate = function(templateName, html, templateUrlConverter, templateCreator) {
  var defs = {};
  var replacedHtml = conditional_replace(html.replace(/(<[^>]+\s)(style|http-equiv)(="[^"]*"[^>]*>)/gi, function(match, p1, p2, p3) {
    return p1 + 'replaced' + p2 + p3;
  }));
  var content = $(replacedHtml);
  var element = content[0];

  var blocks = []; // {rootName, blockName, containerName}
  var _blockPusher = function(rootName, blockName, contextName, containerName) {
    blocks.push({
      root: rootName,
      block: blockName,
      context: contextName,
      container: containerName
    });
  };

  // TODO have to accept nulls as undefineds (because of model.js behaviour)
  var themeUpdater = function(name, key, val) {
    if (typeof defs['themes'] === 'undefined') defs['themes'] = {};
    if (typeof defs['themes'][name] === 'undefined') defs['themes'][name] = {};
    if (typeof defs['themes'][name][key] === 'undefined' || defs['themes'][name][key] === null) defs['themes'][name][key] = val;
    else if (typeof val !== 'undefined' && val !== null) {
      var precVal = defs['themes'][name][key];
      if (precVal != val) console.log("Error setting a new default for property " + key + " in theme " + name + ". old:" + precVal + " new:" + val + "!");
    }
  };

  var containers = $("[data-ko-container]", content);
  var containersDom = {};
  containers.each(function(index, element) {
    var containerName = domutils.getAttribute(element, 'data-ko-container') + "Blocks";

    domutils.removeAttribute(element, 'data-ko-container');
    domutils.setAttribute(element, 'data-bind', 'block: ' + containerName);

    var containerBlocks = $("> [data-ko-block]", element);
    domutils.removeElements(containerBlocks, true);

    containersDom[containerName] = containerBlocks;
  });

  // TODO remove hardcoded properties: we need them because without these loading a basic template fails.
  // Needed in order to use data-ko-block
  modelDef.createOrUpdateBlockDef(defs, 'id');
  // Needed always as it is the default theme section.
  modelDef.createOrUpdateBlockDef(defs, 'bodyTheme');
  // Needed for data-ko-container
  modelDef.createOrUpdateBlockDef(defs, 'blocks', 'blocks[]');

  // Needed if you want to use a text variable? TODO this should not be needed!
  modelDef.createOrUpdateBlockDef(defs, 'text');

  processBlock(element, defs, themeUpdater, _blockPusher, templateUrlConverter, 'template', templateName, undefined, false, templateCreator);

  var blockProcess = function(containerName, index, element) {
    processBlock(element, defs, themeUpdater, _blockPusher, templateUrlConverter, 'block', templateName, containerName, true, templateCreator);
  };

  for (var prop in containersDom)
    if (containersDom.hasOwnProperty(prop)) {
      var containerBlocks = containersDom[prop];
      var containerName = prop;

      modelDef.ensurePathAndGetBindValue(defs, themeUpdater, templateName, templateName, '', containerName + ".blocks", "[]");

      containerBlocks.each(blockProcess.bind(undefined, containerName));
    }

  var templateDef = {
    _defs: defs,
    templateName: templateName,
    _blocks: blocks
  };

  if (typeof defs[templateName]._version !== 'undefined') {
    templateDef.version = defs[templateName]._version;
  }

  return templateDef;
};


module.exports = translateTemplate;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./declarations.js":42,"./domutils.js":43,"./model.js":46,"./stylesheet.js":48,"./utils.js":49}],48:[function(require,module,exports){
"use strict";

// Parses CSS/stylesheets declarations -ko-blockdefs/-ko-themes
// It returns KO bindings but doesn't depend on KO
// Needs a bindingProvider
// Also uses a blockDefsUpdater to update definitions while parsing the stylesheet.

var cssParse = require("./../../../bower_components/mensch/lib/parser.js");
var console = require("./../../../bower_components/console-browserify/index.js");
var converterUtils = require("./utils.js");
var elaborateDeclarations = require("./declarations.js");

/* Temporary experimental code not used
var _processStyleSheetRules_processThemes = function (bindingProvider, themeUpdater, rules) {
  var sels, decls, i, j, k;
  for( i = 0; i < rules.length; i++) {
    if (rules[i].type == 'rule') {
      sels = rules[i].selectors;
      decls = rules[i].declarations;
      for (j = 0; j < sels.length; j++) {
        for (k = 0; k < decls.length; k++) if (decls[k].type == 'property') {
          try {
            var bindVal = bindingProvider('$'+decls[k].name);
            themeUpdater(sels[j], decls[k].name, decls[k].value, bindVal);
          } catch (e) {
            console.log("Exception setting theme for", decls[k].name, decls[k].value, e);
          }
        }
      }
    }
  }
};
*/

var _processStyleSheetRules_processBlockDef = function(blockDefsUpdater, rules) {
  var properties, namedProps, decls;
  // name, contextName, globalStyle, themeOverride, extend, min, max, widget, options, category, variant, help, blockDescription, version, 
  for (var i = 0; i < rules.length; i++) {
    if (rules[i].type == 'rule') {
      var sels = rules[i].selectors;
      var hasDeclarations = false;
      var hasPreviews = false;
      for (var j = 0; j < sels.length; j++) {
        if (sels[j].match(/:preview$/)) {
          hasPreviews = true;
        } else {
          hasDeclarations = true;
        }
      }
      if (hasPreviews && hasDeclarations) {
        console.log("cannot mix selectors type (:preview and declarations) in @supports -ko-blockdefs ", sels);
        throw "Cannot mix selectors type (:preview and declarations) in @supports -ko-blockdefs";
      }
      if (!hasPreviews && !hasDeclarations) {
        console.log("cannot find known selectors in @supports -ko-blockdefs ", sels);
        throw "Cannot find known selectors in @supports -ko-blockdefs";
      }
      if (hasDeclarations) {
        properties = '';
        namedProps = {};

/*
        name = undefined;
        contextName = undefined;
        globalStyle = undefined;
        themeOverride = undefined;
        extend = undefined;
        max = undefined;
        min = undefined;
        widget = undefined;
        options = undefined;
        category = undefined;
        variant = undefined;
        help = undefined;
        blockDescription = undefined;
        version = undefined;
        */
        decls = rules[i].declarations;
        for (var k = 0; k < decls.length; k++) if (decls[k].type == 'property') {
          if (decls[k].name == 'label') namedProps.name = decls[k].value;
          else if (decls[k].name == 'context') namedProps.contextName = decls[k].value;
          else if (decls[k].name == 'properties') properties = decls[k].value;
          else if (decls[k].name == 'theme') namedProps.globalStyle = '_theme_.' + decls[k].value;
          else if (decls[k].name == 'themeOverride') namedProps.themeOverride = String(decls[k].value).toLowerCase() == 'true';
          // else if (decls[k].name == 'extend') extend = decls[k].value;

          // else if (decls[k].name == 'max') max = decls[k].value;
          // else if (decls[k].name == 'min') min = decls[k].value;
          // else if (decls[k].name == 'options') options = decls[k].value;

          // else if (decls[k].name == 'widget') widget = decls[k].value;
          // else if (decls[k].name == 'category') category = decls[k].value;
          // else if (decls[k].name == 'variant') variant = decls[k].value;
          // else if (decls[k].name == 'help') help = decls[k].value;
          // else if (decls[k].name == 'blockDescription') blockDescription = decls[k].value;
          // else if (decls[k].name == 'version') version = decls[k].value;
          else {
            namedProps[decls[k].name] = decls[k].value;
            // TODO in past we detected unsupported properties, while now we simple push every declaration in a namedProperty.
            // This make it harder to spot errors in declarations.
            // console.warn("Unknown property processing @supports -ko-blockdefs ", decls[k], sels);
          }
        }
        for (var l = 0; l < sels.length; l++) {
          blockDefsUpdater(sels[l], properties, namedProps);
        }
      }
      if (hasPreviews) {
        for (var m = 0; m < sels.length; m++) {
          var localBlockName = sels[m].substr(0, sels[m].indexOf(':'));
          var previewBindings = rules[i].declarations;
          blockDefsUpdater(localBlockName, undefined, { previewBindings: previewBindings });
        }
      }

    } else {
      // Ignoring comments or other content
    }
  }
};

var processStylesheetRules = function(style, rules, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName) {
  var newStyle = style;
  var lastStart = null;

  if (typeof rules == 'undefined') {
    var styleSheet = cssParse(style, {
      comments: true,
      position: true
    });
    if (styleSheet.type != 'stylesheet' || typeof styleSheet.stylesheet == 'undefined') {
      console.log("unable to process styleSheet", styleSheet);
      throw "Unable to parse stylesheet";
    }
    rules = styleSheet.stylesheet.rules;
  }

  // WARN currenlty this parses rules in reverse order so that string replacements works using input "positions"
  // otherwise it should compute new offsets on every replacement.
  // But this create issues because of definitions being parsed in reverse order, so this is not a good idea.
  // Sometimes, to work around this issues, you need to create 2 different <style> blocks.
  var bindingProvider;

  for (var i = rules.length - 1; i >= 0; i--) {
    if (rules[i].type == 'supports' && rules[i].name == '-ko-blockdefs') {
      _processStyleSheetRules_processBlockDef(blockDefsUpdater, rules[i].rules);
      newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, lastStart, 0, 0, 0, '');
      /* temporary experimental code not used
      } else if (rules[i].type == 'supports' && rules[i].name == '-ko-themes') {
        bindingProvider = localWithBindingProvider.bind(this, 'theme', '');
        _processStyleSheetRules_processThemes(bindingProvider, themeUpdater, rules[i].rules);
        newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, lastStart, 0, 0, 0, '');
      */
    } else if (rules[i].type == 'media' || rules[i].type == 'supports') {
      newStyle = processStylesheetRules(newStyle, rules[i].rules, localWithBindingProvider, blockDefsUpdater, themeUpdater, templateUrlConverter, rootModelName, templateName);
    } else if (rules[i].type == 'comment') {
      // ignore comments
    } else if (rules[i].type == 'rule') {
      var sels = rules[i].selectors;
      var newSel = "";
      var foundBlockMatch = null;
      for (var j = 0; j < sels.length; j++) {
        if (newSel.length > 0) newSel += ", ";
        var match = sels[j].match(/\[data-ko-block=([^ ]*)\]/);
        if (match !== null) {
          if (foundBlockMatch !== null && foundBlockMatch != match[1]) throw "Found multiple block-match attribute selectors: cannot translate it (" + foundBlockMatch + " vs " + match[1] + ")";
          foundBlockMatch = match[1];
        }
        newSel += '<!-- ko text: templateMode ==\'wysiwyg\' ? \'#main-wysiwyg-area \' : \'\' --><!-- /ko -->' + sels[j];
      }
      if (foundBlockMatch) {
        var loopPrefix = '<!-- ko foreach: $root.findObjectsOfType($data, \'' + foundBlockMatch + '\') -->';
        var loopPostfix = '<!-- /ko -->';
        var end = lastStart;
        var spacing = " ";
        if (rules[i].declarations.length > 0) {
          if (rules[i].declarations[0].position.start.line != rules[i].position.end.line) {
            spacing = "\n" + (new Array(rules[i].position.start.col)).join(" ");
          }
          end = rules[i].declarations[rules[i].declarations.length - 1].position.end;
        }
        if (end === null) newStyle += spacing + loopPostfix;
        else if (end == lastStart) newStyle = converterUtils.removeStyle(newStyle, end, lastStart, 0, 0, 0, spacing + loopPostfix);
        else newStyle = converterUtils.removeStyle(newStyle, end, lastStart, 0, 0, 0, spacing + '}' + spacing + loopPostfix);
        newSel = loopPrefix + spacing + newSel.replace(new RegExp('\\[data-ko-block=' + foundBlockMatch + '\\]', 'g'), '<!-- ko text: \'#\'+id() -->' + foundBlockMatch + '<!-- /ko -->');

        blockDefsUpdater(foundBlockMatch, '', { contextName: 'block' });
      }
      // TODO mensch update (using original mensch library we needed this line, while the patched one doesn't need this code)
      // newSel += " {";
      var localBlockName = foundBlockMatch ? foundBlockMatch : templateName;
      bindingProvider = localWithBindingProvider.bind(this, localBlockName, '');
      var elaboratedStyle = elaborateDeclarations(newStyle, rules[i].declarations, templateUrlConverter, bindingProvider);
      if (elaboratedStyle !== null) newStyle = elaboratedStyle;

      newStyle = converterUtils.removeStyle(newStyle, rules[i].position.start, rules[i].position.end, 0, 0, 0, newSel);
    } else {
      console.log("Unknown rule type", rules[i].type, "while parsing <style> rules");
    }
    lastStart = rules[i].position.start;
  }
  return newStyle;
};

module.exports = processStylesheetRules;
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/mensch/lib/parser.js":10,"./declarations.js":42,"./utils.js":49}],49:[function(require,module,exports){
"use strict";
var console = require("./../../../bower_components/console-browserify/index.js");
var jsep = require("./../../../bower_components/jsep/src/jsep.js");

jsep.addBinaryOp("or", 1);
jsep.addBinaryOp("and", 2);
jsep.addBinaryOp("eq", 6);
jsep.addBinaryOp("neq", 6);
jsep.addBinaryOp("lt", 7);
jsep.addBinaryOp("lte", 7);
jsep.addBinaryOp("gt", 7);
jsep.addBinaryOp("gte", 7);

var addSlashes = function(str) {
  return str.replace(/[\\"']/g, '\\$&').replace(/\u0000/g, '\\0');
};

var removeStyle = function(style, startPos, endPos, skipRows, startOffset, endOffset, insert) {
  var styleRows = style.split("\n");
  var start = startOffset;
  var end = endOffset;
  for (var r = 1 + skipRows; r < startPos.line; r++) start += styleRows[r - 1 - skipRows].length + 1;
  start += startPos.col;
  if (endPos !== null) {
    for (var r2 = 1 + skipRows; r2 < endPos.line; r2++) end += styleRows[r2 - 1 - skipRows].length + 1;
    end += endPos.col;
  } else end += style.length + 1;
  var newStyle = style.substr(0, start - 1) + insert + style.substr(end - 1);
  return newStyle;
};

var expressionGenerator = function(node, bindingProvider, defVal) {
  function mapOperator(op) {
    switch (op) {
      case 'or':
        return '||';
      case 'and':
        return '&&';
      case 'lt':
        return '<';
      case 'lte':
        return '<=';
      case 'gt':
        return '>';
      case 'gte':
        return '>=';
      case 'eq':
        return '==';
      case 'neq':
        return '!=';
      default:
        return op;
    }
  }

  function gen(node, bindingProvider, lookupmember, defVal) {
    if (typeof lookupmember == 'undefined') lookupmember = true;

    if (typeof defVal !== 'undefined' && node.type !== "Identifier" && node.type !== "MemberExpression") console.log("Cannot apply default value to variable when using expressions");

    if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
      return '(' + gen(node.left, bindingProvider, lookupmember) + ' ' + mapOperator(node.operator) + ' ' + gen(node.right, bindingProvider, lookupmember) + ')';
    } else if (node.type === 'CallExpression') {
      var args = node.arguments.map(function(n) {
        return gen(n, bindingProvider, lookupmember);
      });
      return gen(node.callee, bindingProvider, lookupmember) + '(' + args.join(', ') + ')';
    } else if (node.type === "UnaryExpression") {
      return node.operator + gen(node.argument, bindingProvider, lookupmember);
    } else if (node.type == 'MemberExpression' && node.computed) {
      throw "Unexpected computed member expression";
      // return gen(node.object) + '[' + gen(node.property) + ']';
    } else if (node.type == 'MemberExpression' && !node.computed) {
      var me = gen(node.object, bindingProvider, false) + '.' + gen(node.property, bindingProvider, false);
      if (lookupmember && node.object.name !== 'Math' && node.object.name !== 'Color') return bindingProvider(me, defVal) + '()';
      return me;
    } else if (node.type === "Literal") {
      return node.raw;
    } else if (node.type === 'Identifier') {
      var id = node.name;
      if (lookupmember) return bindingProvider(id, defVal) + '()';
      else return id;
    } else if (node.type === 'ConditionalExpression') {
      return '(' + gen(node.test, bindingProvider, lookupmember) + ' ? ' + gen(node.consequent, bindingProvider, lookupmember) + ' : ' + gen(node.alternate, bindingProvider, lookupmember) + ')';
    } else if (node.type === 'Compound') {
      throw "Syntax error in expression: operator expected after " + gen(node.body[0], bindingProvider, false);
    } else {
      throw "Found an unsupported expression type: " + node.type;
    }
  }

  return gen(node, bindingProvider, undefined, defVal);
};

var expressionBinding = function(expression, bindingProvider, defaultValue) {
  var matches;
  if (typeof defaultValue !== 'undefined' && defaultValue !== null) {
    var check = expression.trim().replace(/@\[([^\]]+)\]|@([a-zA-Z0-9\._]+)\b/g, '###var###');
    check = check.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    if (check == '###var###') matches = [null, defaultValue];
    else {
      check = '^' + check.replace(/###var###/g, '(.+)') + '$';
      matches = defaultValue.trim().match(new RegExp(check));
      if (!matches) {
        // TODO throw error?
        console.log("Cannot find matches", matches, "for", defaultValue, expression, check, expression);
        throw "Cannot find default value for " + expression + " in " + defaultValue;
      }
    }
  }
  try {
    var vars = 0;
    var result = "'" + expression.replace(/@\[([^\]]+)\]|@([a-zA-Z0-9\._]+)\b|(')/g, function(match, p1, p2, p3) {
      // escaping..
      if (p3) return "\\" + p3;
      vars++;
      var varName = p1 || p2;
      var defVal;
      if (matches) {
        if (typeof matches[vars] !== 'undefined') {
          defVal = matches[vars].trim();
        } else {
          console.log("ABZZZ Cannot find default value for", varName, "in", matches, "as", vars);
        }
      }
      // in case we found p1 we are in a @[sequence] so we start an expression parser
      if (p1) {
        var parsetree = jsep(p1);
        var gentree = expressionGenerator(parsetree, bindingProvider, defVal);
        return "'+" + gentree + "+'";
      }
      return "'+" + bindingProvider(varName, defVal) + "()+'";
    }) + "'";
    result = result.replace(/(^|[^\\])''\+/g, '$1').replace(/\+''/g, '');

    if (vars === 0 && result !== 'false' && result !== 'true') {
      console.error("Unexpected expression with no valid @variable references", expression);
    }
    return result;
  } catch (e) {
    throw "Exception parsing expression " + expression + " " + e;
  }
};

var conditionBinding = function(condition, bindingProvider) {
  var parsetree = jsep(condition);
  var gentree = expressionGenerator(parsetree, bindingProvider);
  return gentree;
};

module.exports = {
  addSlashes: addSlashes,
  removeStyle: removeStyle,
  conditionBinding: conditionBinding,
  expressionBinding: expressionBinding
};
},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/jsep/src/jsep.js":3}],50:[function(require,module,exports){
(function (global){
"use strict";

// This is complex code to handle "live" model instrumentation and dependency tracking.
// This adds _wrap and _unwrap methods to the model and also instrument the block list so to automatically
// wrap/upwrap objects on simple array methods (push, splice)

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kowrap = require("./../../../bower_components/knockout.wrap/knockout.wrap.js");
var console = require("./../../../bower_components/console-browserify/index.js");

var _getOptionsObject = function(options) {
  var optionsCouples = options.split('|');
  var opts = {};
  for (var i = 0; i < optionsCouples.length; i++) {
    var opt = optionsCouples[i].split('=');
    opts[opt[0]] = opt.length > 1 ? opt[1] : opt[0];
  }
  return opts;
};

// generate a computed variable handling the fallback to theme variable
var _makeComputed = function(target, def, nullIfEqual, schemeSelector, themePath, themes) {
  var res = ko.computed({
    'read': function() {
      var val = target();
      if (val === null) {
        var scheme = ko.utils.unwrapObservable(schemeSelector);
        if (typeof scheme == 'undefined' || scheme == 'custom') {
          return ko.utils.unwrapObservable(def);
        } else {
          return themes[scheme][themePath];
        }
      } else {
        return val;
      }
    },
    'write': function(value) {
      var scheme = ko.utils.unwrapObservable(schemeSelector);
      var defVal;
      if (typeof scheme == 'undefined' || scheme == 'custom') {
        defVal = ko.utils.peekObservable(def);
      } else {
        defVal = themes[scheme][themePath];
      }

      if (!!nullIfEqual) {
        if (value == defVal) target(null);
        else target(value);
      } else {
        var current = ko.utils.peekObservable(target);
        if (value != defVal || current !== null) target(value);
      }

    }
  });
  return res;
};

var _nextVariantFunction = function(ko, prop, variants) {
  var currentValue = ko.utils.unwrapObservable(prop);
  var variantValue;

  for (var i = 0; i < variants.length; i++) {
    variantValue = ko.utils.peekObservable(variants[i]);
    if (variantValue == currentValue) break;
  }

  if (i == variants.length) {
    console.warn("Didn't find a variant!", prop, currentValue, variants);
    i = variants.length - 1;
  }

  var nextVariant = i + 1;
  if (nextVariant == variants.length) nextVariant = 0;
  var nextValue = ko.utils.peekObservable(variants[nextVariant]);

  prop(nextValue);
};

var _getVariants = function(def) {
  var variantProp = def._variant;
  var variantOptions;
  if (typeof def[variantProp] !== 'object' || typeof def[variantProp]._widget === 'undefined' || (typeof def[variantProp]._options !== 'string' && def[variantProp]._widget !== 'boolean')) {
    console.error("Unexpected variant declaration", variantProp, def[variantProp]);
    throw "Unexpected variant declaration: cannot find property " + variantProp + " or its _options string and it is not a boolean";
  }
  // TODO I read the "keys" but this is not 100% correct because they are not garanteed to be sorted as in declaration
  if (typeof def[variantProp]._options == 'string') {
    variantOptions = Object.keys(_getOptionsObject(def[variantProp]._options));
  } else {
    variantOptions = [true, false];
  }
  return variantOptions;
};

var _makeComputedFunction = function(def, defs, thms, ko, contentModel, isContent, t) {
  if (typeof def == 'undefined') {
    if (typeof ko.utils.unwrapObservable(t).type === 'undefined') {
      console.log("TODO ERROR Found a non-typed def ", def, t);
      throw "Found a non-typed def " + def;
    }
    var type = ko.utils.unwrapObservable(ko.utils.unwrapObservable(t).type);
    def = defs[type];
    if (typeof def !== 'object') console.log("TODO ERROR Found a non-object def ", def, "for", type);
  }

  if (typeof contentModel == 'undefined' && typeof isContent != 'undefined' && isContent) {
    contentModel = t;
  }

  var selfPath = '$root.content().';

  var pp = def._globalStyles;
  if (typeof pp != 'undefined')
    for (var p in pp)
      if (pp.hasOwnProperty(p)) {
        var schemePathOrig = '$root.content().theme().scheme';
        var schemePath, vm, path;

        if (pp[p].substr(0, selfPath.length) == selfPath) {
          path = pp[p].substr(selfPath.length);
          vm = contentModel;
        } else {
          throw "UNEXPECTED globalStyle path (" + pp[p] + ") outside selfPath (" + selfPath + ")";
        }
        if (schemePathOrig.substr(0, selfPath.length) == selfPath) {
          schemePath = schemePathOrig.substr(selfPath.length);
        } else {
          console.log("IS THIS CORRECT?", schemePathOrig, selfPath);
          schemePath = schemePathOrig;
        }

        var schemeSelector = vm;

        var pathParts = path.split('().');
        var themePath = '';
        var skip = true;
        for (var i = 0; i < pathParts.length; i++) {
          vm = ko.utils.unwrapObservable(vm)[pathParts[i]];
          // ugly thing to find the path to the schema color property (sometimes we have theme.bodyTheme, some other we have content.theme.bodyTheme...)
          if (skip) {
            if (pathParts[i] == 'theme') skip = false;
          } else {
            if (themePath.length > 0) themePath += '.';
            themePath += pathParts[i];
          }
        }

        var schemeParts = schemePath.split('().');
        for (var i3 = 0; i3 < schemeParts.length; i3++) {
          schemeSelector = ko.utils.unwrapObservable(schemeSelector)[schemeParts[i3]];
        }

        var nullIfEqual = true;
        var tParts = p.split('.');
        var target = t;
        for (var i2 = 0; i2 < tParts.length; i2++) {
          target = ko.utils.unwrapObservable(target)[tParts[i2]];
        }

        if (!ko.isObservable(target)) throw "Unexpected non observable target " + p + "/" + themePath;

        target._defaultComputed = _makeComputed(target, vm, nullIfEqual, schemeSelector, themePath, thms);
      }

  if (typeof def._variant != 'undefined') {
    var pParts = def._variant.split('.');
    // looks in t and not contentModel because variants are declared on single blocks.
    var pTarget = t;
    var pParent = ko.utils.unwrapObservable(t);
    for (var i4 = 0; i4 < pParts.length; i4++) {
      pTarget = ko.utils.unwrapObservable(pTarget)[pParts[i4]];
    }
    if (typeof pTarget._defaultComputed != 'undefined') {
      console.log("Found variant on a style property: beware variants should be only used on content properties because they don't match the theme fallback behaviour", def._variant);
      pTarget = pTarget._defaultComputed;
    }
    if (typeof pTarget == 'undefined') {
      console.log("ERROR looking for variant target", def._variant, t);
      throw "ERROR looking for variant target " + def._variant;
    }
    pParent._nextVariant = _nextVariantFunction.bind(pTarget, ko, pTarget, _getVariants(def));
  }

  for (var prop2 in def)
    if (def.hasOwnProperty(prop2)) {
      var val = def[prop2];
      if (typeof val == 'object' && val !== null && typeof val._context != 'undefined' && val._context == 'block') {
        var propVm = contentModel[prop2]();
        var newVm = _makeComputedFunction(defs[prop2], defs, thms, ko, contentModel, isContent, propVm);
        t[prop2](newVm);
      } else if (typeof val == 'object' && val !== null && val.type == 'blocks') {
        var mainVm = contentModel[prop2]();
        var blocksVm = mainVm.blocks();
        var oldBlock, blockType, newBlock;
        for (var ib = 0; ib < blocksVm.length; ib++) {
          oldBlock = ko.utils.unwrapObservable(blocksVm[ib]);
          blockType = ko.utils.unwrapObservable(oldBlock.type);
          newBlock = _makeComputedFunction(defs[blockType], defs, thms, ko, contentModel, isContent, oldBlock);
          blocksVm[ib](newBlock);
        }

        var blocksObs = mainVm.blocks;

        _augmentBlocksObservable(blocksObs, _blockInstrumentFunction.bind(mainVm, undefined, defs, thms, ko, undefined, contentModel, isContent));

        contentModel[prop2]._wrap = _makeBlocksWrap.bind(contentModel[prop2], blocksObs._instrumentBlock);
        contentModel[prop2]._unwrap = _unwrap.bind(contentModel[prop2]);
      }
    }

  return t;
};

var _augmentBlocksObservable = function(blocksObs, instrument) {
  blocksObs._instrumentBlock = instrument;
  if (typeof blocksObs.origPush == 'undefined') {
    blocksObs.origPush = blocksObs.push;
    blocksObs.push = _makePush.bind(blocksObs);
    blocksObs.origSplice = blocksObs.splice;
    blocksObs.splice = _makeSplice.bind(blocksObs);
  }
};

var _makeBlocksWrap = function(instrument, inputModel) {
  var model = ko.toJS(inputModel);
  var input = model.blocks;
  model.blocks = [];
  var res = kowrap.fromJS(model, undefined, true)();
  _augmentBlocksObservable(res.blocks, instrument);
  for (var i = 0; i < input.length; i++) {
    var obj = ko.toJS(input[i]);
    // console.log("_makeBlocksWrap set blockId", obj.id, 'block_'+i);
    obj.id = 'block_' + i;
    res.blocks.push(obj);
  }
  this(res);
};

var _makePush = function() {
  if (arguments.length > 1) throw "Array push with multiple arguments not implemented";
  // unwrap observable blocks, otherwise visibility (dependency) handling breaks
  if (arguments.length > 0 && ko.isObservable(arguments[0])) {
    if (typeof arguments[0]._unwrap == 'function') {
      arguments[0] = arguments[0]._unwrap();
    } else {
      console.log("WARN: pushing observable with no _unwrap function (TODO remove me, expected condition)");
    }
  }
  if (!ko.isObservable(arguments[0])) {
    var instrumented = this._instrumentBlock(arguments[0]);
    return this.origPush.apply(this, [instrumented]);
  } else {
    return this.origPush.apply(this, arguments);
  }
};

var _makeSplice = function() {
  if (arguments.length > 3) throw "Array splice with multiple objects not implemented";
  if (arguments.length > 2 && ko.isObservable(arguments[2])) {
    if (typeof arguments[2]._unwrap == 'function') {
      arguments[2] = arguments[2]._unwrap();
    } else {
      console.log("WARN: splicing observable with no _unwrap function (TODO remove me, expected condition)");
    }
  }
  if (arguments.length > 2 && !ko.isObservable(arguments[2])) {
    var instrumented = this._instrumentBlock(arguments[2]);
    return this.origSplice.apply(this, [arguments[0], arguments[1], instrumented]);
  } else {
    return this.origSplice.apply(this, arguments);
  }
};

// def, defs and themes are bound in "_modelInstrument" while the next parameters are exposed by this module
var _blockInstrumentFunction = function(def, defs, themes, knockout, self, modelContent, isContent, self2) {
  // ugly: sometimes we have to bind content but not self, so we repeat self at the end as "self2"
  if (typeof self == 'undefined') self = self2;

  var computedFunctions;
  computedFunctions = {
    '': _makeComputedFunction.bind(self, def, defs, themes, knockout, modelContent, isContent)
  };

  var res = kowrap.fromJS(self, computedFunctions, true);
  res._unwrap = _unwrap.bind(res);
  return res;
};

var _wrap = function(instrument, unwrapped) {
  var newContent = ko.utils.unwrapObservable(instrument(ko, unwrapped, undefined, true));
  this(newContent);
};

var _unwrap = function() {
  return ko.toJS(this);
};

var _modelInstrument = function(model, modelDef, defs) {
  var _instrument = _blockInstrumentFunction.bind(undefined, modelDef, defs, defs['themes']);
  var res = _instrument(ko, model, undefined, true);
  // res._instrument = _instrument;
  res._wrap = _wrap.bind(res, _instrument);
  res._unwrap = _unwrap.bind(res);
  return res;
};

module.exports = _modelInstrument;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1,"./../../../bower_components/knockout.wrap/knockout.wrap.js":6}],51:[function(require,module,exports){
(function (global){
var tinycolor = require("./../../../bower_components/tinycolor/tinycolor.js");

function Color(tinycolor) {
  this.getBrightness = function(color) {
    return tinycolor(color).getBrightness();
  };
  this.isLight = function(color) {
    return tinycolor(color).isLight();
  };
  this.isDark = function(color) {
    return tinycolor(color).isDark();
  };
  this.getLuminance = function(color) {
    return tinycolor(color).getLuminance();
  };


  this.lighten = function(color, amount) {
    return tinycolor(color).lighten(amount).toHexString();
  };
  this.brighten = function(color, amount) {
    return tinycolor(color).brighten(amount).toHexString();
  };
  this.darken = function(color, amount) {
    return tinycolor(color).darken(amount).toHexString();
  };
  this.desaturate = function(color, amount) {
    return tinycolor(color).desaturate(amount).toHexString();
  };
  this.saturate = function(color, amount) {
    return tinycolor(color).saturate(amount).toHexString();
  };
  this.greyscale = function(color) {
    return tinycolor(color).greyscale().toHexString();
  };
  this.spin = function(color, amount) {
    return tinycolor(color).spin(amount).toHexString();
  };
  this.complement = function(color) {
    return tinycolor(color).complement().toHexString();
  };

  this.mix = tinycolor.mix;
  this.readability = tinycolor.readability;
  this.isReadable = tinycolor.isReadable;
  this.mostReadable = tinycolor.mostReadable;
}

var colorPlugin = function(vm) {
  global.Color = new Color(tinycolor);
};

module.exports = colorPlugin;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/tinycolor/tinycolor.js":11}],52:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */
var console = require("./../../../bower_components/console-browserify/index.js");
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);

var lsLoader = function(hash_key, emailProcessorBackend) {
  var mdStr = global.localStorage.getItem("metadata-" + hash_key);
  if (mdStr !== null) {
    var model;
    var td = global.localStorage.getItem("template-" + hash_key);
    if (td !== null) model = JSON.parse(td);
    var md = JSON.parse(mdStr);
    return {
      metadata: md,
      model: model,
      extension: lsCommandPluginFactory(md, emailProcessorBackend)
    };
  } else {
    throw "Cannot find stored data for "+hash_key;
  }
};

var lsCommandPluginFactory = function(md, emailProcessorBackend) {
  var commandsPlugin = function(mdkey, mdname, viewModel) {

    // console.log("loading from metadata", md, model);
    var saveCmd = {
      name: 'Save', // l10n happens in the template
      enabled: ko.observable(true)
    };
    saveCmd.execute = function() {
      saveCmd.enabled(false);
      viewModel.metadata.changed = Date.now();
      if (typeof viewModel.metadata.key == 'undefined') {
        console.warn("Unable to find ket in metadata object...", viewModel.metadata);
        viewModel.metadata.key = mdkey;
      }
      global.localStorage.setItem("metadata-" + mdkey, viewModel.exportMetadata());
      global.localStorage.setItem("template-" + mdkey, viewModel.exportJSON());
      saveCmd.enabled(true);
    };
    var testCmd = {
      name: 'Test', // l10n happens in the template
      enabled: ko.observable(true)
    };
    var downloadCmd = {
      name: 'Download', // l10n happens in the template
      enabled: ko.observable(true)
    };
    testCmd.execute = function() {
      testCmd.enabled(false);
      var email = global.localStorage.getItem("testemail");
      if (email === null || email == 'null') email = viewModel.t('Insert here the recipient email address');
      email = global.prompt(viewModel.t("Test email address"), email);
      if (email.match(/@/)) {
        global.localStorage.setItem("testemail", email);
        console.log("TODO testing...", email);
        var postUrl = emailProcessorBackend ? emailProcessorBackend : '/dl/';
        var post = $.post(postUrl, {
          action: 'email',
          rcpt: email,
          subject: "[test] " + mdkey + " - " + mdname,
          html: viewModel.exportHTML()
        }, null, 'html');
        post.fail(function() {
          console.log("fail", arguments);
          viewModel.notifier.error(viewModel.t('Unexpected error talking to server: contact us!'));
        });
        post.success(function() {
          console.log("success", arguments);
          viewModel.notifier.success(viewModel.t("Test email sent..."));
        });
        post.always(function() {
          testCmd.enabled(true);
        });
      } else {
        global.alert(viewModel.t('Invalid email address'));
        testCmd.enabled(true);
      }
    };
    downloadCmd.execute = function() {
      downloadCmd.enabled(false);
      viewModel.notifier.info(viewModel.t("Downloading..."));
      viewModel.exportHTMLtoTextarea('#downloadHtmlTextarea');
      var postUrl = emailProcessorBackend ? emailProcessorBackend : '/dl/';
      global.document.getElementById('downloadForm').setAttribute("action", postUrl);
      global.document.getElementById('downloadForm').submit();
      downloadCmd.enabled(true);
    };

    viewModel.save = saveCmd;
    viewModel.test = testCmd;
    viewModel.download = downloadCmd;
  }.bind(undefined, md.key, md.name);

  return commandsPlugin;
};

module.exports = lsLoader;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],53:[function(require,module,exports){
"use strict";

require("./../../bower_components/knockout-sortable/build/knockout-sortable.min.js");

require("./bindings/jqueryui-spinner.js");
require("./bindings/jqueryui-tabs.js");
require("./bindings/colorpicker.js");
require("./bindings/blocks.js");
require("./bindings/csstext.js");
require("./bindings/bind-iframe.js");
require("./bindings/droppable.js");
require("./bindings/fileupload.js");
require("./bindings/virtuals.js");
require("./bindings/wysiwygs.js");
require("./bindings/scrollfix.js");
require("./bindings/if-subs.js");
require("./bindings/extsortables.js");
require("./bindings/eventable.js");
require("./bindings/tooltips.js");
require("./bindings/extender-pagination.js");
require("./bindings/validated-value.js");
require("./bindings/scrollintoview.js");
},{"./../../bower_components/knockout-sortable/build/knockout-sortable.min.js":4,"./bindings/bind-iframe.js":20,"./bindings/blocks.js":21,"./bindings/colorpicker.js":23,"./bindings/csstext.js":24,"./bindings/droppable.js":25,"./bindings/eventable.js":26,"./bindings/extender-pagination.js":27,"./bindings/extsortables.js":28,"./bindings/fileupload.js":29,"./bindings/if-subs.js":30,"./bindings/jqueryui-spinner.js":31,"./bindings/jqueryui-tabs.js":32,"./bindings/scrollfix.js":34,"./bindings/scrollintoview.js":35,"./bindings/tooltips.js":37,"./bindings/validated-value.js":38,"./bindings/virtuals.js":39,"./bindings/wysiwygs.js":40}],54:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var kojqui = (typeof window !== "undefined" ? window['kojqui'] : typeof global !== "undefined" ? global['kojqui'] : null); // just for the widget plugins
var templateConverter = require("./converter/main.js");
var console = require("./../../bower_components/console-browserify/index.js");
var initializeViewmodel = require("./viewmodel.js");
var templateSystem = require('./bindings/choose-template.js');

// call a given method on every plugin implementing it.
// supports a "reverse" parameter to call the methods from the last one to the first one.
var pluginsCall = function(plugins, methodName, args, reverse) {
  var start, end, diff, res, results;
  results = [];
  if (typeof reverse !== 'undefined' && reverse) {
    start = plugins.length - 1;
    end = 0;
    diff = -1;
  } else {
    start = 0;
    end = plugins.length - 1;
    diff = 1;
  }
  for (var i = start; i != end + diff; i += diff) {
    if (typeof plugins[i][methodName] !== 'undefined') {
      res = plugins[i][methodName].apply(plugins[i], args);
      if (typeof res !== 'undefined') results.push(res);
    }
  }
  return results;
};

// workaround for knockout-jqueryui's buttonset/button disposal:
// https://github.com/gvas/knockout-jqueryui/issues/25
var origDisposeCallback = ko.utils.domNodeDisposal.addDisposeCallback;
ko.utils.domNodeDisposal.addDisposeCallback = function(node, callback) {
  var newCallback = function(node) {
    try {
      callback(node);
    } catch (e) {
      console.log("cought dispose callback exception", e);
    }
  };
  origDisposeCallback(node, newCallback);
};

var bindingPluginMaker = function(performanceAwareCaller) {
  return {
    viewModel: function(viewModel) {
      try {
        performanceAwareCaller('applyBindings', ko.applyBindings.bind(undefined, viewModel));
      } catch (err) {
        console.log(err, err.stack);
        throw err;
      }
    },
    dispose: function() {
      try {
        performanceAwareCaller('unapplyBindings', ko.cleanNode.bind(this, global.document.body));
      } catch (err) {
        console.log(err, err.stack);
        throw err;
      }
    }
  };
};

var templateCreator = function(templatePlugin, htmlOrElement, optionalName, templateMode) {
  var tmpName = optionalName;
  if (typeof optionalName != 'undefined' && typeof templateMode != 'undefined') {
    if (typeof htmlOrElement != 'object' || htmlOrElement.tagName.toLowerCase() != 'replacedhtml') tmpName += '-' + templateMode;
  }

  while (typeof tmpName == 'undefined' || tmpName === null || templatePlugin.exists(tmpName)) {
    tmpName = 'anonymous-' + Math.floor((Math.random() * 100000) + 1);
  }

  if (typeof htmlOrElement == 'object' && htmlOrElement.tagName.toLowerCase() == 'replacedhtml') {
    var $el = $(htmlOrElement);
    var $head = $('replacedhead', $el);
    var $body = $('replacedbody', $el);
    templatePlugin.adder(tmpName + '-head', $head.html() || '');
    templatePlugin.adder(tmpName + '-show', $body.html() || '');
    templatePlugin.adder(tmpName + '-preview', $el.html());
    templatePlugin.adder(tmpName + '-wysiwyg', $el.html());

    // $head.attr('data-bind', 'block: content');
    $head.children().detach();
    $head.html("<!-- ko block: content --><!-- /ko -->");
    $head.before('<!-- ko withProperties: { templateMode: \'head\' } -->');
    $head.after('<!-- /ko -->');
    $body.html("<!-- ko block: content --><!-- /ko -->");

    templatePlugin.adder(tmpName + '-iframe', $el[0].outerHTML);

  } else if (typeof htmlOrElement == 'object') {
    templatePlugin.adder(tmpName, htmlOrElement.outerHTML);
  } else {
    templatePlugin.adder(tmpName, htmlOrElement);
  }

  return tmpName;
};

// Adapter to transform "viewModel plugins" into more generic plugins.
function _viewModelPluginInstance(pluginFunction) {
  var instance;
  return {
    viewModel: function(viewModel) {
      instance = pluginFunction(viewModel);
    },
    init: function() {
      if (typeof instance !== 'undefined' && typeof instance.init !== 'undefined') instance.init();
    },
    dispose: function() {
      if (typeof instance !== 'undefined' && typeof instance.dispose !== 'undefined') instance.dispose();
    }
  };
}

var _templateUrlConverter = function(basePath, url) {
  if (!url.match(/^[^\/]*:/) && !url.match(/^\//) && !url.match(/^\[/) && !url.match(/^#?$/)) {
    // TODO this could be smarter joining the urls...
    return basePath + url;
  } else {
    return null;
  }
};

var templateLoader = function(performanceAwareCaller, templateFileName, templateMetadata, jsorjson, extensions, galleryUrl) {
  var templateFile = typeof templateFileName == 'string' ? templateFileName : templateMetadata.template;
  var templatePath = "./";
  var p = templateFile.lastIndexOf('/');
  if (p != -1) {
    templatePath = templateFile.substr(0, p + 1);
  }

  var templateUrlConverter = _templateUrlConverter.bind(undefined, templatePath);

  var metadata;
  if (typeof templateFile == 'string') {
    metadata = {
      template: templateFile,
      // TODO l10n?
      name: 'No name',
      created: Date.now()
    };
  } else {
    metadata = templateMetadata;
  }

  $.get(templateFile, function(templatecode) {
    var res = templateCompiler(performanceAwareCaller, templateUrlConverter, "template", templatecode, jsorjson, metadata, extensions, galleryUrl);
    res.init();
  });
};

var templateCompiler = function(performanceAwareCaller, templateUrlConverter, templateName, templatecode, jsorjson, metadata, extensions, galleryUrl) {
  // we strip content before <html> tag and after </html> because jquery doesn't parse it.
  // we'll keep it "raw" and use it in the preview/output methods.
  var res = templatecode.match(/^([\S\s]*)([<]html[^>]*>[\S\s]*<\/html>)([\S\s]*)$/i);
  if (res === null) throw "Unable to find <html> opening and closing tags in the template";
  var prefix = res[1];
  // we parse the html content after replacing the tag name for html/head/body so to avoid jquery issues in parsing.
  var basicStructure = { '<html': 0, '<head': 0, '<body': 0, '</html': 0, '</body': 0, '</head': 0 };
  var html = res[2].replace(/(<\/?)(html|head|body)([^>]*>)/gi, function(match, p1, p2, p3) {
    basicStructure[(p1+p2).toLowerCase()] += 1;
    return p1 + 'replaced' + p2 + p3;
  });
  for (var ele in basicStructure) if (basicStructure.hasOwnProperty(ele)) if (basicStructure[ele] != 1) {
    if (basicStructure[ele] === 0) throw "ERROR: missing mandatory element "+ele+">";
    if (basicStructure[ele] > 1) throw "ERROR: multiple element "+ele+"> occourences are not supported (found "+basicStructure[ele]+" occourences)";
  }
  var postfix = res[3];
  var blockDefs = [];
  var enableUndo = true;
  var enableRecorder = true;
  var baseThreshold = '+$root.contentListeners()';

  var plugins = [];

  if (typeof extensions !== 'undefined') {
    for (var i = 0; i < extensions.length; i++) {
      if (typeof extensions[i] == 'function') {
        plugins.push(_viewModelPluginInstance(extensions[i]));
      } else {
        plugins.push(extensions[i]);
      }
    }
  }

  var createdTemplates = [];
  var templatesPlugin = {
    adder: function(id, html) {
      if (typeof html !== 'string') throw "Template system: cannot create new template " + id;
      var trash = html.match(/(data)?-ko-[^ =:]*/g);
      if (trash) {
        console.error("ERROR: found unexpected -ko- attribute in compiled template", id, ", you probably mispelled it:", trash);
      }
      templateSystem.addTemplate(id, html);
      createdTemplates.push(id);
    },
    exists: function(id) {
      var el = templateSystem.getTemplateContent(id);
      if (typeof el !== 'undefined') return true;
      else return false;
    },
    dispose: function() {
      for (var i = createdTemplates.length - 1; i >= 0; i--) {
        templateSystem.removeTemplate(createdTemplates[i]);
      }
    }
  };

  ko.bindingHandlers['block'].templateExists = templatesPlugin.exists;

  // templatecreator tracks created template (via templateAdder) so to be able to dispose them later
  var myTemplateCreator = templateCreator.bind(undefined, templatesPlugin);

  // first pass: we "compile" the template into a termplateDef object
  var templateDef = performanceAwareCaller('translateTemplate', templateConverter.translateTemplate.bind(undefined, templateName, html, templateUrlConverter, myTemplateCreator));

  // second pass: given the templateDef we create a base content model object for this template.
  var content = performanceAwareCaller('generateModel', templateConverter.wrappedResultModel.bind(undefined, templateDef));

  // third pass: we create "style/content editors" for every block
  var widgets = {};
  var widgetPlugins = pluginsCall(plugins, 'widget', [$, ko, kojqui]);
  for (var wi = 0; wi < widgetPlugins.length; wi++) {
    widgets[widgetPlugins[wi].widget] = widgetPlugins[wi];
  }
  blockDefs.push.apply(blockDefs, performanceAwareCaller('generateEditors', templateConverter.generateEditors.bind(undefined, templateDef, widgets, templateUrlConverter, myTemplateCreator, baseThreshold)));

  var incompatibleTemplate = false;
  if (typeof jsorjson !== 'undefined' && jsorjson !== null) {
    var unwrapped;
    if (typeof jsorjson == 'string') {
      unwrapped = ko.utils.parseJson(jsorjson);
    } else {
      unwrapped = jsorjson;
    }

    // we run a basic compatibility check between the content-model we expect and the initialization model
    var checkModelRes = performanceAwareCaller('checkModel', templateConverter.checkModel.bind(undefined, content._unwrap(), blockDefs, unwrapped));
    // if checkModelRes is 1 then the model is not fully compatible but we fixed it
    if (checkModelRes == 2) {
      console.error("Trying to compile an incompatible template version!", content._unwrap(), blockDefs, unwrapped);
      incompatibleTemplate = true;
    }

    try {
      content._wrap(unwrapped);
    } catch (ex) {
      console.error("Unable to inject model content!", ex);
      incompatibleTemplate = true;
    }
  }

  // This build the template for the preview/output, but concatenating prefix, template and content and stripping the "replaced" prefix added to "problematic" tag (html/head/body)
  var iframeTpl = prefix + templateSystem.getTemplateContent(templateName + '-iframe').replace(/(<\/?)replaced(html|head|body)([^>]*>)/gi, function(match, p1, p2, p3) {
    return p1 + p2 + p3;
  }) + postfix;

  // store this so to restore it on disposale
  var origiFrameTpl = ko.bindingHandlers.bindIframe.tpl;
  ko.bindingHandlers.bindIframe.tpl = iframeTpl;
  var iFramePlugin = {
    dispose: function() {
      ko.bindingHandlers.bindIframe.tpl = origiFrameTpl;
    }
  };

  plugins.push(iFramePlugin);
  plugins.push(templatesPlugin);

  // initialize the viewModel object based on the content model.
  var viewModel = performanceAwareCaller('initializeViewmodel', initializeViewmodel.bind(this, content, blockDefs, templateUrlConverter, galleryUrl));

  viewModel.metadata = metadata;
  // let's run some version check on template and editor used to build the model being loaded.
  var editver = '0.13.0';
  if (typeof viewModel.metadata.editorversion !== 'undefined' && viewModel.metadata.editorversion !== editver) {
    console.warn("The model being loaded has been created with an older editor version", viewModel.metadata.editorversion, "vs", editver);
  }
  viewModel.metadata.editorversion = editver;

  if (typeof templateDef.version !== 'undefined') {
    if (typeof viewModel.metadata.templateversion !== 'undefined' && viewModel.metadata.templateversion !== templateDef.version) {
      console.error("The model being loaded has been created with a different template version", templateDef.version, "vs", viewModel.metadata.templateversion);
    }
    viewModel.metadata.templateversion = templateDef.version;
  }

  templateSystem.init();

  // everything's ready, start knockout bindings.
  plugins.push(bindingPluginMaker(performanceAwareCaller));

  pluginsCall(plugins, 'viewModel', [viewModel]);

  if (incompatibleTemplate) {
    $('#incompatible-template').dialog({
      modal: true,
      appendTo: '#mo-body',
      buttons: {
        Ok: function() {
          $(this).dialog("close");
        }
      }
    });
  }

  return {
    model: viewModel,
    init: function() {
      pluginsCall(plugins, 'init', undefined, true);
    },
    dispose: function() {
      pluginsCall(plugins, 'dispose', undefined, true);
    }
  };

};


var checkFeature = function(feature, func) {
  if (!func()) {
    console.warn("Missing feature", feature);
    throw "Missing feature " + feature;
  }
};

var isCompatible = function() {
  try {
    // window.msMatchMedia would match also IE9
    // IE9 wouldn't be so hard to support, but it doesn't worth it. (preview iframe and automatic scroll are 2 things not working in IE9)
    checkFeature('matchMedia', function() {
      return typeof global.matchMedia != 'undefined';
    });
    checkFeature('XMLHttpRequest 2', function() {
      return 'XMLHttpRequest' in global && 'withCredentials' in new global.XMLHttpRequest();
    });
    checkFeature('ES5 strict', function() {
      return function() { /* "use strict";*/
        return typeof this == 'undefined';
      }();
    });
    checkFeature('CSS borderRadius', function() {
      return typeof global.document.body.style['borderRadius'] != 'undefined';
    });
    checkFeature('CSS boxShadow', function() {
      return typeof global.document.body.style['boxShadow'] != 'undefined';
    });
    checkFeature('CSS boxSizing', function() {
      return typeof global.document.body.style['boxSizing'] != 'undefined';
    });
    checkFeature('CSS backgroundSize', function() {
      return typeof global.document.body.style['backgroundSize'] != 'undefined';
    });
    checkFeature('CSS backgroundOrigin', function() {
      return typeof global.document.body.style['backgroundOrigin'] != 'undefined';
    });
    return true;
  } catch (exception) {
    return false;
  }
};


var fixPageEvents = function() {
  // This is global code to prevent dragging/dropping in the page where we don't deal with it.
  // IE8 doesn't have window.addEventListener, but doesn't support drag&drop too.
  if (global.addEventListener) {
    // prevent generic file droppping in the page
    global.addEventListener("drag", function(e) {
      // console.log("browser is using drag listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("dragstart", function(e) {
      // console.log("browser is using dragstart listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("dragover", function(e) {
      // this is called on mouse move on every supported browser.
      // console.log("browser is using dragover listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.addEventListener("drop", function(e) {
      // console.log("browser is using drop listener on window");
      e = e || global.event;
      e.preventDefault();
    }, false);
    global.document.body.addEventListener('drop', function(e) {
      // I browser supportati entrato tutti qui quando si droppa qualcosa sul body
      // console.log("browser is using drop listener on body tag");
      e.preventDefault();
    }, false);
  }
  if (global.document.ondragstart) {
    global.document.ondragstart = function() {
      // console.log("browser called ondragstart. return false!");
      return false;
    };
  }
};

module.exports = {
  compile: templateCompiler,
  load: templateLoader,
  isCompatible: isCompatible,
  fixPageEvents: fixPageEvents
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./bindings/choose-template.js":22,"./converter/main.js":45,"./viewmodel.js":58}],55:[function(require,module,exports){
"use strict";

var console = require("./../../bower_components/console-browserify/index.js");

var _call = function(whatToCall) {
  return whatToCall();
};

var logs = [];

var _timedCall = function(name, whatToCall) {
  var res;
  var start = new Date().getTime();
  if (typeof console == 'object' && console.time) console.time(name);
  res = _call(whatToCall);
  if (typeof console == 'object' && console.time) console.timeEnd(name);
  var diff = new Date().getTime() - start;
  if (typeof console == 'object' && !console.time) console.log(name, "took", diff, "ms");
  logs.push({
    name: name,
    time: diff
  });
  // max logs
  if (logs.length > 100) logs.unshift();
  return res;
};

module.exports = {
  timedCall: _timedCall,
  logs: logs
};
},{"./../../bower_components/console-browserify/index.js":1}],56:[function(require,module,exports){
(function (global){
"use strict";

var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var undoManager = require("./../../../bower_components/knockout-undomanager/knockout-undomanager.js");
var undoserializer = require("./undoserializer.js");

var addUndoStackExtensionMaker = function(performanceAwareCaller) {
  return function(viewModel) {

    viewModel.contentListeners(viewModel.contentListeners() + 2);

    // TODO the labels should be computed observables (needs changes in undomanager projects)
    var undoRedoStack = undoManager(viewModel.content, {
      levels: 100,
      undoLabel: ko.computed(function() { return viewModel.t("Undo (#COUNT#)"); }),
      redoLabel: ko.computed(function() { return viewModel.t("Redo"); })
    });
    viewModel.undo = undoRedoStack.undoCommand;
    viewModel.undo.execute = performanceAwareCaller.bind(viewModel, 'undo', viewModel.undo.execute);
    viewModel.redo = undoRedoStack.redoCommand;
    viewModel.redo.execute = performanceAwareCaller.bind(viewModel, 'redo', viewModel.redo.execute);
    viewModel.undoReset = performanceAwareCaller.bind(viewModel, 'undoReset', undoRedoStack.reset);
    viewModel.setUndoModeMerge = undoRedoStack.setModeMerge;
    viewModel.setUndoModeOnce = undoRedoStack.setModeOnce;
    undoRedoStack.setModeIgnore();
    undoRedoStack.setUndoActionMaker(undoserializer.makeUndoAction.bind(undefined, viewModel.content));
    undoserializer.watchEnabled(true);

    return {
      pause: function() {
        undoRedoStack.setModeIgnore();
      },
      run: function() {
        undoRedoStack.setModeOnce();
      },
      init: function() {
        undoRedoStack.setModeOnce();
      },
      dispose: function() {
        viewModel.contentListeners(viewModel.contentListeners() - 2);
        undoserializer.watchEnabled(false);
        undoRedoStack.dispose();
      }
    };

  };
};

module.exports = addUndoStackExtensionMaker;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/knockout-undomanager/knockout-undomanager.js":5,"./undoserializer.js":57}],57:[function(require,module,exports){
(function (global){
"use strict";
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../../bower_components/console-browserify/index.js");
// This module deals with serialization/deserialization of a "tree-path" representing the path to reach the given leaf.
// In order to be correctly serialized we have to move from "reference" to "string" and viceversa.

var _reference = function(model, path) {
  var p = 0;
  var p1, p2;
  var m = model;
  while (p < path.length) {
    switch (path.charAt(p)) {
      case '(':
        if (path.charAt(p + 1) == ')') {
          m = m();
        } else {
          // TODO error
        }
        p += 2;
        break;
      case '[':
        p2 = path.indexOf(']', p);
        m = m[path.substring(p + 1, p2)];
        p = p2 + 1;
        break;
      case '.':
        p1 = path.indexOf('(', p);
        if (p1 == -1) p1 = path.length;
        p2 = path.indexOf('[', p);
        if (p2 == -1) p2 = path.length;
        p2 = Math.min(p1, p2);
        m = m[path.substring(p + 1, p2)];
        p = p2;
        break;
      default:
        // TODO error
    }
  }
  return m;
};

var _getPath = function(parents, child) {
  var path = "";
  var p;
  for (var k = 0; k <= parents.length; k++) {
    p = k < parents.length ? parents[k] : child;
    if (ko.isObservable(p)) path += '()';
    if (typeof p._fieldName !== 'undefined') {
      path += "." + p._fieldName;
    } else if (k > 0 && typeof parents[k - 1].pop == 'function') {
      var parentArray = ko.isObservable(parents[k - 1]) ? ko.utils.peekObservable(parents[k - 1]) : parents[k - 1];
      var pos = ko.utils.arrayIndexOf(parentArray, p);
      if (pos != -1) {
        path += "[" + pos + "]";
      } else {
        // NOTE this happen, sometimes when TinyMCE sends updates for objects already removed.
        console.error("Unexpected object not found in parent array", parentArray, p, k, parents.length, ko.toJS(parentArray), ko.utils.unwrapObservable(p));
        throw "Unexpected object not found in parent array";
      }
    } else {
      console.error("Unexpected parent with no _fieldName and no parent array", k, parents);
      throw "Unexpected parent with no _fieldName and no parent array";
    }
  }
  return path;
};

var makeDereferencedUndoAction = function(undoFunc, model, path, value, item) {
  var child = _reference(model, path);
  undoFunc(child, value, item);
};

var listener;

var _setListener = function(listenfunc) {
  listener = listenfunc;
};

/* dereferencing path and changing value with "toJS" */
var makeUndoActionDereferenced = function(model, undoFunc, parents, child, oldVal, item) {
  try {
    var path = _getPath(parents, child);

    // Transform actions in simple JS objects.
    if (typeof oldVal === 'object' || typeof oldVal === 'function') oldVal = ko.toJS(oldVal);
    if (typeof item !== 'undefined' && (typeof item.value === 'object' || typeof item.value === 'function')) {
      var newItem = ko.toJS(item);
      item = newItem;
    }

    if (typeof listener !== 'undefined') {
      try {
        listener(path, child, oldVal, item);
      } catch (e) {
        console.log("Undoserializer ignoring exception in listener callback");
      }
    }

    return makeDereferencedUndoAction.bind(undefined, undoFunc, model, path, oldVal, item);
  } catch (e) {
    // NOTE this happens, from time to time, when TinyMCE sends updates for deleted content.
    console.error("Exception processing undo", e, parents, child, item);
  }
};

var watchEnabled;
var _watchEnabled = function(newVal) {
  if (typeof newVal !== 'undefined')
    watchEnabled = newVal;
  else
    return watchEnabled;
};

module.exports = {
  dereference: _getPath,
  reference: _reference,
  makeUndoAction: makeUndoActionDereferenced,
  setListener: _setListener,
  watchEnabled: _watchEnabled
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../../bower_components/console-browserify/index.js":1}],58:[function(require,module,exports){
(function (global){
"use strict";
/* global global: false */

var $ = (typeof window !== "undefined" ? window['jQuery'] : typeof global !== "undefined" ? global['jQuery'] : null);
var ko = (typeof window !== "undefined" ? window['ko'] : typeof global !== "undefined" ? global['ko'] : null);
var console = require("./../../bower_components/console-browserify/index.js");
var performanceAwareCaller = require("./timed-call.js").timedCall;

var toastr = require("./../../bower_components/toastr/toastr.js");
toastr.options = {
  "closeButton": false,
  "debug": false,
  "positionClass": "toast-bottom-full-width",
  "target": "#mo-body",
  "onclick": null,
  "showDuration": "300",
  "hideDuration": "1000",
  "timeOut": "5000",
  "extendedTimeOut": "1000",
  "showEasing": "swing",
  "hideEasing": "linear",
  "showMethod": "fadeIn",
  "hideMethod": "fadeOut"
};

/* NOTE: translations moved to "plugin"
var strings = {
  'show preview and send test': 'Visualizza una anteprima e fai un invio di test',
  // Strings for app.js
  'Download': 'Download',
  'Test': 'Test',
  'Save': 'Salva',
  'Downloading...': "Download in corso...",
  'Invalid email address': "Indirizzo email invalido",
  "Test email sent...": "Email di test inviata...",
  'Unexpected error talking to server: contact us!': 'Errore di comunicazione con il server: contattaci!',
  'Insert here the recipient email address': 'Inserisci qui l\'indirizzo email a cui spedire',
  "Test email address": "Indirizzo email di test",
  // viewModel
  'Block removed: use undo button to restore it...': 'Blocco eliminato: usa il pulsante annulla per recuperarlo...',
  'New block added after the selected one (__pos__)': 'Nuovo blocco aggiunto sotto a quello selezionato (__pos__)',
  'New block added at the model bottom (__pos__)': 'Nuovo blocco aggiunto in fondo al modello (__pos__)',
  // undomain.js
  'Undo (#COUNT#)': 'Annulla (#COUNT#)',
  'Redo': 'Ripristina',
  // editor.js
  'Selected element has no editable properties': 'L\'elemento selezionato non fornisce propriet editabili',
  'This style is specific for this block: click here to remove the custom style and revert to the theme value': 'Questo stile  specifico di questo blocco: clicca qui per annullare lo stile personalizzato',
  'Switch between global and block level styles editing': 'Permette di specificare se si vuole modificare lo stile generale o solamente quello specifico del blocco selezionato',
  // main.tpl.html
  'Undo last operation': 'Annulla ultima operazione',
  'Redo last operation': 'Ripeti operazione annullata',
  'Show image gallery': 'Visualizza galleria immagini',
  'Gallery': 'Galleria',
  'Preview': 'Anteprima',
  'Show live preview': 'Mostra anteprima live',
  'Large screen': 'Schermo grande',
  'Tablet': 'Tablet',
  'Smartphone': 'Smartphone',
  'Show preview and send test': 'Visualizza una anteprima e fai un invio di test',
  'Download template': 'Scarica il template',
  'Save template': 'Salva il template',
  'Saved model is obsolete': 'Modello salvato obsoleto',
  '<p>The saved model has been created with a previous, non completely compatible version, of the template</p><p>Some content or style in the model <b>COULD BE LOST</b> if you will <b>save</b></p><p>Contact us for more informations!</p>': '<p>Il modello salvato  stato creato con una versione precedente del template non del tutto compatibile</p><p>Alcuni contenuti o stili del modello <b>POTREBBERO ESSERE PERSI</b> se procederai e deciderai di <b>salvare</b></p><p>Contattaci se hai dei dubbi!</p>',

  // TODO this cannot be done in knockout as with uncompatible browsers we don't initialize
  // 'Usupported browser': 'Browser non compatibile',
  // '<p>Your browser is not supported.</p><p>Use a different browser or try updaring your browser.</p><p>Supported browsers: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>': '<p>Il tuo browser non  supportato.</p><p>Accedi con un browser differente o prova ad aggiornare il tuo browser.</p><p>Browser supportati: <ul><li>Internet Explorer &gt;= 10</li><li>Google Chrome &gt;= 30</li><li>Apple Safari &gt;= 5</li><li>Mozilla Firefix &gt;= 20</li></ul></p>',

  // toolbox
  'Blocks': 'Blocchi',
  'Blocks ready to be added to the template': 'Elenco contenuti aggiungibili al messaggio',
  'Content': 'Contenuto',
  'Edit content options': 'Modifica opzioni contenuti',
  'Style': 'Stile',
  'Edit style options': 'Modifica opzioni grafiche',
  'Block __name__': 'Blocco __name__',
  'Click or drag to add this block to the template': 'Clicca o trascina per aggiungere al messaggio',
  'Add': 'Aggiungi',
  'By clicking on message parts you will select a block and content options, if any, will show here': 'Cliccando su alcune parti del messaggio selezionerai un blocco e le opzioni contenutistiche, se disponibili, compariranno qui',
  'By clicking on message parts you will select a block and style options, if available, will show here': 'Cliccando su alcune parti del messaggio selezionerai un blocco e le opzioni di stile, se disponibili, compariranno qui',
  'Click or drag files here': 'Clicca o trascina i file qui!',
  'No images uploaded, yet': 'Non hai ancora caricato immagini',
  'Show images from the gallery': 'Visualizza le immagini caricate nella tua area',
  'Loading...': 'Caricamento...',
  'Load gallery': 'Carica galleria',
  'Loading gallery...': 'Caricamento in corso...',
  'The gallery is empty': 'Nessuna immagine nella galleria',
  // img-wysiwyg.tmlp
  'Remove image': 'Rimuovi immagine',
  'Open the image editing tool': 'Avvia strumento modifica immagine',
  'Upload a new image': 'Carica una nuova immagine',
  'Drop an image here': 'Trascina una immagine qui',
  'Drop an image here or click the upload button': 'Trascina una immagine qui o clicca sul pulsante di caricamento',
  // gallery
  'Drag this image and drop it on any template image placeholder': 'Trascina questa immagine sulla posizione in cui vuoi inserirla',
  'Gallery:': 'Galleria:',
  'Session images': 'Immagini di sessione',
  'Recents': 'Recenti',
  'Remote gallery': 'Galleria remota',

  // customstyle
  'Customized block.<ul><li>In this status changes to properties will be specific to the current block (instead of being global to all blocks in the same section)</li><li>A <span class="customStyled"><span>"small cube" </span></span> icon beside the property will mark the customization. By clicking this icon the property value will be reverted to the value defined for the section.</li></ul>': 'Blocco personalizzato.<ul><li>In questa modalit se cambi una propriet verr modificata solamente per questo specifico blocco (invece che per tutti i blocchi della stessa sezione).</li><li>Per segnalare la personalizzazione apparir l\'icona <span class="customStyled"><span> del "cubetto"</span></span> a fianco delle propriet. Cliccando questa icona tornerai al valore comune.</li></ul>',
  // blocks-wysiwyg
  'Drop here blocks from the "Blocks" tab': 'Trascina qui i blocchi dalla scheda \'Blocchi\'',
  // block-wysiwyg
  'Drag this handle to move the block': 'Trascina per spostare il blocco altrove',
  'Move this block upside': 'Sposta il blocco in su',
  'Move this block downside': 'Sposta il blocco in giu',
  'Delete block': 'Elimina blocco',
  'Duplicate block': 'Duplica blocco',
  'Switch block variant': 'Cambia variante blocco',
  // colorpicker
  'Theme Colors,Standard Colors,Web Colors,Theme Colors,Back to Palette,History,No history yet.': 'Colori Tema,Colori Standard,Colori Web,Colori Tema,Torna alla tavolozza,Storico,storico colori vuoto',

  'Drop here': 'Rilascia qui',

};
*/

function initializeEditor(content, blockDefs, thumbPathConverter, galleryUrl) {

  var viewModel = {
    galleryRecent: ko.observableArray([]).extend({
      paging: 16
    }),
    galleryRemote: ko.observableArray([]).extend({
      paging: 16
    }),
    selectedBlock: ko.observable(null),
    selectedItem: ko.observable(null),
    selectedTool: ko.observable(0),
    selectedImageTab: ko.observable(0),
    dragging: ko.observable(false),
    draggingImage: ko.observable(false),
    galleryLoaded: ko.observable(false),
    showPreviewFrame: ko.observable(false),
    previewMode: ko.observable('mobile'),
    showToolbox: ko.observable(true),
    showTheme: ko.observable(false),
    showGallery: ko.observable(false),
    debug: ko.observable(false),
    contentListeners: ko.observable(0),

    logoPath: 'media/editor-icon.png',
    logoUrl: '.',
    logoAlt: 'badsender'
  };

  // viewModel.content = content._instrument(ko, content, undefined, true);
  viewModel.content = content;
  viewModel.blockDefs = blockDefs;

  viewModel.notifier = toastr;

  // Does token substitution in i18next style
  viewModel.tt = function(key, paramObj) {
    if (typeof paramObj !== 'undefined')
      for (var prop in paramObj)
        if (paramObj.hasOwnProperty(prop)) {
          key = key.replace(new RegExp('__' + prop + '__', 'g'), paramObj[prop]);
        }
    return key;
  };

  // Simply maps to tt: language plugins can override this method to define their own language
  // handling.
  // If this method invokes an observable (e.g: viewModel.lang()) then the UI language will automatically
  // update when the "lang" observable changes.
  viewModel.t = viewModel.tt;

  // currently called by editor.html to translate template-defined keys (label, help, descriptions)
  // the editor always uses the "template" category for that strings.
  // you can override this method as you like in order to provide translation or change the strings in any way.
  viewModel.ut = function(category, key) {
    return key;
  };

  viewModel.templatePath = thumbPathConverter;

  viewModel.remoteUrlProcessor = function(url) {
    return url;
  };

  viewModel.remoteFileProcessor = function(fileObj) {
    if (typeof fileObj.url !== 'undefined') fileObj.url = viewModel.remoteUrlProcessor(fileObj.url);
    if (typeof fileObj.thumbnailUrl !== 'undefined') fileObj.thumbnailUrl = viewModel.remoteUrlProcessor(fileObj.thumbnailUrl);
    // deleteUrl?
    return fileObj;
  };

  // toolbox.tmpl.html
  viewModel.loadGallery = function() {
    viewModel.galleryLoaded('loading');
    var url = galleryUrl ? galleryUrl : '/upload/';
    // retrieve the full list of remote files
    $.getJSON(url, function(data) {
      for (var i = 0; i < data.files.length; i++) data.files[i] = viewModel.remoteFileProcessor(data.files[i]);
      viewModel.galleryLoaded(data.files.length);
      // TODO do I want this call to return relative paths? Or just absolute paths?
      viewModel.galleryRemote(data.files.reverse());
    }).fail(function() {
      viewModel.galleryLoaded(false);
      viewModel.notifier.error(viewModel.t('Unexpected error listing files'));
    });
  };

  // img-wysiwyg.tmpl.html
  viewModel.fileToImage = function(obj, event, ui) {
    // console.log("fileToImage", obj);
    return obj.url;
  };

  // block-wysiwyg.tmpl.html
  viewModel.removeBlock = function(data, parent) {
    // let's unselect the block
    if (ko.utils.unwrapObservable(viewModel.selectedBlock) == ko.utils.unwrapObservable(data)) {
      viewModel.selectBlock(null, true);
    }
    var res = parent.blocks.remove(data);
    // TODO This message should be different depending on undo plugin presence.
    viewModel.notifier.info(viewModel.t('Block removed: use undo button to restore it...'));
    return res;
  };

  // block-wysiwyg.tmpl.html
  viewModel.duplicateBlock = function(index, parent) {
    var idx = ko.utils.unwrapObservable(index);
    // Deinstrument/deobserve the object
    var unwrapped = ko.toJS(ko.utils.unwrapObservable(parent.blocks)[idx]);
    // We need to remove the id so that a new one will be assigned to the clone
    if (typeof unwrapped.id !== 'undefined') unwrapped.id = '';
    // insert the cloned block
    parent.blocks.splice(idx + 1, 0, unwrapped);
  };

  // block-wysiwyg.tmpl.html
  viewModel.moveBlock = function(index, parent, up) {
    var idx = ko.utils.unwrapObservable(index);
    var parentBlocks = ko.utils.unwrapObservable(parent.blocks);
    if ((up && idx > 0) || (!up && idx < parentBlocks.length - 1)) {
      var destIndex = idx + (up ? -1 : 1);
      var destBlock = parentBlocks[destIndex];
      viewModel.startMultiple();
      parent.blocks.splice(destIndex, 1);
      parent.blocks.splice(idx, 0, destBlock);
      viewModel.stopMultiple();
    }
  };

  // test method, command line use only
  viewModel.loadDefaultBlocks = function() {
    // cloning the whole "mainBlocks" object so that undomanager will
    // see it as a single operation (maybe I could use "startMultiple"/"stopMultiple".
    var res = ko.toJS(viewModel.content().mainBlocks);
    res.blocks = [];
    var input = ko.utils.unwrapObservable(viewModel.blockDefs);
    for (var i = 0; i < input.length; i++) {
      var obj = ko.toJS(input[i]);
      // generating ids for blocks, maybe this would work also leaving it empty.
      obj.id = 'block_' + i;
      res.blocks.push(obj);
    }
    performanceAwareCaller('setMainBlocks', viewModel.content().mainBlocks._wrap.bind(viewModel.content().mainBlocks, res));
  };

  // gallery-images.tmpl.html
  viewModel.addImage = function(img) {
    var selectedImg = $('#main-wysiwyg-area .selectable-img.selecteditem');
    if (selectedImg.length == 1 && typeof img == 'object' && typeof img.url !== 'undefined') {
      ko.contextFor(selectedImg[0])._src(img.url);
      return true;
    } else {
      return false;
    }
  };

  // toolbox.tmpl.html
  viewModel.addBlock = function(obj, event) {
    // if there is a selected block we try to add the block just after the selected one.
    var selected = viewModel.selectedBlock();
    // search the selected block position.
    var found;
    if (selected !== null) {
      // TODO "mainBlocks" is an hardcoded thing.
      for (var i = viewModel.content().mainBlocks().blocks().length - 1; i >= 0; i--) {
        if (viewModel.content().mainBlocks().blocks()[i]() == selected) {
          found = i;
          break;
        }
      }
    }
    var pos;
    if (typeof found !== 'undefined') {
      pos = found + 1;
      viewModel.content().mainBlocks().blocks.splice(pos, 0, obj);
      viewModel.notifier.info(viewModel.t('New block added after the selected one (__pos__)', {
        pos: pos
      }));
    } else {
      viewModel.content().mainBlocks().blocks.push(obj);
      pos = viewModel.content().mainBlocks().blocks().length - 1;
      viewModel.notifier.info(viewModel.t('New block added at the model bottom (__pos__)', {
        pos: pos
      }));
    }
    // find the newly added block and select it!
    var added = viewModel.content().mainBlocks().blocks()[pos]();
    viewModel.selectBlock(added, true);
    // prevent click propagation (losing url hash - see #43)
    return false;
  };

  // Used by stylesheet.js to create multiple styles
  viewModel.findObjectsOfType = function(data, type) {
    var res = [];
    var obj = ko.utils.unwrapObservable(data);
    for (var prop in obj)
      if (obj.hasOwnProperty(prop)) {
        var val = ko.utils.unwrapObservable(obj[prop]);
        // TODO this is not the right way to deal with "block list" objects.
        if (prop.match(/Blocks$/)) {
          var contents = ko.utils.unwrapObservable(val.blocks);
          for (var i = 0; i < contents.length; i++) {
            var c = ko.utils.unwrapObservable(contents[i]);
            if (type === null || ko.utils.unwrapObservable(c.type) == type) res.push(c);
          }
          // TODO investigate which condition provide a null value.
        } else if (typeof val == 'object' && val !== null) {
          if (type === null || ko.utils.unwrapObservable(val.type) == type) res.push(val);
        }
      }
    return res;
  };

  /*
  viewModel.placeholderHelper = 'sortable-placeholder';
  if (false) {
    viewModel.placeholderHelper = {
      element: function(currentItem) {
        return $('<div />').removeClass('ui-draggable').addClass('sortable-placeholder').css('position', 'relative').css('width', '100%').css('height', currentItem.css('height')).css('opacity', '.8')[0];
      },
      update: function(container, p) {
       return;
      }
    };
  }
  */

  // Attempt to insert the block in the destination layout during dragging
  viewModel.placeholderHelper = {
    element: function(currentItem) {
      return $(currentItem[0].outerHTML).removeClass('ui-draggable').addClass('sortable-placeholder').css('display', 'block').css('position', 'relative').css('width', '100%').css('height', 'auto').css('opacity', '.8')[0];
    },
    update: function(container, p) {
      return;
    }
  };

  // TODO the undumanager should be pluggable.
  // Used by "moveBlock" and blocks-wysiwyg.tmpl.html to "merge" drag/drop operations into a single undo/redo op.
  viewModel.startMultiple = function() {
    if (typeof viewModel.setUndoModeMerge !== 'undefined') viewModel.setUndoModeMerge();
  };
  viewModel.stopMultiple = function() {
    if (typeof viewModel.setUndoModeOnce !== 'undefined') viewModel.setUndoModeOnce();
  };

  // Used by code generated by editor.js
  viewModel.localGlobalSwitch = function(prop, globalProp) {
    var current = prop();
    if (current === null) prop(globalProp());
    else prop(null);
    return false;
  };

  // Used by editor and main "converter" to support item selection
  viewModel.selectItem = function(valueAccessor, item, block) {
    var val = ko.utils.peekObservable(valueAccessor);
    if (typeof block !== 'undefined') viewModel.selectBlock(block, false, true);
    if (val != item) {
      valueAccessor(item);
      // On selectItem if we were on "Blocks" toolbox tab we move to "Content" toolbox tab.
      if (item !== null && viewModel.selectedTool() === 0) viewModel.selectedTool(1);
    }
    return false;
  }.bind(viewModel, viewModel.selectedItem);

  viewModel.isSelectedItem = function(item) {
    return viewModel.selectedItem() == item;
  };

  viewModel.selectBlock = function(valueAccessor, item, doNotSelect, doNotUnselectItem) {
    var val = ko.utils.peekObservable(valueAccessor);
    if (!doNotUnselectItem) viewModel.selectItem(null);
    if (val != item) {
      valueAccessor(item);
      // hide gallery on block selection
      viewModel.showGallery(false);
      if (item !== null && !doNotSelect && viewModel.selectedTool() === 0) viewModel.selectedTool(1);
    }
  }.bind(viewModel, viewModel.selectedBlock);

  // DEBUG
  viewModel.countSubscriptions = function(model, debug) {
    var res = 0;
    for (var prop in model)
      if (model.hasOwnProperty(prop)) {
        var p = model[prop];
        if (ko.isObservable(p)) {
          if (typeof p._defaultComputed != 'undefined') {
            if (typeof debug != 'undefined') console.log(debug + "/" + prop + "/_", p._defaultComputed.getSubscriptionsCount());
            res += p._defaultComputed.getSubscriptionsCount();
          }
          if (typeof debug != 'undefined') console.log(debug + "/" + prop + "/-", p.getSubscriptionsCount());
          res += p.getSubscriptionsCount();
          p = ko.utils.unwrapObservable(p);
        }
        if (typeof p == 'object' && p !== null) {
          var tot = viewModel.countSubscriptions(p, typeof debug != 'undefined' ? debug + '/' + prop + "@" : undefined);
          if (typeof debug != 'undefined') console.log(debug + "/" + prop + "@", tot);
          res += tot;
        }
      }
    return res;
  };

  // DEBUG
  viewModel.loopSubscriptionsCount = function() {
    var count = viewModel.countSubscriptions(viewModel.content());
    global.document.getElementById('subscriptionsCount').innerHTML = count;
    global.setTimeout(viewModel.loopSubscriptionsCount, 1000);
  };

  viewModel.export = function() {
    var content = performanceAwareCaller("exportHTML", viewModel.exportHTML);
    return content;
  };

  function conditional_restore(html) {
    return html.replace(/<replacedcc[^>]* condition="([^"]*)"[^>]*>([\s\S]*?)<\/replacedcc>/g, function(match, condition, body) {
      var dd = '<!--[if '+condition+']>';
      dd += body.replace(/<!-- cc:before:([^ ]*) --><!-- cc:after:\1 -->/g, '</$1>')
            .replace(/^.*<!-- cc:start -->/,'')
            .replace(/<!-- cc:end -->.*$/,'')
            .replace(/<(\/?)cc([A-Za-z]*)/g, '<$1$2');
      dd += '<![endif]-->';
      return dd;
    });
  }

  viewModel.exportHTML = function() {
    var id = 'exportframe';
    $('body').append('<iframe id="' + id + '" data-bind="bindIframe: $data"></iframe>');
    var frameEl = global.document.getElementById(id);
    ko.applyBindings(viewModel, frameEl);
    // Obsolete method didn't work on IE11 when using "HTML5 doctype":
    // var docType = new XMLSerializer().serializeToString(global.document.doctype);
    var node = frameEl.contentWindow.document.doctype;
    var docType = "<!DOCTYPE " + node.name +
      (node.publicId ? ' PUBLIC "' + node.publicId + '"' : '') +
      (!node.publicId && node.systemId ? ' SYSTEM' : '') +
      (node.systemId ? ' "' + node.systemId + '"' : '') + '>';
    var content = docType + "\n" + frameEl.contentWindow.document.documentElement.outerHTML;
    ko.cleanNode(frameEl);
    ko.removeNode(frameEl);

    content = content.replace(/<script ([^>]* )?type="text\/html"[^>]*>[\s\S]*?<\/script>/gm, '');
    // content = content.replace(/<!-- ko .*? -->/g, ''); // sometimes we have expressions like (<!-- ko var > 2 -->)
    content = content.replace(/<!-- ko ((?!--).)*? -->/g, ''); // this replaces the above with a more formal (but slower) solution
    content = content.replace(/<!-- \/ko -->/g, '');
    // Remove data-bind/data-block attributes
    content = content.replace(/ data-bind="[^"]*"/gm, '');
    // Remove trash leftover by TinyMCE
    content = content.replace(/ data-mce-(href|src)="[^"]*"/gm, '');

    // Replace "replacedstyle" to "style" attributes (chrome puts replacedstyle after style)
    content = content.replace(/ style="[^"]*"([^>]*) replaced(style="[^"]*")/gm, '$1 $2');
    // Replace "replacedstyle" to "style" attributes (ie/ff have reverse order)
    content = content.replace(/ replaced(style="[^"]*")([^>]*) style="[^"]*"/gm, ' $1$2');
    content = content.replace(/ replaced(style="[^"]*")/gm, ' $1');

    // same as style, but for http-equiv (some browser break it if we don't replace, but then we find it duplicated)
    content = content.replace(/ http-equiv="[^"]*"([^>]*) replaced(http-equiv="[^"]*")/gm, '$1 $2');
    content = content.replace(/ replaced(http-equiv="[^"]*")([^>]*) http-equiv="[^"]*"/gm, ' $1$2');
    content = content.replace(/ replaced(http-equiv="[^"]*")/gm, ' $1');

    // We already replace style and http-equiv and we don't need this.
    // content = content.replace(/ replaced([^= ]*=)/gm, ' $1');
    // Restore conditional comments
    content = conditional_restore(content);
    var trash = content.match(/ data-[^ =]+(="[^"]+")? /) || content.match(/ replaced([^= ]*=)/);
    if (trash) {
      console.warn("Output HTML contains unexpected data- attributes or replaced attributes", trash);
    }

    return content;
  };

  viewModel.exportHTMLtoTextarea = function(textareaid) {
    $(textareaid).val(viewModel.exportHTML());
  };

  viewModel.exportJSONtoTextarea = function(textareaid) {
    $(textareaid).val(viewModel.exportJSON());
  };

  viewModel.importJSONfromTextarea = function(textareaid) {
    viewModel.importJSON($(textareaid).val());
  };

  viewModel.exportMetadata = function() {
    var json = ko.toJSON(viewModel.metadata);
    return json;
  };

  viewModel.exportJSON = function() {
    var json = ko.toJSON(viewModel.content);
    return json;
  };

  viewModel.exportJS = function() {
    return ko.toJS(viewModel.content);
  };

  viewModel.importJSON = function(json) {
    var unwrapped = ko.utils.parseJson(json);
    viewModel.content._wrap(unwrapped);
  };

  viewModel.exportTheme = function() {
    var flat = {};
    var mod = viewModel.content().theme();

    var _export = function(prefix, flat, mod) {
      for (var prop in mod)
        if (mod.hasOwnProperty(prop)) {
          var a = ko.utils.unwrapObservable(mod[prop]);
          if (a !== null && typeof a == 'object') {
            _export(prop + '.', flat, a);
          } else {
            flat[prefix + prop] = a;
          }
        }
    };

    _export('', flat, mod);

    var output = '';
    for (var prop in flat)
      if (flat.hasOwnProperty(prop) && prop != 'type') {
        output += prop + ": " + flat[prop] + ";" + "\n";
      }

    return output;
  };

  // moxiemanager (or file browser/imageeditor) extension points.
  // Just implement editImage or linkDialog methods
  // viewModel.editImage = function(src, done) {} : implement this method to enable image editing (src is a wirtableObservable).
  // viewModel.linkDialog = function() {}: implement this method using "this" to find the input element $(this).val is a writableObservable.

  viewModel.loadImage = function(img) {
    // push image at top of "recent" gallery
    viewModel.galleryRecent.unshift(img);
    // select recent gallery tab
    viewModel.selectedImageTab(0);
  };

  viewModel.dialog = function(selector, options) {
    $(selector).dialog(options);
  };

  // Dummy log method overridden by extensions
  viewModel.log = function(category, msg) {
    // console.log("viewModel.log", category, msg);
  };

  // automatically load the gallery when the gallery tab is selected
  viewModel.selectedImageTab.subscribe(function(newValue) {
    if (newValue == 1 && viewModel.galleryLoaded() === false) {
      viewModel.loadGallery();
    }
  }, viewModel, 'change');

  return viewModel;

}

module.exports = initializeEditor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../bower_components/console-browserify/index.js":1,"./../../bower_components/toastr/toastr.js":12,"./timed-call.js":55}]},{},[19,13])(19)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qcyIsImJvd2VyX2NvbXBvbmVudHMvZXZvbC1jb2xvcnBpY2tlci9qcy9ldm9sLmNvbG9ycGlja2VyLm1pbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvanNlcC9zcmMvanNlcC5qcyIsImJvd2VyX2NvbXBvbmVudHMva25vY2tvdXQtc29ydGFibGUvYnVpbGQva25vY2tvdXQtc29ydGFibGUubWluLmpzIiwiYm93ZXJfY29tcG9uZW50cy9rbm9ja291dC11bmRvbWFuYWdlci9rbm9ja291dC11bmRvbWFuYWdlci5qcyIsImJvd2VyX2NvbXBvbmVudHMva25vY2tvdXQud3JhcC9rbm9ja291dC53cmFwLmpzIiwiYm93ZXJfY29tcG9uZW50cy9rbm9ja291dGpzLXJlYWN0b3IvZGlzdC9rby1yZWFjdG9yLm1pbi5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9kZWJ1Zy5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9sZXhlci5qcyIsImJvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9wYXJzZXIuanMiLCJib3dlcl9jb21wb25lbnRzL3Rpbnljb2xvci90aW55Y29sb3IuanMiLCJib3dlcl9jb21wb25lbnRzL3RvYXN0ci90b2FzdHIuanMiLCJidWlsZC90ZW1wbGF0ZXMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsInNyYy9qcy9hcHAuanMiLCJzcmMvanMvYmluZGluZ3MvYmluZC1pZnJhbWUuanMiLCJzcmMvanMvYmluZGluZ3MvYmxvY2tzLmpzIiwic3JjL2pzL2JpbmRpbmdzL2Nob29zZS10ZW1wbGF0ZS5qcyIsInNyYy9qcy9iaW5kaW5ncy9jb2xvcnBpY2tlci5qcyIsInNyYy9qcy9iaW5kaW5ncy9jc3N0ZXh0LmpzIiwic3JjL2pzL2JpbmRpbmdzL2Ryb3BwYWJsZS5qcyIsInNyYy9qcy9iaW5kaW5ncy9ldmVudGFibGUuanMiLCJzcmMvanMvYmluZGluZ3MvZXh0ZW5kZXItcGFnaW5hdGlvbi5qcyIsInNyYy9qcy9iaW5kaW5ncy9leHRzb3J0YWJsZXMuanMiLCJzcmMvanMvYmluZGluZ3MvZmlsZXVwbG9hZC5qcyIsInNyYy9qcy9iaW5kaW5ncy9pZi1zdWJzLmpzIiwic3JjL2pzL2JpbmRpbmdzL2pxdWVyeXVpLXNwaW5uZXIuanMiLCJzcmMvanMvYmluZGluZ3MvanF1ZXJ5dWktdGFicy5qcyIsInNyYy9qcy9iaW5kaW5ncy9zY3JpcHQtdGVtcGxhdGUuanMiLCJzcmMvanMvYmluZGluZ3Mvc2Nyb2xsZml4LmpzIiwic3JjL2pzL2JpbmRpbmdzL3Njcm9sbGludG92aWV3LmpzIiwic3JjL2pzL2JpbmRpbmdzL3N0cmluZy10ZW1wbGF0ZS5qcyIsInNyYy9qcy9iaW5kaW5ncy90b29sdGlwcy5qcyIsInNyYy9qcy9iaW5kaW5ncy92YWxpZGF0ZWQtdmFsdWUuanMiLCJzcmMvanMvYmluZGluZ3MvdmlydHVhbHMuanMiLCJzcmMvanMvYmluZGluZ3Mvd3lzaXd5Z3MuanMiLCJzcmMvanMvY29udmVydGVyL2NoZWNrbW9kZWwuanMiLCJzcmMvanMvY29udmVydGVyL2RlY2xhcmF0aW9ucy5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvZG9tdXRpbHMuanMiLCJzcmMvanMvY29udmVydGVyL2VkaXRvci5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvbWFpbi5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvbW9kZWwuanMiLCJzcmMvanMvY29udmVydGVyL3BhcnNlci5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvc3R5bGVzaGVldC5qcyIsInNyYy9qcy9jb252ZXJ0ZXIvdXRpbHMuanMiLCJzcmMvanMvY29udmVydGVyL3dyYXBwZXIuanMiLCJzcmMvanMvZXh0L2NvbG9yLmpzIiwic3JjL2pzL2V4dC9sb2NhbHN0b3JhZ2UuanMiLCJzcmMvanMva28tYmluZGluZ3MuanMiLCJzcmMvanMvdGVtcGxhdGUtbG9hZGVyLmpzIiwic3JjL2pzL3RpbWVkLWNhbGwuanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb21haW4uanMiLCJzcmMvanMvdW5kb21hbmFnZXIvdW5kb3NlcmlhbGl6ZXIuanMiLCJzcmMvanMvdmlld21vZGVsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxbUJBO0FBQ0E7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xOQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzb0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbnZhciBjb25zb2xlXG52YXIgdGltZXMgPSB7fVxuXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZVxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG59IGVsc2Uge1xuICAgIGNvbnNvbGUgPSB7fVxufVxuXG52YXIgZnVuY3Rpb25zID0gW1xuICAgIFtsb2csIFwibG9nXCJdXG4gICAgLCBbaW5mbywgXCJpbmZvXCJdXG4gICAgLCBbd2FybiwgXCJ3YXJuXCJdXG4gICAgLCBbZXJyb3IsIFwiZXJyb3JcIl1cbiAgICAsIFt0aW1lLCBcInRpbWVcIl1cbiAgICAsIFt0aW1lRW5kLCBcInRpbWVFbmRcIl1cbiAgICAsIFt0cmFjZSwgXCJ0cmFjZVwiXVxuICAgICwgW2RpciwgXCJkaXJcIl1cbiAgICAsIFthc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IERhdGUubm93KClcbn1cblxuZnVuY3Rpb24gdGltZUVuZChsYWJlbCkge1xuICAgIHZhciB0aW1lID0gdGltZXNbbGFiZWxdXG4gICAgaWYgKCF0aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggbGFiZWw6IFwiICsgbGFiZWwpXG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQoZXhwcmVzc2lvbikge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgYXJyID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAgIGFzc2VydC5vayhmYWxzZSwgdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJyKSlcbiAgICB9XG59XG4iLCIvKlxuICAgZXZvbC5jb2xvcnBpY2tlciAzLjIuMlxuICAgKGMpIDIwMTUgT2xpdmllciBHaXVsaWVyaVxuICAgaHR0cDovL2V2b2x1dGV1ci5naXRodWIuaW8vY29sb3JwaWNrZXIvXG4qL1xuIWZ1bmN0aW9uKGEsYil7dmFyIGM9MCxkPXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LGU9ZC5pbmRleE9mKFwiTVNJRSBcIik+MCxmPWU/XCItaWVcIjpcIlwiLGc9ZT8hMTovbW96aWxsYS8udGVzdChkLnRvTG93ZXJDYXNlKCkpJiYhL3dlYmtpdC8udGVzdChkLnRvTG93ZXJDYXNlKCkpLGg9W10saT1bXCJmZmZmZmZcIixcIjAwMDAwMFwiLFwiZWVlY2UxXCIsXCIxZjQ5N2RcIixcIjRmODFiZFwiLFwiYzA1MDRkXCIsXCI5YmJiNTlcIixcIjgwNjRhMlwiLFwiNGJhY2M2XCIsXCJmNzk2NDZcIl0saj1bXCJmMmYyZjJcIixcIjdmN2Y3ZlwiLFwiZGRkOWMzXCIsXCJjNmQ5ZjBcIixcImRiZTVmMVwiLFwiZjJkY2RiXCIsXCJlYmYxZGRcIixcImU1ZTBlY1wiLFwiZGJlZWYzXCIsXCJmZGVhZGFcIixcImQ4ZDhkOFwiLFwiNTk1OTU5XCIsXCJjNGJkOTdcIixcIjhkYjNlMlwiLFwiYjhjY2U0XCIsXCJlNWI5YjdcIixcImQ3ZTNiY1wiLFwiY2NjMWQ5XCIsXCJiN2RkZThcIixcImZiZDViNVwiLFwiYmZiZmJmXCIsXCIzZjNmM2ZcIixcIjkzODk1M1wiLFwiNTQ4ZGQ0XCIsXCI5NWIzZDdcIixcImQ5OTY5NFwiLFwiYzNkNjliXCIsXCJiMmEyYzdcIixcIjkyY2RkY1wiLFwiZmFjMDhmXCIsXCJhNWE1YTVcIixcIjI2MjYyNlwiLFwiNDk0NDI5XCIsXCIxNzM2NWRcIixcIjM2NjA5MlwiLFwiOTUzNzM0XCIsXCI3NjkyM2NcIixcIjVmNDk3YVwiLFwiMzE4NTliXCIsXCJlMzZjMDlcIixcIjdmN2Y3ZlwiLFwiMGMwYzBjXCIsXCIxZDFiMTBcIixcIjBmMjQzZVwiLFwiMjQ0MDYxXCIsXCI2MzI0MjNcIixcIjRmNjEyOFwiLFwiM2YzMTUxXCIsXCIyMDU4NjdcIixcIjk3NDgwNlwiXSxrPVtcImMwMDAwMFwiLFwiZmYwMDAwXCIsXCJmZmMwMDBcIixcImZmZmYwMFwiLFwiOTJkMDUwXCIsXCIwMGIwNTBcIixcIjAwYjBmMFwiLFwiMDA3MGMwXCIsXCIwMDIwNjBcIixcIjcwMzBhMFwiXSxsPVtbXCIwMDMzNjZcIixcIjMzNjY5OVwiLFwiMzM2NmNjXCIsXCIwMDMzOTlcIixcIjAwMDA5OVwiLFwiMDAwMGNjXCIsXCIwMDAwNjZcIl0sW1wiMDA2NjY2XCIsXCIwMDY2OTlcIixcIjAwOTljY1wiLFwiMDA2NmNjXCIsXCIwMDMzY2NcIixcIjAwMDBmZlwiLFwiMzMzM2ZmXCIsXCIzMzMzOTlcIl0sW1wiNjY5OTk5XCIsXCIwMDk5OTlcIixcIjMzY2NjY1wiLFwiMDBjY2ZmXCIsXCIwMDk5ZmZcIixcIjAwNjZmZlwiLFwiMzM2NmZmXCIsXCIzMzMzY2NcIixcIjY2NjY5OVwiXSxbXCIzMzk5NjZcIixcIjAwY2M5OVwiLFwiMDBmZmNjXCIsXCIwMGZmZmZcIixcIjMzY2NmZlwiLFwiMzM5OWZmXCIsXCI2Njk5ZmZcIixcIjY2NjZmZlwiLFwiNjYwMGZmXCIsXCI2NjAwY2NcIl0sW1wiMzM5OTMzXCIsXCIwMGNjNjZcIixcIjAwZmY5OVwiLFwiNjZmZmNjXCIsXCI2NmZmZmZcIixcIjY2Y2NmZlwiLFwiOTljY2ZmXCIsXCI5OTk5ZmZcIixcIjk5NjZmZlwiLFwiOTkzM2ZmXCIsXCI5OTAwZmZcIl0sW1wiMDA2NjAwXCIsXCIwMGNjMDBcIixcIjAwZmYwMFwiLFwiNjZmZjk5XCIsXCI5OWZmY2NcIixcImNjZmZmZlwiLFwiY2NjY2ZmXCIsXCJjYzk5ZmZcIixcImNjNjZmZlwiLFwiY2MzM2ZmXCIsXCJjYzAwZmZcIixcIjk5MDBjY1wiXSxbXCIwMDMzMDBcIixcIjAwOTkzM1wiLFwiMzNjYzMzXCIsXCI2NmZmNjZcIixcIjk5ZmY5OVwiLFwiY2NmZmNjXCIsXCJmZmZmZmZcIixcImZmY2NmZlwiLFwiZmY5OWZmXCIsXCJmZjY2ZmZcIixcImZmMDBmZlwiLFwiY2MwMGNjXCIsXCI2NjAwNjZcIl0sW1wiMzMzMzAwXCIsXCIwMDk5MDBcIixcIjY2ZmYzM1wiLFwiOTlmZjY2XCIsXCJjY2ZmOTlcIixcImZmZmZjY1wiLFwiZmZjY2NjXCIsXCJmZjk5Y2NcIixcImZmNjZjY1wiLFwiZmYzM2NjXCIsXCJjYzAwOTlcIixcIjk5MzM5OVwiXSxbXCIzMzY2MDBcIixcIjY2OTkwMFwiLFwiOTlmZjMzXCIsXCJjY2ZmNjZcIixcImZmZmY5OVwiLFwiZmZjYzk5XCIsXCJmZjk5OTlcIixcImZmNjY5OVwiLFwiZmYzMzk5XCIsXCJjYzMzOTlcIixcIjk5MDA5OVwiXSxbXCI2NjY2MzNcIixcIjk5Y2MwMFwiLFwiY2NmZjMzXCIsXCJmZmZmNjZcIixcImZmY2M2NlwiLFwiZmY5OTY2XCIsXCJmZjY2NjZcIixcImZmMDA2NlwiLFwiZDYwMDk0XCIsXCI5OTMzNjZcIl0sW1wiYTU4ODAwXCIsXCJjY2NjMDBcIixcImZmZmYwMFwiLFwiZmZjYzAwXCIsXCJmZjk5MzNcIixcImZmNjYwMFwiLFwiZmYwMDMzXCIsXCJjYzAwNjZcIixcIjY2MDAzM1wiXSxbXCI5OTY2MzNcIixcImNjOTkwMFwiLFwiZmY5OTAwXCIsXCJjYzY2MDBcIixcImZmMzMwMFwiLFwiZmYwMDAwXCIsXCJjYzAwMDBcIixcIjk5MDAzM1wiXSxbXCI2NjMzMDBcIixcIjk5NjYwMFwiLFwiY2MzMzAwXCIsXCI5OTMzMDBcIixcIjk5MDAwMFwiLFwiODAwMDAwXCIsXCI5OTMzMzNcIl1dLG09XCIjMDAwMGZmZmZcIixuPWZ1bmN0aW9uKGEpe3ZhciBiPWEudG9TdHJpbmcoMTYpO3JldHVybiAxPT1iLmxlbmd0aCYmKGI9XCIwXCIrYiksYn0sbz1mdW5jdGlvbihhKXtyZXR1cm4gbihOdW1iZXIoYSkpfSxwPWZ1bmN0aW9uKGEpe3ZhciBiPW4oYSk7cmV0dXJuIGIrYitifSxxPWZ1bmN0aW9uKGEpe2lmKGEubGVuZ3RoPjEwKXt2YXIgYj0xK2EuaW5kZXhPZihcIihcIiksYz1hLmluZGV4T2YoXCIpXCIpLGQ9YS5zdWJzdHJpbmcoYixjKS5zcGxpdChcIixcIik7cmV0dXJuW1wiI1wiLG8oZFswXSksbyhkWzFdKSxvKGRbMl0pXS5qb2luKFwiXCIpfXJldHVybiBhfTthLndpZGdldChcImV2b2wuY29sb3JwaWNrZXJcIix7dmVyc2lvbjpcIjMuMi4xXCIsb3B0aW9uczp7Y29sb3I6bnVsbCxzaG93T246XCJib3RoXCIsaGlkZUJ1dHRvbjohMSxkaXNwbGF5SW5kaWNhdG9yOiEwLHRyYW5zcGFyZW50Q29sb3I6ITEsaGlzdG9yeTohMCxkZWZhdWx0UGFsZXR0ZTpcInRoZW1lXCIsc3RyaW5nczpcIlRoZW1lIENvbG9ycyxTdGFuZGFyZCBDb2xvcnMsV2ViIENvbG9ycyxUaGVtZSBDb2xvcnMsQmFjayB0byBQYWxldHRlLEhpc3RvcnksTm8gaGlzdG9yeSB5ZXQuXCJ9LF9hY3RpdmU6ITEsX2NyZWF0ZTpmdW5jdGlvbigpe3ZhciBiPXRoaXM7c3dpdGNoKHRoaXMuX3BhbGV0dGVJZHg9XCJ0aGVtZVwiPT10aGlzLm9wdGlvbnMuZGVmYXVsdFBhbGV0dGU/MToyLHRoaXMuX2lkPVwiZXZvLWNwXCIrYysrLHRoaXMuX2VuYWJsZWQ9ITAsdGhpcy5vcHRpb25zLnNob3dPbj10aGlzLm9wdGlvbnMuaGlkZUJ1dHRvbj9cImZvY3VzXCI6dGhpcy5vcHRpb25zLnNob3dPbix0aGlzLmVsZW1lbnQuZ2V0KDApLnRhZ05hbWUpe2Nhc2VcIklOUFVUXCI6dmFyIGQ9dGhpcy5vcHRpb25zLmNvbG9yLGg9dGhpcy5lbGVtZW50LGk9KFwiZm9jdXNcIj09PXRoaXMub3B0aW9ucy5zaG93T24/XCJcIjpcImV2by1wb2ludGVyIFwiKStcImV2by1jb2xvcmluZFwiKyhnP1wiLWZmXCI6ZikrKHRoaXMub3B0aW9ucy5oaWRlQnV0dG9uP1wiIGV2by1oaWRkZW4tYnV0dG9uXCI6XCJcIiksaj1cIlwiO2lmKHRoaXMuX2lzUG9wdXA9ITAsdGhpcy5fcGFsZXR0ZT1udWxsLG51bGwhPT1kKWgudmFsKGQpO2Vsc2V7dmFyIGs9aC52YWwoKTtcIlwiIT09ayYmKGQ9dGhpcy5vcHRpb25zLmNvbG9yPWspfWQ9PT1tP2krPVwiIGV2by10cmFuc3BhcmVudFwiOmo9bnVsbCE9PWQ/XCJiYWNrZ3JvdW5kLWNvbG9yOlwiK2Q6XCJcIixoLmFkZENsYXNzKFwiY29sb3JQaWNrZXIgXCIrdGhpcy5faWQpLndyYXAoJzxkaXYgc3R5bGU9XCJ3aWR0aDonKyh0aGlzLm9wdGlvbnMuaGlkZUJ1dHRvbj90aGlzLmVsZW1lbnQud2lkdGgoKTp0aGlzLmVsZW1lbnQud2lkdGgoKSszMikrXCJweDtcIisoZT9cIm1hcmdpbi1ib3R0b206LTIxcHg7XCI6XCJcIikrKGc/XCJwYWRkaW5nOjFweCAwO1wiOlwiXCIpKydcIj48L2Rpdj4nKS5hZnRlcignPGRpdiBjbGFzcz1cIicraSsnXCIgc3R5bGU9XCInK2orJ1wiPjwvZGl2PicpLm9uKFwia2V5dXAgb25wYXN0ZVwiLGZ1bmN0aW9uKGMpe3ZhciBkPWEodGhpcykudmFsKCk7ZCE9Yi5vcHRpb25zLmNvbG9yJiZiLl9zZXRWYWx1ZShkLCEwKX0pO3ZhciBsPXRoaXMub3B0aW9ucy5zaG93T247KFwiYm90aFwiPT09bHx8XCJmb2N1c1wiPT09bCkmJmgub24oXCJmb2N1c1wiLGZ1bmN0aW9uKCl7Yi5zaG93UGFsZXR0ZSgpfSksKFwiYm90aFwiPT09bHx8XCJidXR0b25cIj09PWwpJiZoLm5leHQoKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3RvcFByb3BhZ2F0aW9uKCksYi5zaG93UGFsZXR0ZSgpLCExfSk7YnJlYWs7ZGVmYXVsdDp0aGlzLl9pc1BvcHVwPSExLHRoaXMuX3BhbGV0dGU9dGhpcy5lbGVtZW50Lmh0bWwodGhpcy5fcGFsZXR0ZUhUTUwoKSkuYXR0cihcImFyaWEtaGFzcG9wdXBcIixcInRydWVcIiksdGhpcy5fYmluZENvbG9ycygpfWlmKHRoaXMub3B0aW9ucy5oaXN0b3J5JiYoZCYmdGhpcy5fYWRkMkhpc3RvcnkoZCksdGhpcy5vcHRpb25zLmluaXRpYWxIaXN0b3J5KSl7dmFyIG49dGhpcy5vcHRpb25zLmluaXRpYWxIaXN0b3J5O2Zvcih2YXIgbyBpbiBuKXRoaXMuX2FkZDJIaXN0b3J5KG5bb10pfX0sX3BhbGV0dGVIVE1MOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fcGFsZXR0ZUlkeD1NYXRoLmFicyh0aGlzLl9wYWxldHRlSWR4KSxiPXRoaXMub3B0aW9ucyxjPWIuc3RyaW5ncy5zcGxpdChcIixcIiksZD0nPGRpdiBjbGFzcz1cImV2by1wb3AnK2YrJyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFwiJysodGhpcy5faXNQb3B1cD8nIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGVcIic6XCJcIikrXCI+PHNwYW4+XCIrdGhpc1tcIl9wYWxldHRlSFRNTFwiK2FdKCkrJzwvc3Bhbj48ZGl2IGNsYXNzPVwiZXZvLW1vcmVcIj48YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCI+JytjWzErYV0rXCI8L2E+XCI7cmV0dXJuIGIuaGlzdG9yeSYmKGQrPSc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgY2xhc3M9XCJldm8taGlzdFwiPicrY1s1XStcIjwvYT5cIiksZCs9XCI8L2Rpdj5cIixiLmRpc3BsYXlJbmRpY2F0b3ImJihkKz10aGlzLl9jb2xvckluZEhUTUwodGhpcy5vcHRpb25zLmNvbG9yKSt0aGlzLl9jb2xvckluZEhUTUwoXCJcIikpLGQrPVwiPC9kaXY+XCJ9LF9jb2xvckluZEhUTUw6ZnVuY3Rpb24oYSl7dmFyIGI9ZT9cImV2by1jb2xvcmJveC1pZSBcIjpcIlwiLGM9XCJcIjtyZXR1cm4gYT9hPT09bT9iKz1cImV2by10cmFuc3BhcmVudFwiOmM9XCJiYWNrZ3JvdW5kLWNvbG9yOlwiK2E6Yz1cImRpc3BsYXk6bm9uZVwiLCc8ZGl2IGNsYXNzPVwiZXZvLWNvbG9yXCIgc3R5bGU9XCJmbG9hdDpsZWZ0XCI+PGRpdiBzdHlsZT1cIicrYysnXCIgY2xhc3M9XCInK2IrJ1wiPjwvZGl2PjxzcGFuPicrKGE/YTpcIlwiKStcIjwvc3Bhbj48L2Rpdj5cIn0sX3BhbGV0dGVIVE1MMTpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLm9wdGlvbnMsYj1hLnN0cmluZ3Muc3BsaXQoXCIsXCIpLGM9Jzx0ZCBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IycsZD1lPydcIj48ZGl2IHN0eWxlPVwid2lkdGg6MnB4O1wiPjwvZGl2PjwvdGQ+JzonXCI+PHNwYW4vPjwvdGQ+JyxnPSc8dHI+PHRoIGNvbHNwYW49XCIxMFwiIGNsYXNzPVwidWktd2lkZ2V0LWNvbnRlbnRcIj4nLGg9Jzx0YWJsZSBjbGFzcz1cImV2by1wYWxldHRlJytmKydcIj4nK2crYlswXStcIjwvdGg+PC90cj48dHI+XCIsbD0wOzEwPmw7bCsrKWgrPWMraVtsXStkO2ZvcihoKz1cIjwvdHI+XCIsZXx8KGgrPSc8dHI+PHRoIGNvbHNwYW49XCIxMFwiPjwvdGg+PC90cj4nKSxoKz0nPHRyIGNsYXNzPVwidG9wXCI+JyxsPTA7MTA+bDtsKyspaCs9YytqW2xdK2Q7Zm9yKHZhciBtPTE7ND5tO20rKylmb3IoaCs9JzwvdHI+PHRyIGNsYXNzPVwiaW5cIj4nLGw9MDsxMD5sO2wrKyloKz1jK2pbMTAqbStsXStkO2ZvcihoKz0nPC90cj48dHIgY2xhc3M9XCJib3R0b21cIj4nLGw9NDA7NTA+bDtsKyspaCs9YytqW2xdK2Q7Zm9yKGgrPVwiPC90cj5cIitnLGEudHJhbnNwYXJlbnRDb2xvciYmKGgrPSc8ZGl2IGNsYXNzPVwiZXZvLXRyYW5zcGFyZW50IGV2by10ci1ib3hcIj48L2Rpdj4nKSxoKz1iWzFdK1wiPC90aD48L3RyPjx0cj5cIixsPTA7MTA+bDtsKyspaCs9YytrW2xdK2Q7cmV0dXJuIGgrPVwiPC90cj48L3RhYmxlPlwifSxfcGFsZXR0ZUhUTUwyOmZ1bmN0aW9uKCl7Zm9yKHZhciBhLGIsYz0nPHRkIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojJyxkPWU/J1wiPjxkaXYgc3R5bGU9XCJ3aWR0aDo1cHg7XCI+PC9kaXY+PC90ZD4nOidcIj48c3Bhbi8+PC90ZD4nLGc9Jzx0YWJsZSBjbGFzcz1cImV2by1wYWxldHRlMicrZisnXCI+PHRyPicsaD1cIjwvdHI+PC90YWJsZT5cIixpPSc8ZGl2IGNsYXNzPVwiZXZvLXBhbGNlbnRlclwiPicsaj0wLGs9bC5sZW5ndGg7az5qO2orKyl7aSs9Zzt2YXIgbT1sW2pdO2ZvcihhPTAsYj1tLmxlbmd0aDtiPmE7YSsrKWkrPWMrbVthXStkO2krPWh9aSs9JzxkaXYgY2xhc3M9XCJldm8tc2VwXCIvPic7dmFyIG49XCJcIjtmb3IoaSs9ZyxhPTI1NTthPjEwO2EtPTEwKWkrPWMrcChhKStkLGEtPTEwLG4rPWMrcChhKStkO3JldHVybiBpKz1oK2crbitoK1wiPC9kaXY+XCJ9LF9zd2l0Y2hQYWxldHRlOmZ1bmN0aW9uKGIpe2lmKHRoaXMuX2VuYWJsZWQpe3ZhciBjLGQsZSxmPXRoaXMub3B0aW9ucy5zdHJpbmdzLnNwbGl0KFwiLFwiKTtpZihhKGIpLmhhc0NsYXNzKFwiZXZvLWhpc3RcIikpe3ZhciBnPVsnPHRhYmxlIGNsYXNzPVwiZXZvLXBhbGV0dGVcIj48dHI+PHRoIGNsYXNzPVwidWktd2lkZ2V0LWNvbnRlbnRcIj4nLGZbNV0sXCI8L3RoPjwvdHI+PC90cj48L3RhYmxlPlwiLCc8ZGl2IGNsYXNzPVwiZXZvLWNIaXN0XCI+J107aWYoMD09PWgubGVuZ3RoKWcucHVzaChcIjxwPiZuYnNwO1wiLGZbNl0sXCI8L3A+XCIpO2Vsc2UgZm9yKHZhciBpPWgubGVuZ3RoLTE7aT4tMTtpLS0pOT09PWhbaV0ubGVuZ3RoP2cucHVzaCgnPGRpdiBjbGFzcz1cImV2by10cmFuc3BhcmVudFwiPjwvZGl2PicpOmcucHVzaCgnPGRpdiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyxoW2ldLCdcIj48L2Rpdj4nKTtnLnB1c2goXCI8L2Rpdj5cIiksYz0tdGhpcy5fcGFsZXR0ZUlkeCxkPWcuam9pbihcIlwiKSxlPWZbNF19ZWxzZSB0aGlzLl9wYWxldHRlSWR4PDA/KGM9LXRoaXMuX3BhbGV0dGVJZHgsdGhpcy5fcGFsZXR0ZS5maW5kKFwiLmV2by1oaXN0XCIpLnNob3coKSk6Yz0yPT10aGlzLl9wYWxldHRlSWR4PzE6MixkPXRoaXNbXCJfcGFsZXR0ZUhUTUxcIitjXSgpLGU9ZltjKzFdLHRoaXMuX3BhbGV0dGVJZHg9Yzt0aGlzLl9wYWxldHRlSWR4PWM7dmFyIGo9dGhpcy5fcGFsZXR0ZS5maW5kKFwiLmV2by1tb3JlXCIpLnByZXYoKS5odG1sKGQpLmVuZCgpLmNoaWxkcmVuKCkuZXEoMCkuaHRtbChlKTswPmMmJmoubmV4dCgpLmhpZGUoKX19LF9kb3duT3JVcFBvc2l0aW9uaW5nOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuZWxlbWVudCxiPTA7bnVsbCE9PWEmJjEwMD5iOyl7aWYoXCJ2aXNpYmxlXCIhPWEuY3NzKFwib3ZlcmZsb3dcIikpe3ZhciBjPXRoaXMuX3BhbGV0dGUub2Zmc2V0KCkudG9wK3RoaXMuX3BhbGV0dGUuaGVpZ2h0KCksZD1hLm9mZnNldCgpLnRvcCthLmhlaWdodCgpLGU9dGhpcy5fcGFsZXR0ZS5vZmZzZXQoKS50b3AtdGhpcy5fcGFsZXR0ZS5oZWlnaHQoKS10aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSxmPWEub2Zmc2V0KCkudG9wLGc9Yz5kJiZlPmY7Zz90aGlzLl9wYWxldHRlLmNzcyh7Ym90dG9tOnRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpK1wicHhcIn0pOnRoaXMuX3BhbGV0dGUuY3NzKHtib3R0b206XCJhdXRvXCJ9KTticmVha31pZihcIkhUTUxcIj09YVswXS50YWdOYW1lKWJyZWFrO2E9YS5vZmZzZXRQYXJlbnQoKSxiKyt9fSxzaG93UGFsZXR0ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2VuYWJsZWQmJih0aGlzLl9hY3RpdmU9ITAsYShcIi5jb2xvclBpY2tlclwiKS5ub3QoXCIuXCIrdGhpcy5faWQpLmNvbG9ycGlja2VyKFwiaGlkZVBhbGV0dGVcIiksbnVsbD09PXRoaXMuX3BhbGV0dGUpKXt0aGlzLl9wYWxldHRlPXRoaXMuZWxlbWVudC5uZXh0KCkuYWZ0ZXIodGhpcy5fcGFsZXR0ZUhUTUwoKSkubmV4dCgpLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5zdG9wUHJvcGFnYXRpb24oKSwhMX0pLHRoaXMuX2JpbmRDb2xvcnMoKTt2YXIgYj10aGlzO3RoaXMuX2lzUG9wdXAmJih0aGlzLl9kb3duT3JVcFBvc2l0aW9uaW5nKCksYShkb2N1bWVudC5ib2R5KS5vbihcImNsaWNrLlwiK2IuX2lkLGZ1bmN0aW9uKGEpe2EudGFyZ2V0IT1iLmVsZW1lbnQuZ2V0KDApJiZiLmhpZGVQYWxldHRlKCl9KS5vbihcImtleXVwLlwiK2IuX2lkLGZ1bmN0aW9uKGEpezI3PT09YS5rZXlDb2RlJiZiLmhpZGVQYWxldHRlKCl9KSl9cmV0dXJuIHRoaXN9LGhpZGVQYWxldHRlOmZ1bmN0aW9uKCl7aWYodGhpcy5faXNQb3B1cCYmdGhpcy5fcGFsZXR0ZSl7YShkb2N1bWVudC5ib2R5KS5vZmYoXCJjbGljay5cIit0aGlzLl9pZCk7dmFyIGI9dGhpczt0aGlzLl9wYWxldHRlLm9mZihcIm1vdXNlb3ZlciBjbGlja1wiLFwidGQsLmV2by10cmFuc3BhcmVudFwiKS5mYWRlT3V0KGZ1bmN0aW9uKCl7Yi5fcGFsZXR0ZS5yZW1vdmUoKSxiLl9wYWxldHRlPWIuX2NUeHQ9bnVsbH0pLmZpbmQoXCIuZXZvLW1vcmUgYVwiKS5vZmYoXCJjbGlja1wiKX1yZXR1cm4gdGhpc30sX2JpbmRDb2xvcnM6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9dGhpcy5vcHRpb25zLGQ9dGhpcy5fcGFsZXR0ZS5maW5kKFwiZGl2LmV2by1jb2xvclwiKSxlPWMuaGlzdG9yeT9cInRkLC5ldm8tY0hpc3Q+ZGl2XCI6XCJ0ZFwiO2MudHJhbnNwYXJlbnRDb2xvciYmKGUrPVwiLC5ldm8tdHJhbnNwYXJlbnRcIiksdGhpcy5fY1R4dDE9ZC5lcSgwKS5jaGlsZHJlbigpLmVxKDApLHRoaXMuX2NUeHQyPWQuZXEoMSkuY2hpbGRyZW4oKS5lcSgwKSx0aGlzLl9wYWxldHRlLm9uKFwiY2xpY2tcIixlLGZ1bmN0aW9uKGMpe2lmKGIuX2VuYWJsZWQpe3ZhciBkPWEodGhpcyk7Yi5fc2V0VmFsdWUoZC5oYXNDbGFzcyhcImV2by10cmFuc3BhcmVudFwiKT9tOnEoZC5hdHRyKFwic3R5bGVcIikuc3Vic3RyaW5nKDE3KSkpLGIuX2FjdGl2ZT0hMX19KS5vbihcIm1vdXNlb3ZlclwiLGUsZnVuY3Rpb24oYyl7aWYoYi5fZW5hYmxlZCl7dmFyIGQ9YSh0aGlzKSxlPWQuaGFzQ2xhc3MoXCJldm8tdHJhbnNwYXJlbnRcIik/bTpxKGQuYXR0cihcInN0eWxlXCIpLnN1YnN0cmluZygxNykpO2Iub3B0aW9ucy5kaXNwbGF5SW5kaWNhdG9yJiZiLl9zZXRDb2xvckluZChlLDIpLGIuX2FjdGl2ZSYmYi5lbGVtZW50LnRyaWdnZXIoXCJtb3VzZW92ZXIuY29sb3JcIixlKX19KS5maW5kKFwiLmV2by1tb3JlIGFcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7Yi5fc3dpdGNoUGFsZXR0ZSh0aGlzKX0pfSx2YWw6ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/dGhpcy5vcHRpb25zLmNvbG9yOih0aGlzLl9zZXRWYWx1ZShhKSx0aGlzKX0sX3NldFZhbHVlOmZ1bmN0aW9uKGEsYil7YT1hLnJlcGxhY2UoLyAvZyxcIlwiKSx0aGlzLm9wdGlvbnMuY29sb3I9YSx0aGlzLl9pc1BvcHVwPyhifHx0aGlzLmhpZGVQYWxldHRlKCksdGhpcy5fc2V0Qm94Q29sb3IodGhpcy5lbGVtZW50LnZhbChhKS5uZXh0KCksYSkpOnRoaXMuX3NldENvbG9ySW5kKGEsMSksdGhpcy5vcHRpb25zLmhpc3RvcnkmJnRoaXMuX3BhbGV0dGVJZHg+MCYmdGhpcy5fYWRkMkhpc3RvcnkoYSksdGhpcy5lbGVtZW50LnRyaWdnZXIoXCJjaGFuZ2UuY29sb3JcIixhKX0sX3NldENvbG9ySW5kOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpc1tcIl9jVHh0XCIrYl07dGhpcy5fc2V0Qm94Q29sb3IoYyxhKSxjLm5leHQoKS5odG1sKGEpfSxfc2V0Qm94Q29sb3I6ZnVuY3Rpb24oYSxiKXtiPT09bT9hLmFkZENsYXNzKFwiZXZvLXRyYW5zcGFyZW50XCIpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKTphLnJlbW92ZUNsYXNzKFwiZXZvLXRyYW5zcGFyZW50XCIpLmF0dHIoXCJzdHlsZVwiLFwiYmFja2dyb3VuZC1jb2xvcjpcIitiKX0sX3NldE9wdGlvbjpmdW5jdGlvbihhLGIpe1wiY29sb3JcIj09YT90aGlzLl9zZXRWYWx1ZShiLCEwKTp0aGlzLm9wdGlvbnNbYV09Yn0sX2FkZDJIaXN0b3J5OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1oLmxlbmd0aCxjPTA7Yj5jO2MrKylpZihhPT1oW2NdKXJldHVybjtiPjI3JiZoLnNoaWZ0KCksaC5wdXNoKGEpfSxjbGVhcjpmdW5jdGlvbigpe3RoaXMuaGlkZVBhbGV0dGUoKS52YWwoXCJcIil9LGVuYWJsZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudDtyZXR1cm4gdGhpcy5faXNQb3B1cD9hLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTphLmNzcyh7b3BhY2l0eTpcIjFcIixcInBvaW50ZXItZXZlbnRzXCI6XCJhdXRvXCJ9KSxcImZvY3VzXCIhPT10aGlzLm9wdGlvbnMuc2hvd09uJiZ0aGlzLmVsZW1lbnQubmV4dCgpLmFkZENsYXNzKFwiZXZvLXBvaW50ZXJcIiksYS5yZW1vdmVBdHRyKFwiYXJpYS1kaXNhYmxlZFwiKSx0aGlzLl9lbmFibGVkPSEwLHRoaXN9LGRpc2FibGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnQ7cmV0dXJuIHRoaXMuX2lzUG9wdXA/YS5hdHRyKFwiZGlzYWJsZWRcIixcImRpc2FibGVkXCIpOih0aGlzLmhpZGVQYWxldHRlKCksYS5jc3Moe29wYWNpdHk6XCIwLjNcIixcInBvaW50ZXItZXZlbnRzXCI6XCJub25lXCJ9KSksXCJmb2N1c1wiIT09dGhpcy5vcHRpb25zLnNob3dPbiYmdGhpcy5lbGVtZW50Lm5leHQoKS5yZW1vdmVDbGFzcyhcImV2by1wb2ludGVyXCIpLGEuYXR0cihcImFyaWEtZGlzYWJsZWRcIixcInRydWVcIiksdGhpcy5fZW5hYmxlZD0hMSx0aGlzfSxpc0Rpc2FibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuX2VuYWJsZWR9LGRlc3Ryb3k6ZnVuY3Rpb24oKXthKGRvY3VtZW50LmJvZHkpLm9mZihcImNsaWNrLlwiK3RoaXMuX2lkKSx0aGlzLl9wYWxldHRlJiYodGhpcy5fcGFsZXR0ZS5vZmYoXCJtb3VzZW92ZXIgY2xpY2tcIixcInRkLC5ldm8tY0hpc3Q+ZGl2LC5ldm8tdHJhbnNwYXJlbnRcIikuZmluZChcIi5ldm8tbW9yZSBhXCIpLm9mZihcImNsaWNrXCIpLHRoaXMuX2lzUG9wdXAmJnRoaXMuX3BhbGV0dGUucmVtb3ZlKCksdGhpcy5fcGFsZXR0ZT10aGlzLl9jVHh0PW51bGwpLHRoaXMuX2lzUG9wdXAmJnRoaXMuZWxlbWVudC5uZXh0KCkub2ZmKFwiY2xpY2tcIikucmVtb3ZlKCkuZW5kKCkub2ZmKFwiZm9jdXNcIikudW53cmFwKCksdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFwiY29sb3JQaWNrZXIgXCIrdGhpcy5pZCkuZW1wdHkoKSxhLldpZGdldC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpfX0pfShqUXVlcnkpOyIsIi8vICAgICBKYXZhU2NyaXB0IEV4cHJlc3Npb24gUGFyc2VyIChKU0VQKSA8JT0gdmVyc2lvbiAlPlxuLy8gICAgIEpTRVAgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2Vcbi8vICAgICBodHRwOi8vanNlcC5mcm9tLnNvL1xuXG4vKmdsb2JhbCBtb2R1bGU6IHRydWUsIGV4cG9ydHM6IHRydWUsIGNvbnNvbGU6IHRydWUgKi9cbihmdW5jdGlvbiAocm9vdCkge1xuXHQndXNlIHN0cmljdCc7XG5cdC8vIE5vZGUgVHlwZXNcblx0Ly8gLS0tLS0tLS0tLVxuXHRcblx0Ly8gVGhpcyBpcyB0aGUgZnVsbCBzZXQgb2YgdHlwZXMgdGhhdCBhbnkgSlNFUCBub2RlIGNhbiBiZS5cblx0Ly8gU3RvcmUgdGhlbSBoZXJlIHRvIHNhdmUgc3BhY2Ugd2hlbiBtaW5pZmllZFxuXHR2YXIgQ09NUE9VTkQgPSAnQ29tcG91bmQnLFxuXHRcdElERU5USUZJRVIgPSAnSWRlbnRpZmllcicsXG5cdFx0TUVNQkVSX0VYUCA9ICdNZW1iZXJFeHByZXNzaW9uJyxcblx0XHRMSVRFUkFMID0gJ0xpdGVyYWwnLFxuXHRcdFRISVNfRVhQID0gJ1RoaXNFeHByZXNzaW9uJyxcblx0XHRDQUxMX0VYUCA9ICdDYWxsRXhwcmVzc2lvbicsXG5cdFx0VU5BUllfRVhQID0gJ1VuYXJ5RXhwcmVzc2lvbicsXG5cdFx0QklOQVJZX0VYUCA9ICdCaW5hcnlFeHByZXNzaW9uJyxcblx0XHRMT0dJQ0FMX0VYUCA9ICdMb2dpY2FsRXhwcmVzc2lvbicsXG5cdFx0Q09ORElUSU9OQUxfRVhQID0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG5cdFx0QVJSQVlfRVhQID0gJ0FycmF5RXhwcmVzc2lvbicsXG5cblx0XHRQRVJJT0RfQ09ERSA9IDQ2LCAvLyAnLidcblx0XHRDT01NQV9DT0RFICA9IDQ0LCAvLyAnLCdcblx0XHRTUVVPVEVfQ09ERSA9IDM5LCAvLyBzaW5nbGUgcXVvdGVcblx0XHREUVVPVEVfQ09ERSA9IDM0LCAvLyBkb3VibGUgcXVvdGVzXG5cdFx0T1BBUkVOX0NPREUgPSA0MCwgLy8gKFxuXHRcdENQQVJFTl9DT0RFID0gNDEsIC8vIClcblx0XHRPQlJBQ0tfQ09ERSA9IDkxLCAvLyBbXG5cdFx0Q0JSQUNLX0NPREUgPSA5MywgLy8gXVxuXHRcdFFVTUFSS19DT0RFID0gNjMsIC8vID9cblx0XHRTRU1DT0xfQ09ERSA9IDU5LCAvLyA7XG5cdFx0Q09MT05fQ09ERSAgPSA1OCwgLy8gOlxuXG5cdFx0dGhyb3dFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGluZGV4KSB7XG5cdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSArICcgYXQgY2hhcmFjdGVyICcgKyBpbmRleCk7XG5cdFx0XHRlcnJvci5pbmRleCA9IGluZGV4O1xuXHRcdFx0ZXJyb3IuZGVzY3JpcHRpb24gPSBtZXNzYWdlO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fSxcblxuXHQvLyBPcGVyYXRpb25zXG5cdC8vIC0tLS0tLS0tLS1cblx0XG5cdC8vIFNldCBgdGAgdG8gYHRydWVgIHRvIHNhdmUgc3BhY2UgKHdoZW4gbWluaWZpZWQsIG5vdCBnemlwcGVkKVxuXHRcdHQgPSB0cnVlLFxuXHQvLyBVc2UgYSBxdWlja2x5LWFjY2Vzc2libGUgbWFwIHRvIHN0b3JlIGFsbCBvZiB0aGUgdW5hcnkgb3BlcmF0b3JzXG5cdC8vIFZhbHVlcyBhcmUgc2V0IHRvIGB0cnVlYCAoaXQgcmVhbGx5IGRvZXNuJ3QgbWF0dGVyKVxuXHRcdHVuYXJ5X29wcyA9IHsnLSc6IHQsICchJzogdCwgJ34nOiB0LCAnKyc6IHR9LFxuXHQvLyBBbHNvIHVzZSBhIG1hcCBmb3IgdGhlIGJpbmFyeSBvcGVyYXRpb25zIGJ1dCBzZXQgdGhlaXIgdmFsdWVzIHRvIHRoZWlyXG5cdC8vIGJpbmFyeSBwcmVjZWRlbmNlIGZvciBxdWljayByZWZlcmVuY2U6XG5cdC8vIHNlZSBbT3JkZXIgb2Ygb3BlcmF0aW9uc10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcmRlcl9vZl9vcGVyYXRpb25zI1Byb2dyYW1taW5nX2xhbmd1YWdlKVxuXHRcdGJpbmFyeV9vcHMgPSB7XG5cdFx0XHQnfHwnOiAxLCAnJiYnOiAyLCAnfCc6IDMsICAnXic6IDQsICAnJic6IDUsXG5cdFx0XHQnPT0nOiA2LCAnIT0nOiA2LCAnPT09JzogNiwgJyE9PSc6IDYsXG5cdFx0XHQnPCc6IDcsICAnPic6IDcsICAnPD0nOiA3LCAgJz49JzogNywgXG5cdFx0XHQnPDwnOjgsICAnPj4nOiA4LCAnPj4+JzogOCxcblx0XHRcdCcrJzogOSwgJy0nOiA5LFxuXHRcdFx0JyonOiAxMCwgJy8nOiAxMCwgJyUnOiAxMFxuXHRcdH0sXG5cdC8vIEdldCByZXR1cm4gdGhlIGxvbmdlc3Qga2V5IGxlbmd0aCBvZiBhbnkgb2JqZWN0XG5cdFx0Z2V0TWF4S2V5TGVuID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHR2YXIgbWF4X2xlbiA9IDAsIGxlbjtcblx0XHRcdGZvcih2YXIga2V5IGluIG9iaikge1xuXHRcdFx0XHRpZigobGVuID0ga2V5Lmxlbmd0aCkgPiBtYXhfbGVuICYmIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0bWF4X2xlbiA9IGxlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1heF9sZW47XG5cdFx0fSxcblx0XHRtYXhfdW5vcF9sZW4gPSBnZXRNYXhLZXlMZW4odW5hcnlfb3BzKSxcblx0XHRtYXhfYmlub3BfbGVuID0gZ2V0TWF4S2V5TGVuKGJpbmFyeV9vcHMpLFxuXHQvLyBMaXRlcmFsc1xuXHQvLyAtLS0tLS0tLS0tXG5cdC8vIFN0b3JlIHRoZSB2YWx1ZXMgdG8gcmV0dXJuIGZvciB0aGUgdmFyaW91cyBsaXRlcmFscyB3ZSBtYXkgZW5jb3VudGVyXG5cdFx0bGl0ZXJhbHMgPSB7XG5cdFx0XHQndHJ1ZSc6IHRydWUsXG5cdFx0XHQnZmFsc2UnOiBmYWxzZSxcblx0XHRcdCdudWxsJzogbnVsbFxuXHRcdH0sXG5cdC8vIEV4Y2VwdCBmb3IgYHRoaXNgLCB3aGljaCBpcyBzcGVjaWFsLiBUaGlzIGNvdWxkIGJlIGNoYW5nZWQgdG8gc29tZXRoaW5nIGxpa2UgYCdzZWxmJ2AgYXMgd2VsbFxuXHRcdHRoaXNfc3RyID0gJ3RoaXMnLFxuXHQvLyBSZXR1cm5zIHRoZSBwcmVjZWRlbmNlIG9mIGEgYmluYXJ5IG9wZXJhdG9yIG9yIGAwYCBpZiBpdCBpc24ndCBhIGJpbmFyeSBvcGVyYXRvclxuXHRcdGJpbmFyeVByZWNlZGVuY2UgPSBmdW5jdGlvbihvcF92YWwpIHtcblx0XHRcdHJldHVybiBiaW5hcnlfb3BzW29wX3ZhbF0gfHwgMDtcblx0XHR9LFxuXHQvLyBVdGlsaXR5IGZ1bmN0aW9uIChnZXRzIGNhbGxlZCBmcm9tIG11bHRpcGxlIHBsYWNlcylcblx0Ly8gQWxzbyBub3RlIHRoYXQgYGEgJiYgYmAgYW5kIGBhIHx8IGJgIGFyZSAqbG9naWNhbCogZXhwcmVzc2lvbnMsIG5vdCBiaW5hcnkgZXhwcmVzc2lvbnNcblx0XHRjcmVhdGVCaW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuXHRcdFx0dmFyIHR5cGUgPSAob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicpID8gTE9HSUNBTF9FWFAgOiBCSU5BUllfRVhQO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3BlcmF0b3I6IG9wZXJhdG9yLFxuXHRcdFx0XHRsZWZ0OiBsZWZ0LFxuXHRcdFx0XHRyaWdodDogcmlnaHRcblx0XHRcdH07XG5cdFx0fSxcblx0XHQvLyBgY2hgIGlzIGEgY2hhcmFjdGVyIGNvZGUgaW4gdGhlIG5leHQgdGhyZWUgZnVuY3Rpb25zXG5cdFx0aXNEZWNpbWFsRGlnaXQgPSBmdW5jdGlvbihjaCkge1xuXHRcdFx0cmV0dXJuIChjaCA+PSA0OCAmJiBjaCA8PSA1Nyk7IC8vIDAuLi45XG5cdFx0fSxcblx0XHRpc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKGNoKSB7XG5cdFx0XHRyZXR1cm4gKGNoID09PSAzNikgfHwgKGNoID09PSA5NSkgfHwgLy8gYCRgIGFuZCBgX2Bcblx0XHRcdFx0XHQoY2ggPj0gNjUgJiYgY2ggPD0gOTApIHx8IC8vIEEuLi5aXG5cdFx0XHRcdFx0KGNoID49IDk3ICYmIGNoIDw9IDEyMik7IC8vIGEuLi56XG5cdFx0fSxcblx0XHRpc0lkZW50aWZpZXJQYXJ0ID0gZnVuY3Rpb24oY2gpIHtcblx0XHRcdHJldHVybiAoY2ggPT09IDM2KSB8fCAoY2ggPT09IDk1KSB8fCAvLyBgJGAgYW5kIGBfYFxuXHRcdFx0XHRcdChjaCA+PSA2NSAmJiBjaCA8PSA5MCkgfHwgLy8gQS4uLlpcblx0XHRcdFx0XHQoY2ggPj0gOTcgJiYgY2ggPD0gMTIyKSB8fCAvLyBhLi4uelxuXHRcdFx0XHRcdChjaCA+PSA0OCAmJiBjaCA8PSA1Nyk7IC8vIDAuLi45XG5cdFx0fSxcblxuXHRcdC8vIFBhcnNpbmdcblx0XHQvLyAtLS0tLS0tXG5cdFx0Ly8gYGV4cHJgIGlzIGEgc3RyaW5nIHdpdGggdGhlIHBhc3NlZCBpbiBleHByZXNzaW9uXG5cdFx0anNlcCA9IGZ1bmN0aW9uKGV4cHIpIHtcblx0XHRcdC8vIGBpbmRleGAgc3RvcmVzIHRoZSBjaGFyYWN0ZXIgbnVtYmVyIHdlIGFyZSBjdXJyZW50bHkgYXQgd2hpbGUgYGxlbmd0aGAgaXMgYSBjb25zdGFudFxuXHRcdFx0Ly8gQWxsIG9mIHRoZSBnb2JibGVzIGJlbG93IHdpbGwgbW9kaWZ5IGBpbmRleGAgYXMgd2UgbW92ZSBhbG9uZ1xuXHRcdFx0dmFyIGluZGV4ID0gMCxcblx0XHRcdFx0Y2hhckF0RnVuYyA9IGV4cHIuY2hhckF0LFxuXHRcdFx0XHRjaGFyQ29kZUF0RnVuYyA9IGV4cHIuY2hhckNvZGVBdCxcblx0XHRcdFx0ZXhwckkgPSBmdW5jdGlvbihpKSB7IHJldHVybiBjaGFyQXRGdW5jLmNhbGwoZXhwciwgaSk7IH0sXG5cdFx0XHRcdGV4cHJJQ29kZSA9IGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGNoYXJDb2RlQXRGdW5jLmNhbGwoZXhwciwgaSk7IH0sXG5cdFx0XHRcdGxlbmd0aCA9IGV4cHIubGVuZ3RoLFxuXG5cdFx0XHRcdC8vIFB1c2ggYGluZGV4YCB1cCB0byB0aGUgbmV4dCBub24tc3BhY2UgY2hhcmFjdGVyXG5cdFx0XHRcdGdvYmJsZVNwYWNlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBjaCA9IGV4cHJJQ29kZShpbmRleCk7XG5cdFx0XHRcdFx0Ly8gc3BhY2Ugb3IgdGFiXG5cdFx0XHRcdFx0d2hpbGUoY2ggPT09IDMyIHx8IGNoID09PSA5KSB7XG5cdFx0XHRcdFx0XHRjaCA9IGV4cHJJQ29kZSgrK2luZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBUaGUgbWFpbiBwYXJzaW5nIGZ1bmN0aW9uLiBNdWNoIG9mIHRoaXMgY29kZSBpcyBkZWRpY2F0ZWQgdG8gdGVybmFyeSBleHByZXNzaW9uc1xuXHRcdFx0XHRnb2JibGVFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHRlc3QgPSBnb2JibGVCaW5hcnlFeHByZXNzaW9uKCksXG5cdFx0XHRcdFx0XHRjb25zZXF1ZW50LCBhbHRlcm5hdGU7XG5cdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0aWYoZXhwcklDb2RlKGluZGV4KSA9PT0gUVVNQVJLX0NPREUpIHtcblx0XHRcdFx0XHRcdC8vIFRlcm5hcnkgZXhwcmVzc2lvbjogdGVzdCA/IGNvbnNlcXVlbnQgOiBhbHRlcm5hdGVcblx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHRjb25zZXF1ZW50ID0gZ29iYmxlRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRcdFx0aWYoIWNvbnNlcXVlbnQpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3dFcnJvcignRXhwZWN0ZWQgZXhwcmVzc2lvbicsIGluZGV4KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdFx0aWYoZXhwcklDb2RlKGluZGV4KSA9PT0gQ09MT05fQ09ERSkge1xuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0XHRhbHRlcm5hdGUgPSBnb2JibGVFeHByZXNzaW9uKCk7XG5cdFx0XHRcdFx0XHRcdGlmKCFhbHRlcm5hdGUpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdFeHBlY3RlZCBleHByZXNzaW9uJywgaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogQ09ORElUSU9OQUxfRVhQLFxuXHRcdFx0XHRcdFx0XHRcdHRlc3Q6IHRlc3QsXG5cdFx0XHRcdFx0XHRcdFx0Y29uc2VxdWVudDogY29uc2VxdWVudCxcblx0XHRcdFx0XHRcdFx0XHRhbHRlcm5hdGU6IGFsdGVybmF0ZVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhyb3dFcnJvcignRXhwZWN0ZWQgOicsIGluZGV4KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRlc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFNlYXJjaCBmb3IgdGhlIG9wZXJhdGlvbiBwb3J0aW9uIG9mIHRoZSBzdHJpbmcgKGUuZy4gYCtgLCBgPT09YClcblx0XHRcdFx0Ly8gU3RhcnQgYnkgdGFraW5nIHRoZSBsb25nZXN0IHBvc3NpYmxlIGJpbmFyeSBvcGVyYXRpb25zICgzIGNoYXJhY3RlcnM6IGA9PT1gLCBgIT09YCwgYD4+PmApXG5cdFx0XHRcdC8vIGFuZCBtb3ZlIGRvd24gZnJvbSAzIHRvIDIgdG8gMSBjaGFyYWN0ZXIgdW50aWwgYSBtYXRjaGluZyBiaW5hcnkgb3BlcmF0aW9uIGlzIGZvdW5kXG5cdFx0XHRcdC8vIHRoZW4sIHJldHVybiB0aGF0IGJpbmFyeSBvcGVyYXRpb25cblx0XHRcdFx0Z29iYmxlQmluYXJ5T3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHR2YXIgYmlvcCwgdG9fY2hlY2sgPSBleHByLnN1YnN0cihpbmRleCwgbWF4X2Jpbm9wX2xlbiksIHRjX2xlbiA9IHRvX2NoZWNrLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSh0Y19sZW4gPiAwKSB7XG5cdFx0XHRcdFx0XHRpZihiaW5hcnlfb3BzLmhhc093blByb3BlcnR5KHRvX2NoZWNrKSkge1xuXHRcdFx0XHRcdFx0XHRpbmRleCArPSB0Y19sZW47XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0b19jaGVjaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRvX2NoZWNrID0gdG9fY2hlY2suc3Vic3RyKDAsIC0tdGNfbGVuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIGdvYmJsaW5nIGFuIGluZGl2aWR1YWwgZXhwcmVzc2lvbixcblx0XHRcdFx0Ly8gZS5nLiBgMWAsIGAxKzJgLCBgYSsoYioyKS1NYXRoLnNxcnQoMilgXG5cdFx0XHRcdGdvYmJsZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgY2hfaSwgbm9kZSwgYmlvcCwgcHJlYywgc3RhY2ssIGJpb3BfaW5mbywgbGVmdCwgcmlnaHQsIGk7XG5cblx0XHRcdFx0XHQvLyBGaXJzdCwgdHJ5IHRvIGdldCB0aGUgbGVmdG1vc3QgdGhpbmdcblx0XHRcdFx0XHQvLyBUaGVuLCBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIGJpbmFyeSBvcGVyYXRvciBvcGVyYXRpbmcgb24gdGhhdCBsZWZ0bW9zdCB0aGluZ1xuXHRcdFx0XHRcdGxlZnQgPSBnb2JibGVUb2tlbigpO1xuXHRcdFx0XHRcdGJpb3AgPSBnb2JibGVCaW5hcnlPcCgpO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgd2Fzbid0IGEgYmluYXJ5IG9wZXJhdG9yLCBqdXN0IHJldHVybiB0aGUgbGVmdG1vc3Qgbm9kZVxuXHRcdFx0XHRcdGlmKCFiaW9wKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gc3RhcnQgYSBzdGFjayB0byBwcm9wZXJseSBwbGFjZSB0aGUgYmluYXJ5IG9wZXJhdGlvbnMgaW4gdGhlaXJcblx0XHRcdFx0XHQvLyBwcmVjZWRlbmNlIHN0cnVjdHVyZVxuXHRcdFx0XHRcdGJpb3BfaW5mbyA9IHsgdmFsdWU6IGJpb3AsIHByZWM6IGJpbmFyeVByZWNlZGVuY2UoYmlvcCl9O1xuXG5cdFx0XHRcdFx0cmlnaHQgPSBnb2JibGVUb2tlbigpO1xuXHRcdFx0XHRcdGlmKCFyaWdodCkge1xuXHRcdFx0XHRcdFx0dGhyb3dFcnJvcihcIkV4cGVjdGVkIGV4cHJlc3Npb24gYWZ0ZXIgXCIgKyBiaW9wLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0YWNrID0gW2xlZnQsIGJpb3BfaW5mbywgcmlnaHRdO1xuXG5cdFx0XHRcdFx0Ly8gUHJvcGVybHkgZGVhbCB3aXRoIHByZWNlZGVuY2UgdXNpbmcgW3JlY3Vyc2l2ZSBkZXNjZW50XShodHRwOi8vd3d3LmVuZ3IubXVuLmNhL350aGVvL01pc2MvZXhwX3BhcnNpbmcuaHRtKVxuXHRcdFx0XHRcdHdoaWxlKChiaW9wID0gZ29iYmxlQmluYXJ5T3AoKSkpIHtcblx0XHRcdFx0XHRcdHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGJpb3ApO1xuXG5cdFx0XHRcdFx0XHRpZihwcmVjID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YmlvcF9pbmZvID0geyB2YWx1ZTogYmlvcCwgcHJlYzogcHJlYyB9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG5cdFx0XHRcdFx0XHR3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnByZWMpKSB7XG5cdFx0XHRcdFx0XHRcdHJpZ2h0ID0gc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0XHRcdGJpb3AgPSBzdGFjay5wb3AoKS52YWx1ZTtcblx0XHRcdFx0XHRcdFx0bGVmdCA9IHN0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihiaW9wLCBsZWZ0LCByaWdodCk7XG5cdFx0XHRcdFx0XHRcdHN0YWNrLnB1c2gobm9kZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG5vZGUgPSBnb2JibGVUb2tlbigpO1xuXHRcdFx0XHRcdFx0aWYoIW5vZGUpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3dFcnJvcihcIkV4cGVjdGVkIGV4cHJlc3Npb24gYWZ0ZXIgXCIgKyBiaW9wLCBpbmRleCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKGJpb3BfaW5mbywgbm9kZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aSA9IHN0YWNrLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0bm9kZSA9IHN0YWNrW2ldO1xuXHRcdFx0XHRcdHdoaWxlKGkgPiAxKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihzdGFja1tpIC0gMV0udmFsdWUsIHN0YWNrW2kgLSAyXSwgbm9kZSk7IFxuXHRcdFx0XHRcdFx0aSAtPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBBbiBpbmRpdmlkdWFsIHBhcnQgb2YgYSBiaW5hcnkgZXhwcmVzc2lvbjpcblx0XHRcdFx0Ly8gZS5nLiBgZm9vLmJhcihiYXopYCwgYDFgLCBgXCJhYmNcImAsIGAoYSAlIDIpYCAoYmVjYXVzZSBpdCdzIGluIHBhcmVudGhlc2lzKVxuXHRcdFx0XHRnb2JibGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBjaCwgdG9fY2hlY2ssIHRjX2xlbjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRjaCA9IGV4cHJJQ29kZShpbmRleCk7XG5cblx0XHRcdFx0XHRpZihpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IFBFUklPRF9DT0RFKSB7XG5cdFx0XHRcdFx0XHQvLyBDaGFyIGNvZGUgNDYgaXMgYSBkb3QgYC5gIHdoaWNoIGNhbiBzdGFydCBvZmYgYSBudW1lcmljIGxpdGVyYWxcblx0XHRcdFx0XHRcdHJldHVybiBnb2JibGVOdW1lcmljTGl0ZXJhbCgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZihjaCA9PT0gU1FVT1RFX0NPREUgfHwgY2ggPT09IERRVU9URV9DT0RFKSB7XG5cdFx0XHRcdFx0XHQvLyBTaW5nbGUgb3IgZG91YmxlIHF1b3Rlc1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdvYmJsZVN0cmluZ0xpdGVyYWwoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGNoID09PSBPUEFSRU5fQ09ERSkgeyAvLyBvcGVuIHBhcmVudGhlc2lzXG5cdFx0XHRcdFx0XHQvLyBgZm9vYCwgYGJhci5iYXpgXG5cdFx0XHRcdFx0XHRyZXR1cm4gZ29iYmxlVmFyaWFibGUoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNoID09PSBPQlJBQ0tfQ09ERSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdvYmJsZUFycmF5KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRvX2NoZWNrID0gZXhwci5zdWJzdHIoaW5kZXgsIG1heF91bm9wX2xlbik7XG5cdFx0XHRcdFx0XHR0Y19sZW4gPSB0b19jaGVjay5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSh0Y19sZW4gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmKHVuYXJ5X29wcy5oYXNPd25Qcm9wZXJ0eSh0b19jaGVjaykpIHtcblx0XHRcdFx0XHRcdFx0XHRpbmRleCArPSB0Y19sZW47XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFVOQVJZX0VYUCxcblx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhdG9yOiB0b19jaGVjayxcblx0XHRcdFx0XHRcdFx0XHRcdGFyZ3VtZW50OiBnb2JibGVUb2tlbigpLFxuXHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4OiB0cnVlXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0b19jaGVjayA9IHRvX2NoZWNrLnN1YnN0cigwLCAtLXRjX2xlbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIFBhcnNlIHNpbXBsZSBudW1lcmljIGxpdGVyYWxzOiBgMTJgLCBgMy40YCwgYC41YC4gRG8gdGhpcyBieSB1c2luZyBhIHN0cmluZyB0b1xuXHRcdFx0XHQvLyBrZWVwIHRyYWNrIG9mIGV2ZXJ5dGhpbmcgaW4gdGhlIG51bWVyaWMgbGl0ZXJhbCBhbmQgdGhlbiBjYWxsaW5nIGBwYXJzZUZsb2F0YCBvbiB0aGF0IHN0cmluZ1xuXHRcdFx0XHRnb2JibGVOdW1lcmljTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBudW1iZXIgPSAnJywgY2gsIGNoQ29kZTtcblx0XHRcdFx0XHR3aGlsZShpc0RlY2ltYWxEaWdpdChleHBySUNvZGUoaW5kZXgpKSkge1xuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGV4cHJJKGluZGV4KyspO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKGV4cHJJQ29kZShpbmRleCkgPT09IFBFUklPRF9DT0RFKSB7IC8vIGNhbiBzdGFydCB3aXRoIGEgZGVjaW1hbCBtYXJrZXJcblx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcblxuXHRcdFx0XHRcdFx0d2hpbGUoaXNEZWNpbWFsRGlnaXQoZXhwcklDb2RlKGluZGV4KSkpIHtcblx0XHRcdFx0XHRcdFx0bnVtYmVyICs9IGV4cHJJKGluZGV4KyspO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjaCA9IGV4cHJJKGluZGV4KTtcblx0XHRcdFx0XHRpZihjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHsgLy8gZXhwb25lbnQgbWFya2VyXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gZXhwckkoaW5kZXgrKyk7XG5cdFx0XHRcdFx0XHRjaCA9IGV4cHJJKGluZGV4KTtcblx0XHRcdFx0XHRcdGlmKGNoID09PSAnKycgfHwgY2ggPT09ICctJykgeyAvLyBleHBvbmVudCBzaWduXG5cdFx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHdoaWxlKGlzRGVjaW1hbERpZ2l0KGV4cHJJQ29kZShpbmRleCkpKSB7IC8vZXhwb25lbnQgaXRzZWxmXG5cdFx0XHRcdFx0XHRcdG51bWJlciArPSBleHBySShpbmRleCsrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCFpc0RlY2ltYWxEaWdpdChleHBySUNvZGUoaW5kZXgtMSkpICkge1xuXHRcdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdFeHBlY3RlZCBleHBvbmVudCAoJyArIG51bWJlciArIGV4cHJJKGluZGV4KSArICcpJywgaW5kZXgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblxuXHRcdFx0XHRcdGNoQ29kZSA9IGV4cHJJQ29kZShpbmRleCk7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgdG8gbWFrZSBzdXJlIHRoaXMgaXNuJ3QgYSB2YXJpYWJsZSBuYW1lIHRoYXQgc3RhcnQgd2l0aCBhIG51bWJlciAoMTIzYWJjKVxuXHRcdFx0XHRcdGlmKGlzSWRlbnRpZmllclN0YXJ0KGNoQ29kZSkpIHtcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ1ZhcmlhYmxlIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoIGEgbnVtYmVyICgnICtcblx0XHRcdFx0XHRcdFx0XHRcdG51bWJlciArIGV4cHJJKGluZGV4KSArICcpJywgaW5kZXgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZihjaENvZGUgPT09IFBFUklPRF9DT0RFKSB7XG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmV4cGVjdGVkIHBlcmlvZCcsIGluZGV4KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogTElURVJBTCxcblx0XHRcdFx0XHRcdHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG5cdFx0XHRcdFx0XHRyYXc6IG51bWJlclxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUGFyc2VzIGEgc3RyaW5nIGxpdGVyYWwsIHN0YXJpbmcgd2l0aCBzaW5nbGUgb3IgZG91YmxlIHF1b3RlcyB3aXRoIGJhc2ljIHN1cHBvcnQgZm9yIGVzY2FwZSBjb2Rlc1xuXHRcdFx0XHQvLyBlLmcuIGBcImhlbGxvIHdvcmxkXCJgLCBgJ3RoaXMgaXNcXG5KU0VQJ2Bcblx0XHRcdFx0Z29iYmxlU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBzdHIgPSAnJywgcXVvdGUgPSBleHBySShpbmRleCsrKSwgY2xvc2VkID0gZmFsc2UsIGNoO1xuXG5cdFx0XHRcdFx0d2hpbGUoaW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNoID0gZXhwckkoaW5kZXgrKyk7XG5cdFx0XHRcdFx0XHRpZihjaCA9PT0gcXVvdGUpIHtcblx0XHRcdFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoY2ggPT09ICdcXFxcJykge1xuXHRcdFx0XHRcdFx0XHQvLyBDaGVjayBmb3IgYWxsIG9mIHRoZSBjb21tb24gZXNjYXBlIGNvZGVzXG5cdFx0XHRcdFx0XHRcdGNoID0gZXhwckkoaW5kZXgrKyk7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaChjaCkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ24nOiBzdHIgKz0gJ1xcbic7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3InOiBzdHIgKz0gJ1xccic7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3QnOiBzdHIgKz0gJ1xcdCc7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2InOiBzdHIgKz0gJ1xcYic7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2YnOiBzdHIgKz0gJ1xcZic7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3YnOiBzdHIgKz0gJ1xceDBCJzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN0ciArPSBjaDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZighY2xvc2VkKSB7XG5cdFx0XHRcdFx0XHR0aHJvd0Vycm9yKCdVbmNsb3NlZCBxdW90ZSBhZnRlciBcIicrc3RyKydcIicsIGluZGV4KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogTElURVJBTCxcblx0XHRcdFx0XHRcdHZhbHVlOiBzdHIsXG5cdFx0XHRcdFx0XHRyYXc6IHF1b3RlICsgc3RyICsgcXVvdGVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gR29iYmxlcyBvbmx5IGlkZW50aWZpZXJzXG5cdFx0XHRcdC8vIGUuZy46IGBmb29gLCBgX3ZhbHVlYCwgYCR4MWBcblx0XHRcdFx0Ly8gQWxzbywgdGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhhdCBpZGVudGlmaWVyIGlzIGEgbGl0ZXJhbDpcblx0XHRcdFx0Ly8gKGUuZy4gYHRydWVgLCBgZmFsc2VgLCBgbnVsbGApIG9yIGB0aGlzYFxuXHRcdFx0XHRnb2JibGVJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGNoID0gZXhwcklDb2RlKGluZGV4KSwgc3RhcnQgPSBpbmRleCwgaWRlbnRpZmllcjtcblxuXHRcdFx0XHRcdGlmKGlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuXHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3dFcnJvcignVW5leHBlY3RlZCAnICsgZXhwckkoaW5kZXgpLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0d2hpbGUoaW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNoID0gZXhwcklDb2RlKGluZGV4KTtcblx0XHRcdFx0XHRcdGlmKGlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWRlbnRpZmllciA9IGV4cHIuc2xpY2Uoc3RhcnQsIGluZGV4KTtcblxuXHRcdFx0XHRcdGlmKGxpdGVyYWxzLmhhc093blByb3BlcnR5KGlkZW50aWZpZXIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiBMSVRFUkFMLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogbGl0ZXJhbHNbaWRlbnRpZmllcl0sXG5cdFx0XHRcdFx0XHRcdHJhdzogaWRlbnRpZmllclxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoaWRlbnRpZmllciA9PT0gdGhpc19zdHIpIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IHR5cGU6IFRISVNfRVhQIH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IElERU5USUZJRVIsXG5cdFx0XHRcdFx0XHRcdG5hbWU6IGlkZW50aWZpZXJcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdvYmJsZXMgYSBsaXN0IG9mIGFyZ3VtZW50cyB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYSBmdW5jdGlvbiBjYWxsXG5cdFx0XHRcdC8vIG9yIGFycmF5IGxpdGVyYWwuIFRoaXMgZnVuY3Rpb24gYWxzbyBhc3N1bWVzIHRoYXQgdGhlIG9wZW5pbmcgY2hhcmFjdGVyXG5cdFx0XHRcdC8vIGAoYCBvciBgW2AgaGFzIGFscmVhZHkgYmVlbiBnb2JibGVkLCBhbmQgZ29iYmxlcyBleHByZXNzaW9ucyBhbmQgY29tbWFzXG5cdFx0XHRcdC8vIHVudGlsIHRoZSB0ZXJtaW5hdG9yIGNoYXJhY3RlciBgKWAgb3IgYF1gIGlzIGVuY291bnRlcmVkLlxuXHRcdFx0XHQvLyBlLmcuIGBmb28oYmFyLCBiYXopYCwgYG15X2Z1bmMoKWAsIG9yIGBbYmFyLCBiYXpdYFxuXHRcdFx0XHRnb2JibGVBcmd1bWVudHMgPSBmdW5jdGlvbih0ZXJtaW5hdGlvbikge1xuXHRcdFx0XHRcdHZhciBjaF9pLCBhcmdzID0gW10sIG5vZGU7XG5cdFx0XHRcdFx0d2hpbGUoaW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdFx0Y2hfaSA9IGV4cHJJQ29kZShpbmRleCk7XG5cdFx0XHRcdFx0XHRpZihjaF9pID09PSB0ZXJtaW5hdGlvbikgeyAvLyBkb25lIHBhcnNpbmdcblx0XHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGNoX2kgPT09IENPTU1BX0NPREUpIHsgLy8gYmV0d2VlbiBleHByZXNzaW9uc1xuXHRcdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IGdvYmJsZUV4cHJlc3Npb24oKTtcblx0XHRcdFx0XHRcdFx0aWYoIW5vZGUgfHwgbm9kZS50eXBlID09PSBDT01QT1VORCkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ0V4cGVjdGVkIGNvbW1hJywgaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGFyZ3MucHVzaChub2RlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR29iYmxlIGEgbm9uLWxpdGVyYWwgdmFyaWFibGUgbmFtZS4gVGhpcyB2YXJpYWJsZSBuYW1lIG1heSBpbmNsdWRlIHByb3BlcnRpZXNcblx0XHRcdFx0Ly8gZS5nLiBgZm9vYCwgYGJhci5iYXpgLCBgZm9vWydiYXInXS5iYXpgXG5cdFx0XHRcdC8vIEl0IGFsc28gZ29iYmxlcyBmdW5jdGlvbiBjYWxsczpcblx0XHRcdFx0Ly8gZS5nLiBgTWF0aC5hY29zKG9iai5hbmdsZSlgXG5cdFx0XHRcdGdvYmJsZVZhcmlhYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGNoX2ksIG5vZGU7XG5cdFx0XHRcdFx0Y2hfaSA9IGV4cHJJQ29kZShpbmRleCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZihjaF9pID09PSBPUEFSRU5fQ09ERSkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGdvYmJsZUdyb3VwKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBnb2JibGVJZGVudGlmaWVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xuXHRcdFx0XHRcdHdoaWxlKGNoX2kgPT09IFBFUklPRF9DT0RFIHx8IGNoX2kgPT09IE9CUkFDS19DT0RFIHx8IGNoX2kgPT09IE9QQVJFTl9DT0RFKSB7XG5cdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0aWYoY2hfaSA9PT0gUEVSSU9EX0NPREUpIHtcblx0XHRcdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogTUVNQkVSX0VYUCxcblx0XHRcdFx0XHRcdFx0XHRjb21wdXRlZDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0OiBub2RlLFxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5OiBnb2JibGVJZGVudGlmaWVyKClcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihjaF9pID09PSBPQlJBQ0tfQ09ERSkge1xuXHRcdFx0XHRcdFx0XHRub2RlID0ge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IE1FTUJFUl9FWFAsXG5cdFx0XHRcdFx0XHRcdFx0Y29tcHV0ZWQ6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0OiBub2RlLFxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5OiBnb2JibGVFeHByZXNzaW9uKClcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Z29iYmxlU3BhY2VzKCk7XG5cdFx0XHRcdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRpZihjaF9pICE9PSBDQlJBQ0tfQ09ERSkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ1VuY2xvc2VkIFsnLCBpbmRleCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihjaF9pID09PSBPUEFSRU5fQ09ERSkge1xuXHRcdFx0XHRcdFx0XHQvLyBBIGZ1bmN0aW9uIGNhbGwgaXMgYmVpbmcgbWFkZTsgZ29iYmxlIGFsbCB0aGUgYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdG5vZGUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogQ0FMTF9FWFAsXG5cdFx0XHRcdFx0XHRcdFx0J2FyZ3VtZW50cyc6IGdvYmJsZUFyZ3VtZW50cyhDUEFSRU5fQ09ERSksXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGVlOiBub2RlXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRnb2JibGVTcGFjZXMoKTtcblx0XHRcdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSZXNwb25zaWJsZSBmb3IgcGFyc2luZyBhIGdyb3VwIG9mIHRoaW5ncyB3aXRoaW4gcGFyZW50aGVzZXMgYCgpYFxuXHRcdFx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpdCBuZWVkcyB0byBnb2JibGUgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0Ly8gYW5kIHRoZW4gdHJpZXMgdG8gZ29iYmxlIGV2ZXJ5dGhpbmcgd2l0aGluIHRoYXQgcGFyZW50aGVzaXMsIGFzc3VtaW5nXG5cdFx0XHRcdC8vIHRoYXQgdGhlIG5leHQgdGhpbmcgaXQgc2hvdWxkIHNlZSBpcyB0aGUgY2xvc2UgcGFyZW50aGVzaXMuIElmIG5vdCxcblx0XHRcdFx0Ly8gdGhlbiB0aGUgZXhwcmVzc2lvbiBwcm9iYWJseSBkb2Vzbid0IGhhdmUgYSBgKWBcblx0XHRcdFx0Z29iYmxlR3JvdXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdHZhciBub2RlID0gZ29iYmxlRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRcdGdvYmJsZVNwYWNlcygpO1xuXHRcdFx0XHRcdGlmKGV4cHJJQ29kZShpbmRleCkgPT09IENQQVJFTl9DT0RFKSB7XG5cdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ1VuY2xvc2VkICgnLCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJlc3BvbnNpYmxlIGZvciBwYXJzaW5nIEFycmF5IGxpdGVyYWxzIGBbMSwgMiwgM11gXG5cdFx0XHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGl0IG5lZWRzIHRvIGdvYmJsZSB0aGUgb3BlbmluZyBicmFja2V0XG5cdFx0XHRcdC8vIGFuZCB0aGVuIHRyaWVzIHRvIGdvYmJsZSB0aGUgZXhwcmVzc2lvbnMgYXMgYXJndW1lbnRzLlxuXHRcdFx0XHRnb2JibGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IEFSUkFZX0VYUCxcblx0XHRcdFx0XHRcdGVsZW1lbnRzOiBnb2JibGVBcmd1bWVudHMoQ0JSQUNLX0NPREUpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRub2RlcyA9IFtdLCBjaF9pLCBub2RlO1xuXHRcdFx0XHRcblx0XHRcdHdoaWxlKGluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdGNoX2kgPSBleHBySUNvZGUoaW5kZXgpO1xuXG5cdFx0XHRcdC8vIEV4cHJlc3Npb25zIGNhbiBiZSBzZXBhcmF0ZWQgYnkgc2VtaWNvbG9ucywgY29tbWFzLCBvciBqdXN0IGluZmVycmVkIHdpdGhvdXQgYW55XG5cdFx0XHRcdC8vIHNlcGFyYXRvcnNcblx0XHRcdFx0aWYoY2hfaSA9PT0gU0VNQ09MX0NPREUgfHwgY2hfaSA9PT0gQ09NTUFfQ09ERSkge1xuXHRcdFx0XHRcdGluZGV4Kys7IC8vIGlnbm9yZSBzZXBhcmF0b3JzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gVHJ5IHRvIGdvYmJsZSBlYWNoIGV4cHJlc3Npb24gaW5kaXZpZHVhbGx5XG5cdFx0XHRcdFx0aWYoKG5vZGUgPSBnb2JibGVFeHByZXNzaW9uKCkpKSB7XG5cdFx0XHRcdFx0XHRub2Rlcy5wdXNoKG5vZGUpO1xuXHRcdFx0XHRcdC8vIElmIHdlIHdlcmVuJ3QgYWJsZSB0byBmaW5kIGEgYmluYXJ5IGV4cHJlc3Npb24gYW5kIGFyZSBvdXQgb2Ygcm9vbSwgdGhlblxuXHRcdFx0XHRcdC8vIHRoZSBleHByZXNzaW9uIHBhc3NlZCBpbiBwcm9iYWJseSBoYXMgdG9vIG11Y2hcblx0XHRcdFx0XHR9IGVsc2UgaWYoaW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRocm93RXJyb3IoJ1VuZXhwZWN0ZWQgXCInICsgZXhwckkoaW5kZXgpICsgJ1wiJywgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG9ubHkgb25lIGV4cHJlc3Npb24ganVzdCB0cnkgcmV0dXJuaW5nIHRoZSBleHByZXNzaW9uXG5cdFx0XHRpZihub2Rlcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVzWzBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBDT01QT1VORCxcblx0XHRcdFx0XHRib2R5OiBub2Rlc1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0Ly8gVG8gYmUgZmlsbGVkIGluIGJ5IHRoZSB0ZW1wbGF0ZVxuXHRqc2VwLnZlcnNpb24gPSAnPCU9IHZlcnNpb24gJT4nO1xuXHRqc2VwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAnSmF2YVNjcmlwdCBFeHByZXNzaW9uIFBhcnNlciAoSlNFUCkgdicgKyBqc2VwLnZlcnNpb247IH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QganNlcC5hZGRVbmFyeU9wXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcF9uYW1lIFRoZSBuYW1lIG9mIHRoZSB1bmFyeSBvcCB0byBhZGRcblx0ICogQHJldHVybiBqc2VwXG5cdCAqL1xuXHRqc2VwLmFkZFVuYXJ5T3AgPSBmdW5jdGlvbihvcF9uYW1lKSB7XG5cdFx0dW5hcnlfb3BzW29wX25hbWVdID0gdDsgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QganNlcC5hZGRCaW5hcnlPcFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BfbmFtZSBUaGUgbmFtZSBvZiB0aGUgYmluYXJ5IG9wIHRvIGFkZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcHJlY2VkZW5jZSBUaGUgcHJlY2VkZW5jZSBvZiB0aGUgYmluYXJ5IG9wIChjYW4gYmUgYSBmbG9hdClcblx0ICogQHJldHVybiBqc2VwXG5cdCAqL1xuXHRqc2VwLmFkZEJpbmFyeU9wID0gZnVuY3Rpb24ob3BfbmFtZSwgcHJlY2VkZW5jZSkge1xuXHRcdG1heF9iaW5vcF9sZW4gPSBNYXRoLm1heChvcF9uYW1lLmxlbmd0aCwgbWF4X2Jpbm9wX2xlbik7XG5cdFx0YmluYXJ5X29wc1tvcF9uYW1lXSA9IHByZWNlZGVuY2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QganNlcC5yZW1vdmVVbmFyeU9wXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcF9uYW1lIFRoZSBuYW1lIG9mIHRoZSB1bmFyeSBvcCB0byByZW1vdmVcblx0ICogQHJldHVybiBqc2VwXG5cdCAqL1xuXHRqc2VwLnJlbW92ZVVuYXJ5T3AgPSBmdW5jdGlvbihvcF9uYW1lKSB7XG5cdFx0ZGVsZXRlIHVuYXJ5X29wc1tvcF9uYW1lXTtcblx0XHRpZihvcF9uYW1lLmxlbmd0aCA9PT0gbWF4X3Vub3BfbGVuKSB7XG5cdFx0XHRtYXhfdW5vcF9sZW4gPSBnZXRNYXhLZXlMZW4odW5hcnlfb3BzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QganNlcC5yZW1vdmVCaW5hcnlPcFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BfbmFtZSBUaGUgbmFtZSBvZiB0aGUgYmluYXJ5IG9wIHRvIHJlbW92ZVxuXHQgKiBAcmV0dXJuIGpzZXBcblx0ICovXG5cdGpzZXAucmVtb3ZlQmluYXJ5T3AgPSBmdW5jdGlvbihvcF9uYW1lKSB7XG5cdFx0ZGVsZXRlIGJpbmFyeV9vcHNbb3BfbmFtZV07XG5cdFx0aWYob3BfbmFtZS5sZW5ndGggPT09IG1heF9iaW5vcF9sZW4pIHtcblx0XHRcdG1heF9iaW5vcF9sZW4gPSBnZXRNYXhLZXlMZW4oYmluYXJ5X29wcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vIEluIGRlc2t0b3AgZW52aXJvbm1lbnRzLCBoYXZlIGEgd2F5IHRvIHJlc3RvcmUgdGhlIG9sZCB2YWx1ZSBmb3IgYGpzZXBgXG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgb2xkX2pzZXAgPSByb290LmpzZXA7XG5cdFx0Ly8gVGhlIHN0YXIgb2YgdGhlIHNob3chIEl0J3MgYSBmdW5jdGlvbiFcblx0XHRyb290LmpzZXAgPSBqc2VwO1xuXHRcdC8vIEFuZCBhIGNvdXJ0ZW91cyBmdW5jdGlvbiB3aWxsaW5nIHRvIG1vdmUgb3V0IG9mIHRoZSB3YXkgZm9yIG90aGVyIHNpbWlsYXJseS1uYW1lZCBvYmplY3RzIVxuXHRcdGpzZXAubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYocm9vdC5qc2VwID09PSBqc2VwKSB7XG5cdFx0XHRcdHJvb3QuanNlcCA9IG9sZF9qc2VwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGpzZXA7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBJbiBOb2RlLkpTIGVudmlyb25tZW50c1xuXHRcdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdFx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ganNlcDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5wYXJzZSA9IGpzZXA7XG5cdFx0fVxuXHR9XG59KHRoaXMpKTtcbiIsIi8vIGtub2Nrb3V0LXNvcnRhYmxlIDAuMTEuMCB8IChjKSAyMDE1IFJ5YW4gTmllbWV5ZXIgfCAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxuIWZ1bmN0aW9uKGEpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW1wia25vY2tvdXRcIixcImpxdWVyeVwiLFwianF1ZXJ5LXVpL3NvcnRhYmxlXCIsXCJqcXVlcnktdWkvZHJhZ2dhYmxlXCJdLGEpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUpe3ZhciBiPSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpLGM9KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTsodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpLCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCksYShiLGMpfWVsc2UgYSh3aW5kb3cua28sd2luZG93LmpRdWVyeSl9KGZ1bmN0aW9uKGEsYil7dmFyIGM9XCJrb19zb3J0SXRlbVwiLGQ9XCJrb19zb3VyY2VJbmRleFwiLGU9XCJrb19zb3J0TGlzdFwiLGY9XCJrb19wYXJlbnRMaXN0XCIsZz1cImtvX2RyYWdJdGVtXCIsaD1hLnV0aWxzLnVud3JhcE9ic2VydmFibGUsaT1hLnV0aWxzLmRvbURhdGEuZ2V0LGo9YS51dGlscy5kb21EYXRhLnNldCxrPWIudWkmJmIudWkudmVyc2lvbixsPWsmJmsuaW5kZXhPZihcIjEuNi5cIikmJmsuaW5kZXhPZihcIjEuNy5cIikmJihrLmluZGV4T2YoXCIxLjguXCIpfHxcIjEuOC4yNFwiPT09ayksbT1mdW5jdGlvbihiLGQpe2EudXRpbHMuYXJyYXlGb3JFYWNoKGIsZnVuY3Rpb24oYSl7MT09PWEubm9kZVR5cGUmJihqKGEsYyxkKSxqKGEsZixpKGEucGFyZW50Tm9kZSxlKSkpfSl9LG49ZnVuY3Rpb24oYixjKXt2YXIgZCxlPXt9LGY9aChiKCkpfHx7fTtyZXR1cm4gZi5kYXRhPyhlW2NdPWYuZGF0YSxlLm5hbWU9Zi50ZW1wbGF0ZSk6ZVtjXT1iKCksYS51dGlscy5hcnJheUZvckVhY2goW1wiYWZ0ZXJBZGRcIixcImFmdGVyUmVuZGVyXCIsXCJhc1wiLFwiYmVmb3JlUmVtb3ZlXCIsXCJpbmNsdWRlRGVzdHJveWVkXCIsXCJ0ZW1wbGF0ZUVuZ2luZVwiLFwidGVtcGxhdGVPcHRpb25zXCIsXCJub2Rlc1wiXSxmdW5jdGlvbihiKXtmLmhhc093blByb3BlcnR5KGIpP2VbYl09ZltiXTphLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZS5oYXNPd25Qcm9wZXJ0eShiKSYmKGVbYl09YS5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGVbYl0pfSksXCJmb3JlYWNoXCI9PT1jJiYoZS5hZnRlclJlbmRlcj8oZD1lLmFmdGVyUmVuZGVyLGUuYWZ0ZXJSZW5kZXI9ZnVuY3Rpb24oYSxiKXttLmNhbGwoYixhLGIpLGQuY2FsbChiLGEsYil9KTplLmFmdGVyUmVuZGVyPW0pLGV9LG89ZnVuY3Rpb24oYSxiKXt2YXIgYz1oKGIpO2lmKGMpZm9yKHZhciBkPTA7YT5kO2QrKyljW2RdJiZoKGNbZF0uX2Rlc3Ryb3kpJiZhKys7cmV0dXJuIGF9LHA9ZnVuY3Rpb24oYyxkKXt2YXIgZSxmO2Q/KGY9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZCksZiYmKGU9bmV3IGEudGVtcGxhdGVTb3VyY2VzLmRvbUVsZW1lbnQoZiksZS50ZXh0KGIudHJpbShlLnRleHQoKSkpKSk6YihjKS5jb250ZW50cygpLmVhY2goZnVuY3Rpb24oKXt0aGlzJiYxIT09dGhpcy5ub2RlVHlwZSYmYy5yZW1vdmVDaGlsZCh0aGlzKX0pfTthLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZT17aW5pdDpmdW5jdGlvbihrLG0scSxyLHMpe3ZhciB0LHUsdj1iKGspLHc9aChtKCkpfHx7fSx4PW4obSxcImZvcmVhY2hcIikseT17fTtwKGsseC5uYW1lKSxiLmV4dGVuZCghMCx5LGEuYmluZGluZ0hhbmRsZXJzLnNvcnRhYmxlKSx3Lm9wdGlvbnMmJnkub3B0aW9ucyYmKGEudXRpbHMuZXh0ZW5kKHkub3B0aW9ucyx3Lm9wdGlvbnMpLGRlbGV0ZSB3Lm9wdGlvbnMpLGEudXRpbHMuZXh0ZW5kKHksdykseS5jb25uZWN0Q2xhc3MmJihhLmlzT2JzZXJ2YWJsZSh5LmFsbG93RHJvcCl8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHkuYWxsb3dEcm9wKT9hLmNvbXB1dGVkKHtyZWFkOmZ1bmN0aW9uKCl7dmFyIGI9aCh5LmFsbG93RHJvcCksYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBiP2IuY2FsbCh0aGlzLHguZm9yZWFjaCk6YjthLnV0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcyhrLHkuY29ubmVjdENsYXNzLGMpfSxkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6a30sdGhpcyk6YS51dGlscy50b2dnbGVEb21Ob2RlQ3NzQ2xhc3Moayx5LmNvbm5lY3RDbGFzcyx5LmFsbG93RHJvcCksYS5iaW5kaW5nSGFuZGxlcnMudGVtcGxhdGUuaW5pdChrLGZ1bmN0aW9uKCl7cmV0dXJuIHh9LHEscixzKSx0PXkub3B0aW9ucy5zdGFydCx1PXkub3B0aW9ucy51cGRhdGU7dmFyIHo9c2V0VGltZW91dChmdW5jdGlvbigpe3ZhciBtO3Yuc29ydGFibGUoYS51dGlscy5leHRlbmQoeS5vcHRpb25zLHtzdGFydDpmdW5jdGlvbihiLGMpe3ZhciBlPWMuaXRlbVswXTtqKGUsZCxhLnV0aWxzLmFycmF5SW5kZXhPZihjLml0ZW0ucGFyZW50KCkuY2hpbGRyZW4oKSxlKSksYy5pdGVtLmZpbmQoXCJpbnB1dDpmb2N1c1wiKS5jaGFuZ2UoKSx0JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0scmVjZWl2ZTpmdW5jdGlvbihhLGIpe209aShiLml0ZW1bMF0sZyksbSYmKG0uY2xvbmUmJihtPW0uY2xvbmUoKSkseS5kcmFnZ2VkJiYobT15LmRyYWdnZWQuY2FsbCh0aGlzLG0sYSxiKXx8bSkpfSx1cGRhdGU6ZnVuY3Rpb24oZyxoKXt2YXIgayxuLHAscSxyLHM9aC5pdGVtWzBdLHQ9aC5pdGVtLnBhcmVudCgpWzBdLHY9aShzLGMpfHxtO2lmKG09bnVsbCx2JiZ0aGlzPT09dHx8IWwmJmIuY29udGFpbnModGhpcyx0KSl7aWYoaz1pKHMsZikscD1pKHMsZCksbj1pKHMucGFyZW50Tm9kZSxlKSxxPWEudXRpbHMuYXJyYXlJbmRleE9mKGguaXRlbS5wYXJlbnQoKS5jaGlsZHJlbigpLHMpLHguaW5jbHVkZURlc3Ryb3llZHx8KHA9byhwLGspLHE9byhxLG4pKSwoeS5iZWZvcmVNb3ZlfHx5LmFmdGVyTW92ZSkmJihyPXtpdGVtOnYsc291cmNlUGFyZW50Omssc291cmNlUGFyZW50Tm9kZTprJiZoLnNlbmRlcnx8cy5wYXJlbnROb2RlLHNvdXJjZUluZGV4OnAsdGFyZ2V0UGFyZW50Om4sdGFyZ2V0SW5kZXg6cSxjYW5jZWxEcm9wOiExfSx5LmJlZm9yZU1vdmUmJnkuYmVmb3JlTW92ZS5jYWxsKHRoaXMscixnLGgpKSxrP2Ioaz09PW4/dGhpczpoLnNlbmRlcnx8dGhpcykuc29ydGFibGUoXCJjYW5jZWxcIik6YihzKS5yZW1vdmUoKSxyJiZyLmNhbmNlbERyb3ApcmV0dXJuO3E+PTAmJihrJiYoay5zcGxpY2UocCwxKSxhLnByb2Nlc3NBbGxEZWZlcnJlZEJpbmRpbmdVcGRhdGVzJiZhLnByb2Nlc3NBbGxEZWZlcnJlZEJpbmRpbmdVcGRhdGVzKCkpLG4uc3BsaWNlKHEsMCx2KSksaihzLGMsbnVsbCksYS5wcm9jZXNzQWxsRGVmZXJyZWRCaW5kaW5nVXBkYXRlcyYmYS5wcm9jZXNzQWxsRGVmZXJyZWRCaW5kaW5nVXBkYXRlcygpLHkuYWZ0ZXJNb3ZlJiZ5LmFmdGVyTW92ZS5jYWxsKHRoaXMscixnLGgpfXUmJnUuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjb25uZWN0V2l0aDp5LmNvbm5lY3RDbGFzcz9cIi5cIit5LmNvbm5lY3RDbGFzczohMX0pKSx2b2lkIDAhPT15LmlzRW5hYmxlZCYmYS5jb21wdXRlZCh7cmVhZDpmdW5jdGlvbigpe3Yuc29ydGFibGUoaCh5LmlzRW5hYmxlZCk/XCJlbmFibGVcIjpcImRpc2FibGVcIil9LGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDprfSl9LDApO3JldHVybiBhLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soayxmdW5jdGlvbigpeyh2LmRhdGEoXCJ1aS1zb3J0YWJsZVwiKXx8di5kYXRhKFwic29ydGFibGVcIikpJiZ2LnNvcnRhYmxlKFwiZGVzdHJveVwiKSxhLnV0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzcyhrLHkuY29ubmVjdENsYXNzLCExKSxjbGVhclRpbWVvdXQoeil9KSx7Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fSx1cGRhdGU6ZnVuY3Rpb24oYixjLGQsZixnKXt2YXIgaD1uKGMsXCJmb3JlYWNoXCIpO2ooYixlLGguZm9yZWFjaCksYS5iaW5kaW5nSGFuZGxlcnMudGVtcGxhdGUudXBkYXRlKGIsZnVuY3Rpb24oKXtyZXR1cm4gaH0sZCxmLGcpfSxjb25uZWN0Q2xhc3M6XCJrb19jb250YWluZXJcIixhbGxvd0Ryb3A6ITAsYWZ0ZXJNb3ZlOm51bGwsYmVmb3JlTW92ZTpudWxsLG9wdGlvbnM6e319LGEuYmluZGluZ0hhbmRsZXJzLmRyYWdnYWJsZT17aW5pdDpmdW5jdGlvbihjLGQsZSxmLGkpe3ZhciBrPWgoZCgpKXx8e30sbD1rLm9wdGlvbnN8fHt9LG09YS51dGlscy5leHRlbmQoe30sYS5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLm9wdGlvbnMpLG89bihkLFwiZGF0YVwiKSxwPWsuY29ubmVjdENsYXNzfHxhLmJpbmRpbmdIYW5kbGVycy5kcmFnZ2FibGUuY29ubmVjdENsYXNzLHE9dm9pZCAwIT09ay5pc0VuYWJsZWQ/ay5pc0VuYWJsZWQ6YS5iaW5kaW5nSGFuZGxlcnMuZHJhZ2dhYmxlLmlzRW5hYmxlZDtyZXR1cm4gaz1cImRhdGFcImluIGs/ay5kYXRhOmssaihjLGcsayksYS51dGlscy5leHRlbmQobSxsKSxtLmNvbm5lY3RUb1NvcnRhYmxlPXA/XCIuXCIrcDohMSxiKGMpLmRyYWdnYWJsZShtKSx2b2lkIDAhPT1xJiZhLmNvbXB1dGVkKHtyZWFkOmZ1bmN0aW9uKCl7YihjKS5kcmFnZ2FibGUoaChxKT9cImVuYWJsZVwiOlwiZGlzYWJsZVwiKX0sZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOmN9KSxhLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soYyxmdW5jdGlvbigpe2IoYykuZHJhZ2dhYmxlKFwiZGVzdHJveVwiKX0pLGEuYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLmluaXQoYyxmdW5jdGlvbigpe3JldHVybiBvfSxlLGYsaSl9LHVwZGF0ZTpmdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnPW4oYyxcImRhdGFcIik7cmV0dXJuIGEuYmluZGluZ0hhbmRsZXJzLnRlbXBsYXRlLnVwZGF0ZShiLGZ1bmN0aW9uKCl7cmV0dXJuIGd9LGQsZSxmKX0sY29ubmVjdENsYXNzOmEuYmluZGluZ0hhbmRsZXJzLnNvcnRhYmxlLmNvbm5lY3RDbGFzcyxvcHRpb25zOntoZWxwZXI6XCJjbG9uZVwifX19KTsiLCIvLyBLbm9ja291dCBVbmRvTWFuYWdlciB2MC4yIHwgKGMpIDIwMTUgU3RlZmFubyBCYWduYXJhXG4vLyBMaWNlbnNlOiBNSVQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UpIFxuLy8gcmVxdWlyZXMgXCJrby53YXRjaFwiIG1ldGhvZCBmcm9tIGtub2Nrb3V0LnJlYWN0b3JcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAvLyBNb2R1bGUgc3lzdGVtcyBtYWdpYyBkYW5jZS5cbiAgaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAgIC8vIENvbW1vbkpTIG9yIE5vZGU6IGhhcmQtY29kZWQgZGVwZW5kZW5jeSBvbiBcImtub2Nrb3V0XCJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCksIHJlcXVpcmUoXCIuLy4uL2tub2Nrb3V0anMtcmVhY3Rvci9kaXN0L2tvLXJlYWN0b3IubWluLmpzXCIpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lW1wiYW1kXCJdKSB7XG4gICAgLy8gQU1EIGFub255bW91cyBtb2R1bGUgd2l0aCBoYXJkLWNvZGVkIGRlcGVuZGVuY3kgb24gXCJrbm9ja291dFwiXG4gICAgZGVmaW5lKFtcImtub2Nrb3V0XCIsIFwia25vY2tvdXRqcy1yZWFjdG9yXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gPHNjcmlwdD4gdGFnOiB1c2UgdGhlIGdsb2JhbCBga29gIG9iamVjdFxuICAgIGZhY3Rvcnkoa28sIGtvLndhdGNoKTtcbiAgfVxufShmdW5jdGlvbiAoa28sIHJlYWN0b3IpIHsgXG5cbiAgLy8vIDxzdW1tYXJ5PlxuICAvLy8gICAgIFRyYWNrIGxhc3QgXCJsZXZlbHNcIiBjaGFuZ2VzIHdpdGhpbiB0aGUgY2hhaW5lZCBvYnNlcnZhYmxlIGRvd24gdG8gYW55IGdpdmVuIGxldmVsIGFuZFxuICAvLy8gICAgIHN1cHBvcnRzIHVuZG9pbmcvcmVkb2luZyB0aGUgY2hhbmdlcy5cbiAgLy8vIDwvc3VtbWFyeT5cbiAgLy8vIDxwYXJhbSBuYW1lPVwib3B0aW9uc1wiIHR5cGU9XCJvYmplY3RcIj5cbiAgLy8vICAgICB7IGxldmVsczogMiB9IC0+IFJlbWVtYmVyIG9ubHkgbGFzdCBcImxldmVsc1wiIGNoYW5nZXM8YnIvPlxuICAvLy8gICAgIHsgdW5kb0xhYmVsOiBcIlVuZG8gaXQgKCNDT1VOVCkhXCIgfSAtPiBEZWZpbmUgYSBsYWJlbCBmb3IgdGhlIHVuZG8gY29tbWFuZC4gXCIjQ09VTlQjXCIgc2VxdWVuY2Ugd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBzdGFjayBsZW5ndGguPGJyLz5cbiAgLy8vICAgICB7IHJlZG9MYWJlbDogXCJSZWRvIGl0ICgjQ09VTlQpIVwiIH0gLT4gRGVmaW5lIGEgbGFiZWwgZm9yIHRoZSByZWRvIGNvbW1hbmQuIFwiI0NPVU5UI1wiIHNlcXVlbmNlIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgc3RhY2sgbGVuZ3RoLjxici8+XG4gIC8vLyA8L3BhcmFtPlxuICB2YXIgdW5kb01hbmFnZXIgPSBmdW5jdGlvbiAobW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdW5kb1N0YWNrID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gICAgdmFyIHJlZG9TdGFjayA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICAgIHZhciBsYXN0UHVzaGVkU3RhY2s7XG4gICAgdmFyIFNUQVRFX0RPSU5HID0gMDtcbiAgICB2YXIgU1RBVEVfVU5ET0lORyA9IDE7XG4gICAgdmFyIFNUQVRFX1JFRE9JTkcgPSAyO1xuICAgIHZhciBzdGF0ZSA9IFNUQVRFX0RPSU5HO1xuXG4gICAgdmFyIE1PREVfTk9STUFMID0gMDsgLy8gYWRkIHRvIHN0YWNrIGV2ZXJ5IGNoYW5nZVxuICAgIHZhciBNT0RFX0lHTk9SRSA9IDE7IC8vIGRvIG5vdCBhZGQgYW55dGhpbmcgdG8gdGhlIHN0YWNrXG4gICAgdmFyIE1PREVfT05DRSA9IDI7IC8vIG9ubHkgb25lIHNlcXVlbnRpYWwgY2hhbmdlIGZvciBlYWNoIHByb3BlcnR5IGlzIGFkZGVkIHRvIHRoZSBzdGFja1xuICAgIHZhciBNT0RFX01FUkdFID0gMzsgLy8gbWVyZ2UgbmV4dCBjaGFuZ2Ugd2l0aCB0aGUgbGFzdCBvbmVcbiAgICB2YXIgbW9kZSA9IE1PREVfTk9STUFMO1xuXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgbGV2ZWxzOiAxMDAsXG4gICAgICB1bmRvTGFiZWw6IFwidW5kbyAoI0NPVU5UIylcIixcbiAgICAgIHJlZG9MYWJlbDogXCJyZWRvICgjQ09VTlQjKVwiXG4gICAgfTtcbiAgICBcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBrby51dGlscy5leHRlbmQoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuICBcbiAgICB2YXIgX3B1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAvLyBkdXJhbnRlIFVORE8vUkVETyBsYXZvcmlhbW8gc2VtcHJlIGluIG5vcm1hbGVcbiAgICAgIGlmIChzdGF0ZSA9PSBTVEFURV9VTkRPSU5HKSB7XG4gICAgICAgIF9wdXNoSW50KGFjdGlvbiwgcmVkb1N0YWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gU1RBVEVfUkVET0lORykge1xuICAgICAgICBfcHVzaEludChhY3Rpb24sIHVuZG9TdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09IFNUQVRFX0RPSU5HKSB7XG4gICAgICAgIF9wdXNoSW50KGFjdGlvbiwgdW5kb1N0YWNrKTtcbiAgICAgICAgcmVkb1N0YWNrLnJlbW92ZUFsbCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIF90cnlNZXJnZSA9IGZ1bmN0aW9uIChwcmV2LCBuZXdBY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2YgcHJldi5tZXJnZWRBY3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBwcmV2Lm1lcmdlZEFjdGlvbihuZXdBY3Rpb24pO1xuICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgX3B1c2hJbnQgPSBmdW5jdGlvbiAoYWN0aW9uLCBteVN0YWNrKSB7XG4gICAgICAvKiBnZXN0aW9uZSBkZWwgbWVyZ2UgZGkgYXppb25pOiBzZSBsJ3VsdGltYSBhemlvbmUgbmVsbG8gc3RhY2sgaGEgdW4gbWV0b2RvIFwibWVyZ2VkQWN0aW9uXCJcbiAgICAgICAgIHByb3ZpYW1vIGFkIGludm9jYXJsbyBlIHNlIGNpIHJlc3RpdHVpc2NlIHVuYSBmdW56aW9uZSBsYSB1c2lhbW8gYWwgcG9zdG8gZGkgZW50cmFtYmUgKi9cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiVVJcIiwgXCJfcHVzaEludFwiLCBteVN0YWNrKCkubGVuZ3RoID4gMCA/IHR5cGVvZiBteVN0YWNrKClbbXlTdGFjaygpLmxlbmd0aCAtIDFdLm1lcmdlZEFjdGlvbiA6IFwiRU1QVFlcIik7XG4gICAgICBpZiAobXlTdGFjaygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1lcmdlZCA9IF90cnlNZXJnZShteVN0YWNrKClbbXlTdGFjaygpLmxlbmd0aCAtIDFdLCBhY3Rpb24pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVSXCIsIFwiX3B1c2hJbnQubWVyZ2VkXCIsIG1lcmdlZCwgXCJNVlwiLCB0eXBlb2YgYWN0aW9uLm1lcmdlYWJsZU1vdmUsIFwiTUFcIiwgdHlwZW9mIGFjdGlvbi5tZXJnZWFibGVBY3Rpb24sIFwiTU1cIiwgdHlwZW9mIGFjdGlvbi5tZXJnZU1lKTtcbiAgICAgICAgaWYgKG1lcmdlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG15U3RhY2soKVtteVN0YWNrKCkubGVuZ3RoIC0gMV0gPSBtZXJnZWQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobXlTdGFjaygpLmxlbmd0aCA+PSBvcHRpb25zLmxldmVscykgbXlTdGFjay5zaGlmdCgpO1xuICAgICAgbGFzdFB1c2hlZFN0YWNrID0gbXlTdGFjaztcbiAgICAgIG15U3RhY2sucHVzaChhY3Rpb24pO1xuICAgIH07XG4gICAgXG4gICAgdmFyIF94ZG9Db21tYW5kID0gZnVuY3Rpb24obGFiZWwsIHdvcmtTdGF0ZSwgc3RhY2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGxhYmVsKS5yZXBsYWNlKC8jQ09VTlQjLywgc3RhY2soKS5sZW5ndGgpO1xuICAgICAgICB9KSxcbiAgICAgICAgZW5hYmxlZDoga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrKCkubGVuZ3RoICE9PSAwO1xuICAgICAgICB9KSxcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlID0gd29ya1N0YXRlO1xuICAgICAgICAgICAgdmFyIG9sZE1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgbW9kZSA9IE1PREVfTUVSR0U7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlhET1wiLCBcImJlZm9yZVwiLCBsYWJlbCk7XG4gICAgICAgICAgICBhY3Rpb24oKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiWERPXCIsIFwiYWZ0ZXJcIiwgbGFiZWwpO1xuICAgICAgICAgICAgX3JlbW92ZU1lcmdlZEFjdGlvbihsYXN0UHVzaGVkU3RhY2spO1xuICAgICAgICAgICAgbW9kZSA9IG9sZE1vZGU7XG4gICAgICAgICAgICBzdGF0ZSA9IHByZXZTdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfcmVtb3ZlTWVyZ2VkQWN0aW9uID0gZnVuY3Rpb24obXlTdGFjaykge1xuICAgICAgaWYgKHR5cGVvZiBteVN0YWNrID09ICd1bmRlZmluZWQnKSB0aHJvdyBcIlVuZXhwZWN0ZWQgb3BlcmF0aW9uOiBzdGFjayBjbGVhbmVyIGNhbGxlZCB3aXRoIHVuZGVmaW5lZCBzdGFja1wiO1xuICAgICAgXG4gICAgICBpZiAobXlTdGFjaygpLmxlbmd0aCA+IDAgJiYgdHlwZW9mIG15U3RhY2soKVtteVN0YWNrKCkubGVuZ3RoIC0gMV0ubWVyZ2VkQWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlJlbW92aW5nIG1lcmdlZEFjdGlvbiBmcm9tIHN0YWNrXCIpO1xuICAgICAgICBkZWxldGUgbXlTdGFjaygpW215U3RhY2soKS5sZW5ndGggLSAxXS5tZXJnZWRBY3Rpb247XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfY29tYmluZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgIHZhciByZXMgPSAoZnVuY3Rpb24oZjEsIGYyKSB7XG4gICAgICAgIGYxKCk7XG4gICAgICAgIGYyKCk7XG4gICAgICB9KS5iaW5kKHVuZGVmaW5lZCwgZmlyc3QsIHNlY29uZCk7XG4gICAgICBpZiAodHlwZW9mIGZpcnN0Lm1lcmdlZEFjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVzLm1lcmdlZEFjdGlvbiA9IGZpcnN0Lm1lcmdlZEFjdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHZhciBleGVjdXRlVW5kb0FjdGlvbiA9IGZ1bmN0aW9uKGNoaWxkLCB2YWx1ZSwgaXRlbSkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJleGVjdXRlVW5kb0FjdGlvblwiLCBjaGlsZCwgdmFsdWUsIGl0ZW0pO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hpbGQodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PSAnZGVsZXRlZCcpIHtcbiAgICAgICAgICBjaGlsZC5zcGxpY2UoaXRlbS5pbmRleCwgMCwgaXRlbS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5zdGF0dXMgPT0gJ2FkZGVkJykge1xuICAgICAgICAgIGNoaWxkLnNwbGljZShpdGVtLmluZGV4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcIlVuc3VwcHJvdGVkIGl0ZW0uc3RhdHVzOiBcIitpdGVtLnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGNvbmRpdGlvbjogbm8gaXRlbSBhbmQgbm8gY2hpbGQub2xkVmFsdWVzIVwiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWFrZVVuZG9BY3Rpb25EZWZhdWx0ID0gZnVuY3Rpb24odW5kb0Z1bmMsIHBhcmVudHMsIGNoaWxkLCBvbGRWYWwsIGl0ZW0pIHtcbiAgICAgIHJldHVybiB1bmRvRnVuYy5iaW5kKHVuZGVmaW5lZCwgY2hpbGQsIG9sZFZhbCwgaXRlbSk7XG4gICAgfTtcblxuICAgIHZhciBtYWtlVW5kb0FjdGlvbiA9IG1ha2VVbmRvQWN0aW9uRGVmYXVsdDtcblxuICAgIHZhciBjaGFuZ2VQdXNoZXIgPSBmdW5jdGlvbihwYXJlbnRzLCBjaGlsZCwgaXRlbSkge1xuICAgICAgdmFyIG9sZFZhbCA9IHR5cGVvZiBjaGlsZC5vbGRWYWx1ZXMgIT0gJ3VuZGVmaW5lZCcgPyBjaGlsZC5vbGRWYWx1ZXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWN0ID0gbWFrZVVuZG9BY3Rpb24oZXhlY3V0ZVVuZG9BY3Rpb24sIHBhcmVudHMsIGNoaWxkLCBvbGRWYWwsIGl0ZW0pO1xuXG4gICAgICBpZiAobW9kZSA9PSBNT0RFX0lHTk9SRSkgcmV0dXJuO1xuXG4gICAgICBpZiAobW9kZSA9PSBNT0RFX01FUkdFKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVVJcIiwgXCJtZXJnZW1vZGVcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGFjdC5tZXJnZWRBY3Rpb24gPSBmdW5jdGlvbihuZXdBY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3QWN0aW9uLm1lcmdlTWUgIT09ICd1bmRlZmluZWQnICYmIG5ld0FjdGlvbi5tZXJnZU1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfY29tYmluZWRGdW5jdGlvbihuZXdBY3Rpb24sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgYWN0Lm1lcmdlTWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGFjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoY2hpbGQub2xkVmFsdWVzICYmIG1vZGUgPT0gTU9ERV9PTkNFKSB7XG4gICAgICAgICAgICBhY3QubWVyZ2VkQWN0aW9uID0gZnVuY3Rpb24ob2xkQ2hpbGQsIG9sZEl0ZW0sIG5ld0FjdGlvbikge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld0FjdGlvbi5tZXJnZWFibGVBY3Rpb24gPT0gJ29iamVjdCcgJiYgb2xkQ2hpbGQgPT0gbmV3QWN0aW9uLm1lcmdlYWJsZUFjdGlvbi5jaGlsZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVVJcIiwgXCJpZ25vcmUgdXBkYXRlIGZvciBwcm9wZXJ0eSBpbiBNT0RFX09OQ0VcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZChhY3QsIGNoaWxkLCBpdGVtKTtcbiAgICAgICAgICAgIGFjdC5tZXJnZWFibGVBY3Rpb24gPSB7IGNoaWxkOiBjaGlsZCwgaXRlbTogaXRlbSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVSXCIsIFwiaXRlbS5zdGF0dXNcIiwgaXRlbS5zdGF0dXMpO1xuICAgICAgICAgIC8vIFwiaXRlbVwiIGlzIHZhbHVlZCB3aGVuIGFuIGl0ZW0gaXMgYWRkZWQvcmVtb3ZlZC9yZXRlaW5lZCBpbiBhbiBhcnJheVxuICAgICAgICAgIC8vIHNvbWV0aW1lcyBLTyBkZXRlY3QgXCJtb3Zlc1wiIGFuZCBhZGQgYSBcIm1vdmVkXCIgcHJvcGVydHkgd2l0aCB0aGUgaW5kZXggYnV0XG4gICAgICAgICAgLy8gdGhpcyBkb2Vzbid0IGhhcHBlbiBmb3IgZXhhbXBsZSB1c2luZyBrbm9ja291dC1zb3J0YWJsZSBvciB3aGVuIG1vdmluZyBvYmplY3RzXG4gICAgICAgICAgLy8gYmV0d2VlbiBhcnJheXMuXG4gICAgICAgICAgLy8gU28gdGhpcyBlbmRzIHVwIGhhbmRsaW5nIHRoaXMgd2l0aCBcIm1lcmdlYWJsZU1vdmVcIiBhbmQgXCJtZXJnZWRBY3Rpb25cIjogXG4gICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5zdGF0dXMgPT0gJ2RlbGV0ZWQnKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNlIHNvbm8gaW4gTU9ERSA9IE1FUkdFIGRldm8gbWV0dGVlciB1bmEgZnVuemlvbmUgZGkgbWVyZ2UgY2hlIGFjY2V0dGEgdHV0dG8uXG4gICAgICAgICAgICAvLyBhbHRyaW1lbnRpIGxhc2NpbyBxdWVzdGEuXG4gICAgICAgICAgICBhY3QubWVyZ2VkQWN0aW9uID0gZnVuY3Rpb24ob2xkQ2hpbGQsIG9sZEl0ZW0sIG5ld0FjdGlvbikge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVSXCIsIFwiYWN0Lm1lcmdlZEFjdGlvblwiLCB0eXBlb2YgbmV3QWN0aW9uLm1lcmdlYWJsZU1vdmUpO1xuICAgICAgICAgICAgICAvLyBhIGRlbGV0ZWQgYWN0aW9uIGlzIGFibGUgdG8gbWVyZ2Ugd2l0aCBhIGFkZGVkIGFjdGlvbiBpZiB0aGV5IGFwcGx5IHRvIHRoZSBzYW1lXG4gICAgICAgICAgICAgIC8vIG9iamVjdC5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdBY3Rpb24ubWVyZ2VhYmxlTW92ZSA9PSAnb2JqZWN0JyAmJiBvbGRJdGVtLnZhbHVlID09IG5ld0FjdGlvbi5tZXJnZWFibGVNb3ZlLml0ZW0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2UgSSBzaW1wbHkgcmV0dXJuIGEgc2luZ2xlIGFjdGlvbiBydW5uaW5nIGJvdGggYWN0aW9ucyBpbiBzZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdheSB0aGUgXCJ1bmRvXCIgd2lsbCBuZWVkIHRvIHVuZG8gb25seSBvbmNlIGZvciBhIFwibW92ZVwiIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbWJpbmVkRnVuY3Rpb24obmV3QWN0aW9uLCB0aGlzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVSXCIsIFwibm90IG1lcmdlYWJsZVwiLCB0eXBlb2YgbmV3QWN0aW9uLm1lcmdlYWJsZU1vdmUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LmJpbmQoYWN0LCBjaGlsZCwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uc3RhdHVzID09ICdhZGRlZCcpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhIG1lcmdlYWJsZU1vdmUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIG5leHQgYWN0aW9uIFwibWVyZ2VkQWN0aW9uXCIgdG8gc2VlIGlmIHRoaXMgYWN0aW9uXG4gICAgICAgICAgICAvLyBjYW4gYmUgbWVyZ2VkLlxuICAgICAgICAgICAgYWN0Lm1lcmdlYWJsZU1vdmUgPSB7IGNoaWxkOiBjaGlsZCwgaXRlbTogaXRlbSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBhY3QgIT09ICd1bmRlZmluZWQnKSBfcHVzaChhY3QpO1xuICAgIH07XG5cbiAgICB2YXIgcmVhY3Rvck9wdGlvbnMgPSB7IGRlcHRoOiAtMSwgb2xkVmFsdWVzOiAxLCBtdXRhYmxlOiB0cnVlLCAvKiB0YWdQYXJlbnRzV2l0aE5hbWU6IHRydWUgKi8gdGFnRmllbGRzOiB0cnVlIH07XG5cbiAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgIHZhciByZWFjdCA9IHR5cGVvZiByZWFjdG9yID09ICdmdW5jdGlvbicgPyByZWFjdG9yIDoga28ud2F0Y2g7XG4gICAgdmFyIHJlcyA9IHJlYWN0KG1vZGVsLCByZWFjdG9yT3B0aW9ucywgY2hhbmdlUHVzaGVyLCBjb250ZXh0KTtcblxuICAgIHJldHVybiB7XG4gICAgICBwdXNoOiBfcHVzaCwgXG4gICAgICB1bmRvQ29tbWFuZDogX3hkb0NvbW1hbmQob3B0aW9ucy51bmRvTGFiZWwsIFNUQVRFX1VORE9JTkcsIHVuZG9TdGFjayksXG4gICAgICByZWRvQ29tbWFuZDogX3hkb0NvbW1hbmQob3B0aW9ucy5yZWRvTGFiZWwsIFNUQVRFX1JFRE9JTkcsIHJlZG9TdGFjayksXG4gICAgICByZXNldDogZnVuY3Rpb24oKSB7IHVuZG9TdGFjay5yZW1vdmVBbGwoKTsgcmVkb1N0YWNrLnJlbW92ZUFsbCgpOyB9LFxuICAgICAgLy8gc2V0TW9kZTogZnVuY3Rpb24obmV3TW9kZSkgeyBtb2RlID0gbmV3TW9kZTsgX3JlbW92ZU1lcmdlZEFjdGlvbih1bmRvU3RhY2spOyB9LFxuICAgICAgc2V0TW9kZU9uY2U6IGZ1bmN0aW9uKCkgeyBtb2RlID0gTU9ERV9PTkNFOyBfcmVtb3ZlTWVyZ2VkQWN0aW9uKHVuZG9TdGFjayk7IH0sXG4gICAgICBzZXRNb2RlTWVyZ2U6IGZ1bmN0aW9uKCkgeyBtb2RlID0gTU9ERV9NRVJHRTsgX3JlbW92ZU1lcmdlZEFjdGlvbih1bmRvU3RhY2spOyB9LFxuICAgICAgc2V0TW9kZU5vcm1hbDogZnVuY3Rpb24oKSB7IG1vZGUgPSBNT0RFX05PUk1BTDsgX3JlbW92ZU1lcmdlZEFjdGlvbih1bmRvU3RhY2spOyB9LFxuICAgICAgc2V0TW9kZUlnbm9yZTogZnVuY3Rpb24oKSB7IG1vZGUgPSBNT0RFX0lHTk9SRTsgX3JlbW92ZU1lcmdlZEFjdGlvbih1bmRvU3RhY2spOyB9LFxuICAgICAgc2V0VW5kb0FjdGlvbk1ha2VyOiBmdW5jdGlvbihtYWtlcikgeyBtYWtlVW5kb0FjdGlvbiA9IG1ha2VyOyB9LFxuICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7IC8qIGtvLnVud2F0Y2gobW9kZWwsIHJlYWN0b3JPcHRpb25zLCBjaGFuZ2VQdXNoZXIpOyAqLyByZXMuZGlzcG9zZSgpOyB9XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gdW5kb01hbmFnZXI7XG4gIFxufSkpOyIsIi8vIEtub2Nrb3V0IEZhc3QgTWFwcGluZyB2MC4xXG4vLyBMaWNlbnNlOiBNSVQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0Ly8gTW9kdWxlIHN5c3RlbXMgbWFnaWMgZGFuY2UuXG5cblx0aWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTIG9yIE5vZGU6IGhhcmQtY29kZWQgZGVwZW5kZW5jeSBvbiBcImtub2Nrb3V0XCJcblx0XHRmYWN0b3J5KCh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpLCBleHBvcnRzKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lW1wiYW1kXCJdKSB7XG5cdFx0Ly8gQU1EIGFub255bW91cyBtb2R1bGUgd2l0aCBoYXJkLWNvZGVkIGRlcGVuZGVuY3kgb24gXCJrbm9ja291dFwiXG5cdFx0ZGVmaW5lKFtcImtub2Nrb3V0XCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gPHNjcmlwdD4gdGFnOiB1c2UgdGhlIGdsb2JhbCBga29gIG9iamVjdCwgYXR0YWNoaW5nIGEgYHdyYXBgIHByb3BlcnR5XG5cdFx0ZmFjdG9yeShrbywga28ud3JhcCA9IHt9KTtcblx0fVxufShmdW5jdGlvbiAoa28sIGV4cG9ydHMpIHtcbiAgICBcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIG1pbWljcyBrby5tYXBwaW5nXG4gICAgZXhwb3J0cy5mcm9tSlMgPSBmdW5jdGlvbihqc09iamVjdCwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKVxuICAgIHtcbiAgICAgICAgcmVzZXQoKTtcblx0cmV0dXJuIHdyYXAoanNPYmplY3QsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cyk7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBmdW5jdGlvbiB1bndyYXBzIHRoZSBvdXRlciBmb3IgYXNzaWduaW5nIHRoZSByZXN1bHQgdG8gYW4gb2JzZXJ2YWJsZVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQvaXNzdWVzLzUxN1xuICAgIGV4cG9ydHMudXBkYXRlRnJvbUpTID0gZnVuY3Rpb24ob2JzZXJ2YWJsZSwganNPYmplY3QsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cylcbiAgICB7XG4gICAgICAgIHJlc2V0KCk7XG5cdHJldHVybiBvYnNlcnZhYmxlKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUod3JhcChqc09iamVjdCwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKSkpO1xuICAgIH1cblxuICAgIGV4cG9ydHMuZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvblN0cmluZywgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKSB7XG5cdHZhciBwYXJzZWQgPSBrby51dGlscy5wYXJzZUpzb24oanNvblN0cmluZyk7XG5cdGFyZ3VtZW50c1swXSA9IHBhcnNlZDtcblx0cmV0dXJuIGV4cG9ydHMuZnJvbUpTLmFwcGx5KHRoaXMsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cyk7XG4gICAgfTtcbiAgICBcbiAgICBleHBvcnRzLnRvSlMgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuXHRyZXR1cm4gdW53cmFwKG9ic2VydmFibGUpO1xuICAgIH1cblxuICAgIGV4cG9ydHMudG9KU09OID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcblx0dmFyIHBsYWluSmF2YVNjcmlwdE9iamVjdCA9IGV4cG9ydHMudG9KUyhvYnNlcnZhYmxlKTtcblx0cmV0dXJuIGtvLnV0aWxzLnN0cmluZ2lmeUpzb24ocGxhaW5KYXZhU2NyaXB0T2JqZWN0KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHlwZU9mKHZhbHVlKSB7XG5cdHZhciBzID0gdHlwZW9mIHZhbHVlO1xuXHRpZiAocyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PSBEYXRlKVxuICAgICAgICAgICAgICAgICAgICBzID0gJ2RhdGUnO1xuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgICAgICAgICAgICAgICAgcyA9ICdhcnJheSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXHRcdHMgPSAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cdH1cblx0cmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLy8gdW53cmFwcGluZ1xuICAgIGZ1bmN0aW9uIHVud3JhcE9iamVjdChvKVxuICAgIHtcblx0dmFyIHQgPSB7fTtcblxuXHRmb3IgKHZhciBrIGluIG8pXG5cdHtcblx0ICAgIHZhciB2ID0gb1trXTtcblxuXHQgICAgaWYgKGtvLmlzQ29tcHV0ZWQodikpXG5cdFx0Y29udGludWU7XG5cblx0ICAgIHRba10gPSB1bndyYXAodik7XG5cdH1cblxuXHRyZXR1cm4gdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bndyYXBBcnJheShhKVxuICAgIHtcblx0dmFyIHIgPSBbXTtcblxuXHRpZiAoIWEgfHwgYS5sZW5ndGggPT0gMClcblx0ICAgIHJldHVybiByO1xuXHRcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7ICsraSlcblx0ICAgIHIucHVzaCh1bndyYXAoYVtpXSkpO1xuXG5cdHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVud3JhcCh2KVxuICAgIHtcblx0dmFyIGlzT2JzZXJ2YWJsZSA9IGtvLmlzT2JzZXJ2YWJsZSh2KTtcblxuXHRpZiAoaXNPYnNlcnZhYmxlKVxuXHR7XG5cdCAgICB2YXIgdmFsID0gdigpO1xuXG5cdCAgICByZXR1cm4gdW53cmFwKHZhbCk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdCAgICBpZiAodHlwZU9mKHYpID09IFwiYXJyYXlcIilcblx0ICAgIHtcblx0XHRyZXR1cm4gdW53cmFwQXJyYXkodik7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlT2YodikgPT0gXCJvYmplY3RcIilcblx0ICAgIHtcblx0XHRyZXR1cm4gdW53cmFwT2JqZWN0KHYpO1xuXHQgICAgfVxuXHQgICAgZWxzZVxuXHQgICAge1xuXHRcdHJldHVybiB2O1xuXHQgICAgfVxuXHR9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXQoKVxuICAgIHtcbiAgICAgICAgcGFyZW50cyA9IFt7b2JqOiBudWxsLCB3cmFwcGVkOiBudWxsLCBsdmw6IFwiXCJ9XTtcbiAgICB9ICAgIFxuICAgIFxuICAgIC8vIHdyYXBwaW5nXG5cbiAgICBmdW5jdGlvbiB3cmFwT2JqZWN0KG8sIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cylcbiAgICB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50c1tpXS5vYmogPT09IG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50c1tpXS53cmFwcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0dmFyIHQgPSB7fTtcblxuXHRmb3IgKHZhciBrIGluIG8pXG5cdHtcblx0ICAgIHZhciB2ID0gb1trXTtcblxuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHtvYmo6IG8sIHdyYXBwZWQ6IHQsIGx2bDogY3VycmVudEx2bCgpICsgXCIvXCIgKyBrfSk7XG5cblx0ICAgIHRba10gPSB3cmFwKHYsIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cyk7XG5cbiAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG5cdH1cblxuXHRpZiAoY29tcHV0ZWRGdW5jdGlvbnMgJiYgY29tcHV0ZWRGdW5jdGlvbnNbY3VycmVudEx2bCgpXSlcblx0ICAgIHQgPSBjb21wdXRlZEZ1bmN0aW9uc1tjdXJyZW50THZsKCldKHQpO1xuXG4gICAgICAgIGlmIChoYXNFUzVQbHVnaW4oKSlcbiAgICAgICAgICAgIGtvLnRyYWNrKHQpO1xuXG5cdGlmIChvYnNlcnZhYmxlT2JqZWN0cykgcmV0dXJuIGtvLm9ic2VydmFibGUodCk7XG5cdHJldHVybiB0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBBcnJheShhLCBjb21wdXRlZEZ1bmN0aW9ucywgb2JzZXJ2YWJsZU9iamVjdHMpXG4gICAge1xuXHR2YXIgciA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuXG5cdGlmICghYSB8fCBhLmxlbmd0aCA9PSAwKVxuXHQgICAgcmV0dXJuIHI7XG5cblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7ICsraSlcblx0ICAgIHIucHVzaCh3cmFwKGFbaV0sIGNvbXB1dGVkRnVuY3Rpb25zLCBvYnNlcnZhYmxlT2JqZWN0cykpO1xuXG5cdHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIGEgc3RhY2ssIHVzZWQgZm9yIHR3byBwdXJwb3NlczpcbiAgICAvLyAgLSBjaXJjdWxhciByZWZlcmVuY2UgY2hlY2tpbmdcbiAgICAvLyAgLSBjb21wdXRlZCBmdW5jdGlvbnNcbiAgICB2YXIgcGFyZW50cztcblxuICAgIGZ1bmN0aW9uIGN1cnJlbnRMdmwoKVxuICAgIHtcblx0cmV0dXJuIHBhcmVudHNbcGFyZW50cy5sZW5ndGgtMV0ubHZsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXAodiwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKVxuICAgIHtcblx0aWYgKHR5cGVPZih2KSA9PSBcImFycmF5XCIpXG5cdHtcblx0ICAgIHJldHVybiB3cmFwQXJyYXkodiwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlT2YodikgPT0gXCJvYmplY3RcIilcblx0e1xuXHQgICAgcmV0dXJuIHdyYXBPYmplY3QodiwgY29tcHV0ZWRGdW5jdGlvbnMsIG9ic2VydmFibGVPYmplY3RzKTtcblx0fVxuXHRlbHNlXG5cdHtcbiAgICAgICAgICAgIGlmICghaGFzRVM1UGx1Z2luKCkgJiYgdHlwZW9mIHYgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB7XG5cdCAgICAgICAgdmFyIHQgPSBrby5vYnNlcnZhYmxlKCk7XG5cdCAgICAgICAgdCh2KTtcblx0ICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuXHR9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzRVM1UGx1Z2luKClcbiAgICB7XG4gICAgICAgIHJldHVybiBrby50cmFjayAhPSBudWxsO1xuICAgIH1cbn0pKTtcbiIsImtvLnN1YnNjcmliYWJsZS5mbi53YXRjaD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10eXBlb2YgYTtyZXR1cm5cImJvb2xlYW5cIj09PWV8fFwidW5kZWZpbmVkXCI9PT1lP2tvLndhdGNoKHRoaXMse2VuYWJsZWQ6YSE9PSExfSk6XCJmdW5jdGlvblwiIT09ZXx8a28uaXNTdWJzY3JpYmFibGUoYSk/a28ud2F0Y2goYSxiLGMsZHx8dGhpcyk6a28ud2F0Y2godGhpcyxifHx7fSxhLGR8fHRoaXMpLHRoaXN9LGtvLndhdGNoPWZ1bmN0aW9uKGEsYixjLGQpe2Z1bmN0aW9uIGUoaCxpLGosayxsLG0pe2lmKGgmJjAhPT1iLmRlcHRoJiYoLTE9PT1iLmRlcHRofHxqLmxlbmd0aDwoYi5kZXB0aHx8MSkpKXtpZihiLndhdGNoZWRPbmx5JiYhaC53YXRjaGFibGUmJmghPWEpcmV0dXJuO2lmKChiLmVuYWJsZWQ9PT0hMXx8Yi5lbmFibGVkPT09ITApJiYoaC53YXRjaGFibGU9Yi5lbmFibGVkKSxoLndhdGNoYWJsZT09PSExKXJldHVybjtiLnNlYWw9PT0hMCYmKGgud2F0Y2hhYmxlPSExKTt2YXIgbj10eXBlb2YgaDtpZihcIm9iamVjdFwiPT09bnx8XCJmdW5jdGlvblwiPT09bil7aWYoaC5fd2F0Y2hlcj09PWQpcmV0dXJuO2lmKGIuaGlkZSYma28udXRpbHMuYXJyYXlJbmRleE9mKGIuaGlkZSxoKT4tMSlyZXR1cm47dmFyIG89W10uY29uY2F0KGosaSYmaSE9PWE/aTpbXSk7aWYoXCJmdW5jdGlvblwiIT09bil7aWYoXCJbb2JqZWN0IE9iamVjdF1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChoKSlrby51dGlscy5vYmplY3RGb3JFYWNoKGgsZnVuY3Rpb24oYSxjKXtpZihjPWIuZ2V0dGVyP2IuZ2V0dGVyLmNhbGwoZCxvLGgsYSk6Yyl7aWYoYi53cmFwKXt2YXIgZj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYyk7XCJbb2JqZWN0IEZ1bmN0aW9uXVwiIT09ZiYmXCJbb2JqZWN0IE9iamVjdF1cIiE9PWYmJihiLmJlZm9yZVdyYXAmJmIuYmVmb3JlV3JhcC5jYWxsKGQsbyxoLGMpPT09ITF8fChjPWhbYV09XCJbb2JqZWN0IEFycmF5XVwiPT09Zj9rby5vYnNlcnZhYmxlQXJyYXkoYyk6a28ub2JzZXJ2YWJsZShjKSkpfWIudW5sb29wJiYoYy5fd2F0Y2hlcj1rP3ZvaWQgMDpkKTt2YXIgZz1lKGMsbD9udWxsOmgsbyxrLG51bGwsYSk7Yi50YWdGaWVsZHMmJnZvaWQgMD09PWMuX2ZpZWxkTmFtZSYmKGd8fFwicGFyZW50c09ubHlcIiE9PWIudGFnRmllbGRzJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjfHxcIm9iamVjdFwiPT10eXBlb2YgYykmJihjLl9maWVsZE5hbWU9YSl9fSk7ZWxzZSBpZihiLmhpZGVBcnJheXMhPT0hMClmb3IodmFyIHA9MDtwPGgubGVuZ3RoO3ArKyllKGhbcF0sbD9udWxsOmgsbyxrKTtyZXR1cm4hMH1pZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBoLm5vdGlmeVN1YnNjcmliZXJzJiZjKXtpZihiLmVuYWJsZWQ9PT0hMCYmaC53YXRjaGFibGU9PT0hMSlyZXR1cm47aWYoa3x8IWIuYmVmb3JlV2F0Y2h8fGIuYmVmb3JlV2F0Y2guY2FsbChkLG8saCxtKSE9PSExKXt2YXIgcT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBoLnBvcDtpZihrP2YoaCk6ZyhoLHEsbyxsKSxxKXJldHVybiBlKGgoKSxsP251bGw6aCxvLGssITApLCEwO2lmKGIuaGlkZVdyYXBwZWRWYWx1ZXMhPT0hMClyZXR1cm4gZShoKCksbD9udWxsOmgsbyxrLCEwKX19fX19ZnVuY3Rpb24gZihhKXt2YXIgYz1hW2hdO2lmKCFjKXRocm93XCJTdWJzY3JpcHRpb25zIGZpZWxkICguXCIraCtcIikgbm90IGRlZmluZWQgZm9yIG9ic2VydmFibGUgY2hpbGQgXCIrKGEuX2ZpZWxkTmFtZXx8XCJcIik7aWYoYy5jaGFuZ2UpZm9yKHZhciBlPWMuY2hhbmdlLmxlbmd0aC0xO2U+PTA7ZS0tKWMuY2hhbmdlW2VdLl93YXRjaGVyPT09ZCYmYy5jaGFuZ2VbZV0uZGlzcG9zZSgpO2lmKGMuYmVmb3JlQ2hhbmdlJiYoYi5tdXRhYmxlfHxiLm9sZFZhbHVlcz4wKSlmb3IodmFyIGU9Yy5iZWZvcmVDaGFuZ2UubGVuZ3RoLTE7ZT49MDtlLS0pYy5iZWZvcmVDaGFuZ2VbZV0uX3dhdGNoZXI9PT1kJiZjLmJlZm9yZUNoYW5nZVtlXS5kaXNwb3NlKCk7aWYoYy5hcnJheUNoYW5nZSlmb3IodmFyIGU9Yy5hcnJheUNoYW5nZS5sZW5ndGgtMTtlPj0wO2UtLSljLmFycmF5Q2hhbmdlW2VdLl93YXRjaGVyPT09ZCYmYy5hcnJheUNoYW5nZVtlXS5kaXNwb3NlKCl9ZnVuY3Rpb24gZyhhLGYsZyxoKXtmP2Euc3Vic2NyaWJlKGZ1bmN0aW9uKGIpe2tvLnV0aWxzLmFycmF5Rm9yRWFjaChiLGZ1bmN0aW9uKGIpe3ZhciBmPWMuY2FsbChkLGcsYSxiKTt2b2lkIDAhPT1mJiZkKGYpLGIubW92ZWR8fHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKGIudmFsdWUsaD9udWxsOmEsZyxcImRlbGV0ZWRcIj09PWIuc3RhdHVzKX0sMCl9KX0sdm9pZCAwLFwiYXJyYXlDaGFuZ2VcIikuX3dhdGNoZXI9ZDooYS5zdWJzY3JpYmUoZnVuY3Rpb24oKXtpZihhLndhdGNoYWJsZSE9PSExKXt2YXIgZj1jLmNhbGwoZCxnLGEpO3ZvaWQgMCE9PWYmJmQoZiksYi5tdXRhYmxlJiZcIm9iamVjdFwiPT10eXBlb2YgYSgpJiZlKGEoKSxoP251bGw6YSxnKX19LG51bGwsXCJjaGFuZ2VcIikuX3dhdGNoZXI9ZCwoYi5vbGRWYWx1ZXM+MHx8Yi5tdXRhYmxlKSYmKGEuc3Vic2NyaWJlKGZ1bmN0aW9uKGMpe2lmKGIub2xkVmFsdWVzPjApe3ZhciBkPWEub2xkVmFsdWVzP2Eub2xkVmFsdWVzOmEub2xkVmFsdWVzPVtdO2ZvcihkLnVuc2hpZnQoYyk7ZC5sZW5ndGg+Yi5vbGRWYWx1ZXM7KWQucG9wKCl9Yi5tdXRhYmxlJiZcIm9iamVjdFwiPT10eXBlb2YgYyYmZShjLGg/bnVsbDphLGcsITEsITApfSxudWxsLFwiYmVmb3JlQ2hhbmdlXCIpLl93YXRjaGVyPWQpKX1cImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiYoZD1kfHxjLGM9YixiPXt9KSxkPWR8fHRoaXM7dmFyIGg7c3dpdGNoKGtvLkRFQlVHfHxrby52ZXJzaW9uKXtjYXNlITA6aD1cIl9zdWJzY3JpcHRpb25zXCI7YnJlYWs7Y2FzZVwiMy4wLjBcIjpoPVwiRlwiO2JyZWFrO2Nhc2VcIjMuMS4wXCI6aD1cIkhcIjticmVhaztjYXNlXCIzLjIuMFwiOmg9XCJNXCI7YnJlYWs7Y2FzZVwiMy4zLjBcIjpoPVwiR1wiO2Nhc2VcIjMuNC4wXCI6aD1cIktcIjticmVhaztkZWZhdWx0OnRocm93XCJVbnN1cHBvcnRlZCBLbm9ja291dCB2ZXJzaW9uLiBPbmx5IHYzLjAuMCB0byB2My40LjAgYXJlIHN1cHBvcnRlZCB3aGVuIG1pbmlmaWVkLiBDdXJyZW50IHZlcnNpb24gaXMgXCIra28udmVyc2lvbn1yZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiBhfHxrby5pc1N1YnNjcmliYWJsZShhKT8oZShhLG51bGwsW10pLHtkaXNwb3NlOmZ1bmN0aW9uKCl7ZShhLG51bGwsW10sITApfX0pOmtvLmNvbXB1dGVkKGEsYyxiKX07d2luZG93LmZvbyA9IFwiMS4zLjZcIjsiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcblxuZnVuY3Rpb24gZGVidWcobGFiZWwpIHtcbiAgcmV0dXJuIF9kZWJ1Zy5iaW5kKG51bGwsIGxhYmVsKTtcbn1cblxuZnVuY3Rpb24gX2RlYnVnKGxhYmVsKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICBhcmdzLnVuc2hpZnQoJ1snICsgbGFiZWwgKyAnXScpO1xuICBwcm9jZXNzLnN0ZGVyci53cml0ZShhcmdzLmpvaW4oJyAnKSArICdcXG4nKTtcbn0iLCJ2YXIgREVCVUcgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHByaW50IGRlYnVnZ2luZyBpbmZvLlxudmFyIFRJTUVSID0gZmFsc2U7IC8vIGB0cnVlYCB0byB0aW1lIGNhbGxzIHRvIGBsZXgoKWAgYW5kIHByaW50IHRoZSByZXN1bHRzLlxuXG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJykoJ2xleCcpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBsZXg7XG5cbi8qKlxuICogQ29udmVydCBhIENTUyBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBsZXhpY2FsIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzIENTU1xuICogQHJldHVybnMge0FycmF5fSBsZXhpY2FsIHRva2Vuc1xuICovXG5mdW5jdGlvbiBsZXgoY3NzKSB7XG4gIHZhciBzdGFydDsgLy8gRGVidWcgdGltZXIgc3RhcnQuXG5cbiAgdmFyIGJ1ZmZlciA9ICcnOyAgICAgIC8vIENoYXJhY3RlciBhY2N1bXVsYXRvclxuICB2YXIgY2g7ICAgICAgICAgICAgICAgLy8gQ3VycmVudCBjaGFyYWN0ZXJcbiAgdmFyIGNvbHVtbiA9IDA7ICAgICAgIC8vIEN1cnJlbnQgc291cmNlIGNvbHVtbiBudW1iZXJcbiAgdmFyIGN1cnNvciA9IC0xOyAgICAgIC8vIEN1cnJlbnQgc291cmNlIGN1cnNvciBwb3NpdGlvblxuICB2YXIgZGVwdGggPSAwOyAgICAgICAgLy8gQ3VycmVudCBuZXN0aW5nIGRlcHRoXG4gIHZhciBsaW5lID0gMTsgICAgICAgICAvLyBDdXJyZW50IHNvdXJjZSBsaW5lIG51bWJlclxuICB2YXIgc3RhdGUgPSAnYmVmb3JlLXNlbGVjdG9yJzsgLy8gQ3VycmVudCBzdGF0ZVxuICB2YXIgc3RhY2sgPSBbc3RhdGVdOyAgLy8gU3RhdGUgc3RhY2tcbiAgdmFyIHRva2VuID0ge307ICAgICAgIC8vIEN1cnJlbnQgdG9rZW5cbiAgdmFyIHRva2VucyA9IFtdOyAgICAgIC8vIFRva2VuIGFjY3VtdWxhdG9yXG5cbiAgLy8gU3VwcG9ydGVkIEAtcnVsZXMsIGluIHJvdWdobHkgZGVzY2VuZGluZyBvcmRlciBvZiB1c2FnZSBwcm9iYWJpbGl0eS5cbiAgdmFyIGF0UnVsZXMgPSBbXG4gICAgJ21lZGlhJyxcbiAgICAna2V5ZnJhbWVzJyxcbiAgICB7IG5hbWU6ICctd2Via2l0LWtleWZyYW1lcycsIHR5cGU6ICdrZXlmcmFtZXMnLCBwcmVmaXg6ICctd2Via2l0LScgfSxcbiAgICB7IG5hbWU6ICctbW96LWtleWZyYW1lcycsIHR5cGU6ICdrZXlmcmFtZXMnLCBwcmVmaXg6ICctbW96LScgfSxcbiAgICB7IG5hbWU6ICctbXMta2V5ZnJhbWVzJywgdHlwZTogJ2tleWZyYW1lcycsIHByZWZpeDogJy1tcy0nIH0sXG4gICAgeyBuYW1lOiAnLW8ta2V5ZnJhbWVzJywgdHlwZTogJ2tleWZyYW1lcycsIHByZWZpeDogJy1vLScgfSxcbiAgICAnZm9udC1mYWNlJyxcbiAgICB7IG5hbWU6ICdpbXBvcnQnLCBzdGF0ZTogJ2JlZm9yZS1hdC12YWx1ZScgfSxcbiAgICB7IG5hbWU6ICdjaGFyc2V0Jywgc3RhdGU6ICdiZWZvcmUtYXQtdmFsdWUnIH0sXG4gICAgJ3N1cHBvcnRzJyxcbiAgICAndmlld3BvcnQnLFxuICAgIHsgbmFtZTogJ25hbWVzcGFjZScsIHN0YXRlOiAnYmVmb3JlLWF0LXZhbHVlJyB9LFxuICAgICdkb2N1bWVudCcsXG4gICAgeyBuYW1lOiAnLW1vei1kb2N1bWVudCcsIHR5cGU6ICdkb2N1bWVudCcsIHByZWZpeDogJy1tb3otJyB9LFxuICAgICdwYWdlJ1xuICBdO1xuXG4gIC8vIC0tIEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQWR2YW5jZSB0aGUgY2hhcmFjdGVyIGN1cnNvciBhbmQgcmV0dXJuIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIG5leHQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q2goKSB7XG4gICAgc2tpcCgpO1xuICAgIHJldHVybiBjc3NbY3Vyc29yXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0YXRlIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgc3RhY2suXG4gICAqIFRoZSBzdGFjayBpcyBMSUZPIHNvIGluZGV4aW5nIGlzIGZyb20gdGhlIHJpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4PTBdIEluZGV4IHRvIHJldHVybi5cbiAgICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMSAtIGluZGV4XSA6IHN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgYWhlYWQgZm9yIGEgc3RyaW5nIGJlZ2lubmluZyBmcm9tIHRoZSBuZXh0IHBvc2l0aW9uLiBUaGUgc3RyaW5nXG4gICAqIGJlaW5nIGxvb2tlZCBmb3IgbXVzdCBzdGFydCBhdCB0aGUgbmV4dCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGxvb2sgZm9yLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgc3RyaW5nIHdhcyBmb3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzTmV4dFN0cmluZyhzdHIpIHtcbiAgICB2YXIgc3RhcnQgPSBjdXJzb3IgKyAxO1xuICAgIHJldHVybiAoc3RyID09PSBjc3Muc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgc3RyLmxlbmd0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIGEgc3Vic3RyaW5nIGJlZ2lubmluZyBmcm9tIHRoZSBuZXh0XG4gICAqIHBvc2l0aW9uLiBUaGUgc3RyaW5nIGJlaW5nIGxvb2tlZCBmb3IgbWF5IGJlZ2luIGFueXdoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJzdHJpbmcgdG8gbG9vayBmb3IuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ8ZmFsc2V9IFRoZSBwb3NpdGlvbiwgb3IgYGZhbHNlYCBpZiBub3QgZm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kKHN0cikge1xuICAgIHZhciBwb3MgPSBjc3Muc2xpY2UoY3Vyc29yKS5pbmRleE9mKHN0cik7XG5cbiAgICByZXR1cm4gcG9zID4gMCA/IHBvcyA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY2hhcmFjdGVyIGlzIG5leHQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjaCBDaGFyYWN0ZXIuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgbmV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzTmV4dENoYXIoY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IHBlZWsoMSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGdpdmVuIGN1cnNvciBvZmZzZXQuIFRoZSBvZmZzZXQgaXMgcmVsYXRpdmVcbiAgICogdG8gdGhlIGN1cnNvciwgc28gbmVnYXRpdmUgdmFsdWVzIG1vdmUgYmFja3dhcmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0xXSBDdXJzb3Igb2Zmc2V0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBwZWVrKG9mZnNldCkge1xuICAgIHJldHVybiBjc3NbY3Vyc29yICsgKG9mZnNldCB8fCAxKV07XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjdXJyZW50IHN0YXRlIGZyb20gdGhlIHN0YWNrIGFuZCBzZXQgdGhlIG5ldyBjdXJyZW50IHN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVtb3ZlZCBzdGF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgIHZhciByZW1vdmVkID0gc3RhY2sucG9wKCk7XG4gICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblxuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBzdGF0ZSBhbmQgYWRkIGl0IHRvIHRoZSBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1N0YXRlIFRoZSBuZXcgc3RhdGUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBuZXcgc3RhY2sgbGVuZ3RoLlxuICAgKi9cbiAgZnVuY3Rpb24gcHVzaFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBzdGFjay5wdXNoKHN0YXRlKTtcblxuICAgIHJldHVybiBzdGFjay5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgY3VycmVudCBzdGF0ZSB3aXRoIGEgbmV3IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3U3RhdGUgVGhlIG5ldyBzdGF0ZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlcGxhY2VkIHN0YXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKG5ld1N0YXRlKSB7XG4gICAgdmFyIHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9IHN0YXRlID0gbmV3U3RhdGU7XG5cbiAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBjaGFyYWN0ZXIgY3Vyc29yLiBQb3NpdGl2ZSBudW1iZXJzIG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkLlxuICAgKiBOZWdhdGl2ZSBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkIVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW249MV0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2tpcC5cbiAgICovXG4gIGZ1bmN0aW9uIHNraXAobikge1xuICAgIGlmICgobiB8fCAxKSA9PSAxKSB7XG4gICAgICBpZiAoY3NzW2N1cnNvcl0gPT0gJ1xcbicpIHtcbiAgICAgICAgbGluZSsrO1xuICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uKys7XG4gICAgICB9XG4gICAgICBjdXJzb3IrKztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBTdHIgPSBjc3Muc2xpY2UoY3Vyc29yLCBjdXJzb3IgKyBuKS5zcGxpdCgnXFxuJyk7XG4gICAgICBpZiAoc2tpcFN0ci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxpbmUgKz0gc2tpcFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgfVxuICAgICAgY29sdW1uICs9IHNraXBTdHJbc2tpcFN0ci5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICBjdXJzb3IgPSBjdXJzb3IgKyBuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGN1cnJlbnQgdG9rZW4gdG8gdGhlIHBpbGUgYW5kIHJlc2V0IHRoZSBidWZmZXIuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRUb2tlbigpIHtcbiAgICB0b2tlbi5lbmQgPSB7XG4gICAgICBsaW5lOiBsaW5lLFxuICAgICAgY29sOiBjb2x1bW5cbiAgICB9O1xuXG4gICAgREVCVUcgJiYgZGVidWcoJ2FkZFRva2VuOicsIEpTT04uc3RyaW5naWZ5KHRva2VuLCBudWxsLCAyKSk7XG5cbiAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICBidWZmZXIgPSAnJztcbiAgICB0b2tlbiA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVG9rZW4gdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVUb2tlbih0eXBlKSB7XG4gICAgdG9rZW4gPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgY29sIDogY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIC0tIE1haW4gTG9vcCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKlxuICBUaGUgbWFpbiBsb29wIGlzIGEgc3RhdGUgbWFjaGluZSB0aGF0IHJlYWRzIGluIG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lLFxuICBhbmQgZGV0ZXJtaW5lcyB3aGF0IHRvIGRvIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBjaGFyYWN0ZXIuXG4gIFRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzZXJpZXMgb2YgbmVzdGVkIGBzd2l0Y2hgIHN0YXRlbWVudHMgYW5kIHRoZVxuICBjYXNlIG9yZGVycyBoYXZlIGJlZW4gbWlsZGx5IG9wdGltaXplZCBiYXNlZCBvbiByb3VnaCBwcm9iYWJpbGl0aWVzXG4gIGNhbGN1bGF0ZWQgYnkgcHJvY2Vzc2luZyBhIHNtYWxsIHNhbXBsZSBvZiByZWFsLXdvcmxkIENTUy5cblxuICBGdXJ0aGVyIG9wdGltaXphdGlvbiAoc3VjaCBhcyBhIGRpc3BhdGNoIHRhYmxlKSBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5XG4gIHNpbmNlIHRoZSB0b3RhbCBudW1iZXIgb2YgY2FzZXMgaXMgdmVyeSBsb3cuXG4gICovXG5cbiAgVElNRVIgJiYgKHN0YXJ0ID0gRGF0ZS5ub3coKSk7XG5cbiAgd2hpbGUgKGNoID0gZ2V0Q2goKSkge1xuICAgIERFQlVHICYmIGRlYnVnKGNoLCBnZXRTdGF0ZSgpKTtcblxuICAgIC8vIGNvbHVtbiArPSAxO1xuXG4gICAgc3dpdGNoIChjaCkge1xuICAgIC8vIFNwYWNlXG4gICAgY2FzZSAnICc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgIGNhc2UgJ3ZhbHVlLXBhcmVuJzpcbiAgICAgIGNhc2UgJ2F0LWdyb3VwJzpcbiAgICAgIGNhc2UgJ2F0LXZhbHVlJzpcbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XG4gICAgICBjYXNlICdzaW5nbGUtc3RyaW5nJzpcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gTmV3bGluZSBvciB0YWJcbiAgICBjYXNlICdcXG4nOlxuICAgIGNhc2UgJ1xcdCc6XG4gICAgY2FzZSAnXFxyJzpcbiAgICBjYXNlICdcXGYnOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICBjYXNlICd2YWx1ZS1wYXJlbic6XG4gICAgICBjYXNlICdhdC1ncm91cCc6XG4gICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XG4gICAgICBjYXNlICdzZWxlY3Rvcic6XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2F0LXZhbHVlJzpcbiAgICAgICAgLy8gVG9rZW5pemUgYW4gQC1ydWxlIGlmIGEgc2VtaS1jb2xvbiB3YXMgb21pdHRlZC5cbiAgICAgICAgaWYgKCdcXG4nID09PSBjaCkge1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gYnVmZmVyLnRyaW0oKTtcbiAgICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICAgIHBvcFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmICgnXFxuJyA9PT0gY2gpIHtcbiAgICAgIC8vICAgY29sdW1uID0gMDtcbiAgICAgIC8vICAgbGluZSArPSAxO1xuICAgICAgLy8gfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc6JzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgIHRva2VuLm5hbWUgPSBidWZmZXIudHJpbSgpO1xuICAgICAgICBidWZmZXIgPSAnJztcblxuICAgICAgICByZXBsYWNlU3RhdGUoJ2JlZm9yZS12YWx1ZScpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLXNlbGVjdG9yJzpcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuXG4gICAgICAgIGluaXRpYWxpemVUb2tlbignc2VsZWN0b3InKTtcbiAgICAgICAgcHVzaFN0YXRlKCdzZWxlY3RvcicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnOyc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgLy8gVG9rZW5pemUgYSBkZWNsYXJhdGlvblxuICAgICAgICAvLyBpZiB2YWx1ZSBpcyBlbXB0eSBza2lwIHRoZSBkZWNsYXJhdGlvblxuICAgICAgICBpZiAoYnVmZmVyLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSBidWZmZXIudHJpbSgpLFxuICAgICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZVN0YXRlKCdiZWZvcmUtbmFtZScpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndmFsdWUtcGFyZW4nOlxuICAgICAgICAvLyBJbnNpZ25pZmljYW50IHNlbWktY29sb25cbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXQtdmFsdWUnOlxuICAgICAgICAvLyBUb2tlbml6ZSBhbiBALXJ1bGVcbiAgICAgICAgdG9rZW4udmFsdWUgPSBidWZmZXIudHJpbSgpO1xuICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICBwb3BTdGF0ZSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLW5hbWUnOlxuICAgICAgICAvLyBFeHRyYW5lb3VzIHNlbWktY29sb25cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3snOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICdzZWxlY3Rvcic6XG4gICAgICAgIC8vIElmIHRoZSBzZXF1ZW5jZSBpcyBgXFx7YCB0aGVuIGFzc3VtZSB0aGF0IHRoZSBicmFjZSBzaG91bGQgYmUgZXNjYXBlZC5cbiAgICAgICAgaWYgKHBlZWsoLTEpID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG9rZW5pemUgYSBzZWxlY3RvclxuICAgICAgICB0b2tlbi50ZXh0ID0gYnVmZmVyLnRyaW0oKTtcbiAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgcmVwbGFjZVN0YXRlKCdiZWZvcmUtbmFtZScpO1xuICAgICAgICBkZXB0aCA9IGRlcHRoICsgMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2F0LWdyb3VwJzpcbiAgICAgICAgLy8gVG9rZW5pemUgYW4gQC1ncm91cFxuICAgICAgICB0b2tlbi5uYW1lID0gYnVmZmVyLnRyaW0oKTtcblxuICAgICAgICAvLyBYWFg6IEAtcnVsZXMgYXJlIHN0YXJ0aW5nIHRvIGdldCBoYWlyeVxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICAgICAgY2FzZSAndmlld3BvcnQnIDpcbiAgICAgICAgY2FzZSAncGFnZScgICAgIDpcbiAgICAgICAgICBwdXNoU3RhdGUoJ2JlZm9yZS1uYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoU3RhdGUoJ2JlZm9yZS1zZWxlY3RvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgZGVwdGggPSBkZXB0aCArIDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICduYW1lJzpcbiAgICAgIGNhc2UgJ2F0LXJ1bGUnOlxuICAgICAgICAvLyBUb2tlbml6ZSBhIGRlY2xhcmF0aW9uIG9yIGFuIEAtcnVsZVxuICAgICAgICB0b2tlbi5uYW1lID0gYnVmZmVyLnRyaW0oKTtcbiAgICAgICAgYWRkVG9rZW4oKTtcbiAgICAgICAgcHVzaFN0YXRlKCdiZWZvcmUtbmFtZScpO1xuICAgICAgICBkZXB0aCA9IGRlcHRoICsgMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgY2FzZSAnZG91YmxlLXN0cmluZyc6XG4gICAgICBjYXNlICdzaW5nbGUtc3RyaW5nJzpcbiAgICAgICAgLy8gSWdub3JlIGJyYWNlcyBpbiBjb21tZW50cyBhbmQgc3RyaW5nc1xuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ30nOlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICdiZWZvcmUtbmFtZSc6XG4gICAgICBjYXNlICduYW1lJzpcbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIC8vIElmIHRoZSBidWZmZXIgY29udGFpbnMgYW55dGhpbmcsIGl0IGlzIGEgdmFsdWVcbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gYnVmZmVyLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHRva2VuIGhhcyBhIG5hbWUgYW5kIGEgdmFsdWUgaXQgc2hvdWxkIGJlIHRva2VuaXplZC5cbiAgICAgICAgaWYgKHRva2VuLm5hbWUgJiYgdG9rZW4udmFsdWUpIHtcbiAgICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGVhdmUgdGhlIGJsb2NrXG4gICAgICAgIGluaXRpYWxpemVUb2tlbignZW5kJyk7XG4gICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgIHBvcFN0YXRlKCk7XG5cbiAgICAgICAgLy8gV2UgbWlnaHQgbmVlZCB0byBsZWF2ZSBhZ2Fpbi5cbiAgICAgICAgLy8gWFhYOiBXaGF0IGFib3V0IDMgbGV2ZWxzIGRlZXA/XG4gICAgICAgIGlmICgnYXQtZ3JvdXAnID09PSBnZXRTdGF0ZSgpKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdhdC1ncm91cC1lbmQnKTtcbiAgICAgICAgICBhZGRUb2tlbigpO1xuICAgICAgICAgIHBvcFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgICAgICBkZXB0aCA9IGRlcHRoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhdC1ncm91cCc6XG4gICAgICBjYXNlICdiZWZvcmUtc2VsZWN0b3InOlxuICAgICAgY2FzZSAnc2VsZWN0b3InOlxuICAgICAgICAvLyBJZiB0aGUgc2VxdWVuY2UgaXMgYFxcfWAgdGhlbiBhc3N1bWUgdGhhdCB0aGUgYnJhY2Ugc2hvdWxkIGJlIGVzY2FwZWQuXG4gICAgICAgIGlmIChwZWVrKC0xKSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgICAgICAvLyBMZWF2ZSBibG9jayBpZiBpbiBhbiBhdC1ncm91cFxuICAgICAgICAgIGlmICgnYXQtZ3JvdXAnID09PSBnZXRTdGF0ZSgxKSkge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdhdC1ncm91cC1lbmQnKTtcbiAgICAgICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgIHBvcFN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwdGggPiAwKSB7XG4gICAgICAgICAgZGVwdGggPSBkZXB0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2RvdWJsZS1zdHJpbmcnOlxuICAgICAgY2FzZSAnc2luZ2xlLXN0cmluZyc6XG4gICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgLy8gSWdub3JlIGJyYWNlcyBpbiBjb21tZW50cyBhbmQgc3RyaW5ncy5cbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICAvLyBTdHJpbmdzXG4gICAgY2FzZSAnXCInOlxuICAgIGNhc2UgXCInXCI6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ2RvdWJsZS1zdHJpbmcnOlxuICAgICAgICBpZiAoJ1wiJyA9PT0gY2ggJiYgJ1xcXFwnICE9PSBwZWVrKC0xKSkge1xuICAgICAgICAgIHBvcFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgICBpZiAoXCInXCIgPT09IGNoICYmICdcXFxcJyAhPT0gcGVlaygtMSkpIHtcbiAgICAgICAgICBwb3BTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtYXQtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ2F0LXZhbHVlJyk7XG4gICAgICAgIHB1c2hTdGF0ZSgnXCInID09PSBjaCA/ICdkb3VibGUtc3RyaW5nJyA6ICdzaW5nbGUtc3RyaW5nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiZWZvcmUtdmFsdWUnOlxuICAgICAgICByZXBsYWNlU3RhdGUoJ3ZhbHVlJyk7XG4gICAgICAgIHB1c2hTdGF0ZSgnXCInID09PSBjaCA/ICdkb3VibGUtc3RyaW5nJyA6ICdzaW5nbGUtc3RyaW5nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgLy8gSWdub3JlIHN0cmluZ3Mgd2l0aGluIGNvbW1lbnRzLlxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKCdcXFxcJyAhPT0gcGVlaygtMSkpIHtcbiAgICAgICAgICBwdXNoU3RhdGUoJ1wiJyA9PT0gY2ggPyAnZG91YmxlLXN0cmluZycgOiAnc2luZ2xlLXN0cmluZycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gQ29tbWVudHNcbiAgICBjYXNlICcvJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlLXZhbHVlJzpcbiAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcbiAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICBpZiAoaXNOZXh0Q2hhcignKicpKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGNvbW1lbnRzIGluIHNlbGVjdG9ycywgcHJvcGVydGllcyBhbmQgdmFsdWVzLiBUaGV5IGFyZVxuICAgICAgICAgIC8vIGRpZmZpY3VsdCB0byByZXByZXNlbnQgaW4gdGhlIEFTVC5cbiAgICAgICAgICB2YXIgcG9zID0gZmluZCgnKi8nKTtcblxuICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIHNraXAocG9zICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGlzTmV4dENoYXIoJyonKSkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbW1lbnQgdG9rZW5cbiAgICAgICAgICBpbml0aWFsaXplVG9rZW4oJ2NvbW1lbnQnKTtcbiAgICAgICAgICBwdXNoU3RhdGUoJ2NvbW1lbnQnKTtcbiAgICAgICAgICBza2lwKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICAvLyBDb21tZW50IGVuZCBvciB1bml2ZXJzYWwgc2VsZWN0b3JcbiAgICBjYXNlICcqJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgIGlmIChpc05leHRDaGFyKCcvJykpIHtcbiAgICAgICAgICAvLyBUb2tlbml6ZSBhIGNvbW1lbnRcbiAgICAgICAgICB0b2tlbi50ZXh0ID0gYnVmZmVyOyAvLyBEb24ndCB0cmltKCkhXG4gICAgICAgICAgc2tpcCgpO1xuICAgICAgICAgIGFkZFRva2VuKCk7XG4gICAgICAgICAgcG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS1zZWxlY3Rvcic6XG4gICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdzZWxlY3RvcicpO1xuICAgICAgICBwdXNoU3RhdGUoJ3NlbGVjdG9yJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIC8vIEAtcnVsZXNcbiAgICBjYXNlICdAJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICBjYXNlICdkb3VibGUtc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3NpbmdsZS1zdHJpbmcnOlxuICAgICAgICBidWZmZXIgKz0gY2g7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHN1cHBvcnRlZCBALXJ1bGVzIGFuZCBhdHRlbXB0IHRvIHRva2VuaXplIG9uZS5cbiAgICAgICAgdmFyIHRva2VuaXplZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgdmFyIHJ1bGU7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGF0UnVsZXMubGVuZ3RoOyAhdG9rZW5pemVkICYmIGogPCBsZW47ICsraikge1xuICAgICAgICAgIHJ1bGUgPSBhdFJ1bGVzW2pdO1xuICAgICAgICAgIG5hbWUgPSBydWxlLm5hbWUgfHwgcnVsZTtcblxuICAgICAgICAgIGlmICghaXNOZXh0U3RyaW5nKG5hbWUpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB0b2tlbml6ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaW5pdGlhbGl6ZVRva2VuKG5hbWUpO1xuICAgICAgICAgIHB1c2hTdGF0ZShydWxlLnN0YXRlIHx8ICdhdC1ncm91cCcpO1xuICAgICAgICAgIHNraXAobmFtZS5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKHJ1bGUucHJlZml4KSB7XG4gICAgICAgICAgICB0b2tlbi5wcmVmaXggPSBydWxlLnByZWZpeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocnVsZS50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gcnVsZS50eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9rZW5pemVkKSB7XG4gICAgICAgICAgLy8gS2VlcCBvbiB0cnVja2luJyBBbWVyaWNhIVxuICAgICAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gUGFyZW50aGVzZXMgYXJlIHRyYWNrZWQgdG8gZGlzYW1iaWd1YXRlIHNlbWktY29sb25zLCBzdWNoIGFzIHdpdGhpbiBhXG4gICAgLy8gZGF0YSBVUkkuXG4gICAgY2FzZSAnKCc6XG4gICAgICBzd2l0Y2ggKGdldFN0YXRlKCkpIHtcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgcHVzaFN0YXRlKCd2YWx1ZS1wYXJlbicpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcpJzpcbiAgICAgIHN3aXRjaCAoZ2V0U3RhdGUoKSkge1xuICAgICAgY2FzZSAndmFsdWUtcGFyZW4nOlxuICAgICAgICBwb3BTdGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYnVmZmVyICs9IGNoO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoIChnZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlICdiZWZvcmUtc2VsZWN0b3InOlxuICAgICAgICBpbml0aWFsaXplVG9rZW4oJ3NlbGVjdG9yJyk7XG4gICAgICAgIHB1c2hTdGF0ZSgnc2VsZWN0b3InKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS1uYW1lJzpcbiAgICAgICAgaW5pdGlhbGl6ZVRva2VuKCdwcm9wZXJ0eScpO1xuICAgICAgICByZXBsYWNlU3RhdGUoJ25hbWUnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS12YWx1ZSc6XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgndmFsdWUnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JlZm9yZS1hdC12YWx1ZSc6XG4gICAgICAgIHJlcGxhY2VTdGF0ZSgnYXQtdmFsdWUnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlciArPSBjaDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIFRJTUVSICYmIGRlYnVnKCdyYW4gaW4nLCAoRGF0ZS5ub3coKSAtIHN0YXJ0KSArICdtcycpO1xuXG4gIHJldHVybiB0b2tlbnM7XG59XG4iLCJ2YXIgREVCVUcgPSBmYWxzZTsgLy8gYHRydWVgIHRvIHByaW50IGRlYnVnZ2luZyBpbmZvLlxudmFyIFRJTUVSID0gZmFsc2U7IC8vIGB0cnVlYCB0byB0aW1lIGNhbGxzIHRvIGBwYXJzZSgpYCBhbmQgcHJpbnQgdGhlIHJlc3VsdHMuXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKSgncGFyc2UnKTtcbnZhciBsZXggPSByZXF1aXJlKCcuL2xleGVyJyk7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG52YXIgX2NvbW1lbnRzOyAgIC8vIFdoZXRoZXIgY29tbWVudHMgYXJlIGFsbG93ZWQuXG52YXIgX2RlcHRoOyAgICAgIC8vIEN1cnJlbnQgYmxvY2sgbmVzdGluZyBkZXB0aC5cbnZhciBfcG9zaXRpb247ICAgLy8gV2hldGhlciB0byBpbmNsdWRlIGxpbmUvY29sdW1uIHBvc2l0aW9uLlxudmFyIF90b2tlbnM7ICAgICAvLyBBcnJheSBvZiBsZXhpY2FsIHRva2Vucy5cblxuLyoqXG4gKiBDb252ZXJ0IGEgQ1NTIHN0cmluZyBvciBhcnJheSBvZiBsZXhpY2FsIHRva2VucyBpbnRvIGEgYHN0cmluZ2lmeWAtYWJsZSBBU1QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNzcyBDU1Mgc3RyaW5nIG9yIGFycmF5IG9mIGxleGljYWwgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tbWVudHM9ZmFsc2VdIGFsbG93IGNvbW1lbnQgbm9kZXMgaW4gdGhlIEFTVFxuICogQHJldHVybnMge09iamVjdH0gYHN0cmluZ2lmeWAtYWJsZSBBU1RcbiAqL1xuZnVuY3Rpb24gcGFyc2UoY3NzLCBvcHRpb25zKSB7XG4gIHZhciBzdGFydDsgLy8gRGVidWcgdGltZXIgc3RhcnQuXG5cbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgX2NvbW1lbnRzID0gISFvcHRpb25zLmNvbW1lbnRzO1xuICBfcG9zaXRpb24gPSAhIW9wdGlvbnMucG9zaXRpb247XG5cbiAgX2RlcHRoID0gMDtcblxuICAvLyBPcGVyYXRlIG9uIGEgY29weSBvZiB0aGUgZ2l2ZW4gdG9rZW5zLCBvciB0aGUgbGV4KCknZCBDU1Mgc3RyaW5nLlxuICBfdG9rZW5zID0gQXJyYXkuaXNBcnJheShjc3MpID8gY3NzLnNsaWNlKCkgOiBsZXgoY3NzKTtcblxuICB2YXIgcnVsZTtcbiAgdmFyIHJ1bGVzID0gW107XG4gIHZhciB0b2tlbjtcblxuICBUSU1FUiAmJiAoc3RhcnQgPSBEYXRlLm5vdygpKTtcblxuICB3aGlsZSAoKHRva2VuID0gbmV4dCgpKSkge1xuICAgIHJ1bGUgPSBwYXJzZVRva2VuKHRva2VuKTtcbiAgICBydWxlICYmIHJ1bGVzLnB1c2gocnVsZSk7XG4gIH1cblxuICBUSU1FUiAmJiBkZWJ1ZygncmFuIGluJywgKERhdGUubm93KCkgLSBzdGFydCkgKyAnbXMnKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3R5bGVzaGVldFwiLFxuICAgIHN0eWxlc2hlZXQ6IHtcbiAgICAgIHJ1bGVzOiBydWxlc1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLS0gRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQnVpbGQgYW4gQVNUIG5vZGUgZnJvbSBhIGxleGljYWwgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIGxleGljYWwgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3ZlcnJpZGVdIG9iamVjdCBoYXNoIG9mIHByb3BlcnRpZXMgdGhhdCBvdmVycmlkZSB0aG9zZVxuICogICBhbHJlYWR5IGluIHRoZSB0b2tlbiwgb3IgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0b2tlbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFTVCBub2RlXG4gKi9cbmZ1bmN0aW9uIGFzdE5vZGUodG9rZW4sIG92ZXJyaWRlKSB7XG4gIG92ZXJyaWRlIHx8IChvdmVycmlkZSA9IHt9KTtcblxuICB2YXIga2V5O1xuICB2YXIga2V5cyA9IFsndHlwZScsICduYW1lJywgJ3ZhbHVlJ107XG4gIHZhciBub2RlID0ge307XG5cbiAgLy8gQXZvaWRpbmcgW10uZm9yRWFjaCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICh0b2tlbltrZXldKSB7XG4gICAgICBub2RlW2tleV0gPSBvdmVycmlkZVtrZXldIHx8IHRva2VuW2tleV07XG4gICAgfVxuICB9XG5cbiAga2V5cyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlKTtcblxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIW5vZGVba2V5XSkge1xuICAgICAgbm9kZVtrZXldID0gb3ZlcnJpZGVba2V5XTtcbiAgICB9XG4gIH1cblxuICBpZiAoX3Bvc2l0aW9uKSB7XG4gICAgbm9kZS5wb3NpdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiB0b2tlbi5zdGFydCxcbiAgICAgIGVuZDogdG9rZW4uZW5kXG4gICAgfTtcbiAgfVxuXG4gIERFQlVHICYmIGRlYnVnKCdhc3ROb2RlOicsIEpTT04uc3RyaW5naWZ5KG5vZGUsIG51bGwsIDIpKTtcblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBsZXhpY2FsIHRva2VuIGZyb20gdGhlIHN0YWNrIGFuZCByZXR1cm4gdGhlIHJlbW92ZWQgdG9rZW4uXG4gKlxuICogQHJldHVybnMge09iamVjdH0gbGV4aWNhbCB0b2tlblxuICovXG5mdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgdG9rZW4gPSBfdG9rZW5zLnNoaWZ0KCk7XG4gIERFQlVHICYmIGRlYnVnKCduZXh0OicsIEpTT04uc3RyaW5naWZ5KHRva2VuLCBudWxsLCAyKSk7XG4gIHJldHVybiB0b2tlbjtcbn1cblxuLy8gLS0gUGFyc2UqIEZ1bmN0aW9ucyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEAtZ3JvdXAgbGV4aWNhbCB0b2tlbiB0byBhbiBBU1Qgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gQC1ncm91cCBsZXhpY2FsIHRva2VuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBALWdyb3VwIEFTVCBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXRHcm91cCh0b2tlbikge1xuICBfZGVwdGggPSBfZGVwdGggKyAxO1xuXG4gIC8vIEFzIHRoZSBALWdyb3VwIHRva2VuIGlzIGFzc2VtYmxlZCwgcmVsZXZhbnQgdG9rZW4gdmFsdWVzIGFyZSBjYXB0dXJlZCBoZXJlXG4gIC8vIHRlbXBvcmFyaWx5LiBUaGV5IHdpbGwgbGF0ZXIgYmUgdXNlZCBhcyBgdG9rZW5pemUoKWAgb3ZlcnJpZGVzLlxuICB2YXIgb3ZlcnJpZGVzID0ge307XG5cbiAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gIGNhc2UgJ3ZpZXdwb3J0JyA6XG4gICAgb3ZlcnJpZGVzLmRlY2xhcmF0aW9ucyA9IHBhcnNlRGVjbGFyYXRpb25zKCk7XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAncGFnZSc6XG4gICAgb3ZlcnJpZGVzLnByZWZpeCA9IHRva2VuLnByZWZpeDtcbiAgICBvdmVycmlkZXMuZGVjbGFyYXRpb25zID0gcGFyc2VEZWNsYXJhdGlvbnMoKTtcbiAgICBicmVhaztcblxuICBkZWZhdWx0OlxuICAgIG92ZXJyaWRlcy5wcmVmaXggPSB0b2tlbi5wcmVmaXg7XG4gICAgb3ZlcnJpZGVzLnJ1bGVzID0gcGFyc2VSdWxlcygpO1xuICB9XG5cbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4sIG92ZXJyaWRlcyk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBAaW1wb3J0IGxleGljYWwgdG9rZW4gdG8gYW4gQVNUIG5vZGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIEBpbXBvcnQgbGV4aWNhbCB0b2tlblxuICogQHJldHVybnMge09iamVjdH0gQGltcG9ydCBBU1Qgbm9kZVxuICovXG5mdW5jdGlvbiBwYXJzZUF0SW1wb3J0KHRva2VuKSB7XG4gIHJldHVybiBhc3ROb2RlKHRva2VuKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEBjaGFyc2V0IHRva2VuIHRvIGFuIEFTVCBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBAY2hhcnNldCBsZXhpY2FsIHRva2VuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBAY2hhcnNldCBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2hhcnNldCh0b2tlbikge1xuICByZXR1cm4gYXN0Tm9kZSh0b2tlbik7XG59XG5cbi8qKlxuICogQ29udmVydCBhIGNvbW1lbnQgdG9rZW4gdG8gYW4gQVNUIE5vZGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuIGNvbW1lbnQgbGV4aWNhbCB0b2tlblxuICogQHJldHVybnMge09iamVjdH0gY29tbWVudCBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29tbWVudCh0b2tlbikge1xuICByZXR1cm4gYXN0Tm9kZSh0b2tlbiwge3RleHQ6IHRva2VuLnRleHR9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VOYW1lc3BhY2UodG9rZW4pIHtcbiAgcmV0dXJuIGFzdE5vZGUodG9rZW4pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBwcm9wZXJ0eSBsZXhpY2FsIHRva2VuIHRvIGEgcHJvcGVydHkgQVNUIG5vZGUuXG4gKlxuICogQHJldHVybnMge09iamVjdH0gcHJvcGVydHkgbm9kZVxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BlcnR5KHRva2VuKSB7XG4gIHJldHVybiBhc3ROb2RlKHRva2VuKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc2VsZWN0b3IgbGV4aWNhbCB0b2tlbiB0byBhIHNlbGVjdG9yIEFTVCBub2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbiBzZWxlY3RvciBsZXhpY2FsIHRva2VuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBzZWxlY3RvciBub2RlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2VsZWN0b3IodG9rZW4pIHtcbiAgZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBhc3ROb2RlKHRva2VuLCB7XG4gICAgdHlwZTogJ3J1bGUnLFxuICAgIHNlbGVjdG9yczogdG9rZW4udGV4dC5zcGxpdCgnLCcpLm1hcCh0cmltKSxcbiAgICBkZWNsYXJhdGlvbnM6IHBhcnNlRGVjbGFyYXRpb25zKHRva2VuKVxuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgbGV4aWNhbCB0b2tlbiB0byBhbiBBU1Qgbm9kZS5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH0gQVNUIG5vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VUb2tlbih0b2tlbikge1xuICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgLy8gQ2FzZXMgYXJlIGxpc3RlZCBpbiByb3VnaGx5IGRlc2NlbmRpbmcgb3JkZXIgb2YgcHJvYmFiaWxpdHkuXG4gIGNhc2UgJ3Byb3BlcnR5JzogcmV0dXJuIHBhcnNlUHJvcGVydHkodG9rZW4pO1xuXG4gIGNhc2UgJ3NlbGVjdG9yJzogcmV0dXJuIHBhcnNlU2VsZWN0b3IodG9rZW4pO1xuXG4gIGNhc2UgJ2F0LWdyb3VwLWVuZCc6IF9kZXB0aCA9IF9kZXB0aCAtIDE7IHJldHVybjtcblxuICBjYXNlICdtZWRpYScgICAgIDpcbiAgY2FzZSAna2V5ZnJhbWVzJyA6cmV0dXJuIHBhcnNlQXRHcm91cCh0b2tlbik7XG5cbiAgY2FzZSAnY29tbWVudCc6IGlmIChfY29tbWVudHMpIHsgcmV0dXJuIHBhcnNlQ29tbWVudCh0b2tlbik7IH0gYnJlYWs7XG5cbiAgY2FzZSAnY2hhcnNldCc6IHJldHVybiBwYXJzZUNoYXJzZXQodG9rZW4pO1xuICBjYXNlICdpbXBvcnQnOiByZXR1cm4gcGFyc2VBdEltcG9ydCh0b2tlbik7XG5cbiAgY2FzZSAnbmFtZXNwYWNlJzogcmV0dXJuIHBhcnNlTmFtZXNwYWNlKHRva2VuKTtcblxuICBjYXNlICdmb250LWZhY2UnOlxuICBjYXNlICdzdXBwb3J0cycgOlxuICBjYXNlICd2aWV3cG9ydCcgOlxuICBjYXNlICdkb2N1bWVudCcgOlxuICBjYXNlICdwYWdlJyAgICAgOiByZXR1cm4gcGFyc2VBdEdyb3VwKHRva2VuKTtcbiAgfVxuXG4gIERFQlVHICYmIGRlYnVnKCdwYXJzZVRva2VuOiB1bmV4cGVjdGVkIHRva2VuOicsIEpTT04uc3RyaW5naWZ5KHRva2VuKSk7XG59XG5cbi8vIC0tIFBhcnNlIEhlbHBlciBGdW5jdGlvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogSXRlcmF0aXZlbHkgcGFyc2VzIGxleGljYWwgdG9rZW5zIGZyb20gdGhlIHN0YWNrIGludG8gQVNUIG5vZGVzIHVudGlsIGFcbiAqIGNvbmRpdGlvbmFsIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgYXQgd2hpY2ggcG9pbnQgaXRlcmF0aW9uIHRlcm1pbmF0ZXNcbiAqIGFuZCBhbnkgQVNUIG5vZGVzIGNvbGxlY3RlZCBhcmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uRm5cbiAqICAgQHBhcmFtIHtPYmplY3R9IHRva2VuIHRoZSBsZXhpY2FsIHRva2VuIGJlaW5nIHBhcnNlZFxuICogICBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSB0b2tlbiBzaG91bGQgYmUgcGFyc2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICogQHJldHVybiB7QXJyYXl9IEFTVCBub2Rlc1xuICovXG5mdW5jdGlvbiBwYXJzZVRva2Vuc1doaWxlKGNvbmRpdGlvbkZuKSB7XG4gIHZhciBub2RlO1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgdmFyIHRva2VuO1xuXG4gIHdoaWxlICgodG9rZW4gPSBuZXh0KCkpICYmIChjb25kaXRpb25GbiAmJiBjb25kaXRpb25Gbih0b2tlbikpKSB7XG4gICAgbm9kZSA9IHBhcnNlVG9rZW4odG9rZW4pO1xuICAgIG5vZGUgJiYgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuXG4gIC8vIFBsYWNlIGFuIHVudXNlZCBub24tYGVuZGAgbGV4aWNhbCB0b2tlbiBiYWNrIG9udG8gdGhlIHN0YWNrLlxuICBpZiAodG9rZW4gJiYgdG9rZW4udHlwZSAhPT0gJ2VuZCcpIHtcbiAgICBfdG9rZW5zLnVuc2hpZnQodG9rZW4pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzZXJpZXMgb2YgdG9rZW5zIGludG8gYSBzZXF1ZW5jZSBvZiBkZWNsYXJhdGlvbiBBU1Qgbm9kZXMuXG4gKlxuICogQHJldHVybnMge0FycmF5fSBkZWNsYXJhdGlvbiBub2Rlc1xuICovXG5mdW5jdGlvbiBwYXJzZURlY2xhcmF0aW9ucygpIHtcbiAgcmV0dXJuIHBhcnNlVG9rZW5zV2hpbGUoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuICh0b2tlbi50eXBlID09PSAncHJvcGVydHknIHx8IHRva2VuLnR5cGUgPT09ICdjb21tZW50Jyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzZXJpZXMgb2YgdG9rZW5zIGludG8gYSBzZXF1ZW5jZSBvZiBydWxlIG5vZGVzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX0gcnVsZSBub2Rlc1xuICovXG5mdW5jdGlvbiBwYXJzZVJ1bGVzKCkge1xuICByZXR1cm4gcGFyc2VUb2tlbnNXaGlsZShmdW5jdGlvbiAoKSB7IHJldHVybiBfZGVwdGg7IH0pO1xufVxuIiwiLy8gVGlueUNvbG9yIHYxLjIuMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9UaW55Q29sb3Jcbi8vIEJyaWFuIEdyaW5zdGVhZCwgTUlUIExpY2Vuc2VcblxuKGZ1bmN0aW9uKCkge1xuXG52YXIgdHJpbUxlZnQgPSAvXltcXHMsI10rLyxcbiAgICB0cmltUmlnaHQgPSAvXFxzKyQvLFxuICAgIHRpbnlDb3VudGVyID0gMCxcbiAgICBtYXRoID0gTWF0aCxcbiAgICBtYXRoUm91bmQgPSBtYXRoLnJvdW5kLFxuICAgIG1hdGhNaW4gPSBtYXRoLm1pbixcbiAgICBtYXRoTWF4ID0gbWF0aC5tYXgsXG4gICAgbWF0aFJhbmRvbSA9IG1hdGgucmFuZG9tO1xuXG5mdW5jdGlvbiB0aW55Y29sb3IgKGNvbG9yLCBvcHRzKSB7XG5cbiAgICBjb2xvciA9IChjb2xvcikgPyBjb2xvciA6ICcnO1xuICAgIG9wdHMgPSBvcHRzIHx8IHsgfTtcblxuICAgIC8vIElmIGlucHV0IGlzIGFscmVhZHkgYSB0aW55Y29sb3IsIHJldHVybiBpdHNlbGZcbiAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiB0aW55Y29sb3IpIHtcbiAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgY2FsbCB1c2luZyBuZXcgaW5zdGVhZFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0aW55Y29sb3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGlueWNvbG9yKGNvbG9yLCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgcmdiID0gaW5wdXRUb1JHQihjb2xvcik7XG4gICAgdGhpcy5fb3JpZ2luYWxJbnB1dCA9IGNvbG9yLFxuICAgIHRoaXMuX3IgPSByZ2IucixcbiAgICB0aGlzLl9nID0gcmdiLmcsXG4gICAgdGhpcy5fYiA9IHJnYi5iLFxuICAgIHRoaXMuX2EgPSByZ2IuYSxcbiAgICB0aGlzLl9yb3VuZEEgPSBtYXRoUm91bmQoMTAwKnRoaXMuX2EpIC8gMTAwLFxuICAgIHRoaXMuX2Zvcm1hdCA9IG9wdHMuZm9ybWF0IHx8IHJnYi5mb3JtYXQ7XG4gICAgdGhpcy5fZ3JhZGllbnRUeXBlID0gb3B0cy5ncmFkaWVudFR5cGU7XG5cbiAgICAvLyBEb24ndCBsZXQgdGhlIHJhbmdlIG9mIFswLDI1NV0gY29tZSBiYWNrIGluIFswLDFdLlxuICAgIC8vIFBvdGVudGlhbGx5IGxvc2UgYSBsaXR0bGUgYml0IG9mIHByZWNpc2lvbiBoZXJlLCBidXQgd2lsbCBmaXggaXNzdWVzIHdoZXJlXG4gICAgLy8gLjUgZ2V0cyBpbnRlcnByZXRlZCBhcyBoYWxmIG9mIHRoZSB0b3RhbCwgaW5zdGVhZCBvZiBoYWxmIG9mIDFcbiAgICAvLyBJZiBpdCB3YXMgc3VwcG9zZWQgdG8gYmUgMTI4LCB0aGlzIHdhcyBhbHJlYWR5IHRha2VuIGNhcmUgb2YgYnkgYGlucHV0VG9SZ2JgXG4gICAgaWYgKHRoaXMuX3IgPCAxKSB7IHRoaXMuX3IgPSBtYXRoUm91bmQodGhpcy5fcik7IH1cbiAgICBpZiAodGhpcy5fZyA8IDEpIHsgdGhpcy5fZyA9IG1hdGhSb3VuZCh0aGlzLl9nKTsgfVxuICAgIGlmICh0aGlzLl9iIDwgMSkgeyB0aGlzLl9iID0gbWF0aFJvdW5kKHRoaXMuX2IpOyB9XG5cbiAgICB0aGlzLl9vayA9IHJnYi5vaztcbiAgICB0aGlzLl90Y19pZCA9IHRpbnlDb3VudGVyKys7XG59XG5cbnRpbnljb2xvci5wcm90b3R5cGUgPSB7XG4gICAgaXNEYXJrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnJpZ2h0bmVzcygpIDwgMTI4O1xuICAgIH0sXG4gICAgaXNMaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0RhcmsoKTtcbiAgICB9LFxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2s7XG4gICAgfSxcbiAgICBnZXRPcmlnaW5hbElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbElucHV0O1xuICAgIH0sXG4gICAgZ2V0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcbiAgICB9LFxuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfSxcbiAgICBnZXRCcmlnaHRuZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9BRVJUI2NvbG9yLWNvbnRyYXN0XG4gICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgIHJldHVybiAocmdiLnIgKiAyOTkgKyByZ2IuZyAqIDU4NyArIHJnYi5iICogMTE0KSAvIDEwMDA7XG4gICAgfSxcbiAgICBnZXRMdW1pbmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgdmFyIHJnYiA9IHRoaXMudG9SZ2IoKTtcbiAgICAgICAgdmFyIFJzUkdCLCBHc1JHQiwgQnNSR0IsIFIsIEcsIEI7XG4gICAgICAgIFJzUkdCID0gcmdiLnIvMjU1O1xuICAgICAgICBHc1JHQiA9IHJnYi5nLzI1NTtcbiAgICAgICAgQnNSR0IgPSByZ2IuYi8yNTU7XG5cbiAgICAgICAgaWYgKFJzUkdCIDw9IDAuMDM5MjgpIHtSID0gUnNSR0IgLyAxMi45Mjt9IGVsc2Uge1IgPSBNYXRoLnBvdygoKFJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEdzUkdCIDw9IDAuMDM5MjgpIHtHID0gR3NSR0IgLyAxMi45Mjt9IGVsc2Uge0cgPSBNYXRoLnBvdygoKEdzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgaWYgKEJzUkdCIDw9IDAuMDM5MjgpIHtCID0gQnNSR0IgLyAxMi45Mjt9IGVsc2Uge0IgPSBNYXRoLnBvdygoKEJzUkdCICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO31cbiAgICAgICAgcmV0dXJuICgwLjIxMjYgKiBSKSArICgwLjcxNTIgKiBHKSArICgwLjA3MjIgKiBCKTtcbiAgICB9LFxuICAgIHNldEFscGhhOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hID0gYm91bmRBbHBoYSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3JvdW5kQSA9IG1hdGhSb3VuZCgxMDAqdGhpcy5fYSkgLyAxMDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9Ic3Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHJldHVybiB7IGg6IGhzdi5oICogMzYwLCBzOiBoc3YucywgdjogaHN2LnYsIGE6IHRoaXMuX2EgfTtcbiAgICB9LFxuICAgIHRvSHN2U3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc3YuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHN2LnMgKiAxMDApLCB2ID0gbWF0aFJvdW5kKGhzdi52ICogMTAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcImhzdihcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlKVwiIDpcbiAgICAgICAgICBcImhzdmEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b0hzbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoc2wgPSByZ2JUb0hzbCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgcmV0dXJuIHsgaDogaHNsLmggKiAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9Ic2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9Ic2wodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgIHZhciBoID0gbWF0aFJvdW5kKGhzbC5oICogMzYwKSwgcyA9IG1hdGhSb3VuZChoc2wucyAqIDEwMCksIGwgPSBtYXRoUm91bmQoaHNsLmwgKiAxMDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgIFwiaHNsKFwiICArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUpXCIgOlxuICAgICAgICAgIFwiaHNsYShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUsIFwiKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICB9LFxuICAgIHRvSGV4OiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiByZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCBhbGxvdzNDaGFyKTtcbiAgICB9LFxuICAgIHRvSGV4U3RyaW5nOiBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLnRvSGV4KGFsbG93M0NoYXIpO1xuICAgIH0sXG4gICAgdG9IZXg4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYmFUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0aGlzLl9hKTtcbiAgICB9LFxuICAgIHRvSGV4OFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLnRvSGV4OCgpO1xuICAgIH0sXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRoUm91bmQodGhpcy5fciksIGc6IG1hdGhSb3VuZCh0aGlzLl9nKSwgYjogbWF0aFJvdW5kKHRoaXMuX2IpLCBhOiB0aGlzLl9hIH07XG4gICAgfSxcbiAgICB0b1JnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKHRoaXMuX3IpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2cpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXCIpXCIgOlxuICAgICAgICAgIFwicmdiYShcIiArIG1hdGhSb3VuZCh0aGlzLl9yKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9nKSArIFwiLCBcIiArIG1hdGhSb3VuZCh0aGlzLl9iKSArIFwiLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgcjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgZzogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYjogbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiVcIiwgYTogdGhpcy5fYSB9O1xuICAgIH0sXG4gICAgdG9QZXJjZW50YWdlUmdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICBcInJnYihcIiAgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9yLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9nLCAyNTUpICogMTAwKSArIFwiJSwgXCIgKyBtYXRoUm91bmQoYm91bmQwMSh0aGlzLl9iLCAyNTUpICogMTAwKSArIFwiJSlcIiA6XG4gICAgICAgICAgXCJyZ2JhKFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgfSxcbiAgICB0b05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhleE5hbWVzW3JnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRydWUpXSB8fCBmYWxzZTtcbiAgICB9LFxuICAgIHRvRmlsdGVyOiBmdW5jdGlvbihzZWNvbmRDb2xvcikge1xuICAgICAgICB2YXIgaGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0aGlzLl9hKTtcbiAgICAgICAgdmFyIHNlY29uZEhleDhTdHJpbmcgPSBoZXg4U3RyaW5nO1xuICAgICAgICB2YXIgZ3JhZGllbnRUeXBlID0gdGhpcy5fZ3JhZGllbnRUeXBlID8gXCJHcmFkaWVudFR5cGUgPSAxLCBcIiA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHNlY29uZENvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRpbnljb2xvcihzZWNvbmRDb2xvcik7XG4gICAgICAgICAgICBzZWNvbmRIZXg4U3RyaW5nID0gcy50b0hleDhTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChcIitncmFkaWVudFR5cGUrXCJzdGFydENvbG9yc3RyPVwiK2hleDhTdHJpbmcrXCIsZW5kQ29sb3JzdHI9XCIrc2Vjb25kSGV4OFN0cmluZytcIilcIjtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdFNldCA9ICEhZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5fZm9ybWF0O1xuXG4gICAgICAgIHZhciBmb3JtYXR0ZWRTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc0FscGhhID0gdGhpcy5fYSA8IDEgJiYgdGhpcy5fYSA+PSAwO1xuICAgICAgICB2YXIgbmVlZHNBbHBoYUZvcm1hdCA9ICFmb3JtYXRTZXQgJiYgaGFzQWxwaGEgJiYgKGZvcm1hdCA9PT0gXCJoZXhcIiB8fCBmb3JtYXQgPT09IFwiaGV4NlwiIHx8IGZvcm1hdCA9PT0gXCJoZXgzXCIgfHwgZm9ybWF0ID09PSBcIm5hbWVcIik7XG5cbiAgICAgICAgaWYgKG5lZWRzQWxwaGFGb3JtYXQpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgXCJ0cmFuc3BhcmVudFwiLCBhbGwgb3RoZXIgbm9uLWFscGhhIGZvcm1hdHNcbiAgICAgICAgICAgIC8vIHdpbGwgcmV0dXJuIHJnYmEgd2hlbiB0aGVyZSBpcyB0cmFuc3BhcmVuY3kuXG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIiAmJiB0aGlzLl9hID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9OYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1JnYlN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicmdiXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcInByZ2JcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1BlcmNlbnRhZ2VSZ2JTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleFwiIHx8IGZvcm1hdCA9PT0gXCJoZXg2XCIpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDNcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhleDhcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleDhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhzbFwiKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSHNsU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJoc3ZcIikge1xuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzdlN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZyB8fCB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfSxcblxuICAgIF9hcHBseU1vZGlmaWNhdGlvbjogZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gZm4uYXBwbHkobnVsbCwgW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgICAgIHRoaXMuX3IgPSBjb2xvci5fcjtcbiAgICAgICAgdGhpcy5fZyA9IGNvbG9yLl9nO1xuICAgICAgICB0aGlzLl9iID0gY29sb3IuX2I7XG4gICAgICAgIHRoaXMuc2V0QWxwaGEoY29sb3IuX2EpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGxpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24obGlnaHRlbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGJyaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGJyaWdodGVuLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZGFya2VuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGRhcmtlbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGRlc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oZGVzYXR1cmF0ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNhdHVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKHNhdHVyYXRlLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZ3JleXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGdyZXlzY2FsZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNwaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNb2RpZmljYXRpb24oc3BpbiwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgX2FwcGx5Q29tYmluYXRpb246IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICB9LFxuICAgIGFuYWxvZ291czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKGFuYWxvZ291cywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihjb21wbGVtZW50LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbW9ub2Nocm9tYXRpYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKG1vbm9jaHJvbWF0aWMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzcGxpdGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihzcGxpdGNvbXBsZW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICB0cmlhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHRyaWFkLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgdGV0cmFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24odGV0cmFkLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5cbi8vIElmIGlucHV0IGlzIGFuIG9iamVjdCwgZm9yY2UgMSBpbnRvIFwiMS4wXCIgdG8gaGFuZGxlIHJhdGlvcyBwcm9wZXJseVxuLy8gU3RyaW5nIGlucHV0IHJlcXVpcmVzIFwiMS4wXCIgYXMgaW5wdXQsIHNvIDEgd2lsbCBiZSB0cmVhdGVkIGFzIDFcbnRpbnljb2xvci5mcm9tUmF0aW8gPSBmdW5jdGlvbihjb2xvciwgb3B0cykge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgbmV3Q29sb3IgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBjb2xvcikge1xuICAgICAgICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29sb3JbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb2xvcltpXSA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3JbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IG5ld0NvbG9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IsIG9wdHMpO1xufTtcblxuLy8gR2l2ZW4gYSBzdHJpbmcgb3Igb2JqZWN0LCBjb252ZXJ0IHRoYXQgaW5wdXQgdG8gUkdCXG4vLyBQb3NzaWJsZSBzdHJpbmcgaW5wdXRzOlxuLy9cbi8vICAgICBcInJlZFwiXG4vLyAgICAgXCIjZjAwXCIgb3IgXCJmMDBcIlxuLy8gICAgIFwiI2ZmMDAwMFwiIG9yIFwiZmYwMDAwXCJcbi8vICAgICBcIiNmZjAwMDAwMFwiIG9yIFwiZmYwMDAwMDBcIlxuLy8gICAgIFwicmdiIDI1NSAwIDBcIiBvciBcInJnYiAoMjU1LCAwLCAwKVwiXG4vLyAgICAgXCJyZ2IgMS4wIDAgMFwiIG9yIFwicmdiICgxLCAwLCAwKVwiXG4vLyAgICAgXCJyZ2JhICgyNTUsIDAsIDAsIDEpXCIgb3IgXCJyZ2JhIDI1NSwgMCwgMCwgMVwiXG4vLyAgICAgXCJyZ2JhICgxLjAsIDAsIDAsIDEpXCIgb3IgXCJyZ2JhIDEuMCwgMCwgMCwgMVwiXG4vLyAgICAgXCJoc2woMCwgMTAwJSwgNTAlKVwiIG9yIFwiaHNsIDAgMTAwJSA1MCVcIlxuLy8gICAgIFwiaHNsYSgwLCAxMDAlLCA1MCUsIDEpXCIgb3IgXCJoc2xhIDAgMTAwJSA1MCUsIDFcIlxuLy8gICAgIFwiaHN2KDAsIDEwMCUsIDEwMCUpXCIgb3IgXCJoc3YgMCAxMDAlIDEwMCVcIlxuLy9cbmZ1bmN0aW9uIGlucHV0VG9SR0IoY29sb3IpIHtcblxuICAgIHZhciByZ2IgPSB7IHI6IDAsIGc6IDAsIGI6IDAgfTtcbiAgICB2YXIgYSA9IDE7XG4gICAgdmFyIG9rID0gZmFsc2U7XG4gICAgdmFyIGZvcm1hdCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbG9yID0gc3RyaW5nSW5wdXRUb09iamVjdChjb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShcInJcIikgJiYgY29sb3IuaGFzT3duUHJvcGVydHkoXCJnXCIpICYmIGNvbG9yLmhhc093blByb3BlcnR5KFwiYlwiKSkge1xuICAgICAgICAgICAgcmdiID0gcmdiVG9SZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICBmb3JtYXQgPSBTdHJpbmcoY29sb3Iucikuc3Vic3RyKC0xKSA9PT0gXCIlXCIgPyBcInByZ2JcIiA6IFwicmdiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJoXCIpICYmIGNvbG9yLmhhc093blByb3BlcnR5KFwic1wiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcInZcIikpIHtcbiAgICAgICAgICAgIGNvbG9yLnMgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnMpO1xuICAgICAgICAgICAgY29sb3IudiA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iudik7XG4gICAgICAgICAgICByZ2IgPSBoc3ZUb1JnYihjb2xvci5oLCBjb2xvci5zLCBjb2xvci52KTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiaHN2XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJoXCIpICYmIGNvbG9yLmhhc093blByb3BlcnR5KFwic1wiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcImxcIikpIHtcbiAgICAgICAgICAgIGNvbG9yLnMgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnMpO1xuICAgICAgICAgICAgY29sb3IubCA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3IubCk7XG4gICAgICAgICAgICByZ2IgPSBoc2xUb1JnYihjb2xvci5oLCBjb2xvci5zLCBjb2xvci5sKTtcbiAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiaHNsXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJhXCIpKSB7XG4gICAgICAgICAgICBhID0gY29sb3IuYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGEgPSBib3VuZEFscGhhKGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2s6IG9rLFxuICAgICAgICBmb3JtYXQ6IGNvbG9yLmZvcm1hdCB8fCBmb3JtYXQsXG4gICAgICAgIHI6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5yLCAwKSksXG4gICAgICAgIGc6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5nLCAwKSksXG4gICAgICAgIGI6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5iLCAwKSksXG4gICAgICAgIGE6IGFcbiAgICB9O1xufVxuXG5cbi8vIENvbnZlcnNpb24gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBgcmdiVG9Ic2xgLCBgcmdiVG9Ic3ZgLCBgaHNsVG9SZ2JgLCBgaHN2VG9SZ2JgIG1vZGlmaWVkIGZyb206XG4vLyA8aHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdD5cblxuLy8gYHJnYlRvUmdiYFxuLy8gSGFuZGxlIGJvdW5kcyAvIHBlcmNlbnRhZ2UgY2hlY2tpbmcgdG8gY29uZm9ybSB0byBDU1MgY29sb3Igc3BlY1xuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvPlxuLy8gKkFzc3VtZXM6KiByLCBnLCBiIGluIFswLCAyNTVdIG9yIFswLCAxXVxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiBbMCwgMjU1XVxuZnVuY3Rpb24gcmdiVG9SZ2IociwgZywgYil7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogYm91bmQwMShyLCAyNTUpICogMjU1LFxuICAgICAgICBnOiBib3VuZDAxKGcsIDI1NSkgKiAyNTUsXG4gICAgICAgIGI6IGJvdW5kMDEoYiwgMjU1KSAqIDI1NVxuICAgIH07XG59XG5cbi8vIGByZ2JUb0hzbGBcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU0wuXG4vLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgaCwgcywgbCB9IGluIFswLDFdXG5mdW5jdGlvbiByZ2JUb0hzbChyLCBnLCBiKSB7XG5cbiAgICByID0gYm91bmQwMShyLCAyNTUpO1xuICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gICAgYiA9IGJvdW5kMDEoYiwgMjU1KTtcblxuICAgIHZhciBtYXggPSBtYXRoTWF4KHIsIGcsIGIpLCBtaW4gPSBtYXRoTWluKHIsIGcsIGIpO1xuICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYobWF4ID09IG1pbikge1xuICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICAgIHN3aXRjaChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaCAvPSA2O1xuICAgIH1cblxuICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIGw6IGwgfTtcbn1cblxuLy8gYGhzbFRvUmdiYFxuLy8gQ29udmVydHMgYW4gSFNMIGNvbG9yIHZhbHVlIHRvIFJHQi5cbi8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCBsIGFyZSBjb250YWluZWQgWzAsIDFdIG9yIFswLCAxMDBdXG4vLyAqUmV0dXJuczoqIHsgciwgZywgYiB9IGluIHRoZSBzZXQgWzAsIDI1NV1cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgICB2YXIgciwgZywgYjtcblxuICAgIGggPSBib3VuZDAxKGgsIDM2MCk7XG4gICAgcyA9IGJvdW5kMDEocywgMTAwKTtcbiAgICBsID0gYm91bmQwMShsLCAxMDApO1xuXG4gICAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XG4gICAgICAgIGlmKHQgPiAxKSB0IC09IDE7XG4gICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcbiAgICAgICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgaWYocyA9PT0gMCkge1xuICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcbiAgICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHI6IHIgKiAyNTUsIGc6IGcgKiAyNTUsIGI6IGIgKiAyNTUgfTtcbn1cblxuLy8gYHJnYlRvSHN2YFxuLy8gQ29udmVydHMgYW4gUkdCIGNvbG9yIHZhbHVlIHRvIEhTVlxuLy8gKkFzc3VtZXM6KiByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV0gb3IgWzAsIDFdXG4vLyAqUmV0dXJuczoqIHsgaCwgcywgdiB9IGluIFswLDFdXG5mdW5jdGlvbiByZ2JUb0hzdihyLCBnLCBiKSB7XG5cbiAgICByID0gYm91bmQwMShyLCAyNTUpO1xuICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gICAgYiA9IGJvdW5kMDEoYiwgMjU1KTtcblxuICAgIHZhciBtYXggPSBtYXRoTWF4KHIsIGcsIGIpLCBtaW4gPSBtYXRoTWluKHIsIGcsIGIpO1xuICAgIHZhciBoLCBzLCB2ID0gbWF4O1xuXG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4O1xuXG4gICAgaWYobWF4ID09IG1pbikge1xuICAgICAgICBoID0gMDsgLy8gYWNocm9tYXRpY1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3dpdGNoKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSA2O1xuICAgIH1cbiAgICByZXR1cm4geyBoOiBoLCBzOiBzLCB2OiB2IH07XG59XG5cbi8vIGBoc3ZUb1JnYmBcbi8vIENvbnZlcnRzIGFuIEhTViBjb2xvciB2YWx1ZSB0byBSR0IuXG4vLyAqQXNzdW1lczoqIGggaXMgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMzYwXSBhbmQgcyBhbmQgdiBhcmUgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMTAwXVxuLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiB0aGUgc2V0IFswLCAyNTVdXG4gZnVuY3Rpb24gaHN2VG9SZ2IoaCwgcywgdikge1xuXG4gICAgaCA9IGJvdW5kMDEoaCwgMzYwKSAqIDY7XG4gICAgcyA9IGJvdW5kMDEocywgMTAwKTtcbiAgICB2ID0gYm91bmQwMSh2LCAxMDApO1xuXG4gICAgdmFyIGkgPSBtYXRoLmZsb29yKGgpLFxuICAgICAgICBmID0gaCAtIGksXG4gICAgICAgIHAgPSB2ICogKDEgLSBzKSxcbiAgICAgICAgcSA9IHYgKiAoMSAtIGYgKiBzKSxcbiAgICAgICAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKSxcbiAgICAgICAgbW9kID0gaSAlIDYsXG4gICAgICAgIHIgPSBbdiwgcSwgcCwgcCwgdCwgdl1bbW9kXSxcbiAgICAgICAgZyA9IFt0LCB2LCB2LCBxLCBwLCBwXVttb2RdLFxuICAgICAgICBiID0gW3AsIHAsIHQsIHYsIHYsIHFdW21vZF07XG5cbiAgICByZXR1cm4geyByOiByICogMjU1LCBnOiBnICogMjU1LCBiOiBiICogMjU1IH07XG59XG5cbi8vIGByZ2JUb0hleGBcbi8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB0byBoZXhcbi8vIEFzc3VtZXMgciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdXG4vLyBSZXR1cm5zIGEgMyBvciA2IGNoYXJhY3RlciBoZXhcbmZ1bmN0aW9uIHJnYlRvSGV4KHIsIGcsIGIsIGFsbG93M0NoYXIpIHtcblxuICAgIHZhciBoZXggPSBbXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKHIpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgIHBhZDIobWF0aFJvdW5kKGIpLnRvU3RyaW5nKDE2KSlcbiAgICBdO1xuXG4gICAgLy8gUmV0dXJuIGEgMyBjaGFyYWN0ZXIgaGV4IGlmIHBvc3NpYmxlXG4gICAgaWYgKGFsbG93M0NoYXIgJiYgaGV4WzBdLmNoYXJBdCgwKSA9PSBoZXhbMF0uY2hhckF0KDEpICYmIGhleFsxXS5jaGFyQXQoMCkgPT0gaGV4WzFdLmNoYXJBdCgxKSAmJiBoZXhbMl0uY2hhckF0KDApID09IGhleFsyXS5jaGFyQXQoMSkpIHtcbiAgICAgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGV4LmpvaW4oXCJcIik7XG59XG5cbi8vIGByZ2JhVG9IZXhgXG4vLyBDb252ZXJ0cyBhbiBSR0JBIGNvbG9yIHBsdXMgYWxwaGEgdHJhbnNwYXJlbmN5IHRvIGhleFxuLy8gQXNzdW1lcyByLCBnLCBiIGFuZCBhIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XVxuLy8gUmV0dXJucyBhbiA4IGNoYXJhY3RlciBoZXhcbmZ1bmN0aW9uIHJnYmFUb0hleChyLCBnLCBiLCBhKSB7XG5cbiAgICB2YXIgaGV4ID0gW1xuICAgICAgICBwYWQyKGNvbnZlcnREZWNpbWFsVG9IZXgoYSkpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChyKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChnKS50b1N0cmluZygxNikpLFxuICAgICAgICBwYWQyKG1hdGhSb3VuZChiKS50b1N0cmluZygxNikpXG4gICAgXTtcblxuICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbn1cblxuLy8gYGVxdWFsc2Bcbi8vIENhbiBiZSBjYWxsZWQgd2l0aCBhbnkgdGlueWNvbG9yIGlucHV0XG50aW55Y29sb3IuZXF1YWxzID0gZnVuY3Rpb24gKGNvbG9yMSwgY29sb3IyKSB7XG4gICAgaWYgKCFjb2xvcjEgfHwgIWNvbG9yMikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yMSkudG9SZ2JTdHJpbmcoKSA9PSB0aW55Y29sb3IoY29sb3IyKS50b1JnYlN0cmluZygpO1xufTtcblxudGlueWNvbG9yLnJhbmRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aW55Y29sb3IuZnJvbVJhdGlvKHtcbiAgICAgICAgcjogbWF0aFJhbmRvbSgpLFxuICAgICAgICBnOiBtYXRoUmFuZG9tKCksXG4gICAgICAgIGI6IG1hdGhSYW5kb20oKVxuICAgIH0pO1xufTtcblxuXG4vLyBNb2RpZmljYXRpb24gRnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGFua3MgdG8gbGVzcy5qcyBmb3Igc29tZSBvZiB0aGUgYmFzaWNzIGhlcmVcbi8vIDxodHRwczovL2dpdGh1Yi5jb20vY2xvdWRoZWFkL2xlc3MuanMvYmxvYi9tYXN0ZXIvbGliL2xlc3MvZnVuY3Rpb25zLmpzPlxuXG5mdW5jdGlvbiBkZXNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5zIC09IGFtb3VudCAvIDEwMDtcbiAgICBoc2wucyA9IGNsYW1wMDEoaHNsLnMpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gc2F0dXJhdGUoY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgaHNsLnMgKz0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5zID0gY2xhbXAwMShoc2wucyk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG5mdW5jdGlvbiBncmV5c2NhbGUoY29sb3IpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5kZXNhdHVyYXRlKDEwMCk7XG59XG5cbmZ1bmN0aW9uIGxpZ2h0ZW4gKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5sICs9IGFtb3VudCAvIDEwMDtcbiAgICBoc2wubCA9IGNsYW1wMDEoaHNsLmwpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuZnVuY3Rpb24gYnJpZ2h0ZW4oY29sb3IsIGFtb3VudCkge1xuICAgIGFtb3VudCA9IChhbW91bnQgPT09IDApID8gMCA6IChhbW91bnQgfHwgMTApO1xuICAgIHZhciByZ2IgPSB0aW55Y29sb3IoY29sb3IpLnRvUmdiKCk7XG4gICAgcmdiLnIgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuciAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgIHJnYi5nID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLmcgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuYiA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5iIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgcmV0dXJuIHRpbnljb2xvcihyZ2IpO1xufVxuXG5mdW5jdGlvbiBkYXJrZW4gKGNvbG9yLCBhbW91bnQpIHtcbiAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5sIC09IGFtb3VudCAvIDEwMDtcbiAgICBoc2wubCA9IGNsYW1wMDEoaHNsLmwpO1xuICAgIHJldHVybiB0aW55Y29sb3IoaHNsKTtcbn1cblxuLy8gU3BpbiB0YWtlcyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGFtb3VudCB3aXRoaW4gWy0zNjAsIDM2MF0gaW5kaWNhdGluZyB0aGUgY2hhbmdlIG9mIGh1ZS5cbi8vIFZhbHVlcyBvdXRzaWRlIG9mIHRoaXMgcmFuZ2Ugd2lsbCBiZSB3cmFwcGVkIGludG8gdGhpcyByYW5nZS5cbmZ1bmN0aW9uIHNwaW4oY29sb3IsIGFtb3VudCkge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGh1ZSA9IChtYXRoUm91bmQoaHNsLmgpICsgYW1vdW50KSAlIDM2MDtcbiAgICBoc2wuaCA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG4gICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xufVxuXG4vLyBDb21iaW5hdGlvbiBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhhbmtzIHRvIGpRdWVyeSB4Q29sb3IgZm9yIHNvbWUgb2YgdGhlIGlkZWFzIGJlaGluZCB0aGVzZVxuLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmZ1c2lvbi9qUXVlcnkteGNvbG9yL2Jsb2IvbWFzdGVyL2pxdWVyeS54Y29sb3IuanM+XG5cbmZ1bmN0aW9uIGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIGhzbC5oID0gKGhzbC5oICsgMTgwKSAlIDM2MDtcbiAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG59XG5cbmZ1bmN0aW9uIHRyaWFkKGNvbG9yKSB7XG4gICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICB2YXIgaCA9IGhzbC5oO1xuICAgIHJldHVybiBbXG4gICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMTIwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDI0MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHRldHJhZChjb2xvcikge1xuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIGggPSBoc2wuaDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDkwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDE4MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAyNzApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSlcbiAgICBdO1xufVxuXG5mdW5jdGlvbiBzcGxpdGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgICB2YXIgaHNsID0gdGlueWNvbG9yKGNvbG9yKS50b0hzbCgpO1xuICAgIHZhciBoID0gaHNsLmg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGlueWNvbG9yKGNvbG9yKSxcbiAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyA3MikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubH0pLFxuICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDIxNikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubH0pXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gYW5hbG9nb3VzKGNvbG9yLCByZXN1bHRzLCBzbGljZXMpIHtcbiAgICByZXN1bHRzID0gcmVzdWx0cyB8fCA2O1xuICAgIHNsaWNlcyA9IHNsaWNlcyB8fCAzMDtcblxuICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgdmFyIHBhcnQgPSAzNjAgLyBzbGljZXM7XG4gICAgdmFyIHJldCA9IFt0aW55Y29sb3IoY29sb3IpXTtcblxuICAgIGZvciAoaHNsLmggPSAoKGhzbC5oIC0gKHBhcnQgKiByZXN1bHRzID4+IDEpKSArIDcyMCkgJSAzNjA7IC0tcmVzdWx0czsgKSB7XG4gICAgICAgIGhzbC5oID0gKGhzbC5oICsgcGFydCkgJSAzNjA7XG4gICAgICAgIHJldC5wdXNoKHRpbnljb2xvcihoc2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbW9ub2Nocm9tYXRpYyhjb2xvciwgcmVzdWx0cykge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IDY7XG4gICAgdmFyIGhzdiA9IHRpbnljb2xvcihjb2xvcikudG9Ic3YoKTtcbiAgICB2YXIgaCA9IGhzdi5oLCBzID0gaHN2LnMsIHYgPSBoc3YudjtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgdmFyIG1vZGlmaWNhdGlvbiA9IDEgLyByZXN1bHRzO1xuXG4gICAgd2hpbGUgKHJlc3VsdHMtLSkge1xuICAgICAgICByZXQucHVzaCh0aW55Y29sb3IoeyBoOiBoLCBzOiBzLCB2OiB2fSkpO1xuICAgICAgICB2ID0gKHYgKyBtb2RpZmljYXRpb24pICUgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG4vLyBVdGlsaXR5IEZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnRpbnljb2xvci5taXggPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMiwgYW1vdW50KSB7XG4gICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCA1MCk7XG5cbiAgICB2YXIgcmdiMSA9IHRpbnljb2xvcihjb2xvcjEpLnRvUmdiKCk7XG4gICAgdmFyIHJnYjIgPSB0aW55Y29sb3IoY29sb3IyKS50b1JnYigpO1xuXG4gICAgdmFyIHAgPSBhbW91bnQgLyAxMDA7XG4gICAgdmFyIHcgPSBwICogMiAtIDE7XG4gICAgdmFyIGEgPSByZ2IyLmEgLSByZ2IxLmE7XG5cbiAgICB2YXIgdzE7XG5cbiAgICBpZiAodyAqIGEgPT0gLTEpIHtcbiAgICAgICAgdzEgPSB3O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHcxID0gKHcgKyBhKSAvICgxICsgdyAqIGEpO1xuICAgIH1cblxuICAgIHcxID0gKHcxICsgMSkgLyAyO1xuXG4gICAgdmFyIHcyID0gMSAtIHcxO1xuXG4gICAgdmFyIHJnYmEgPSB7XG4gICAgICAgIHI6IHJnYjIuciAqIHcxICsgcmdiMS5yICogdzIsXG4gICAgICAgIGc6IHJnYjIuZyAqIHcxICsgcmdiMS5nICogdzIsXG4gICAgICAgIGI6IHJnYjIuYiAqIHcxICsgcmdiMS5iICogdzIsXG4gICAgICAgIGE6IHJnYjIuYSAqIHAgICsgcmdiMS5hICogKDEgLSBwKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGlueWNvbG9yKHJnYmEpO1xufTtcblxuXG4vLyBSZWFkYWJpbGl0eSBGdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWYgKFdDQUcgVmVyc2lvbiAyKVxuXG4vLyBgY29udHJhc3RgXG4vLyBBbmFseXplIHRoZSAyIGNvbG9ycyBhbmQgcmV0dXJucyB0aGUgY29sb3IgY29udHJhc3QgZGVmaW5lZCBieSAoV0NBRyBWZXJzaW9uIDIpXG50aW55Y29sb3IucmVhZGFiaWxpdHkgPSBmdW5jdGlvbihjb2xvcjEsIGNvbG9yMikge1xuICAgIHZhciBjMSA9IHRpbnljb2xvcihjb2xvcjEpO1xuICAgIHZhciBjMiA9IHRpbnljb2xvcihjb2xvcjIpO1xuICAgIHJldHVybiAoTWF0aC5tYXgoYzEuZ2V0THVtaW5hbmNlKCksYzIuZ2V0THVtaW5hbmNlKCkpKzAuMDUpIC8gKE1hdGgubWluKGMxLmdldEx1bWluYW5jZSgpLGMyLmdldEx1bWluYW5jZSgpKSswLjA1KTtcbn07XG5cbi8vIGBpc1JlYWRhYmxlYFxuLy8gRW5zdXJlIHRoYXQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvciBjb21iaW5hdGlvbnMgbWVldCBXQ0FHMiBndWlkZWxpbmVzLlxuLy8gVGhlIHRoaXJkIGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIE9iamVjdC5cbi8vICAgICAgdGhlICdsZXZlbCcgcHJvcGVydHkgc3RhdGVzICdBQScgb3IgJ0FBQScgLSBpZiBtaXNzaW5nIG9yIGludmFsaWQsIGl0IGRlZmF1bHRzIHRvICdBQSc7XG4vLyAgICAgIHRoZSAnc2l6ZScgcHJvcGVydHkgc3RhdGVzICdsYXJnZScgb3IgJ3NtYWxsJyAtIGlmIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgZGVmYXVsdHMgdG8gJ3NtYWxsJy5cbi8vIElmIHRoZSBlbnRpcmUgb2JqZWN0IGlzIGFic2VudCwgaXNSZWFkYWJsZSBkZWZhdWx0cyB0byB7bGV2ZWw6XCJBQVwiLHNpemU6XCJzbWFsbFwifS5cblxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIpID0+IGZhbHNlXG4vLyAgICB0aW55Y29sb3IuaXNSZWFkYWJsZShcIiMwMDBcIiwgXCIjMTExXCIse2xldmVsOlwiQUFcIixzaXplOlwibGFyZ2VcIn0pID0+IGZhbHNlXG50aW55Y29sb3IuaXNSZWFkYWJsZSA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCB3Y2FnMikge1xuICAgIHZhciByZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eShjb2xvcjEsIGNvbG9yMik7XG4gICAgdmFyIHdjYWcyUGFybXMsIG91dDtcblxuICAgIG91dCA9IGZhbHNlO1xuXG4gICAgd2NhZzJQYXJtcyA9IHZhbGlkYXRlV0NBRzJQYXJtcyh3Y2FnMik7XG4gICAgc3dpdGNoICh3Y2FnMlBhcm1zLmxldmVsICsgd2NhZzJQYXJtcy5zaXplKSB7XG4gICAgICAgIGNhc2UgXCJBQXNtYWxsXCI6XG4gICAgICAgIGNhc2UgXCJBQUFsYXJnZVwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQWxhcmdlXCI6XG4gICAgICAgICAgICBvdXQgPSByZWFkYWJpbGl0eSA+PSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBQUFzbWFsbFwiOlxuICAgICAgICAgICAgb3V0ID0gcmVhZGFiaWxpdHkgPj0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuXG59O1xuXG4vLyBgbW9zdFJlYWRhYmxlYFxuLy8gR2l2ZW4gYSBiYXNlIGNvbG9yIGFuZCBhIGxpc3Qgb2YgcG9zc2libGUgZm9yZWdyb3VuZCBvciBiYWNrZ3JvdW5kXG4vLyBjb2xvcnMgZm9yIHRoYXQgYmFzZSwgcmV0dXJucyB0aGUgbW9zdCByZWFkYWJsZSBjb2xvci5cbi8vIE9wdGlvbmFsbHkgcmV0dXJucyBCbGFjayBvciBXaGl0ZSBpZiB0aGUgbW9zdCByZWFkYWJsZSBjb2xvciBpcyB1bnJlYWRhYmxlLlxuLy8gKkV4YW1wbGUqXG4vLyAgICB0aW55Y29sb3IubW9zdFJlYWRhYmxlKHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjMTIzXCIsIFtcIiMxMjRcIiwgXCIjMTI1XCJdLHtpbmNsdWRlRmFsbGJhY2tDb2xvcnM6ZmFsc2V9KS50b0hleFN0cmluZygpOyAvLyBcIiMxMTIyNTVcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSh0aW55Y29sb3IubW9zdFJlYWRhYmxlKFwiIzEyM1wiLCBbXCIjMTI0XCIsIFwiIzEyNVwiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWV9KS50b0hleFN0cmluZygpOyAgLy8gXCIjZmZmZmZmXCJcbi8vICAgIHRpbnljb2xvci5tb3N0UmVhZGFibGUoXCIjYTgwMTVhXCIsIFtcIiNmYWYzZjNcIl0se2luY2x1ZGVGYWxsYmFja0NvbG9yczp0cnVlLGxldmVsOlwiQUFBXCIsc2l6ZTpcImxhcmdlXCJ9KS50b0hleFN0cmluZygpOyAvLyBcIiNmYWYzZjNcIlxuLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiNhODAxNWFcIiwgW1wiI2ZhZjNmM1wiXSx7aW5jbHVkZUZhbGxiYWNrQ29sb3JzOnRydWUsbGV2ZWw6XCJBQUFcIixzaXplOlwic21hbGxcIn0pLnRvSGV4U3RyaW5nKCk7IC8vIFwiI2ZmZmZmZlwiXG50aW55Y29sb3IubW9zdFJlYWRhYmxlID0gZnVuY3Rpb24oYmFzZUNvbG9yLCBjb2xvckxpc3QsIGFyZ3MpIHtcbiAgICB2YXIgYmVzdENvbG9yID0gbnVsbDtcbiAgICB2YXIgYmVzdFNjb3JlID0gMDtcbiAgICB2YXIgcmVhZGFiaWxpdHk7XG4gICAgdmFyIGluY2x1ZGVGYWxsYmFja0NvbG9ycywgbGV2ZWwsIHNpemUgO1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGluY2x1ZGVGYWxsYmFja0NvbG9ycyA9IGFyZ3MuaW5jbHVkZUZhbGxiYWNrQ29sb3JzIDtcbiAgICBsZXZlbCA9IGFyZ3MubGV2ZWw7XG4gICAgc2l6ZSA9IGFyZ3Muc2l6ZTtcblxuICAgIGZvciAodmFyIGk9IDA7IGkgPCBjb2xvckxpc3QubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHJlYWRhYmlsaXR5ID0gdGlueWNvbG9yLnJlYWRhYmlsaXR5KGJhc2VDb2xvciwgY29sb3JMaXN0W2ldKTtcbiAgICAgICAgaWYgKHJlYWRhYmlsaXR5ID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSByZWFkYWJpbGl0eTtcbiAgICAgICAgICAgIGJlc3RDb2xvciA9IHRpbnljb2xvcihjb2xvckxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbnljb2xvci5pc1JlYWRhYmxlKGJhc2VDb2xvciwgYmVzdENvbG9yLCB7XCJsZXZlbFwiOmxldmVsLFwic2l6ZVwiOnNpemV9KSB8fCAhaW5jbHVkZUZhbGxiYWNrQ29sb3JzKSB7XG4gICAgICAgIHJldHVybiBiZXN0Q29sb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmdzLmluY2x1ZGVGYWxsYmFja0NvbG9ycz1mYWxzZTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvci5tb3N0UmVhZGFibGUoYmFzZUNvbG9yLFtcIiNmZmZcIiwgXCIjMDAwXCJdLGFyZ3MpO1xuICAgIH1cbn07XG5cblxuLy8gQmlnIExpc3Qgb2YgQ29sb3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3I+XG52YXIgbmFtZXMgPSB0aW55Y29sb3IubmFtZXMgPSB7XG4gICAgYWxpY2VibHVlOiBcImYwZjhmZlwiLFxuICAgIGFudGlxdWV3aGl0ZTogXCJmYWViZDdcIixcbiAgICBhcXVhOiBcIjBmZlwiLFxuICAgIGFxdWFtYXJpbmU6IFwiN2ZmZmQ0XCIsXG4gICAgYXp1cmU6IFwiZjBmZmZmXCIsXG4gICAgYmVpZ2U6IFwiZjVmNWRjXCIsXG4gICAgYmlzcXVlOiBcImZmZTRjNFwiLFxuICAgIGJsYWNrOiBcIjAwMFwiLFxuICAgIGJsYW5jaGVkYWxtb25kOiBcImZmZWJjZFwiLFxuICAgIGJsdWU6IFwiMDBmXCIsXG4gICAgYmx1ZXZpb2xldDogXCI4YTJiZTJcIixcbiAgICBicm93bjogXCJhNTJhMmFcIixcbiAgICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gICAgYnVybnRzaWVubmE6IFwiZWE3ZTVkXCIsXG4gICAgY2FkZXRibHVlOiBcIjVmOWVhMFwiLFxuICAgIGNoYXJ0cmV1c2U6IFwiN2ZmZjAwXCIsXG4gICAgY2hvY29sYXRlOiBcImQyNjkxZVwiLFxuICAgIGNvcmFsOiBcImZmN2Y1MFwiLFxuICAgIGNvcm5mbG93ZXJibHVlOiBcIjY0OTVlZFwiLFxuICAgIGNvcm5zaWxrOiBcImZmZjhkY1wiLFxuICAgIGNyaW1zb246IFwiZGMxNDNjXCIsXG4gICAgY3lhbjogXCIwZmZcIixcbiAgICBkYXJrYmx1ZTogXCIwMDAwOGJcIixcbiAgICBkYXJrY3lhbjogXCIwMDhiOGJcIixcbiAgICBkYXJrZ29sZGVucm9kOiBcImI4ODYwYlwiLFxuICAgIGRhcmtncmF5OiBcImE5YTlhOVwiLFxuICAgIGRhcmtncmVlbjogXCIwMDY0MDBcIixcbiAgICBkYXJrZ3JleTogXCJhOWE5YTlcIixcbiAgICBkYXJra2hha2k6IFwiYmRiNzZiXCIsXG4gICAgZGFya21hZ2VudGE6IFwiOGIwMDhiXCIsXG4gICAgZGFya29saXZlZ3JlZW46IFwiNTU2YjJmXCIsXG4gICAgZGFya29yYW5nZTogXCJmZjhjMDBcIixcbiAgICBkYXJrb3JjaGlkOiBcIjk5MzJjY1wiLFxuICAgIGRhcmtyZWQ6IFwiOGIwMDAwXCIsXG4gICAgZGFya3NhbG1vbjogXCJlOTk2N2FcIixcbiAgICBkYXJrc2VhZ3JlZW46IFwiOGZiYzhmXCIsXG4gICAgZGFya3NsYXRlYmx1ZTogXCI0ODNkOGJcIixcbiAgICBkYXJrc2xhdGVncmF5OiBcIjJmNGY0ZlwiLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFwiMmY0ZjRmXCIsXG4gICAgZGFya3R1cnF1b2lzZTogXCIwMGNlZDFcIixcbiAgICBkYXJrdmlvbGV0OiBcIjk0MDBkM1wiLFxuICAgIGRlZXBwaW5rOiBcImZmMTQ5M1wiLFxuICAgIGRlZXBza3libHVlOiBcIjAwYmZmZlwiLFxuICAgIGRpbWdyYXk6IFwiNjk2OTY5XCIsXG4gICAgZGltZ3JleTogXCI2OTY5NjlcIixcbiAgICBkb2RnZXJibHVlOiBcIjFlOTBmZlwiLFxuICAgIGZpcmVicmljazogXCJiMjIyMjJcIixcbiAgICBmbG9yYWx3aGl0ZTogXCJmZmZhZjBcIixcbiAgICBmb3Jlc3RncmVlbjogXCIyMjhiMjJcIixcbiAgICBmdWNoc2lhOiBcImYwZlwiLFxuICAgIGdhaW5zYm9ybzogXCJkY2RjZGNcIixcbiAgICBnaG9zdHdoaXRlOiBcImY4ZjhmZlwiLFxuICAgIGdvbGQ6IFwiZmZkNzAwXCIsXG4gICAgZ29sZGVucm9kOiBcImRhYTUyMFwiLFxuICAgIGdyYXk6IFwiODA4MDgwXCIsXG4gICAgZ3JlZW46IFwiMDA4MDAwXCIsXG4gICAgZ3JlZW55ZWxsb3c6IFwiYWRmZjJmXCIsXG4gICAgZ3JleTogXCI4MDgwODBcIixcbiAgICBob25leWRldzogXCJmMGZmZjBcIixcbiAgICBob3RwaW5rOiBcImZmNjliNFwiLFxuICAgIGluZGlhbnJlZDogXCJjZDVjNWNcIixcbiAgICBpbmRpZ286IFwiNGIwMDgyXCIsXG4gICAgaXZvcnk6IFwiZmZmZmYwXCIsXG4gICAga2hha2k6IFwiZjBlNjhjXCIsXG4gICAgbGF2ZW5kZXI6IFwiZTZlNmZhXCIsXG4gICAgbGF2ZW5kZXJibHVzaDogXCJmZmYwZjVcIixcbiAgICBsYXduZ3JlZW46IFwiN2NmYzAwXCIsXG4gICAgbGVtb25jaGlmZm9uOiBcImZmZmFjZFwiLFxuICAgIGxpZ2h0Ymx1ZTogXCJhZGQ4ZTZcIixcbiAgICBsaWdodGNvcmFsOiBcImYwODA4MFwiLFxuICAgIGxpZ2h0Y3lhbjogXCJlMGZmZmZcIixcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCJmYWZhZDJcIixcbiAgICBsaWdodGdyYXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRncmVlbjogXCI5MGVlOTBcIixcbiAgICBsaWdodGdyZXk6IFwiZDNkM2QzXCIsXG4gICAgbGlnaHRwaW5rOiBcImZmYjZjMVwiLFxuICAgIGxpZ2h0c2FsbW9uOiBcImZmYTA3YVwiLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFwiMjBiMmFhXCIsXG4gICAgbGlnaHRza3libHVlOiBcIjg3Y2VmYVwiLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBcIjc4OVwiLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBcImIwYzRkZVwiLFxuICAgIGxpZ2h0eWVsbG93OiBcImZmZmZlMFwiLFxuICAgIGxpbWU6IFwiMGYwXCIsXG4gICAgbGltZWdyZWVuOiBcIjMyY2QzMlwiLFxuICAgIGxpbmVuOiBcImZhZjBlNlwiLFxuICAgIG1hZ2VudGE6IFwiZjBmXCIsXG4gICAgbWFyb29uOiBcIjgwMDAwMFwiLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFwiNjZjZGFhXCIsXG4gICAgbWVkaXVtYmx1ZTogXCIwMDAwY2RcIixcbiAgICBtZWRpdW1vcmNoaWQ6IFwiYmE1NWQzXCIsXG4gICAgbWVkaXVtcHVycGxlOiBcIjkzNzBkYlwiLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBcIjNjYjM3MVwiLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogXCI3YjY4ZWVcIixcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogXCIwMGZhOWFcIixcbiAgICBtZWRpdW10dXJxdW9pc2U6IFwiNDhkMWNjXCIsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBcImM3MTU4NVwiLFxuICAgIG1pZG5pZ2h0Ymx1ZTogXCIxOTE5NzBcIixcbiAgICBtaW50Y3JlYW06IFwiZjVmZmZhXCIsXG4gICAgbWlzdHlyb3NlOiBcImZmZTRlMVwiLFxuICAgIG1vY2Nhc2luOiBcImZmZTRiNVwiLFxuICAgIG5hdmFqb3doaXRlOiBcImZmZGVhZFwiLFxuICAgIG5hdnk6IFwiMDAwMDgwXCIsXG4gICAgb2xkbGFjZTogXCJmZGY1ZTZcIixcbiAgICBvbGl2ZTogXCI4MDgwMDBcIixcbiAgICBvbGl2ZWRyYWI6IFwiNmI4ZTIzXCIsXG4gICAgb3JhbmdlOiBcImZmYTUwMFwiLFxuICAgIG9yYW5nZXJlZDogXCJmZjQ1MDBcIixcbiAgICBvcmNoaWQ6IFwiZGE3MGQ2XCIsXG4gICAgcGFsZWdvbGRlbnJvZDogXCJlZWU4YWFcIixcbiAgICBwYWxlZ3JlZW46IFwiOThmYjk4XCIsXG4gICAgcGFsZXR1cnF1b2lzZTogXCJhZmVlZWVcIixcbiAgICBwYWxldmlvbGV0cmVkOiBcImRiNzA5M1wiLFxuICAgIHBhcGF5YXdoaXA6IFwiZmZlZmQ1XCIsXG4gICAgcGVhY2hwdWZmOiBcImZmZGFiOVwiLFxuICAgIHBlcnU6IFwiY2Q4NTNmXCIsXG4gICAgcGluazogXCJmZmMwY2JcIixcbiAgICBwbHVtOiBcImRkYTBkZFwiLFxuICAgIHBvd2RlcmJsdWU6IFwiYjBlMGU2XCIsXG4gICAgcHVycGxlOiBcIjgwMDA4MFwiLFxuICAgIHJlYmVjY2FwdXJwbGU6IFwiNjYzMzk5XCIsXG4gICAgcmVkOiBcImYwMFwiLFxuICAgIHJvc3licm93bjogXCJiYzhmOGZcIixcbiAgICByb3lhbGJsdWU6IFwiNDE2OWUxXCIsXG4gICAgc2FkZGxlYnJvd246IFwiOGI0NTEzXCIsXG4gICAgc2FsbW9uOiBcImZhODA3MlwiLFxuICAgIHNhbmR5YnJvd246IFwiZjRhNDYwXCIsXG4gICAgc2VhZ3JlZW46IFwiMmU4YjU3XCIsXG4gICAgc2Vhc2hlbGw6IFwiZmZmNWVlXCIsXG4gICAgc2llbm5hOiBcImEwNTIyZFwiLFxuICAgIHNpbHZlcjogXCJjMGMwYzBcIixcbiAgICBza3libHVlOiBcIjg3Y2VlYlwiLFxuICAgIHNsYXRlYmx1ZTogXCI2YTVhY2RcIixcbiAgICBzbGF0ZWdyYXk6IFwiNzA4MDkwXCIsXG4gICAgc2xhdGVncmV5OiBcIjcwODA5MFwiLFxuICAgIHNub3c6IFwiZmZmYWZhXCIsXG4gICAgc3ByaW5nZ3JlZW46IFwiMDBmZjdmXCIsXG4gICAgc3RlZWxibHVlOiBcIjQ2ODJiNFwiLFxuICAgIHRhbjogXCJkMmI0OGNcIixcbiAgICB0ZWFsOiBcIjAwODA4MFwiLFxuICAgIHRoaXN0bGU6IFwiZDhiZmQ4XCIsXG4gICAgdG9tYXRvOiBcImZmNjM0N1wiLFxuICAgIHR1cnF1b2lzZTogXCI0MGUwZDBcIixcbiAgICB2aW9sZXQ6IFwiZWU4MmVlXCIsXG4gICAgd2hlYXQ6IFwiZjVkZWIzXCIsXG4gICAgd2hpdGU6IFwiZmZmXCIsXG4gICAgd2hpdGVzbW9rZTogXCJmNWY1ZjVcIixcbiAgICB5ZWxsb3c6IFwiZmYwXCIsXG4gICAgeWVsbG93Z3JlZW46IFwiOWFjZDMyXCJcbn07XG5cbi8vIE1ha2UgaXQgZWFzeSB0byBhY2Nlc3MgY29sb3JzIHZpYSBgaGV4TmFtZXNbaGV4XWBcbnZhciBoZXhOYW1lcyA9IHRpbnljb2xvci5oZXhOYW1lcyA9IGZsaXAobmFtZXMpO1xuXG5cbi8vIFV0aWxpdGllc1xuLy8gLS0tLS0tLS0tXG5cbi8vIGB7ICduYW1lMSc6ICd2YWwxJyB9YCBiZWNvbWVzIGB7ICd2YWwxJzogJ25hbWUxJyB9YFxuZnVuY3Rpb24gZmxpcChvKSB7XG4gICAgdmFyIGZsaXBwZWQgPSB7IH07XG4gICAgZm9yICh2YXIgaSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBmbGlwcGVkW29baV1dID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxpcHBlZDtcbn1cblxuLy8gUmV0dXJuIGEgdmFsaWQgYWxwaGEgdmFsdWUgWzAsMV0gd2l0aCBhbGwgaW52YWxpZCB2YWx1ZXMgYmVpbmcgc2V0IHRvIDFcbmZ1bmN0aW9uIGJvdW5kQWxwaGEoYSkge1xuICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG4vLyBUYWtlIGlucHV0IGZyb20gWzAsIG5dIGFuZCByZXR1cm4gaXQgYXMgWzAsIDFdXG5mdW5jdGlvbiBib3VuZDAxKG4sIG1heCkge1xuICAgIGlmIChpc09uZVBvaW50WmVybyhuKSkgeyBuID0gXCIxMDAlXCI7IH1cblxuICAgIHZhciBwcm9jZXNzUGVyY2VudCA9IGlzUGVyY2VudGFnZShuKTtcbiAgICBuID0gbWF0aE1pbihtYXgsIG1hdGhNYXgoMCwgcGFyc2VGbG9hdChuKSkpO1xuXG4gICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IHBlcmNlbnRhZ2UgaW50byBudW1iZXJcbiAgICBpZiAocHJvY2Vzc1BlcmNlbnQpIHtcbiAgICAgICAgbiA9IHBhcnNlSW50KG4gKiBtYXgsIDEwKSAvIDEwMDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzXG4gICAgaWYgKChtYXRoLmFicyhuIC0gbWF4KSA8IDAuMDAwMDAxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gWzAsIDFdIHJhbmdlIGlmIGl0IGlzbid0IGFscmVhZHlcbiAgICByZXR1cm4gKG4gJSBtYXgpIC8gcGFyc2VGbG9hdChtYXgpO1xufVxuXG4vLyBGb3JjZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbmZ1bmN0aW9uIGNsYW1wMDEodmFsKSB7XG4gICAgcmV0dXJuIG1hdGhNaW4oMSwgbWF0aE1heCgwLCB2YWwpKTtcbn1cblxuLy8gUGFyc2UgYSBiYXNlLTE2IGhleCB2YWx1ZSBpbnRvIGEgYmFzZS0xMCBpbnRlZ2VyXG5mdW5jdGlvbiBwYXJzZUludEZyb21IZXgodmFsKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTYpO1xufVxuXG4vLyBOZWVkIHRvIGhhbmRsZSAxLjAgYXMgMTAwJSwgc2luY2Ugb25jZSBpdCBpcyBhIG51bWJlciwgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGl0IGFuZCAxXG4vLyA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NDIyMDcyL2phdmFzY3JpcHQtaG93LXRvLWRldGVjdC1udW1iZXItYXMtYS1kZWNpbWFsLWluY2x1ZGluZy0xLTA+XG5mdW5jdGlvbiBpc09uZVBvaW50WmVybyhuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgbi5pbmRleE9mKCcuJykgIT0gLTEgJiYgcGFyc2VGbG9hdChuKSA9PT0gMTtcbn1cblxuLy8gQ2hlY2sgdG8gc2VlIGlmIHN0cmluZyBwYXNzZWQgaW4gaXMgYSBwZXJjZW50YWdlXG5mdW5jdGlvbiBpc1BlcmNlbnRhZ2Uobikge1xuICAgIHJldHVybiB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIiAmJiBuLmluZGV4T2YoJyUnKSAhPSAtMTtcbn1cblxuLy8gRm9yY2UgYSBoZXggdmFsdWUgdG8gaGF2ZSAyIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBhZDIoYykge1xuICAgIHJldHVybiBjLmxlbmd0aCA9PSAxID8gJzAnICsgYyA6ICcnICsgYztcbn1cblxuLy8gUmVwbGFjZSBhIGRlY2ltYWwgd2l0aCBpdCdzIHBlcmNlbnRhZ2UgdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnRUb1BlcmNlbnRhZ2Uobikge1xuICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgbiA9IChuICogMTAwKSArIFwiJVwiO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG4vLyBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gYSBoZXggdmFsdWVcbmZ1bmN0aW9uIGNvbnZlcnREZWNpbWFsVG9IZXgoZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZCkgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIENvbnZlcnRzIGEgaGV4IHZhbHVlIHRvIGEgZGVjaW1hbFxuZnVuY3Rpb24gY29udmVydEhleFRvRGVjaW1hbChoKSB7XG4gICAgcmV0dXJuIChwYXJzZUludEZyb21IZXgoaCkgLyAyNTUpO1xufVxuXG52YXIgbWF0Y2hlcnMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI2ludGVnZXJzPlxuICAgIHZhciBDU1NfSU5URUdFUiA9IFwiWy1cXFxcK10/XFxcXGQrJT9cIjtcblxuICAgIC8vIDxodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXZhbHVlcy8jbnVtYmVyLXZhbHVlPlxuICAgIHZhciBDU1NfTlVNQkVSID0gXCJbLVxcXFwrXT9cXFxcZCpcXFxcLlxcXFxkKyU/XCI7XG5cbiAgICAvLyBBbGxvdyBwb3NpdGl2ZS9uZWdhdGl2ZSBpbnRlZ2VyL251bWJlci4gIERvbid0IGNhcHR1cmUgdGhlIGVpdGhlci9vciwganVzdCB0aGUgZW50aXJlIG91dGNvbWUuXG4gICAgdmFyIENTU19VTklUID0gXCIoPzpcIiArIENTU19OVU1CRVIgKyBcIil8KD86XCIgKyBDU1NfSU5URUdFUiArIFwiKVwiO1xuXG4gICAgLy8gQWN0dWFsIG1hdGNoaW5nLlxuICAgIC8vIFBhcmVudGhlc2VzIGFuZCBjb21tYXMgYXJlIG9wdGlvbmFsLCBidXQgbm90IHJlcXVpcmVkLlxuICAgIC8vIFdoaXRlc3BhY2UgY2FuIHRha2UgdGhlIHBsYWNlIG9mIGNvbW1hcyBvciBvcGVuaW5nIHBhcmVuXG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0gzID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG4gICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0g0ID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZ2I6IG5ldyBSZWdFeHAoXCJyZ2JcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgcmdiYTogbmV3IFJlZ0V4cChcInJnYmFcIiArIFBFUk1JU1NJVkVfTUFUQ0g0KSxcbiAgICAgICAgaHNsOiBuZXcgUmVnRXhwKFwiaHNsXCIgKyBQRVJNSVNTSVZFX01BVENIMyksXG4gICAgICAgIGhzbGE6IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgIGhzdjogbmV3IFJlZ0V4cChcImhzdlwiICsgUEVSTUlTU0lWRV9NQVRDSDMpLFxuICAgICAgICBoc3ZhOiBuZXcgUmVnRXhwKFwiaHN2YVwiICsgUEVSTUlTU0lWRV9NQVRDSDQpLFxuICAgICAgICBoZXgzOiAvXihbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgICAgICBoZXg2OiAvXihbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvLFxuICAgICAgICBoZXg4OiAvXihbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkL1xuICAgIH07XG59KSgpO1xuXG4vLyBgc3RyaW5nSW5wdXRUb09iamVjdGBcbi8vIFBlcm1pc3NpdmUgc3RyaW5nIHBhcnNpbmcuICBUYWtlIGluIGEgbnVtYmVyIG9mIGZvcm1hdHMsIGFuZCBvdXRwdXQgYW4gb2JqZWN0XG4vLyBiYXNlZCBvbiBkZXRlY3RlZCBmb3JtYXQuICBSZXR1cm5zIGB7IHIsIGcsIGIgfWAgb3IgYHsgaCwgcywgbCB9YCBvciBgeyBoLCBzLCB2fWBcbmZ1bmN0aW9uIHN0cmluZ0lucHV0VG9PYmplY3QoY29sb3IpIHtcblxuICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSh0cmltTGVmdCwnJykucmVwbGFjZSh0cmltUmlnaHQsICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBuYW1lZCA9IGZhbHNlO1xuICAgIGlmIChuYW1lc1tjb2xvcl0pIHtcbiAgICAgICAgY29sb3IgPSBuYW1lc1tjb2xvcl07XG4gICAgICAgIG5hbWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sb3IgPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICByZXR1cm4geyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwLCBmb3JtYXQ6IFwibmFtZVwiIH07XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIG1hdGNoIHN0cmluZyBpbnB1dCB1c2luZyByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgIC8vIEtlZXAgbW9zdCBvZiB0aGUgbnVtYmVyIGJvdW5kaW5nIG91dCBvZiB0aGlzIGZ1bmN0aW9uIC0gZG9uJ3Qgd29ycnkgYWJvdXQgWzAsMV0gb3IgWzAsMTAwXSBvciBbMCwzNjBdXG4gICAgLy8gSnVzdCByZXR1cm4gYW4gb2JqZWN0IGFuZCBsZXQgdGhlIGNvbnZlcnNpb24gZnVuY3Rpb25zIGhhbmRsZSB0aGF0LlxuICAgIC8vIFRoaXMgd2F5IHRoZSByZXN1bHQgd2lsbCBiZSB0aGUgc2FtZSB3aGV0aGVyIHRoZSB0aW55Y29sb3IgaXMgaW5pdGlhbGl6ZWQgd2l0aCBzdHJpbmcgb3Igb2JqZWN0LlxuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRjaFsxXSwgZzogbWF0Y2hbMl0sIGI6IG1hdGNoWzNdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5yZ2JhLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyByOiBtYXRjaFsxXSwgZzogbWF0Y2hbMl0sIGI6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIGw6IG1hdGNoWzNdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oc2xhLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIGw6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHN2LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIHY6IG1hdGNoWzNdIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oc3ZhLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4geyBoOiBtYXRjaFsxXSwgczogbWF0Y2hbMl0sIHY6IG1hdGNoWzNdLCBhOiBtYXRjaFs0XSB9O1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbMV0pLFxuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSksXG4gICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbNF0pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXg4XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMV0pLFxuICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSksXG4gICAgICAgICAgICBmb3JtYXQ6IG5hbWVkID8gXCJuYW1lXCIgOiBcImhleFwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzFdICsgJycgKyBtYXRjaFsxXSksXG4gICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0gKyAnJyArIG1hdGNoWzJdKSxcbiAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArICcnICsgbWF0Y2hbM10pLFxuICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXhcIlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXQ0FHMlBhcm1zKHBhcm1zKSB7XG4gICAgLy8gcmV0dXJuIHZhbGlkIFdDQUcyIHBhcm1zIGZvciBpc1JlYWRhYmxlLlxuICAgIC8vIElmIGlucHV0IHBhcm1zIGFyZSBpbnZhbGlkLCByZXR1cm4ge1wibGV2ZWxcIjpcIkFBXCIsIFwic2l6ZVwiOlwic21hbGxcIn1cbiAgICB2YXIgbGV2ZWwsIHNpemU7XG4gICAgcGFybXMgPSBwYXJtcyB8fCB7XCJsZXZlbFwiOlwiQUFcIiwgXCJzaXplXCI6XCJzbWFsbFwifTtcbiAgICBsZXZlbCA9IChwYXJtcy5sZXZlbCB8fCBcIkFBXCIpLnRvVXBwZXJDYXNlKCk7XG4gICAgc2l6ZSA9IChwYXJtcy5zaXplIHx8IFwic21hbGxcIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGV2ZWwgIT09IFwiQUFcIiAmJiBsZXZlbCAhPT0gXCJBQUFcIikge1xuICAgICAgICBsZXZlbCA9IFwiQUFcIjtcbiAgICB9XG4gICAgaWYgKHNpemUgIT09IFwic21hbGxcIiAmJiBzaXplICE9PSBcImxhcmdlXCIpIHtcbiAgICAgICAgc2l6ZSA9IFwic21hbGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcImxldmVsXCI6bGV2ZWwsIFwic2l6ZVwiOnNpemV9O1xufVxuXG4vLyBOb2RlOiBFeHBvcnQgZnVuY3Rpb25cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0aW55Y29sb3I7XG59XG4vLyBBTUQvcmVxdWlyZWpzOiBEZWZpbmUgdGhlIG1vZHVsZVxuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtyZXR1cm4gdGlueWNvbG9yO30pO1xufVxuLy8gQnJvd3NlcjogRXhwb3NlIHRvIHdpbmRvd1xuZWxzZSB7XG4gICAgd2luZG93LnRpbnljb2xvciA9IHRpbnljb2xvcjtcbn1cblxufSkoKTtcbiIsIi8qXG4gKiBUb2FzdHJcbiAqIENvcHlyaWdodCAyMDEyLTIwMTVcbiAqIEF1dGhvcnM6IEpvaG4gUGFwYSwgSGFucyBGasOkbGxlbWFyaywgYW5kIFRpbSBGZXJyZWxsLlxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFVzZSwgcmVwcm9kdWN0aW9uLCBkaXN0cmlidXRpb24sIGFuZCBtb2RpZmljYXRpb24gb2YgdGhpcyBjb2RlIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZFxuICogY29uZGl0aW9ucyBvZiB0aGUgTUlUIGxpY2Vuc2UsIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIEFSSUEgU3VwcG9ydDogR3JldGEgS3JhZnNpZ1xuICpcbiAqIFByb2plY3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9Db2RlU2V2ZW4vdG9hc3RyXG4gKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cbjsgKGZ1bmN0aW9uIChkZWZpbmUpIHtcbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZnVuY3Rpb24gKCQpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcjtcbiAgICAgICAgICAgIHZhciB0b2FzdElkID0gMDtcbiAgICAgICAgICAgIHZhciB0b2FzdFR5cGUgPSB7XG4gICAgICAgICAgICAgICAgZXJyb3I6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgaW5mbzogJ2luZm8nLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiAnd2FybmluZydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0b2FzdHIgPSB7XG4gICAgICAgICAgICAgICAgY2xlYXI6IGNsZWFyLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBpbmZvOiBpbmZvLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzIuMS4yJyxcbiAgICAgICAgICAgICAgICB3YXJuaW5nOiB3YXJuaW5nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNUb2FzdDtcblxuICAgICAgICAgICAgcmV0dXJuIHRvYXN0cjtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCB0aXRsZSwgb3B0aW9uc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvYXN0VHlwZS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiBnZXRPcHRpb25zKCkuaWNvbkNsYXNzZXMuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNPdmVycmlkZTogb3B0aW9uc092ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGFpbmVyKG9wdGlvbnMsIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0gZ2V0T3B0aW9ucygpOyB9XG4gICAgICAgICAgICAgICAgJGNvbnRhaW5lciA9ICQoJyMnICsgb3B0aW9ucy5jb250YWluZXJJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCRjb250YWluZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICRjb250YWluZXIgPSBjcmVhdGVDb250YWluZXIob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpbmZvKG1lc3NhZ2UsIHRpdGxlLCBvcHRpb25zT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9hc3RUeXBlLmluZm8sXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogZ2V0T3B0aW9ucygpLmljb25DbGFzc2VzLmluZm8sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNPdmVycmlkZTogb3B0aW9uc092ZXJyaWRlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3VjY2VzcyhtZXNzYWdlLCB0aXRsZSwgb3B0aW9uc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvYXN0VHlwZS5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3M6IGdldE9wdGlvbnMoKS5pY29uQ2xhc3Nlcy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zT3ZlcnJpZGU6IG9wdGlvbnNPdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSwgdGl0bGUsIG9wdGlvbnNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2FzdFR5cGUud2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzOiBnZXRPcHRpb25zKCkuaWNvbkNsYXNzZXMud2FybmluZyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc092ZXJyaWRlOiBvcHRpb25zT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhcigkdG9hc3RFbGVtZW50LCBjbGVhck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoISRjb250YWluZXIpIHsgZ2V0Q29udGFpbmVyKG9wdGlvbnMpOyB9XG4gICAgICAgICAgICAgICAgaWYgKCFjbGVhclRvYXN0KCR0b2FzdEVsZW1lbnQsIG9wdGlvbnMsIGNsZWFyT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb250YWluZXIob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmUoJHRvYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIGlmICghJGNvbnRhaW5lcikgeyBnZXRDb250YWluZXIob3B0aW9ucyk7IH1cbiAgICAgICAgICAgICAgICBpZiAoJHRvYXN0RWxlbWVudCAmJiAkKCc6Zm9jdXMnLCAkdG9hc3RFbGVtZW50KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVG9hc3QoJHRvYXN0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRjb250YWluZXIuY2hpbGRyZW4oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgJGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGludGVybmFsIGZ1bmN0aW9uc1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhckNvbnRhaW5lciAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciB0b2FzdHNUb0NsZWFyID0gJGNvbnRhaW5lci5jaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0b2FzdHNUb0NsZWFyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVG9hc3QoJCh0b2FzdHNUb0NsZWFyW2ldKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhclRvYXN0ICgkdG9hc3RFbGVtZW50LCBvcHRpb25zLCBjbGVhck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9yY2UgPSBjbGVhck9wdGlvbnMgJiYgY2xlYXJPcHRpb25zLmZvcmNlID8gY2xlYXJPcHRpb25zLmZvcmNlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCR0b2FzdEVsZW1lbnQgJiYgKGZvcmNlIHx8ICQoJzpmb2N1cycsICR0b2FzdEVsZW1lbnQpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudFtvcHRpb25zLmhpZGVNZXRob2RdKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmhpZGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5oaWRlRWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgcmVtb3ZlVG9hc3QoJHRvYXN0RWxlbWVudCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgJGNvbnRhaW5lciA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIG9wdGlvbnMuY29udGFpbmVySWQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhvcHRpb25zLnBvc2l0aW9uQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3JvbGUnLCAnYWxlcnQnKTtcblxuICAgICAgICAgICAgICAgICRjb250YWluZXIuYXBwZW5kVG8oJChvcHRpb25zLnRhcmdldCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXREZWZhdWx0cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YXBUb0Rpc21pc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRvYXN0Q2xhc3M6ICd0b2FzdCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcklkOiAndG9hc3QtY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgZGVidWc6IGZhbHNlLFxuXG4gICAgICAgICAgICAgICAgICAgIHNob3dNZXRob2Q6ICdmYWRlSW4nLCAvL2ZhZGVJbiwgc2xpZGVEb3duLCBhbmQgc2hvdyBhcmUgYnVpbHQgaW50byBqUXVlcnlcbiAgICAgICAgICAgICAgICAgICAgc2hvd0R1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICAgICAgICAgIHNob3dFYXNpbmc6ICdzd2luZycsIC8vc3dpbmcgYW5kIGxpbmVhciBhcmUgYnVpbHQgaW50byBqUXVlcnlcbiAgICAgICAgICAgICAgICAgICAgb25TaG93bjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBoaWRlTWV0aG9kOiAnZmFkZU91dCcsXG4gICAgICAgICAgICAgICAgICAgIGhpZGVEdXJhdGlvbjogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUVhc2luZzogJ3N3aW5nJyxcbiAgICAgICAgICAgICAgICAgICAgb25IaWRkZW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VNZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZUR1cmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VFYXNpbmc6IGZhbHNlLFxuXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkVGltZU91dDogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkNsYXNzZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAndG9hc3QtZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbzogJ3RvYXN0LWluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogJ3RvYXN0LXN1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZzogJ3RvYXN0LXdhcm5pbmcnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzczogJ3RvYXN0LWluZm8nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkNsYXNzOiAndG9hc3QtdG9wLXJpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgdGltZU91dDogNTAwMCwgLy8gU2V0IHRpbWVPdXQgYW5kIGV4dGVuZGVkVGltZU91dCB0byAwIHRvIG1ha2UgaXQgc3RpY2t5XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlQ2xhc3M6ICd0b2FzdC10aXRsZScsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VDbGFzczogJ3RvYXN0LW1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVIdG1sOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAnYm9keScsXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlSHRtbDogJzxidXR0b24gdHlwZT1cImJ1dHRvblwiPiZ0aW1lczs8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgICAgICBuZXdlc3RPblRvcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudER1cGxpY2F0ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0JhcjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwdWJsaXNoKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RlbmVyKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBub3RpZnkobWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgdmFyIGljb25DbGFzcyA9IG1hcC5pY29uQ2xhc3MgfHwgb3B0aW9ucy5pY29uQ2xhc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChtYXAub3B0aW9uc092ZXJyaWRlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKG9wdGlvbnMsIG1hcC5vcHRpb25zT3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpY29uQ2xhc3MgPSBtYXAub3B0aW9uc092ZXJyaWRlLmljb25DbGFzcyB8fCBpY29uQ2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEV4aXQob3B0aW9ucywgbWFwKSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIHRvYXN0SWQrKztcblxuICAgICAgICAgICAgICAgICRjb250YWluZXIgPSBnZXRDb250YWluZXIob3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyICR0b2FzdEVsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgJHRpdGxlRWxlbWVudCA9ICQoJzxkaXYvPicpO1xuICAgICAgICAgICAgICAgIHZhciAkbWVzc2FnZUVsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcbiAgICAgICAgICAgICAgICB2YXIgJHByb2dyZXNzRWxlbWVudCA9ICQoJzxkaXYvPicpO1xuICAgICAgICAgICAgICAgIHZhciAkY2xvc2VFbGVtZW50ID0gJChvcHRpb25zLmNsb3NlSHRtbCk7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzQmFyID0ge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbElkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXhIaWRlVGltZTogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICB0b2FzdElkOiB0b2FzdElkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbWFwXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHBlcnNvbmFsaXplVG9hc3QoKTtcblxuICAgICAgICAgICAgICAgIGRpc3BsYXlUb2FzdCgpO1xuXG4gICAgICAgICAgICAgICAgaGFuZGxlRXZlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICBwdWJsaXNoKHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnICYmIGNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAkdG9hc3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZXNjYXBlSHRtbChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZyhzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMzk7JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcGVyc29uYWxpemVUb2FzdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SWNvbigpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaXRsZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldENsb3NlQnV0dG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFByb2dyZXNzQmFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRzKCkge1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmhvdmVyKHN0aWNrQXJvdW5kLCBkZWxheWVkSGlkZVRvYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLm9uY2xpY2sgJiYgb3B0aW9ucy50YXBUb0Rpc21pc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuY2xpY2soaGlkZVRvYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNsb3NlQnV0dG9uICYmICRjbG9zZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjbG9zZUVsZW1lbnQuY2xpY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlVG9hc3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQuY2xpY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlVG9hc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGlzcGxheVRvYXN0KCkge1xuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmhpZGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50W29wdGlvbnMuc2hvd01ldGhvZF0oXG4gICAgICAgICAgICAgICAgICAgICAgICB7ZHVyYXRpb246IG9wdGlvbnMuc2hvd0R1cmF0aW9uLCBlYXNpbmc6IG9wdGlvbnMuc2hvd0Vhc2luZywgY29tcGxldGU6IG9wdGlvbnMub25TaG93bn1cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lT3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldFRpbWVvdXQoaGlkZVRvYXN0LCBvcHRpb25zLnRpbWVPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWUgPSBwYXJzZUZsb2F0KG9wdGlvbnMudGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5oaWRlRXRhID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByb2dyZXNzQmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHVwZGF0ZVByb2dyZXNzLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRJY29uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmljb25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5hZGRDbGFzcyhvcHRpb25zLnRvYXN0Q2xhc3MpLmFkZENsYXNzKGljb25DbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRTZXF1ZW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubmV3ZXN0T25Ub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjb250YWluZXIucHJlcGVuZCgkdG9hc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRjb250YWluZXIuYXBwZW5kKCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0VGl0bGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAudGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aXRsZUVsZW1lbnQuYXBwZW5kKCFvcHRpb25zLmVzY2FwZUh0bWwgPyBtYXAudGl0bGUgOiBlc2NhcGVIdG1sKG1hcC50aXRsZSkpLmFkZENsYXNzKG9wdGlvbnMudGl0bGVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LmFwcGVuZCgkdGl0bGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldE1lc3NhZ2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJG1lc3NhZ2VFbGVtZW50LmFwcGVuZCghb3B0aW9ucy5lc2NhcGVIdG1sID8gbWFwLm1lc3NhZ2UgOiBlc2NhcGVIdG1sKG1hcC5tZXNzYWdlKSkuYWRkQ2xhc3Mob3B0aW9ucy5tZXNzYWdlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5hcHBlbmQoJG1lc3NhZ2VFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldENsb3NlQnV0dG9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGNsb3NlRWxlbWVudC5hZGRDbGFzcygndG9hc3QtY2xvc2UtYnV0dG9uJykuYXR0cigncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQucHJlcGVuZCgkY2xvc2VFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFByb2dyZXNzQmFyKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcm9ncmVzc0Jhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHByb2dyZXNzRWxlbWVudC5hZGRDbGFzcygndG9hc3QtcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQucHJlcGVuZCgkcHJvZ3Jlc3NFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZEV4aXQob3B0aW9ucywgbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZXZlbnREdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwLm1lc3NhZ2UgPT09IHByZXZpb3VzVG9hc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUb2FzdCA9IG1hcC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoaWRlVG9hc3Qob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG92ZXJyaWRlICYmIG9wdGlvbnMuY2xvc2VNZXRob2QgIT09IGZhbHNlID8gb3B0aW9ucy5jbG9zZU1ldGhvZCA6IG9wdGlvbnMuaGlkZU1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gb3ZlcnJpZGUgJiYgb3B0aW9ucy5jbG9zZUR1cmF0aW9uICE9PSBmYWxzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNsb3NlRHVyYXRpb24gOiBvcHRpb25zLmhpZGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVhc2luZyA9IG92ZXJyaWRlICYmIG9wdGlvbnMuY2xvc2VFYXNpbmcgIT09IGZhbHNlID8gb3B0aW9ucy5jbG9zZUVhc2luZyA6IG9wdGlvbnMuaGlkZUVhc2luZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQoJzpmb2N1cycsICR0b2FzdEVsZW1lbnQpLmxlbmd0aCAmJiAhb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocHJvZ3Jlc3NCYXIuaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdG9hc3RFbGVtZW50W21ldGhvZF0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uSGlkZGVuICYmIHJlc3BvbnNlLnN0YXRlICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uSGlkZGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXRlID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGlzaChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWRIaWRlVG9hc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwIHx8IG9wdGlvbnMuZXh0ZW5kZWRUaW1lT3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldFRpbWVvdXQoaGlkZVRvYXN0LCBvcHRpb25zLmV4dGVuZGVkVGltZU91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5tYXhIaWRlVGltZSA9IHBhcnNlRmxvYXQob3B0aW9ucy5leHRlbmRlZFRpbWVPdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NCYXIuaGlkZUV0YSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcHJvZ3Jlc3NCYXIubWF4SGlkZVRpbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdGlja0Fyb3VuZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Jhci5oaWRlRXRhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgJHRvYXN0RWxlbWVudC5zdG9wKHRydWUsIHRydWUpW29wdGlvbnMuc2hvd01ldGhvZF0oXG4gICAgICAgICAgICAgICAgICAgICAgICB7ZHVyYXRpb246IG9wdGlvbnMuc2hvd0R1cmF0aW9uLCBlYXNpbmc6IG9wdGlvbnMuc2hvd0Vhc2luZ31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSAoKHByb2dyZXNzQmFyLmhpZGVFdGEgLSAobmV3IERhdGUoKS5nZXRUaW1lKCkpKSAvIHByb2dyZXNzQmFyLm1heEhpZGVUaW1lKSAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgJHByb2dyZXNzRWxlbWVudC53aWR0aChwZXJjZW50YWdlICsgJyUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBnZXREZWZhdWx0cygpLCB0b2FzdHIub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZVRvYXN0KCR0b2FzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoISRjb250YWluZXIpIHsgJGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpOyB9XG4gICAgICAgICAgICAgICAgaWYgKCR0b2FzdEVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkdG9hc3RFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICR0b2FzdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICgkY29udGFpbmVyLmNoaWxkcmVuKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICRjb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVG9hc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pKCk7XG4gICAgfSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uIChkZXBzLCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vTm9kZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnRvYXN0ciA9IGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG4gICAgfVxufSkpO1xuIiwidmFyIHRlbXBsYXRlU3lzdGVtID0gcmVxdWlyZSgnLi4vc3JjL2pzL2JpbmRpbmdzL2Nob29zZS10ZW1wbGF0ZS5qcycpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYXJyYXlcIiwgXCI8IS0tIGtvIGZvcmVhY2g6ICRkYXRhIC0tPjwhLS0ga28gYmxvY2s6ICRkYXRhIC0tPjwhLS0gL2tvIC0tPjwhLS0gL2tvIC0tPlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJibG9jay1zaG93XCIsIFwiPCEtLSBrbyBibG9jazogJGRhdGEsIHNjcm9sbEludG9WaWV3OiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgPT09ICRkYXRhIC0tPjwhLS0gL2tvIC0tPlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJibG9jay13eXNpd3lnXCIsIFwiPGRpdiBjbGFzcz1cXHgyMmVkaXRhYmxlIGJsb2NrXFx4MjIgZGF0YS1kcm9wLWNvbnRlbnQ9XFx4MjJEcm9wIGhlcmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7ICdkYXRhLWRyb3AtY29udGVudCc6ICRyb290LnQoJ0Ryb3AgaGVyZScpIH0sIGNsaWNrOiBmdW5jdGlvbihvYmosIGV2dCkgeyAkcm9vdC5zZWxlY3RCbG9jayhvYmopOyByZXR1cm4gdHJ1ZSB9LCBjbGlja0J1YmJsZTogZmFsc2UsIGNzczogeyBzZWxlY3RlZDogJHJvb3Quc2VsZWN0ZWRCbG9jaygpID09PSAkZGF0YSB9LCBzY3JvbGxJbnRvVmlldzogJHJvb3Quc2VsZWN0ZWRCbG9jaygpID09PSAkZGF0YVxceDIyPiAgPGRpdiBjbGFzcz1cXHgyMm1vLWJsb2Nrc2VsZWN0aW9uaGVscGVyXFx4MjI+PC9kaXY+ICA8ZGl2IGNsYXNzPVxceDIydG9vbHNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRpbmRleCAhPSAndW5kZWZpbmVkJyAtLT4gICAgPGRpdiB0aXRsZT1cXHgyMkRyYWcgdGhpcyBoYW5kbGUgdG8gbW92ZSB0aGUgYmxvY2tcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdEcmFnIHRoaXMgaGFuZGxlIHRvIG1vdmUgdGhlIGJsb2NrJykgfVxceDIyIGNsYXNzPVxceDIydG9vbCBoYW5kbGVcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXNvcnRcXHgyMj48L2k+PC9kaXY+ICAgIDwhLS0ga28gaWY6ICRpbmRleCgpID4gMCAtLT4gICAgPGRpdiB0aXRsZT1cXHgyMk1vdmUgdGhpcyBibG9jayB1cHNpZGVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdNb3ZlIHRoaXMgYmxvY2sgdXBzaWRlJykgfVxceDIyIGNsYXNzPVxceDIydG9vbCBtb3ZldXBcXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXNvcnQtYXNjXFx4MjIgZGF0YS1iaW5kPSdjbGljazogJHJvb3QubW92ZUJsb2NrLmJpbmQoJGVsZW1lbnQsICRpbmRleCwgJHBhcmVudCwgdHJ1ZSknPjwvaT48L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6ICRpbmRleCgpIDwgJHBhcmVudC5ibG9ja3MoKS5sZW5ndGggLTEgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJNb3ZlIHRoaXMgYmxvY2sgZG93bnNpZGVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdNb3ZlIHRoaXMgYmxvY2sgZG93bnNpZGUnKSB9XFx4MjIgY2xhc3M9XFx4MjJ0b29sIG1vdmVkb3duXFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1zb3J0LWRlc2NcXHgyMiBkYXRhLWJpbmQ9J2NsaWNrOiAkcm9vdC5tb3ZlQmxvY2suYmluZCgkZWxlbWVudCwgJGluZGV4LCAkcGFyZW50LCBmYWxzZSknPjwvaT48L2Rpdj4gICAgPCEtLSAva28gLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJEZWxldGUgYmxvY2tcXHgyMiBjbGFzcz1cXHgyMnRvb2wgZGVsZXRlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnRGVsZXRlIGJsb2NrJykgfSwgY2xpY2s6ICRyb290LnJlbW92ZUJsb2NrLmJpbmQoJGVsZW1lbnQsICRyYXdEYXRhLCAkcGFyZW50KVxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtdHJhc2gtb1xceDIyPjwvaT48L2Rpdj4gICAgPGRpdiB0aXRsZT1cXHgyMkR1cGxpY2F0ZSBibG9ja1xceDIyIGNsYXNzPVxceDIydG9vbCBjbG9uZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0R1cGxpY2F0ZSBibG9jaycpIH0sIGNsaWNrOiAkcm9vdC5kdXBsaWNhdGVCbG9jay5iaW5kKCRlbGVtZW50LCAkaW5kZXgsICRwYXJlbnQpXFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1maWxlcy1vXFx4MjI+PC9pPjwvZGl2PiAgICA8IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRkYXRhLl9uZXh0VmFyaWFudCAhPSAndW5kZWZpbmVkJyAtLT48ZGl2IHRpdGxlPVxceDIyU3dpdGNoIGJsb2NrIHZhcmlhbnRcXHgyMiBjbGFzcz1cXHgyMnRvb2wgdmFyaWFudFxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1N3aXRjaCBibG9jayB2YXJpYW50JykgfSwgY2xpY2s6ICRkYXRhLl9uZXh0VmFyaWFudFxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtbWFnaWNcXHgyMj48L2k+PC9kaXY+PCEtLSAva28gLS0+ICA8L2Rpdj4gIDwhLS0ga28gYmxvY2s6ICRkYXRhIC0tPjwhLS0gL2tvIC0tPjwvZGl2PlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJibG9ja3Mtc2hvd1wiLCBcIjwhLS0ga28gdGVtcGxhdGU6IHsgbmFtZTogJ2Jsb2NrLXNob3cnLCBmb3JlYWNoOiBibG9ja3MgfSAtLT48IS0tIC9rbyAtLT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwiYmxvY2tzLXd5c2l3eWdcIiwgXCI8ZGl2IGNsYXNzPVxceDIyc29ydGFibGUtYmxvY2tzLWVkaXRcXHgyMiBkYXRhLWRyb3AtY29udGVudD1cXHgyMkRyb3AgaGVyZVxceDIyIGRhdGEtZW1wdHktY29udGVudD1cXHgyMkRyb3AgaGVyZSBibG9ja3MgZnJvbSB0aGUgQmxvY2tzIHRhYlxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgJ2RhdGEtZHJvcC1jb250ZW50JzogJHJvb3QudCgnRHJvcCBoZXJlJyksICdkYXRhLWVtcHR5LWNvbnRlbnQnOiAkcm9vdC50KCdEcm9wIGhlcmUgYmxvY2tzIGZyb20gdGhlICZxdW90O0Jsb2NrcyZxdW90OyB0YWInKSB9LCBjc3M6IHsgJ2VtcHR5Jzoga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShibG9ja3MpLmxlbmd0aCA9PSAwIH0sIGV4dHNvcnRhYmxlOiB7IGNvbm5lY3RDbGFzczogJ3NvcnRhYmxlLWJsb2Nrcy1lZGl0JywgdGVtcGxhdGU6ICdibG9jay13eXNpd3lnJywgZGF0YTogYmxvY2tzLCBkcmFnZ2luZzogJHJvb3QuZHJhZ2dpbmcsIGJlZm9yZU1vdmU6ICRyb290LnN0YXJ0TXVsdGlwbGUsIGFmdGVyTW92ZTogJHJvb3Quc3RvcE11bHRpcGxlLCBvcHRpb25zOiB7IGhhbmRsZTogJy5oYW5kbGUnLCBwbGFjZWhvbGRlcjogJHJvb3QucGxhY2Vob2xkZXJIZWxwZXIgfSB9XFx4MjI+PC9kaXY+XCIpO1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImN1c3RvbXN0eWxlXCIsIFwiPGRpdiBjbGFzcz1cXHgyMmN1c3RvbVN0eWxlSGVscFxceDIyIGRhdGEtYmluZD1cXHgyMmh0bWw6ICRyb290LnQoJ0N1c3RvbWl6ZWQgYmxvY2suPHVsPjxsaT5JbiB0aGlzIHN0YXR1cyBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgd2lsbCBiZSBzcGVjaWZpYyB0byB0aGUgY3VycmVudCBibG9jayAoaW5zdGVhZCBvZiBiZWluZyBnbG9iYWwgdG8gYWxsIGJsb2NrcyBpbiB0aGUgc2FtZSBzZWN0aW9uKTwvbGk+PGxpPkEgPHNwYW4gY2xhc3M9JnF1b3Q7Y3VzdG9tU3R5bGVkJnF1b3Q7PjxzcGFuPiZxdW90O3NtYWxsIGN1YmUmcXVvdDsgPC9zcGFuPjwvc3Bhbj4gaWNvbiBiZXNpZGUgdGhlIHByb3BlcnR5IHdpbGwgbWFyayB0aGUgY3VzdG9taXphdGlvbi4gQnkgY2xpY2tpbmcgdGhpcyBpY29uIHRoZSBwcm9wZXJ0eSB2YWx1ZSB3aWxsIGJlIHJldmVydGVkIHRvIHRoZSB2YWx1ZSBkZWZpbmVkIGZvciB0aGUgc2VjdGlvbi48L2xpPjwvdWw+JylcXHgyMj5DdXN0b21pemVkIGJsb2NrLjx1bD48bGk+SW4gdGhpcyBzdGF0dXMgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIHdpbGwgYmUgc3BlY2lmaWMgdG8gdGhlIGN1cnJlbnQgYmxvY2sgKGluc3RlYWQgb2YgYmVpbmcgZ2xvYmFsIHRvIGFsbCBibG9ja3MgaW4gdGhlIHNhbWUgc2VjdGlvbik8L2xpPjxsaT5BIDxzcGFuIGNsYXNzPVxceDIyY3VzdG9tU3R5bGVkXFx4MjI+PHNwYW4+XFx4MjJzbWFsbCBjdWJlXFx4MjIgPC9zcGFuPjwvc3Bhbj4gaWNvbiBiZXNpZGUgdGhlIHByb3BlcnR5IHdpbGwgbWFyayB0aGUgY3VzdG9taXphdGlvbi4gQnkgY2xpY2tpbmcgdGhpcyBpY29uIHRoZSBwcm9wZXJ0eSB2YWx1ZSB3aWxsIGJlIHJldmVydGVkIHRvIHRoZSB2YWx1ZSBkZWZpbmVkIGZvciB0aGUgc2VjdGlvbi48L2xpPjwvdWw+PC9kaXY+XCIpO1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImVtcHR5XCIsIFwiXCIpO1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImVycm9yXCIsIFwiWzxkaXYgc3R5bGU9XFx4MjJiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmMGYwXFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDoga28udG9KUygkZGF0YSlcXHgyMj48L2Rpdj5dXCIpO1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImdhbGxlcnktaW1hZ2VzXCIsIFwiPGRpdiBkYXRhLWJpbmQ9XFx4MjJmb3JlYWNoOiBpdGVtcy5jdXJyZW50UGFnZURhdGFcXHgyMj4gIDxkaXYgY2xhc3M9XFx4MjJkcmFnZ2FibGUtaXRlbVxceDIyIGRhdGEtYmluZD1cXHgyMmlmOiB0eXBlb2YgdGh1bWJuYWlsVXJsICE9ICd1bmRlZmluZWQnXFx4MjI+ICAgIDxkaXYgY2xhc3M9XFx4MjJkcmFnZ2FibGUgaW1hZ2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuYWRkSW1hZ2UsIGV4dGRyYWdnYWJsZTogeyBkYXRhOiAkZGF0YSwgZHJvcENvbnRhaW5lcjogJyNtYWluLXd5c2l3eWctYXJlYScsIGRyYWdnaW5nOiAkcm9vdC5kcmFnZ2luZ0ltYWdlLCAnb3B0aW9ucyc6IHsgJ2FwcGVuZFRvJzogJyNwYWdlJyB9IH0sIHN0eWxlOiB7IGJhY2tncm91bmRJbWFnZTogJ3VybChcXFxcJycgKyB0aHVtYm5haWxVcmwgKyAnXFxcXCcpJyB9XFx4MjI+ICAgICAgPGltZyB0aXRsZT1cXHgyMlRyYXNjaW5hIHF1ZXN0YSBpbW1hZ2luZSBzdWxsYSBwb3NpemlvbmUgaW4gY3VpIHZ1b2kgaW5zZXJpcmxhXFx4MjIgc3R5bGU9XFx4MjJkaXNwbGF5OiBibG9jaztcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge30sIGF0dHI6IHsgc3JjOiB0aHVtYm5haWxVcmwgfVxceDIyLz4gICAgPC9kaXY+ICA8L2Rpdj48L2Rpdj48IS0tIGtvIGlmOiBpdGVtcy5wYWdlQ291bnQoKSA+IDEgLS0+PGRpdiBjbGFzcz1cXHgyMmdhbGxlcnlQYWdlclxceDIyIGRhdGEtYmluZD1cXHgyMmJ1dHRvbnNldDoge31cXHgyMj4gIDxhIGhyZWY9XFx4MjIjXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6IGl0ZW1zLm1vdmVGaXJzdCwgYnV0dG9uOiB7IGRpc2FibGVkOiBpdGVtcy5jdXJyZW50UGFnZSgpID09IDEsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mYXN0LWJhY2t3YXJkJyB9LCB0ZXh0OiBmYWxzZSB9XFx4MjI+Rmlyc3Q8L2E+ICA8YSBocmVmPVxceDIyI1xceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiBpdGVtcy5tb3ZlUHJldmlvdXMsIGJ1dHRvbjogeyBkaXNhYmxlZDogaXRlbXMuY3VycmVudFBhZ2UoKSA9PSAxLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtYmFja3dhcmQnIH0sIHRleHQ6IGZhbHNlIH1cXHgyMj5QcmV2aW91czwvYT4gIDxzcGFuIGRhdGEtYmluZD1cXHgyMmJ1dHRvbjogeyBkaXNhYmxlZDogdHJ1ZSwgdGV4dDogdHJ1ZSwgbGFiZWw6ICcgJytpdGVtcy5jdXJyZW50UGFnZSgpKycgZGkgJytpdGVtcy5wYWdlQ291bnQoKSsnICcgfVxceDIyPiBYIGRpIFkgPC9zcGFuPiAgPGEgaHJlZj1cXHgyMiNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogaXRlbXMubW92ZU5leHQsIGJ1dHRvbjogeyBkaXNhYmxlZDogaXRlbXMuY3VycmVudFBhZ2UoKSA9PSBpdGVtcy5wYWdlQ291bnQoKSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZvcndhcmQnIH0sIHRleHQ6IGZhbHNlIH1cXHgyMj5OZXh0PC9hPiAgPGEgaHJlZj1cXHgyMiNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogaXRlbXMubW92ZUxhc3QsIGJ1dHRvbjogeyBkaXNhYmxlZDogaXRlbXMuY3VycmVudFBhZ2UoKSA9PSBpdGVtcy5wYWdlQ291bnQoKSwgaWNvbnM6IHsgcHJpbWFyeTogJ2ZhIGZhLWZhc3QtZm9yd2FyZCcgfSwgdGV4dDogZmFsc2UgfVxceDIyPkxhc3Q8L2E+PC9kaXY+PCEtLSAva28gLS0+XCIpO1xuICB0ZW1wbGF0ZVN5c3RlbS5hZGRUZW1wbGF0ZShcImltZy13eXNpd3lnXCIsIFwiPHRhYmxlIHRhYmZvY3VzPVxceDIyMFxceDIyIGNlbGxzcGFjaW5nPVxceDIyMFxceDIyIGNlbGxwYWRkaW5nPVxceDIyMFxceDIyIGRhdGEtZHJvcC1jb250ZW50PVxceDIyRHJvcCBoZXJlXFx4MjIgZGF0YS1iaW5kPVxceDIyc3R5bGU6IF9zdHlsZWJpbmQsIGNsaWNrOiBmdW5jdGlvbihvYmosIGV2dCkgeyAkcm9vdC5zZWxlY3RJdGVtKF9pdGVtLCBfZGF0YSk7IHJldHVybiB0cnVlOyB9LCBjbGlja0J1YmJsZTogZmFsc2UsIGZ1ZHJvcHBhYmxlOiB7IGFjdGl2ZUNsYXNzOiAndWktc3RhdGUtaGlnaGxpZ2h0JywgaG92ZXJDbGFzczogJ3VpLXN0YXRlLWRyYWdob3ZlcicgfSwgZHJvcHBhYmxlOiB7IG9wdGlvbnM6IHsgYWNjZXB0OiAnLmltYWdlJywgYWN0aXZlQ2xhc3M6ICd1aS1zdGF0ZS1oaWdobGlnaHQnLCBob3ZlckNsYXNzOiAndWktc3RhdGUtZHJhZ2hvdmVyJyB9LCBkYXRhOiBfc3JjLCBkcmFnZ2VkOiAkcm9vdC5maWxlVG9JbWFnZSB9LCBjc3M6IHsgc2VsZWN0ZWRpdGVtOiAkcm9vdC5pc1NlbGVjdGVkSXRlbShfaXRlbSkgfSwgc2Nyb2xsSW50b1ZpZXc6ICRyb290LmlzU2VsZWN0ZWRJdGVtKF9pdGVtKSwgYXR0cjogeyAnZGF0YS1kcm9wLWNvbnRlbnQnOiAkcm9vdC50KCdEcm9wIGhlcmUnKSwgd2lkdGg6IF93aWR0aCwgaGVpZ2h0OiBfaGVpZ2h0LCBhbGlnbjogX2FsaWduIH1cXHgyMiAgY2xhc3M9XFx4MjJpbWctd3lzaXd5ZyBzZWxlY3RhYmxlLWltZ1xceDIyIHN0eWxlPVxceDIyZGlzcGxheTogdGFibGU7XFx4MjI+PHRyPjx0ZCBjbGFzcz1cXHgyMnVwbG9hZHpvbmVcXHgyMj4gIDxkaXYgY2xhc3M9XFx4MjJtby1pbWdzZWxlY3Rpb25oZWxwZXJcXHgyMj48L2Rpdj4gIDxkaXYgY2xhc3M9XFx4MjJtby11cGxvYWR6b25lXFx4MjI+PC9kaXY+ICA8ZGl2IGNsYXNzPVxceDIyaW1nLXNpemVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiBfc2l6ZVxceDIyPnNpemU8L2Rpdj4gIDxkaXYgY2xhc3M9XFx4MjJtaWR0b29sc1xceDIyIGRhdGEtYmluZD1cXHgyMnRvb2x0aXBzOiB7fVxceDIyPiAgICA8IS0tIGtvIGlmOiBfc3JjKCkgIT0gJycgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJSZW1vdmUgaW1hZ2VcXHgyMiBjbGFzcz1cXHgyMnRvb2wgZGVsZXRlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnUmVtb3ZlIGltYWdlJykgfSwgY2xpY2s6IF9zcmMuYmluZChfc3JjLCAnJyksIGNsaWNrQnViYmxlOiBmYWxzZVxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtdHJhc2gtb1xceDIyPjwvaT48L2Rpdj4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRyb290LmVkaXRJbWFnZSAhPT0gJ3VuZGVmaW5lZCcgLS0+ICAgIDxkaXYgdGl0bGU9XFx4MjJPcGVuIHRoZSBpbWFnZSBlZGl0aW5nIHRvb2xcXHgyMiBjbGFzcz1cXHgyMnRvb2wgZWRpdFxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ09wZW4gdGhlIGltYWdlIGVkaXRpbmcgdG9vbCcpIH0sIGNsaWNrOiAkcm9vdC5lZGl0SW1hZ2UuYmluZCgkZWxlbWVudCwgX3NyYyksIGNsaWNrQnViYmxlOiBmYWxzZVxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtcGVuY2lsXFx4MjI+PC9pPjwvZGl2PiAgICA8IS0tIC9rbyAtLT4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6IF9zcmMoKSA9PSAnJyAtLT4gICAgPGRpdiB0aXRsZT1cXHgyMlVwbG9hZCBhIG5ldyBpbWFnZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1VwbG9hZCBhIG5ldyBpbWFnZScpIH1cXHgyMiBjbGFzcz1cXHgyMnRvb2wgdXBsb2FkXFx4MjIgc3R5bGU9XFx4MjJwb3NpdGlvbjogcmVsYXRpdmU7IG92ZXJmbG93OiBoaWRkZW47XFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS11cGxvYWRcXHgyMj48L2k+ICAgICAgPGlucHV0IGNsYXNzPVxceDIyZmlsZXVwbG9hZCBub2ZpbGVcXHgyMiB0eXBlPVxceDIyZmlsZVxceDIyIG5hbWU9XFx4MjJmaWxlc1tdXFx4MjIgZGF0YS1iaW5kPVxceDIyZmlsZXVwbG9hZDogeyBkYXRhOiBfc3JjLCBvbmVycm9yOiAkcm9vdC5ub3RpZmllci5lcnJvciwgb25maWxlOiAkcm9vdC5sb2FkSW1hZ2UsIGNhbnZhc1ByZXZpZXc6IHRydWUgfVxceDIyIHN0eWxlPVxceDIyei1pbmRleDogMjA7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBtaW4td2lkdGg6IDEwMCU7IG1pbi1oZWlnaHQ6IDEwMCU7IGZvbnQtc2l6ZTogOTk5cHg7IHRleHQtYWxpZ246IHJpZ2h0OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9MCk7IG9wYWNpdHk6IDA7IG91dGxpbmU6IG5vbmU7IGN1cnNvcjogaW5oZXJpdDsgZGlzcGxheTogYmxvY2tcXHgyMj4gICAgPC9kaXY+ICAgIDwhLS0gL2tvIC0tPiAgPC9kaXY+ICA8IS0tIGtvIHRlbXBsYXRlOiBfdGVtcGxhdGUgLS0+PCEtLSAva28gLS0+ICA8IS0tIGtvIGlmOiBfc3JjKCkgPT0gJycgLS0+ICAgIDwhLS0gICAgPGltZyBzdHlsZT1cXHgyMmRpc3BsYXk6IGJsb2NrO1xceDIyIGNsYXNzPVxceDIyaW1ncGxhY2Vob2xkZXJcXHgyMiB3aWR0aD1cXHgyMjIwMFxceDIyIHNyYz1cXHgyMlxceDIyIGFsdD1cXHgyMkluc2VydCBhbiBpbWFnZSBoZXJlXFx4MjIgZGF0YS1iaW5kPVxceDIyd3lzaXd5Z1NyYzogeyBzcmM6IF9zcmMucHJlbG9hZGVkLCBwbGFjZWhvbGRlcjogX3BsYWNlaG9sZGVyc3JjLCB3aWR0aDogX3dpZHRoLCBoZWlnaHQ6IF9oZWlnaHQsIG1ldGhvZDogX21ldGhvZCB9XFx4MjIgLz4gICAgLS0+ICAgIDxzcGFuIGNsYXNzPVxceDIyZmlsZXVwbG9hZHRleHRcXHgyMiBzdHlsZT1cXHgyMnRleHQtYWxpZ246IGNlbnRlcjsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiBjZW50ZXI7IGZsZXgtYWxpZ246IGNlbnRlcjsganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IHBhZGRpbmc6IDFlbTsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7XFx4MjI+PHNwYW4gY2xhc3M9XFx4MjJ0ZXh0TWlkZGxlXFx4MjIgc3R5bGU9XFx4MjIgdGV4dC1zaGFkb3c6IDFweCAxcHggMCAjRkZGRkZGLCAwIDAgMTBweCAjRkZGRkZGOyBmb250LXdlaWdodDogYm9sZDtcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdEcm9wIGFuIGltYWdlIGhlcmUnKVxceDIyPkRyb3AgYW4gaW1hZ2UgaGVyZTwvc3Bhbj48L3NwYW4+ICA8IS0tIC9rbyAtLT4gIDwhLS0ga28gaWY6IF9zcmMoKSAhPSAnJyAtLT4gIDwhLS0gICAgPGltZyBzdHlsZT1cXHgyMmRpc3BsYXk6IGJsb2NrO1xceDIyIHdpZHRoPVxceDIyMjAwXFx4MjIgc3JjPVxceDIyXFx4MjIgZGF0YS1iaW5kPVxceDIycHJlbG9hZGVyOiBfc3JjLCB3eXNpd3lnU3JjOiB7IHNyYzogX3NyYy5wcmVsb2FkZWQsIHBsYWNlaG9sZGVyOiBfcGxhY2Vob2xkZXJzcmMsIHdpZHRoOiBfd2lkdGgsIGhlaWdodDogX2hlaWdodCwgbWV0aG9kOiBfbWV0aG9kIH1cXHgyMiAvPiAgICAtLT4gIDwhLS0gL2tvIC0tPiAgPCEtLSBwdWxzYW50ZSBwZXIgbGEgY2FuY2VsbGF6aW9uZSAtLT4gIDxkaXYgdGl0bGU9XFx4MjJEcm9wIGFuIGltYWdlIGhlcmUgb3IgY2xpY2sgdGhlIHVwbG9hZCBidXR0b25cXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdEcm9wIGFuIGltYWdlIGhlcmUgb3IgY2xpY2sgdGhlIHVwbG9hZCBidXR0b24nKSB9LCB0b29sdGlwczoge31cXHgyMiBjbGFzcz1cXHgyMndvcmt6b25lXFx4MjIgc3R5bGU9XFx4MjJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgb3ZlcmZsb3c6IGhpZGRlbjtcXHgyMj4gICAgPCEtLSBrbyBpZjogX3NyYy5wcmVsb2FkZWQgJiYgX3NyYygpICE9IF9zcmMucHJlbG9hZGVkKCkgLS0+UFJFTE9BRElORy4uLi48IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogX3NyYygpICE9ICcnIC0tPiAgICAgIDxpbnB1dCBjbGFzcz1cXHgyMmZpbGV1cGxvYWQgd2l0aGZpbGVcXHgyMiB0eXBlPVxceDIyZmlsZVxceDIyIG5hbWU9XFx4MjJmaWxlc1tdXFx4MjIgZGF0YS1iaW5kPVxceDIyZmlsZXVwbG9hZDogeyBkYXRhOiBfc3JjLCBvbmVycm9yOiAkcm9vdC5ub3RpZmllci5lcnJvciwgb25maWxlOiAkcm9vdC5nYWxsZXJ5UmVjZW50LnVuc2hpZnQuYmluZCgkcm9vdC5nYWxsZXJ5UmVjZW50KSwgY2FudmFzUHJldmlldzogdHJ1ZSB9XFx4MjIgc3R5bGU9XFx4MjJ6LWluZGV4OiAtMjA7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBtaW4td2lkdGg6IDEwMCU7IG1pbi1oZWlnaHQ6IDEwMCU7IGZvbnQtemllOiA5OTlweDsgdGV4dC1hbGlnbjogcmlnaHQ7IGZpbHRlcjogYWxwaGEob3BhY2l0eT0wKTsgb3BhY2l0eTogMDsgb3V0bGluZTogbm9uZTsgY3Vyc29yOiBpbmhlcml0OyBkaXNwbGF5OiBibG9ja1xceDIyPiAgICA8IS0tIC9rbyAtLT4gICAgPGRpdiBjbGFzcz1cXHgyMnByb2dyZXNzXFx4MjIgc3R5bGU9XFx4MjJvcGFjaXR5OiAuNTsgd2lkdGg6IDgwJTsgbWFyZ2luLWxlZnQ6IDEwJTsgcG9zaXRpb246IGFic29sdXRlOyBib3R0b206IDMwJTsgaGVpZ2h0OiAyMHB4OyBib3JkZXI6IDJweCBzb2xpZCBibGFjaztcXHgyMj4gICAgICA8ZGl2IGNsYXNzPVxceDIycHJvZ3Jlc3MtYmFyIHByb2dyZXNzLWJhci1zdWNjZXNzXFx4MjIgc3R5bGU9XFx4MjJoZWlnaHQ6IDIwcHg7IGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBcXHgyMj48L2Rpdj4gICAgPC9kaXY+ICA8L2Rpdj48L3RhYmxlPlwiKTtcbiAgdGVtcGxhdGVTeXN0ZW0uYWRkVGVtcGxhdGUoXCJtYWluXCIsIFwiPGRpdiBpZD1cXHgyMnBhZ2VcXHgyMiBzdHlsZT1cXHgyMmRpc3BsYXk6IG5vbmU7XFx4MjIgZGF0YS1iaW5kPVxceDIydmlzaWJsZTogdHJ1ZSwgY3NzOiB7IHdpdGhUb29sYm94OiAkcm9vdC5zaG93VG9vbGJveCwgd2l0aFByZXZpZXdGcmFtZTogc2hvd1ByZXZpZXdGcmFtZSB9XFx4MjI+ICA8ZGl2IGlkPVxceDIybWFpbi1lZGl0LWFyZWFcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0QmxvY2sobnVsbCk7IHJldHVybiB0cnVlOyB9LCBjbGlja0J1YmJsZTogZmFsc2VcXHgyMj4gICAgPCEtLSBrbyB3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6ICd3eXNpd3lnJywgdGVtcGxhdGVNb2RlRmFsbGJhY2s6ICdzaG93JyB9IC0tPiAgICA8ZGl2IGlkPVxceDIybWFpbi13eXNpd3lnLWFyZWFcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ3eXNpd3lnU2Nyb2xsZml4OiB0cnVlLCBzY3JvbGxhYmxlOiB0cnVlLCBmdWRyb3BwYWJsZTogeyBhY3RpdmU6IGRyYWdnaW5nSW1hZ2UgfSwgY3NzOiB7IGlzZHJhZ2dpbmc6IGRyYWdnaW5nLCBpc2RyYWdnaW5naW1nOiBkcmFnZ2luZ0ltYWdlIH0sIGJsb2NrOiBjb250ZW50XFx4MjI+PC9kaXY+ICAgIDwhLS0gL2tvIC0tPiAgPC9kaXY+ICA8ZGl2IGlkPVxceDIydG9vbGJhclxceDIyIGNsYXNzPVxceDIybW9cXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0b29sdGlwczoge31cXHgyMj4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRyb290LnVuZG8gIT0gJ3VuZGVmaW5lZCcgLS0+ICAgIDxzcGFuIGRhdGEtYmluZD1cXHgyMmJ1dHRvbnNldDogeyB9XFx4MjIgY2xhc3M9XFx4MjJsZWZ0QnV0dG9uc1xceDIyPiAgICA8YSB0aXRsZT1cXHgyMlVuZG8gbGFzdCBvcGVyYXRpb25cXHgyMiBocmVmPVxceDIyI1xceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1VuZG8gbGFzdCBvcGVyYXRpb24nKSB9LCBjbGljazogJHJvb3QudW5kby5leGVjdXRlLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LnVuZG8uZW5hYmxlZCgpLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtcmVwbHknIH0sIGxhYmVsOiAkcm9vdC51bmRvLm5hbWUsIHRleHQ6IHRydWUgfVxceDIyPlVORE88L2E+ICAgIDxhIHRpdGxlPVxceDIyUmVkbyBsYXN0IG9wZXJhdGlvblxceDIyIGhyZWY9XFx4MjIjXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnUmVkbyBsYXN0IG9wZXJhdGlvbicpIH0sIGNsaWNrOiAkcm9vdC5yZWRvLmV4ZWN1dGUsIGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IGRpc2FibGVkOiAhJHJvb3QucmVkby5lbmFibGVkKCksIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1zaGFyZScgfSwgbGFiZWw6ICRyb290LnJlZG8ubmFtZSwgdGV4dDogdHJ1ZSB9XFx4MjI+UkVETzwvYT4gICAgPC9zcGFuPiAgICA8IS0tIGtvIGlmOiAkcm9vdC5kZWJ1ZyAtLT4gICAgPGEgaHJlZj1cXHgyMiNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QudW5kb1Jlc2V0LCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LnVuZG8uZW5hYmxlZCgpICYmICEkcm9vdC5yZWRvLmVuYWJsZWQoKSwgbGFiZWw6ICdyZXNldCcsIHRleHQ6IHRydWUgfVxceDIyPlJFU0VUPC9hPiAgICA8IS0tIC9rbyAtLT4gICAgPCEtLSAva28gLS0+ICAgIDxzcGFuPiAgICA8aW5wdXQgaWQ9XFx4MjJzaG93R2FsbGVyeVxceDIyIHR5cGU9XFx4MjJjaGVja2JveFxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LnNob3dHYWxsZXJ5LCBidXR0b246IHsgcmVmcmVzaE9uOiAkcm9vdC5zaG93R2FsbGVyeSwgICAgIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1waWN0dXJlLW8nLCBzZWNvbmRhcnk6IG51bGwgfSwgdGV4dDogdHJ1ZSwgbGFiZWw6ICRyb290LnQoJ0dhbGxlcnknKSB9XFx4MjI+PGxhYmVsIHRpdGxlPVxceDIyU2hvdyBpbWFnZSBnYWxsZXJ5XFx4MjIgZm9yPVxceDIyc2hvd0dhbGxlcnlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTaG93IGltYWdlIGdhbGxlcnknKSB9XFx4MjI+c2hvdyBnYWxsZXJ5PC9sYWJlbD48L2lucHV0PiAgICA8L3NwYW4+ICAgIDxpbnB1dCBpZD1cXHgyMnByZXZpZXdGcmFtZVRvZ2dsZVxceDIyIHR5cGU9XFx4MjJjaGVja2JveFxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LnNob3dQcmV2aWV3RnJhbWUsIGJ1dHRvbjogeyByZWZyZXNoT246ICRyb290LnNob3dQcmV2aWV3RnJhbWUsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS10YWJsZXQnLCBzZWNvbmRhcnk6IG51bGwgfSwgdGV4dDogZmFsc2UsIGxhYmVsOiAkcm9vdC50KCdQcmV2aWV3JykgfVxceDIyPjxsYWJlbCB0aXRsZT1cXHgyMlNob3cgbGl2ZSBwcmV2aWV3XFx4MjIgZm9yPVxceDIycHJldmlld0ZyYW1lVG9nZ2xlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU2hvdyBsaXZlIHByZXZpZXcnKSB9XFx4MjI+UFJFVklFVzwvbGFiZWw+PC9pbnB1dD4gICAgPCEtLSBrbyBpZjogJHJvb3QuZGVidWcgLS0+ICAgIDxhIGhyZWY9XFx4MjIjXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmV4cG9ydCwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgbGFiZWw6ICdleHBvcnQnLCB0ZXh0OiB0cnVlIH1cXHgyMj5FWFBPUlQ8L2E+ICAgIDxpbnB1dCB0eXBlPVxceDIyY2hlY2tib3hcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjaGVja2VkOiAkcm9vdC5kZWJ1Z1xceDIyIC8+IGRlYnVnICAgIDxhIGhyZWY9XFx4MjIjXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmxvYWREZWZhdWx0QmxvY2tzLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtdXBsb2FkJyB9LCBsYWJlbDogJ0RlZmF1bHQnLCB0ZXh0OiB0cnVlIH1cXHgyMj5MT0FEIEJMT0NLUzwvYT4gICAgWzxhIGlkPVxceDIyc3Vic2NyaXB0aW9uc0NvdW50XFx4MjIgaHJlZj1cXHgyMmphdmFzY3JpcHQ6dmlld01vZGVsLmxvb3BTdWJzY3JpcHRpb25zQ291bnQoKVxceDIyPnN1YnM8L2E+XSAgICA8IS0tIC9rbyAtLT4gICAgPHNwYW4gZGF0YS1iaW5kPVxceDIydmlzaWJsZTogZmFsc2VcXHgyMj4gICAgPGlucHV0IHR5cGU9XFx4MjJjaGVja2JveFxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LnNob3dUb29sYm94XFx4MjIgLz4gdG9vbGJveCAgICA8L3NwYW4+ICAgIDxkaXYgY2xhc3M9XFx4MjJyaWdodEJ1dHRvbnNcXHgyMj4gICAgPCEtLSBrbyBpZjogdHlwZW9mICRyb290LnNhdmUgIT09ICd1bmRlZmluZWQnIC0tPiAgICA8YSB0aXRsZT1cXHgyMlNhdmUgdGVtcGxhdGVcXHgyMiBocmVmPVxceDIyI1xceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1NhdmUgdGVtcGxhdGUnKSB9LCBjbGljazogJHJvb3Quc2F2ZS5leGVjdXRlLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LnNhdmUuZW5hYmxlZCgpLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtY2xvdWQtdXBsb2FkJyB9LCBsYWJlbDogJHJvb3QudCgkcm9vdC5zYXZlLm5hbWUpLCB0ZXh0OiB0cnVlIH1cXHgyMj5TQUxWQTwvYT4gICAgPCEtLSAva28gLS0+ICAgIDwhLS0ga28gaWY6IHR5cGVvZiAkcm9vdC50ZXN0ICE9PSAndW5kZWZpbmVkJyAtLT4gICAgPGEgdGl0bGU9XFx4MjJTaG93IHByZXZpZXcgYW5kIHNlbmQgdGVzdFxceDIyIGhyZWY9XFx4MjIjXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU2hvdyBwcmV2aWV3IGFuZCBzZW5kIHRlc3QnKSB9LCBjbGljazogJHJvb3QudGVzdC5leGVjdXRlLCBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyBkaXNhYmxlZDogISRyb290LnRlc3QuZW5hYmxlZCgpLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtcGFwZXItcGxhbmUnIH0sIGxhYmVsOiAkcm9vdC50KCRyb290LnRlc3QubmFtZSksIHRleHQ6IHRydWUgfVxceDIyPlRFU1Q8L2E+ICAgIDwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiB0eXBlb2YgJHJvb3QuZG93bmxvYWQgIT09ICd1bmRlZmluZWQnIC0tPiAgICA8Zm9ybSBpZD1cXHgyMmRvd25sb2FkRm9ybVxceDIyIGFjdGlvbj1cXHgyMiNcXHgyMiBtZXRob2Q9XFx4MjJQT1NUXFx4MjI+ICAgIDxpbnB1dCB0eXBlPVxceDIyaGlkZGVuXFx4MjIgbmFtZT1cXHgyMmFjdGlvblxceDIyIHZhbHVlPVxceDIyZG93bmxvYWRcXHgyMiAvPiAgICA8aW5wdXQgdHlwZT1cXHgyMmhpZGRlblxceDIyIG5hbWU9XFx4MjJmaWxlbmFtZVxceDIyIHZhbHVlPVxceDIyZW1haWwuaHRtbFxceDIyIC8+ICAgIDxpbnB1dCB0eXBlPVxceDIyaGlkZGVuXFx4MjIgbmFtZT1cXHgyMmh0bWxcXHgyMiBpZD1cXHgyMmRvd25sb2FkSHRtbFRleHRhcmVhXFx4MjIgLz4gICAgPGEgdGl0bGU9XFx4MjJEb3dubG9hZCB0ZW1wbGF0ZVxceDIyIGhyZWY9XFx4MjIjXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnRG93bmxvYWQgdGVtcGxhdGUnKSB9LCBjbGljazogJHJvb3QuZG93bmxvYWQuZXhlY3V0ZSwgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgZGlzYWJsZWQ6ICEkcm9vdC5kb3dubG9hZC5lbmFibGVkKCksIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1kb3dubG9hZCcgfSwgbGFiZWw6ICRyb290LnQoJHJvb3QuZG93bmxvYWQubmFtZSksIHRleHQ6IHRydWUgfVxceDIyPkRPV05MT0FEPC9hPiAgICA8L2Zvcm0+ICAgIDwhLS0gL2tvIC0tPiAgICA8L2Rpdj4gIDwvZGl2PiAgPCEtLSBrbyBpZjogJHJvb3Quc2hvd1Rvb2xib3ggLS0+ICA8ZGl2IGlkPVxceDIybWFpbi10b29sYm94XFx4MjIgY2xhc3M9XFx4MjJtb1xceDIyIGRhdGEtYmluZD1cXHgyMnNjcm9sbGFibGU6IHRydWUsIHdpdGhQcm9wZXJ0aWVzOiB7IHRlbXBsYXRlTW9kZTogJ2VkaXQnIH1cXHgyMj4gICAgPGRpdiBkYXRhLWJpbmQ9XFx4MjJ0ZW1wbGF0ZTogeyBuYW1lOiAndG9vbGJveCcgfVxceDIyPjwvZGl2PiAgPC9kaXY+ICA8IS0tIC9rbyAtLT4gICAgPGRpdiBpZD1cXHgyMm1haW4tcHJldmlld1xceDIyIGNsYXNzPVxceDIybW9cXHgyMiBkYXRhLWJpbmQ9XFx4MjJzY3JvbGxhYmxlOiB0cnVlLCBpZjogJHJvb3Quc2hvd1ByZXZpZXdGcmFtZVxceDIyPiAgICA8ZGl2IGlkPVxceDIycHJldmlldy10b29sYmFyXFx4MjI+ICAgICAgPGRpdiBkYXRhLWJpbmQ9XFx4MjJ2aXNpYmxlOiAkcm9vdC5zaG93UHJldmlld0ZyYW1lLCBidXR0b25zZXQ6IHsgfVxceDIyIHN0eWxlPVxceDIyZGlzcGxheTogaW5saW5lLWJsb2NrXFx4MjI+ICAgICAgICA8aW5wdXQgaWQ9XFx4MjJwcmV2aWV3TGFyZ2VcXHgyMiB0eXBlPVxceDIycmFkaW9cXHgyMiBuYW1lPVxceDIycHJldmlld01vZGVcXHgyMiB2YWx1ZT1cXHgyMmxhcmdlXFx4MjIgZGF0YS1iaW5kPVxceDIyY2hlY2tlZDogJHJvb3QucHJldmlld01vZGUsIGJ1dHRvbjogeyB0ZXh0OiBmYWxzZSwgbGFiZWw6ICdsYXJnZScsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1kZXNrdG9wJyB9IH1cXHgyMiAvPiAgICAgICAgPGxhYmVsIGZvcj1cXHgyMnByZXZpZXdMYXJnZVxceDIyIHRpdGxlPVxceDIyTGFyZ2Ugc2NyZWVuXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnTGFyZ2Ugc2NyZWVuJykgfVxceDIyPkxhcmdlIHNjcmVlbjwvbGFiZWw+ICAgICAgICA8aW5wdXQgaWQ9XFx4MjJwcmV2aWV3RGVza3RvcFxceDIyIHR5cGU9XFx4MjJyYWRpb1xceDIyIG5hbWU9XFx4MjJwcmV2aWV3TW9kZVxceDIyIHZhbHVlPVxceDIyZGVza3RvcFxceDIyIGRhdGEtYmluZD1cXHgyMmNoZWNrZWQ6ICRyb290LnByZXZpZXdNb2RlLCBidXR0b246IHsgdGV4dDogZmFsc2UsIGxhYmVsOiAnZGVza3RvcCcsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS10YWJsZXQnIH0gfVxceDIyIC8+ICAgICAgICA8bGFiZWwgZm9yPVxceDIycHJldmlld0Rlc2t0b3BcXHgyMiB0aXRsZT1cXHgyMlRhYmxldFxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1RhYmxldCcpIH1cXHgyMj5UYWJsZXQ8L2xhYmVsPiAgICAgICAgPGlucHV0IGlkPVxceDIycHJldmlld01vYmlsZVxceDIyIHR5cGU9XFx4MjJyYWRpb1xceDIyIG5hbWU9XFx4MjJwcmV2aWV3TW9kZVxceDIyIHZhbHVlPVxceDIybW9iaWxlXFx4MjIgZGF0YS1iaW5kPVxceDIyY2hlY2tlZDogJHJvb3QucHJldmlld01vZGUsIGJ1dHRvbjogeyB0ZXh0OiBmYWxzZSwgbGFiZWw6ICdtb2JpbGUnLCBpY29uczogeyBwcmltYXJ5OiAnZmEgZmEtZncgZmEtbW9iaWxlJyB9IH1cXHgyMiAvPiAgICAgICAgPGxhYmVsIGZvcj1cXHgyMnByZXZpZXdNb2JpbGVcXHgyMiB0aXRsZT1cXHgyMlNtYXJ0cGhvbmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTbWFydHBob25lJykgfVxceDIyPlNtYXJ0cGhvbmU8L2xhYmVsPiAgICAgIDwvZGl2PiAgICA8L2Rpdj4gICAgPGRpdiBpZD1cXHgyMmZyYW1lLWNvbnRhaW5lclxceDIyIGRhdGEtYmluZD1cXHgyMmNzczogeyBkZXNrdG9wOiAkcm9vdC5wcmV2aWV3TW9kZSgpID09ICdkZXNrdG9wJywgbW9iaWxlOiAkcm9vdC5wcmV2aWV3TW9kZSgpID09ICdtb2JpbGUnLCBsYXJnZTogJHJvb3QucHJldmlld01vZGUoKSA9PSAnbGFyZ2UnIH1cXHgyMj4gICAgICA8aWZyYW1lIGRhdGEtYmluZD1cXHgyMmJpbmRJZnJhbWU6ICRkYXRhXFx4MjI+PC9pZnJhbWU+ICAgIDwvZGl2PiAgPC9kaXY+ICA8ZGl2IGNsYXNzPVxceDIybW9cXHgyMiBpZD1cXHgyMm1vLWJvZHlcXHgyMj48L2Rpdj4gIDwhLS0gVE9ETyBSRU1PVkUgTUUgIDxkaXYgaWQ9XFx4MjJpbmNvbXBhdGlibGUtYnJvd3NlclxceDIyIHRpdGxlPVxceDIyVW5zdXBwb3J0ZWQgYnJvd3NlclxceDIyIHN0eWxlPVxceDIyZGlzcGxheTogbm9uZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1VzdXBwb3J0ZWQgYnJvd3NlcicpIH0sIGh0bWw6ICc8cD5Zb3VyIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZC48L3A+PHA+VXNlIGEgZGlmZmVyZW50IGJyb3dzZXIgb3IgdHJ5IHVwZGFyaW5nIHlvdXIgYnJvd3Nlci48L3A+PHA+U3VwcG9ydGVkIGJyb3dzZXJzOiA8dWw+PGxpPkludGVybmV0IEV4cGxvcmVyICZndDs9IDEwPC9saT48bGk+R29vZ2xlIENocm9tZSAmZ3Q7PSAzMDwvbGk+PGxpPkFwcGxlIFNhZmFyaSAmZ3Q7PSA1PC9saT48bGk+TW96aWxsYSBGaXJlZml4ICZndDs9IDIwPC9saT48L3VsPjwvcD4nXFx4MjI+ICAgIFVuc3VwcG9ydGVkIGJyb3dzZXIgIDwvZGl2PiAgLS0+ICA8ZGl2IGlkPVxceDIyaW5jb21wYXRpYmxlLXRlbXBsYXRlXFx4MjIgdGl0bGU9XFx4MjJTYXZlZCBtb2RlbCBpcyBvYnNvbGV0ZVxceDIyIHN0eWxlPVxceDIyZGlzcGxheTogbm9uZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ1NhdmVkIG1vZGVsIGlzIG9ic29sZXRlJykgfSwgaHRtbDogJHJvb3QudCgnPHA+VGhlIHNhdmVkIG1vZGVsIGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBhIHByZXZpb3VzLCBub24gY29tcGxldGVseSBjb21wYXRpYmxlIHZlcnNpb24sIG9mIHRoZSB0ZW1wbGF0ZTwvcD48cD5Tb21lIGNvbnRlbnQgb3Igc3R5bGUgaW4gdGhlIG1vZGVsIDxiPkNPVUxEIEJFIExPU1Q8L2I+IGlmIHlvdSB3aWxsIDxiPnNhdmU8L2I+PC9wPjxwPkNvbnRhY3QgdXMgZm9yIG1vcmUgaW5mb3JtYXRpb25zITwvcD4nKVxceDIyPiAgICBJbmNvbXBhdGlibGUgdGVtcGxhdGUgIDwvZGl2PiAgPGRpdiBpZD1cXHgyMmZha2UtaW1hZ2UtZWRpdG9yXFx4MjIgdGl0bGU9XFx4MjJGYWtlIGltYWdlIGVkaXRvclxceDIyIHN0eWxlPVxceDIyZGlzcGxheTogbm9uZVxceDIyIGRhdGEtYmluZD1cXHgyMmF0dHI6IHsgdGl0bGU6ICRyb290LnQoJ0Zha2UgaW1hZ2UgZWRpdG9yJykgfSwgaHRtbDogJHJvb3QudCgnPHA+RmFrZSBpbWFnZSBlZGl0b3I8L3A+JylcXHgyMj4gICAgPHA+RmFrZSBpbWFnZSBlZGl0b3I8L3A+ICA8L2Rpdj48L2Rpdj48IS0tIGtvIGlmOiAkcm9vdC5sb2dvUGF0aCAtLT48ZGl2IGlkPVxceDIybG9hZGluZ1xceDIyIGNsYXNzPVxceDIybG9hZGluZ1xceDIyIHN0eWxlPVxceDIyZGlzcGxheTogYmxvY2s7IHdpZHRoOiAzMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyBoZWlnaHQ6IDMycHg7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOjA7IGJvdHRvbTogMDsgbGVmdDogMDsgcmlnaHQ6IDA7ICBtYXJnaW46IGF1dG87XFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyBzdHlsZTogJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiA1cHg7IGxlZnQ6IDZweDsgei1pbmRleDogMTUwOyd9LCBjc3M6IHsgbG9hZGluZzogZmFsc2UgfVxceDIyPiAgPGEgaHJlZj1cXHgyMi9cXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IGhyZWY6ICRyb290LmxvZ29VcmwsIGFsdDogJHJvb3QubG9nb0FsdCB9XFx4MjI+PGltZyBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHNyYzogJHJvb3QubG9nb1BhdGggfVxceDIyIHdpZHRoPVxceDIyMzJcXHgyMiBoZWlnaHQ9XFx4MjIzMlxceDIyIGFsdD1cXHgyMm1vc2FpY29cXHgyMiBib3JkZXI9XFx4MjIwXFx4MjIgLz48L2E+ICA8ZGl2IHN0eWxlPVxceDIyb3BhY2l0eTogMFxceDIyIGRhdGEtYmluZD1cXHgyMnZpc2libGU6IGZhbHNlXFx4MjI+T3BwcHMuLi4gISE8L2Rpdj48L2Rpdj48IS0tIC9rbyAtLT5cIik7XG4gIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKFwidG9vbGJveFwiLCBcIjxkaXYgaWQ9XFx4MjJ0b29sdGFic1xceDIyIGNsYXNzPVxceDIydGFic19ob3Jpem9udGFsIGJ1dHRvbl9jb2xvclxceDIyIGRhdGEtYmluZD1cXHgyMnRhYnM6IHsgYWN0aXZlOiAkcm9vdC5zZWxlY3RlZFRvb2wgfVxceDIyPiAgPHVsPiAgICA8bGkgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+PGEgdGl0bGU9XFx4MjJCbG9ja3MgcmVhZHkgdG8gYmUgYWRkZWQgdG8gdGhlIHRlbXBsYXRlXFx4MjIgZGF0YS1sb2NhbD1cXHgyMnRydWVcXHgyMiBocmVmPVxceDIyI3Rvb2xibG9ja3NcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdCbG9ja3MgcmVhZHkgdG8gYmUgYWRkZWQgdG8gdGhlIHRlbXBsYXRlJykgfVxceDIyPjxpIGNsYXNzPVxceDIyZmEgZmEtZncgZmEtY3ViZXNcXHgyMj48L2k+IDxzcGFuIGRhdGEtYmluZD1cXHgyMmh0bWw6ICRyb290LnQoJ0Jsb2NrcycpXFx4MjI+QmxvY2tzPC9zcGFuPjwvYT48L2xpPiAgICA8bGkgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+PGEgdGl0bGU9XFx4MjJFZGl0IGNvbnRlbnQgb3B0aW9uc1xceDIyIGhyZWY9XFx4MjIjdG9vbGNvbnRlbnRzXFx4MjIgZGF0YS1sb2NhbD1cXHgyMnRydWVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdFZGl0IGNvbnRlbnQgb3B0aW9ucycpIH1cXHgyMj48aSBjbGFzcz1cXHgyMmZhIGZhLWZ3IGZhLXBlbmNpbFxceDIyPjwvaT4gPHNwYW4gZGF0YS1iaW5kPVxceDIyaHRtbDogJHJvb3QudCgnQ29udGVudCcpXFx4MjI+Q29udGVudDwvc3Bhbj48L2E+PC9saT4gICAgPGxpIGRhdGEtYmluZD1cXHgyMnRvb2x0aXBzOiB7fVxceDIyPjxhIHRpdGxlPVxceDIyRWRpdCBzdHlsZSBvcHRpb25zXFx4MjIgaHJlZj1cXHgyMiN0b29sc3R5bGVzXFx4MjIgZGF0YS1sb2NhbD1cXHgyMnRydWVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdFZGl0IHN0eWxlIG9wdGlvbnMnKSB9XFx4MjI+PGkgY2xhc3M9XFx4MjJmYSBmYS1mdyBmYS1wYWludC1icnVzaFxceDIyPjwvaT4gPHNwYW4gZGF0YS1iaW5kPVxceDIyaHRtbDogJHJvb3QudCgnU3R5bGUnKVxceDIyPlN0eWxlPC9zcGFuPjwvYT48L2xpPiAgPC91bD4gIDxkaXYgaWQ9XFx4MjJ0b29sYmxvY2tzXFx4MjIgZGF0YS1iaW5kPVxceDIyc2Nyb2xsYWJsZTogdHJ1ZVxceDIyPiAgICA8ZGl2IGNsYXNzPVxceDIyYmxvY2stbGlzdFxceDIyIGRhdGEtYmluZD1cXHgyMmZvcmVhY2g6IGJsb2NrRGVmc1xceDIyIHN0eWxlPVxceDIydGV4dC1hbGlnbjogY2VudGVyXFx4MjI+ICAgICAgPGRpdiBjbGFzcz1cXHgyMmRyYWdnYWJsZS1pdGVtXFx4MjIgZGF0YS1iaW5kPVxceDIyd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiAnc2hvdycgfVxceDIyPiAgICAgICAgPGRpdiBjbGFzcz1cXHgyMmJsb2NrXFx4MjIgZGF0YS1iaW5kPVxceDIyZXh0ZHJhZ2dhYmxlOiB7IGNvbm5lY3RDbGFzczogJ3NvcnRhYmxlLWJsb2Nrcy1lZGl0JywgZGF0YTogJGRhdGEsIGRyb3BDb250YWluZXI6ICcjbWFpbi13eXNpd3lnLWFyZWEnLCBkcmFnZ2luZzogJHJvb3QuZHJhZ2dpbmcsICdvcHRpb25zJzogeyBoYW5kbGU6ICcuaGFuZGxlJywgZGlzdGFuY2U6IDEwLCAnYXBwZW5kVG8nOiAnI3BhZ2UnIH0gfSwgY2xpY2s6ICRyb290LmFkZEJsb2NrXFx4MjIgc3R5bGU9XFx4MjJwb3NpdGlvbjogcmVsYXRpdmU7XFx4MjI+ICAgICAgICAgIDxkaXYgdGl0bGU9XFx4MjJDbGljayBvciBkcmFnIHRvIGFkZCB0aGlzIGJsb2NrIHRvIHRoZSB0ZW1wbGF0ZVxceDIyIGNsYXNzPVxceDIyaGFuZGxlXFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnQ2xpY2sgb3IgZHJhZyB0byBhZGQgdGhpcyBibG9jayB0byB0aGUgdGVtcGxhdGUnKSB9LCB0b29sdGlwczoge31cXHgyMj48L2Rpdj4gICAgICAgICAgPGltZyBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IGFsdDogJHJvb3QudCgnQmxvY2sgX19uYW1lX18nLCB7IG5hbWU6IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodHlwZSkgfSksIHNyYzogJHJvb3QudGVtcGxhdGVQYXRoKCdlZHJlcy8nK2tvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodHlwZSkrJy5wbmcnKSB9XFx4MjIgYWx0PVxceDIyQmxvY2sgX19uYW1lX19cXHgyMiAvPiAgICAgICAgPC9kaXY+ICAgICAgICA8YSBocmVmPVxceDIyI1xceDIyIGNsYXNzPVxceDIyYWRkYmxvY2tidXR0b25cXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuYWRkQmxvY2ssIGJ1dHRvbjogeyBsYWJlbDogJHJvb3QudCgnQWRkJykgfVxceDIyPkFkZDwvYT4gICAgICA8L2Rpdj4gICAgPC9kaXY+ICA8L2Rpdj4gIDxkaXYgaWQ9XFx4MjJ0b29sY29udGVudHNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJzY3JvbGxhYmxlOiB0cnVlXFx4MjI+ICAgIDwhLS0ga28gaWY6ICRyb290LnNlbGVjdGVkQmxvY2soKSAhPT0gbnVsbCAtLT4gICAgPGRpdiBkYXRhLWJpbmQ9XFx4MjJibG9jazogJHJvb3Quc2VsZWN0ZWRCbG9ja1xceDIyPjwvZGl2PiAgICA8IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogJHJvb3Quc2VsZWN0ZWRCbG9jaygpID09IG51bGwgLS0+ICAgIDxkaXYgY2xhc3M9XFx4MjJub1NlbGVjdGVkQmxvY2tcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdCeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBjb250ZW50IG9wdGlvbnMsIGlmIGFueSwgd2lsbCBzaG93IGhlcmUnKVxceDIyPkJ5IGNsaWNraW5nIG9uIG1lc3NhZ2UgcGFydHMgeW91IHdpbGwgc2VsZWN0IGEgYmxvY2sgYW5kIGNvbnRlbnQgb3B0aW9ucywgaWYgYW55LCB3aWxsIHNob3cgaGVyZTwvZGl2PiAgICA8IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBibG9jazogY29udGVudCAtLT48IS0tIC9rbyAtLT4gIDwvZGl2PiAgICA8ZGl2IGlkPVxceDIydG9vbHN0eWxlc1xceDIyIGRhdGEtYmluZD1cXHgyMnNjcm9sbGFibGU6IHRydWUsIHdpdGhQcm9wZXJ0aWVzOiB7IHRlbXBsYXRlTW9kZTogJ3N0eWxlcicgfVxceDIyPiAgICA8IS0tIGtvIGlmOiB0eXBlb2YgJHJvb3QuY29udGVudCgpLnRoZW1lID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgJHJvb3QuY29udGVudCgpLnRoZW1lKCkuc2NoZW1lID09PSAndW5kZWZpbmVkJyB8fCAkcm9vdC5jb250ZW50KCkudGhlbWUoKS5zY2hlbWUoKSA9PT0gJ2N1c3RvbScgLS0+ICAgICAgPCEtLSBrbyBpZjogJHJvb3Quc2VsZWN0ZWRCbG9jaygpICE9PSBudWxsIC0tPiAgICAgIDxkaXYgZGF0YS1iaW5kPVxceDIyYmxvY2s6ICRyb290LnNlbGVjdGVkQmxvY2ssIGNzczogeyB3b3JrTG9jYWw6ICRyb290LnNlbGVjdGVkQmxvY2soKS5jdXN0b21TdHlsZSwgd29ya0dsb2JhbDogdHlwZW9mICRyb290LnNlbGVjdGVkQmxvY2soKS5jdXN0b21TdHlsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgISRyb290LnNlbGVjdGVkQmxvY2soKS5jdXN0b21TdHlsZSgpIH1cXHgyMj48L2Rpdj4gICAgICA8IS0tIC9rbyAtLT4gICAgICA8IS0tIGtvIGlmOiAkcm9vdC5zZWxlY3RlZEJsb2NrKCkgPT0gbnVsbCAtLT4gICAgICA8ZGl2IGNsYXNzPVxceDIybm9TZWxlY3RlZEJsb2NrXFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnQnkgY2xpY2tpbmcgb24gbWVzc2FnZSBwYXJ0cyB5b3Ugd2lsbCBzZWxlY3QgYSBibG9jayBhbmQgc3R5bGUgb3B0aW9ucywgaWYgYXZhaWxhYmxlLCB3aWxsIHNob3cgaGVyZScpXFx4MjI+QnkgY2xpY2tpbmcgb24gbWVzc2FnZSBwYXJ0cyB5b3Ugd2lsbCBzZWxlY3QgYSBibG9jayBhbmQgc3R5bGUgb3B0aW9ucywgaWYgYXZhaWxhYmxlLCB3aWxsIHNob3cgaGVyZTwvZGl2PiAgICAgIDwhLS0gL2tvIC0tPiAgICAgIDxkaXYgY2xhc3M9XFx4MjJ3b3JrR2xvYmFsQ29udGVudFxceDIyPiAgICAgIDwhLS0ga28gYmxvY2s6IGNvbnRlbnQgLS0+PCEtLSAva28gLS0+ICAgICAgPC9kaXY+ICAgIDwhLS0gL2tvIC0tPiAgPC9kaXY+PC9kaXY+ICAgICAgICA8ZGl2IGlkPVxceDIydG9vbGltYWdlc1xceDIyIGNsYXNzPVxceDIyc2xpZGViYXJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJzY3JvbGxhYmxlOiB0cnVlLCBjc3M6IHsgaGlkZGVuOiAkcm9vdC5zaG93R2FsbGVyeSgpID09PSBmYWxzZSB9XFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIyY2xvc2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3Quc2hvd0dhbGxlcnkuYmluZCgkZWxlbWVudCwgZmFsc2UpO1xceDIyPlg8L2Rpdj4gIDxzcGFuIGNsYXNzPVxceDIycGFuZS10aXRsZVxceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6ICRyb290LnQoJ0dhbGxlcnk6JylcXHgyMj5HYWxsZXJ5Ojwvc3Bhbj4gIDxkaXYgZGF0YS1kcm9wLWNvbnRlbnQ9XFx4MjJEcm9wIGhlcmVcXHgyMiBjbGFzcz1cXHgyMmltZy1kcm9wem9uZSBwYW5lIHVwbG9hZHpvbmVcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7ICdkYXRhLWRyb3AtY29udGVudCc6ICRyb290LnQoJ0Ryb3AgaGVyZScpIH0sIGZ1ZHJvcHBhYmxlOiB7IGFjdGl2ZUNsYXNzOiAndWktc3RhdGUtaGlnaGxpZ2h0JywgaG92ZXJDbGFzczogJ3VpLXN0YXRlLWRyYWdob3ZlcicgfVxceDIyPiAgPGRpdiBjbGFzcz1cXHgyMm1vLXVwbG9hZHpvbmVcXHgyMiBzdHlsZT1cXHgyMnBvc2l0aW9uOiByZWxhdGl2ZTsgcGFkZGluZzogMmVtOyBib3JkZXI6IDJweCBkb3R0ZWQgIzgwODA4MFxceDIyPiAgICAgPGlucHV0IGNsYXNzPVxceDIyZmlsZXVwbG9hZFxceDIyIHR5cGU9XFx4MjJmaWxlXFx4MjIgbXVsdGlwbGUgbmFtZT1cXHgyMmZpbGVzW11cXHgyMiBkYXRhLWJpbmQ9XFx4MjJmaWxldXBsb2FkOiB7IG9uZXJyb3I6ICRyb290Lm5vdGlmaWVyLmVycm9yLCBvbmZpbGU6ICRyb290LmxvYWRJbWFnZSB9XFx4MjIgc3R5bGU9XFx4MjJ6LWluZGV4OiAxMDsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG1pbi13aWR0aDogMTAwJTsgbWluLWhlaWdodDogMTAwJTsgZm9udC16aWU6IDk5OXB4OyB0ZXh0LWFsaWduOiByaWdodDsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTApOyBvcGFjaXR5OiAwOyBvdXRsaW5lOiBub25lOyBjdXJzb3I6IGluaGVyaXQ7IGRpc3BsYXk6IGJsb2NrXFx4MjI+ICAgICA8c3BhbiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdDbGljayBvciBkcmFnIGZpbGVzIGhlcmUnKVxceDIyPkNsaWNrIG9yIGRyYWcgZmlsZXMgaGVyZTwvc3Bhbj4gICAgIDxkaXYgY2xhc3M9XFx4MjJ3b3Jrem9uZVxceDIyIHN0eWxlPVxceDIycG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBoaWRkZW47XFx4MjI+ICAgICAgIDxkaXYgY2xhc3M9XFx4MjJwcm9ncmVzc1xceDIyIHN0eWxlPVxceDIyb3BhY2l0eTogLjU7IHdpZHRoOiA4MCU7IG1hcmdpbi1sZWZ0OiAxMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAzMCU7IGhlaWdodDogMjBweDsgYm9yZGVyOiAycHggc29saWQgYmxhY2s7XFx4MjI+ICAgICAgICAgPGRpdiBjbGFzcz1cXHgyMnByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItc3VjY2Vzc1xceDIyIHN0eWxlPVxceDIyaGVpZ2h0OiAyMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgXFx4MjI+PC9kaXY+ICAgICAgIDwvZGl2PiAgICAgPC9kaXY+ICA8L2Rpdj4gIDwvZGl2PiAgPCEtLSBrbyBpZjogJHJvb3Quc2hvd0dhbGxlcnkoKSAtLT4gIDxkaXYgaWQ9XFx4MjJ0b29saW1hZ2VzdGFiXFx4MjIgY2xhc3M9XFx4MjJ0YWJzX2hvcml6b250YWxcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0YWJzOiB7IGFjdGl2ZTogJHJvb3Quc2VsZWN0ZWRJbWFnZVRhYiB9XFx4MjI+ICAgIDx1bD4gICAgICA8bGkgZGF0YS1iaW5kPVxceDIydG9vbHRpcHM6IHt9XFx4MjI+PGEgdGl0bGU9XFx4MjJTZXNzaW9uIGltYWdlc1xceDIyIGRhdGEtbG9jYWw9XFx4MjJ0cnVlXFx4MjIgaHJlZj1cXHgyMiN0b29saW1hZ2VzcmVjZW50XFx4MjIgZGF0YS1iaW5kPVxceDIyYXR0cjogeyB0aXRsZTogJHJvb3QudCgnU2Vzc2lvbiBpbWFnZXMnKSB9LCB0ZXh0OiAkcm9vdC50KCdSZWNlbnRzJylcXHgyMj5SZWNlbnRzPC9hPjwvbGk+ICAgICAgPGxpIGRhdGEtYmluZD1cXHgyMnRvb2x0aXBzOiB7fVxceDIyPjxhIHRpdGxlPVxceDIyUmVtb3RlIGdhbGxlcnlcXHgyMiBkYXRhLWxvY2FsPVxceDIydHJ1ZVxceDIyIGhyZWY9XFx4MjIjdG9vbGltYWdlc2dhbGxlcnlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdSZW1vdGUgZ2FsbGVyeScpIH0sIHRleHQ6ICRyb290LnQoJ0dhbGxlcnknKVxceDIyPkdhbGxlcnk8L2E+PC9saT4gICAgPC91bD4gICAgPGRpdiBpZD1cXHgyMnRvb2xpbWFnZXNyZWNlbnRcXHgyMj4gICAgICA8IS0tIGtvIGlmOiBnYWxsZXJ5UmVjZW50KCkubGVuZ3RoID09IDAgLS0+PGRpdiBjbGFzcz1cXHgyMmdhbGxlcnlFbXB0eVxceDIyIGRhdGEtYmluZD1cXHgyMnRleHQ6ICRyb290LnQoJ05vIGltYWdlcyB1cGxvYWRlZCwgeWV0JylcXHgyMj5ObyBpbWFnZXMgdXBsb2FkZWQsIHlldDwvZGl2PjwhLS0gL2tvIC0tPiAgICAgIDwhLS0ga28gdGVtcGxhdGU6IHtuYW1lOiAnZ2FsbGVyeS1pbWFnZXMnLCBkYXRhOiB7IGl0ZW1zOiBnYWxsZXJ5UmVjZW50IH0gfSAtLT4jIHJlY2VudCBnYWxsZXJ5ICM8IS0tIC9rbyAtLT4gICAgPC9kaXY+ICAgIDxkaXYgaWQ9XFx4MjJ0b29saW1hZ2VzZ2FsbGVyeVxceDIyIHN0eWxlPVxceDIydGV4dC1hbGlnbjogY2VudGVyXFx4MjI+ICAgIDwhLS0ga28gaWY6ICRyb290LmdhbGxlcnlMb2FkZWQoKSA9PT0gZmFsc2UgLS0+PGEgY2xhc3M9XFx4MjJsb2FkYnV0dG9uXFx4MjIgdGl0bGU9XFx4MjJTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5XFx4MjIgaHJlZj1cXHgyMiNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KCdTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5JykgfSwgY2xpY2s6ICRyb290LmxvYWRHYWxsZXJ5LCBidXR0b246IHsgZGlzYWJsZWQ6ICRyb290LmdhbGxlcnlMb2FkZWQsIGljb25zOiB7IHByaW1hcnk6ICdmYSBmYS1mdyBmYS1waWN0dXJlLW8nIH0sIGxhYmVsOiAkcm9vdC5nYWxsZXJ5TG9hZGVkKCkgPT0gJ2xvYWRpbmcnID8gJHJvb3QudCgnTG9hZGluZy4uLicpIDogJHJvb3QudCgnTG9hZCBnYWxsZXJ5JyksIHRleHQ6IHRydWUgfVxceDIyPiMgbG9hZCBnYWxseSAjPC9hPjwhLS0gL2tvIC0tPiAgICA8IS0tIGtvIGlmOiAkcm9vdC5nYWxsZXJ5TG9hZGVkKCkgPT09ICdsb2FkaW5nJyAtLT48ZGl2IGNsYXNzPVxceDIyZ2FsbGVyeUVtcHR5XFx4MjIgZGF0YS1iaW5kPVxceDIydGV4dDogJHJvb3QudCgnTG9hZGluZyBnYWxsZXJ5Li4uJylcXHgyMj5Mb2FkaW5nIGdhbGxlcnkuLi48L2Rpdj48IS0tIC9rbyAtLT4gICAgPCEtLSBrbyBpZjogJHJvb3QuZ2FsbGVyeUxvYWRlZCgpID09PSAwIC0tPjxkaXYgY2xhc3M9XFx4MjJnYWxsZXJ5RW1wdHlcXHgyMiBkYXRhLWJpbmQ9XFx4MjJ0ZXh0OiAkcm9vdC50KCdUaGUgZ2FsbGVyeSBpcyBlbXB0eScpXFx4MjI+VGhlIGdhbGxlcnkgaXMgZW1wdHk8L2Rpdj48IS0tIC9rbyAtLT4gICAgPCEtLSBrbyB0ZW1wbGF0ZToge25hbWU6ICdnYWxsZXJ5LWltYWdlcycsIGRhdGE6IHsgaXRlbXM6IGdhbGxlcnlSZW1vdGUgfSB9IC0tPiMgcmVtb3RlIGdhbGxlcnkgIzwhLS0gL2tvIC0tPiAgICA8L2Rpdj4gIDwvZGl2PiAgPCEtLSAva28gLS0+PC9kaXY+PGRpdiBpZD1cXHgyMnRvb2xkZWJ1Z1xceDIyIGNsYXNzPVxceDIyc2xpZGViYXJcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjc3M6IHsgaGlkZGVuOiAkcm9vdC5kZWJ1ZygpID09PSBmYWxzZSB9XFx4MjI+ICA8ZGl2IGNsYXNzPVxceDIyY2xvc2VcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuZGVidWcuYmluZCgkZWxlbWVudCwgZmFsc2UpO1xceDIyPlg8L2Rpdj4gICAgPCEtLSBrbyBpZjogJHJvb3QuZGVidWcgLS0+ICBDb250ZW50OiAgPHByZSBkYXRhLWJpbmQ9J3RleHQ6IGtvLnRvSlNPTihjb250ZW50LCBudWxsLCAyKScgc3R5bGU9XFx4MjJvdmVyZmxvdzogYXV0bzsgaGVpZ2h0OiAyMCVcXHgyMj48L3ByZT4gIEJsb2NrRGVmczogIDxwcmUgZGF0YS1iaW5kPSd0ZXh0OiBrby50b0pTT04oYmxvY2tEZWZzLCBudWxsLCAyKScgc3R5bGU9XFx4MjJvdmVyZmxvdzogYXV0bzsgaGVpZ2h0OiAyMCVcXHgyMj48L3ByZT4gIDwhLS0gL2tvIC0tPiAgPGEgaHJlZj1cXHgyMiNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuZXhwb3J0SFRNTHRvVGV4dGFyZWEuYmluZCgkZWxlbWVudCwgJyNvdXRwdXRodG1sJyk7IGNsaWNrQnViYmxlOiBmYWxzZSwgYnV0dG9uOiB7IHRleHQ6IHRydWUsIGxhYmVsOidHZW5lcmF0ZScgfVxceDIyPk91dHB1dDwvYT4gIDxhIGhyZWY9XFx4MjIjXFx4MjIgZGF0YS1iaW5kPVxceDIyY2xpY2s6ICRyb290LmV4cG9ydEpTT050b1RleHRhcmVhLmJpbmQoJGVsZW1lbnQsICcjb3V0cHV0aHRtbCcpOyBjbGlja0J1YmJsZTogZmFsc2UsIGJ1dHRvbjogeyB0ZXh0OiB0cnVlLCBsYWJlbDonRXhwb3J0JyB9XFx4MjI+RXhwb3J0PC9hPiAgPGEgaHJlZj1cXHgyMiNcXHgyMiBkYXRhLWJpbmQ9XFx4MjJjbGljazogJHJvb3QuaW1wb3J0SlNPTmZyb21UZXh0YXJlYS5iaW5kKCRlbGVtZW50LCAnI291dHB1dGh0bWwnKTsgY2xpY2tCdWJibGU6IGZhbHNlLCBidXR0b246IHsgdGV4dDogdHJ1ZSwgbGFiZWw6J0ltcG9ydCcgfVxceDIyPkltcG9ydDwvYT4gIDx0ZXh0YXJlYSBpZD1cXHgyMm91dHB1dGh0bWxcXHgyMiByb3dzPVxceDIyMTBcXHgyMiBzdHlsZT1cXHgyMndpZHRoOiAxMDAlO1xceDIyPjwvdGV4dGFyZWE+PC9kaXY+PGRpdiBpZD1cXHgyMnRvb2x0aGVtZVxceDIyIGNsYXNzPVxceDIydWktd2lkZ2V0IHNsaWRlYmFyXFx4MjIgZGF0YS1iaW5kPVxceDIyY3NzOiB7IGhpZGRlbjogJHJvb3Quc2hvd1RoZW1lKCkgPT09IGZhbHNlIH1cXHgyMj4gIDxkaXYgY2xhc3M9XFx4MjJjbG9zZVxceDIyIGRhdGEtYmluZD1cXHgyMmNsaWNrOiAkcm9vdC5zaG93VGhlbWUuYmluZCgkZWxlbWVudCwgZmFsc2UpO1xceDIyPlg8L2Rpdj4gICAgPCEtLSBrbyB3aXRoUHJvcGVydGllczogeyB0ZW1wbGF0ZU1vZGU6ICdzdHlsZXInIH0gLS0+ICAgIDwhLS0ga28gaWY6ICRyb290LnNob3dUaGVtZSAtLT4gICAgICA8IS0tIGtvIGJsb2NrOiAkcm9vdC5jb250ZW50KCkudGhlbWUgLS0+PCEtLSAva28gLS0+ICAgIDwhLS0gL2tvIC0tPiAgPCEtLSAva28gLS0+PC9kaXY+XCIpO1xufSk7XG4iLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlICovXG4vKiBnbG9iYWwgWE1MSHR0cFJlcXVlc3Q6IGZhbHNlICovXG5cbnZhciB0ZW1wbGF0ZUxvYWRlciA9IHJlcXVpcmUoJy4vdGVtcGxhdGUtbG9hZGVyLmpzJyk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG5yZXF1aXJlKFwiLi9rby1iaW5kaW5ncy5qc1wiKTtcbnZhciBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyID0gcmVxdWlyZShcIi4vdGltZWQtY2FsbC5qc1wiKS50aW1lZENhbGw7XG5cbnZhciBhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlciA9IHJlcXVpcmUoXCIuL3VuZG9tYW5hZ2VyL3VuZG9tYWluLmpzXCIpO1xudmFyIGNvbG9yUGx1Z2luID0gcmVxdWlyZShcIi4vZXh0L2NvbG9yLmpzXCIpO1xuXG52YXIgbG9jYWxTdG9yYWdlTG9hZGVyID0gcmVxdWlyZShcIi4vZXh0L2xvY2Fsc3RvcmFnZS5qc1wiKTtcblxuZnVuY3Rpb24gX2Nhbm9uaWNhbGl6ZSh1cmwpIHtcbiAgdmFyIGRpdiA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IFwiPGE+PC9hPlwiO1xuICBkaXYuZmlyc3RDaGlsZC5ocmVmID0gdXJsOyAvLyBFbnN1cmVzIHRoYXQgdGhlIGhyZWYgaXMgcHJvcGVybHkgZXNjYXBlZFxuICBkaXYuaW5uZXJIVE1MID0gZGl2LmlubmVySFRNTDsgLy8gUnVuIHRoZSBjdXJyZW50IGlubmVySFRNTCBiYWNrIHRocm91Z2ggdGhlIHBhcnNlclxuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQuaHJlZjtcbn1cblxudmFyIGFwcGx5QmluZGluZ09wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCBrbykge1xuICAvLyBwdXNoIFwiY29udmVydGVkVXJsXCIgbWV0aG9kIHRvIHRoZSB3eXNpd3lnU3JjIGJpbmRpbmdcbiAga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMuY29udmVydGVkVXJsID0gZnVuY3Rpb24oc3JjLCBtZXRob2QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaW1nUHJvY2Vzc29yQmFja2VuZCA9IG9wdGlvbnMuaW1nUHJvY2Vzc29yQmFja2VuZCA/IG9wdGlvbnMuaW1nUHJvY2Vzc29yQmFja2VuZCA6ICcuL3VwbG9hZCc7XG4gICAgdmFyIGJhY2tFbmRNYXRjaCA9IGltZ1Byb2Nlc3NvckJhY2tlbmQubWF0Y2goL14oaHR0cHM/OlxcL1xcL1teXFwvXSpcXC8pLiokLyk7XG4gICAgdmFyIHNyY01hdGNoID0gc3JjLm1hdGNoKC9eKGh0dHBzPzpcXC9cXC9bXlxcL10qXFwvKS4qJC8pO1xuICAgIGlmIChiYWNrRW5kTWF0Y2ggPT09IG51bGwgfHwgKHNyY01hdGNoICE9PSBudWxsICYmIGJhY2tFbmRNYXRjaFsxXSA9PSBzcmNNYXRjaFsxXSkpIHtcbiAgICAgIHJldHVybiBpbWdQcm9jZXNzb3JCYWNrZW5kICsgXCI/c3JjPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNyYykgKyBcIiZtZXRob2Q9XCIgKyBlbmNvZGVVUklDb21wb25lbnQobWV0aG9kKSArIFwiJnBhcmFtcz1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh3aWR0aCArIFwiLFwiICsgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJDYW5ub3QgYXBwbHkgYmFja2VuZCBpbWFnZSByZXNpemluZyB0byBub24tbG9jYWwgcmVzb3VyY2VzIFwiLCBzcmMsIG1ldGhvZCwgd2lkdGgsIGhlaWdodCwgYmFja0VuZE1hdGNoLCBzcmNNYXRjaCk7XG4gICAgICByZXR1cm4gc3JjICsgXCI/bWV0aG9kPVwiICsgbWV0aG9kICsgXCImd2lkdGg9XCIgKyB3aWR0aCArIChoZWlnaHQgIT09IG51bGwgPyBcIiZoZWlnaHQ9XCIgKyBoZWlnaHQgOiAnJyk7XG4gICAgfVxuICB9O1xuXG4gIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjLnBsYWNlaG9sZGVyVXJsID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgdGV4dCkge1xuICAgIHJldHVybiBvcHRpb25zLmltZ1Byb2Nlc3NvckJhY2tlbmQgKyBcIj9tZXRob2Q9XCIgKyAncGxhY2Vob2xkZXInICsgXCImcGFyYW1zPVwiICsgd2lkdGggKyBlbmNvZGVVUklDb21wb25lbnQoXCIsXCIpICsgaGVpZ2h0O1xuICB9O1xuXG4gIC8vIHB1c2hlcyBjdXN0b20gdGlueW1jZSBjb25maWd1cmF0aW9ucyBmcm9tIG9wdGlvbnMgdG8gdGhlIGJpbmRpbmdcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW55bWNlQ29uZmlnKVxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLnN0YW5kYXJkT3B0aW9ucyA9IG9wdGlvbnMudGlueW1jZUNvbmZpZztcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW55bWNlQ29uZmlnRnVsbClcbiAgICBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5mdWxsT3B0aW9ucyA9IG9wdGlvbnMudGlueW1jZUNvbmZpZ0Z1bGw7XG59O1xuXG52YXIgc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zLCB0ZW1wbGF0ZUZpbGUsIHRlbXBsYXRlTWV0YWRhdGEsIGpzb3Jqc29uLCBjdXN0b21FeHRlbnNpb25zKSB7XG5cbiAgdGVtcGxhdGVMb2FkZXIuZml4UGFnZUV2ZW50cygpO1xuXG4gIHZhciBmaWxlVXBsb2FkTWVzc2FnZXNFeHRlbnNpb24gPSBmdW5jdGlvbih2bSkge1xuICAgIHZhciBmaWxldXBsb2FkQ29uZmlnID0ge1xuICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgdW5rbm93bkVycm9yOiB2bS50KCdVbmtub3duIGVycm9yJyksXG4gICAgICAgIHVwbG9hZGVkQnl0ZXM6IHZtLnQoJ1VwbG9hZGVkIGJ5dGVzIGV4Y2VlZCBmaWxlIHNpemUnKSxcbiAgICAgICAgbWF4TnVtYmVyT2ZGaWxlczogdm0udCgnTWF4aW11bSBudW1iZXIgb2YgZmlsZXMgZXhjZWVkZWQnKSxcbiAgICAgICAgYWNjZXB0RmlsZVR5cGVzOiB2bS50KCdGaWxlIHR5cGUgbm90IGFsbG93ZWQnKSxcbiAgICAgICAgbWF4RmlsZVNpemU6IHZtLnQoJ0ZpbGUgaXMgdG9vIGxhcmdlJyksXG4gICAgICAgIG1pbkZpbGVTaXplOiB2bS50KCdGaWxlIGlzIHRvbyBzbWFsbCcpLFxuICAgICAgICBwb3N0X21heF9zaXplOiB2bS50KCdUaGUgdXBsb2FkZWQgZmlsZSBleGNlZWRzIHRoZSBwb3N0X21heF9zaXplIGRpcmVjdGl2ZSBpbiBwaHAuaW5pJyksXG4gICAgICAgIG1heF9maWxlX3NpemU6IHZtLnQoJ0ZpbGUgaXMgdG9vIGJpZycpLFxuICAgICAgICBtaW5fZmlsZV9zaXplOiB2bS50KCdGaWxlIGlzIHRvbyBzbWFsbCcpLFxuICAgICAgICBhY2NlcHRfZmlsZV90eXBlczogdm0udCgnRmlsZXR5cGUgbm90IGFsbG93ZWQnKSxcbiAgICAgICAgbWF4X251bWJlcl9vZl9maWxlczogdm0udCgnTWF4aW11bSBudW1iZXIgb2YgZmlsZXMgZXhjZWVkZWQnKSxcbiAgICAgICAgbWF4X3dpZHRoOiB2bS50KCdJbWFnZSBleGNlZWRzIG1heGltdW0gd2lkdGgnKSxcbiAgICAgICAgbWluX3dpZHRoOiB2bS50KCdJbWFnZSByZXF1aXJlcyBhIG1pbmltdW0gd2lkdGgnKSxcbiAgICAgICAgbWF4X2hlaWdodDogdm0udCgnSW1hZ2UgZXhjZWVkcyBtYXhpbXVtIGhlaWdodCcpLFxuICAgICAgICBtaW5faGVpZ2h0OiB2bS50KCdJbWFnZSByZXF1aXJlcyBhIG1pbmltdW0gaGVpZ2h0JyksXG4gICAgICAgIGFib3J0OiB2bS50KCdGaWxlIHVwbG9hZCBhYm9ydGVkJyksXG4gICAgICAgIGltYWdlX3Jlc2l6ZTogdm0udCgnRmFpbGVkIHRvIHJlc2l6ZSBpbWFnZScpLFxuICAgICAgICBnZW5lcmljOiB2bS50KCdVbmV4cGVjdGVkIHVwbG9hZCBlcnJvcicpXG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBmaWxlVXBsb2FkIG9wdGlvbnMuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maWxldXBsb2FkQ29uZmlnKVxuICAgICAgZmlsZXVwbG9hZENvbmZpZyA9ICQuZXh0ZW5kKHRydWUsIGZpbGV1cGxvYWRDb25maWcsIG9wdGlvbnMuZmlsZXVwbG9hZENvbmZpZyk7XG5cbiAgICBrby5iaW5kaW5nSGFuZGxlcnNbJ2ZpbGV1cGxvYWQnXS5leHRlbmRPcHRpb25zID0gZmlsZXVwbG9hZENvbmZpZztcblxuICB9O1xuXG4gIHZhciBzaW1wbGVUcmFuc2xhdGlvblBsdWdpbiA9IGZ1bmN0aW9uKHZtKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpbmdzKSB7XG4gICAgICB2bS50ID0gZnVuY3Rpb24oa2V5LCBvYmpQYXJhbSkge1xuICAgICAgICB2YXIgcmVzID0gb3B0aW9ucy5zdHJpbmdzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTWlzc2luZyB0cmFuc2xhdGlvbiBzdHJpbmcgZm9yXCIsa2V5LFwiOiB1c2luZyBkZWZhdWx0IHN0cmluZ1wiKTtcbiAgICAgICAgICByZXMgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZtLnR0KHJlcywgb2JqUGFyYW0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGV4dGVuc2lvbnMgPSBbYWRkVW5kb1N0YWNrRXh0ZW5zaW9uTWFrZXIocGVyZm9ybWFuY2VBd2FyZUNhbGxlciksIGNvbG9yUGx1Z2luLCBzaW1wbGVUcmFuc2xhdGlvblBsdWdpbl07XG4gIGlmICh0eXBlb2YgY3VzdG9tRXh0ZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBjdXN0b21FeHRlbnNpb25zLmxlbmd0aDsgaysrKSBleHRlbnNpb25zLnB1c2goY3VzdG9tRXh0ZW5zaW9uc1trXSk7XG4gIGV4dGVuc2lvbnMucHVzaChmaWxlVXBsb2FkTWVzc2FnZXNFeHRlbnNpb24pO1xuXG4gIHZhciBnYWxsZXJ5VXJsID0gb3B0aW9ucy5maWxldXBsb2FkQ29uZmlnID8gb3B0aW9ucy5maWxldXBsb2FkQ29uZmlnLnVybCA6ICcvdXBsb2FkLyc7XG4gIGFwcGx5QmluZGluZ09wdGlvbnMob3B0aW9ucywga28pO1xuXG4gIC8vIFRPRE8gd2hhdCBhYm91dCBhcHBlbmRpbmcgdG8gYW5vdGhlciBlbGVtZW50P1xuICAkKFwiPCEtLSBrbyB0ZW1wbGF0ZTogJ21haW4nIC0tPjwhLS0gL2tvIC0tPlwiKS5hcHBlbmRUbyhnbG9iYWwuZG9jdW1lbnQuYm9keSk7XG5cbiAgLy8gdGVtcGxhdGVGaWxlIG1heSBvdmVycmlkZSB0aGUgdGVtcGxhdGUgcGF0aCBpbiB0ZW1wbGF0ZU1ldGFkYXRhXG4gIGlmICh0eXBlb2YgdGVtcGxhdGVGaWxlID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0ZW1wbGF0ZU1ldGFkYXRhICE9ICd1bmRlZmluZWQnKSB7XG4gICAgdGVtcGxhdGVGaWxlID0gdGVtcGxhdGVNZXRhZGF0YS50ZW1wbGF0ZTtcbiAgfVxuICAvLyBUT0RPIGNhbm9uaWNhbGl6ZSB0ZW1wbGF0ZUZpbGUgdG8gYWJzb2x1dGUgb3IgcmVsYXRpdmUgZGVwZW5kaW5nIG9uIFwicmVsYXRpdmVVcmxzRXhjZXB0aW9uXCIgcGx1Z2luXG5cbiAgdGVtcGxhdGVMb2FkZXIubG9hZChwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyLCB0ZW1wbGF0ZUZpbGUsIHRlbXBsYXRlTWV0YWRhdGEsIGpzb3Jqc29uLCBleHRlbnNpb25zLCBnYWxsZXJ5VXJsKTtcblxufTtcblxudmFyIGluaXRGcm9tTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24ob3B0aW9ucywgaGFzaF9rZXksIGN1c3RvbUV4dGVuc2lvbnMpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbHNEYXRhID0gbG9jYWxTdG9yYWdlTG9hZGVyKGhhc2hfa2V5LCBvcHRpb25zLmVtYWlsUHJvY2Vzc29yQmFja2VuZCk7XG4gICAgdmFyIGV4dGVuc2lvbnMgPSB0eXBlb2YgY3VzdG9tRXh0ZW5zaW9ucyAhPT0gJ3VuZGVmaW5lZCcgPyBjdXN0b21FeHRlbnNpb25zIDogW107XG4gICAgZXh0ZW5zaW9ucy5wdXNoKGxzRGF0YS5leHRlbnNpb24pO1xuICAgIHZhciB0ZW1wbGF0ZSA9IF9jYW5vbmljYWxpemUobHNEYXRhLm1ldGFkYXRhLnRlbXBsYXRlKTtcbiAgICBzdGFydChvcHRpb25zLCB0ZW1wbGF0ZSwgbHNEYXRhLm1ldGFkYXRhLCBsc0RhdGEubW9kZWwsIGV4dGVuc2lvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRPRE8gbm90IGZvdW5kIFwiLCBoYXNoX2tleSwgZSk7XG4gIH1cbn07XG5cbnZhciBpbml0ID0gZnVuY3Rpb24ob3B0aW9ucywgY3VzdG9tRXh0ZW5zaW9ucykge1xuXG4gIHZhciBoYXNoID0gZ2xvYmFsLmxvY2F0aW9uLmhhc2ggPyBnbG9iYWwubG9jYXRpb24uaHJlZi5zcGxpdChcIiNcIilbMV0gOiB1bmRlZmluZWQ7XG5cbiAgLy8gTG9hZGluZyBmcm9tIGNvbmZpZ3VyZWQgdGVtcGxhdGUgb3IgY29uZmlndXJlZCBtZXRhZGF0YVxuICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy50ZW1wbGF0ZSB8fCBvcHRpb25zLmRhdGEpKSB7XG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKG9wdGlvbnMuZGF0YSk7XG4gICAgICBzdGFydChvcHRpb25zLCB1bmRlZmluZWQsIGRhdGEubWV0YWRhdGEsIGRhdGEuY29udGVudCwgY3VzdG9tRXh0ZW5zaW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0KG9wdGlvbnMsIG9wdGlvbnMudGVtcGxhdGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjdXN0b21FeHRlbnNpb25zKTtcbiAgICB9XG4gICAgLy8gTG9hZGluZyBmcm9tIExvY2FsU3RvcmFnZSAoaWYgdXJsIGhhc2ggaGFzIGEgN2NoYXJzIGtleSlcbiAgfSBlbHNlIGlmIChoYXNoICYmIGhhc2gubGVuZ3RoID09IDcpIHtcbiAgICBpbml0RnJvbUxvY2FsU3RvcmFnZShvcHRpb25zLCBoYXNoLCBjdXN0b21FeHRlbnNpb25zKTtcbiAgICAvLyBMb2FkaW5nIGZyb20gdGVtcGxhdGUgdXJsIGFzIGhhc2ggKGlmIGhhc2ggaXMgbm90IGEgdmFsaWQgbG9jYWxzdG9yYWdlIGtleSlcbiAgfSBlbHNlIGlmIChoYXNoKSB7XG4gICAgc3RhcnQob3B0aW9ucywgX2Nhbm9uaWNhbGl6ZShoYXNoKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGN1c3RvbUV4dGVuc2lvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0NvbXBhdGlibGU6IHRlbXBsYXRlTG9hZGVyLmlzQ29tcGF0aWJsZSxcbiAgaW5pdDogaW5pdCxcbiAgc3RhcnQ6IHN0YXJ0XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbi8vIEBzZWUgYWxzbyBzY3JpcHQtdGVtcGxhdGUuanMgcHVzaFRlbXBsYXRlXG52YXIgYWRkU2NyaXB0VGVtcGxhdGUgPSBmdW5jdGlvbihkb2MsIHRlbXBsYXRlTmFtZSwgdGVtcGxhdGVNYXJrdXApIHtcbiAgdmFyIHNjcmlwdFRhZyA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0VGFnLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2h0bWwnKTtcbiAgc2NyaXB0VGFnLnNldEF0dHJpYnV0ZSgnaWQnLCB0ZW1wbGF0ZU5hbWUpO1xuICBzY3JpcHRUYWcudGV4dCA9IHRlbXBsYXRlTWFya3VwO1xuICBkb2MuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRUYWcpO1xuICByZXR1cm4gc2NyaXB0VGFnO1xuICAvLyAkKCc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2h0bWxcIj48L3NjJyArICdyaXB0PicpLnRleHQodGVtcGxhdGVNYXJrdXApLmF0dHIoJ2lkJywgdGVtcGxhdGVOYW1lKS5hcHBlbmRUbygkKCdib2R5JykpO1xufTtcblxuLy8gdXNlZCBmb3IgbGl2ZSBwcmV2aWV3IGluIGlmcmFtZS5cbmtvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lID0ge1xuICAvLyB0cGwgd2lsbCBiZSBvdmVycmlkZW4gd2l0aCB0aGUgc3RydWN0dXJlIHBhcnNlZCBieSB0aGUgaW5wdXQgdGVtcGxhdGUuXG4gIHRwbDogXCI8IURPQ1RZUEUgaHRtbD5cXHJcXG48aHRtbD5cXHJcXG48aGVhZD5cXHJcXG48L2hlYWQ+XFxyXFxuPGJvZHk+PGRpdiBkYXRhLWJpbmQ9XFxcImJsb2NrOiBjb250ZW50XFxcIj48L2Rpdj48L2JvZHk+XFxyXFxuPC9odG1sPlxcclxcblwiLFxuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yKSB7XG4gICAgZnVuY3Rpb24gYmluZElmcmFtZShsb2NhbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGlmcmFtZSA9IGVsZW1lbnQuY29udGVudERvY3VtZW50O1xuICAgICAgICBpZnJhbWUub3BlbigpO1xuICAgICAgICBpZnJhbWUud3JpdGUoa28uYmluZGluZ0hhbmRsZXJzLmJpbmRJZnJhbWUudHBsKTtcbiAgICAgICAgaWZyYW1lLmNsb3NlKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgaWZyYW1lZG9jID0gaWZyYW1lLmJvZHk7XG4gICAgICAgICAgaWYgKGlmcmFtZWRvYykge1xuICAgICAgICAgICAgLy8gc2NyaXB0cyBoYXZlIHRvIGJlIGR1cGxpY2F0ZWQgKG1heWJlIHRoaXMgaXMgbm90IG5lZWRlZCBhbnltb3JlIHNpbmNlIHVzaW5nIHN0cmluZy10ZW1wbGF0ZXMpXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVzID0gZWxlbWVudC5jb250ZW50V2luZG93LnBhcmVudC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBsYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodGVtcGxhdGVzW2ldLmdldEF0dHJpYnV0ZSgndHlwZScpID09ICd0ZXh0L2h0bWwnICYmIHRlbXBsYXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICAgICAgICAgICAgICBhZGRTY3JpcHRUZW1wbGF0ZShpZnJhbWUsIHRlbXBsYXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJyksIHRlbXBsYXRlc1tpXS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBodG1sID0gaWZyYW1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiSFRNTFwiKTtcblxuICAgICAgICAgICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAga28uY2xlYW5Ob2RlKGh0bWxbMF0gfHwgaWZyYW1lZG9jKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBrby5hcHBseUJpbmRpbmdzKHZhbHVlQWNjZXNzb3IoKSwgaHRtbFswXSB8fCBpZnJhbWVkb2MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vIGlmcmFtZWRvY1wiLCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciByZWFkaW5nIGlmcmFtZS5ib2R5XCIsIGUsIGxvY2FsKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXJyb3IgcmVhZGluZyBpZnJhbWUgY29udGVudERvY3VtZW50XCIsIGUsIGxvY2FsKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgLy8gaWdub3JlZFxuICAgICAgfVxuICAgIH1cbiAgICBiaW5kSWZyYW1lKFwiZmlyc3QgY2FsbFwiKTtcbiAgICAvLyBvbGRlciBicm93c2VycyBuZWVkZWQgdGhpc1xuICAgIC8vIGtvLnV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQsICdsb2FkJywgYmluZElmcmFtZSk7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWxzIGdsb2JhbDpmYWxzZSAqL1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cblxua28uYmluZGluZ0hhbmRsZXJzWyd3aXRoUHJvcGVydGllcyddID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIC8vIE1ha2UgYSBtb2RpZmllZCBiaW5kaW5nIGNvbnRleHQsIHdpdGggYSBleHRyYSBwcm9wZXJ0aWVzLCBhbmQgYXBwbHkgaXQgdG8gZGVzY2VuZGFudCBlbGVtZW50c1xuICAgIHZhciBjaGlsZEJpbmRpbmdDb250ZXh0ID0gYmluZGluZ0NvbnRleHQuY3JlYXRlQ2hpbGRDb250ZXh0KFxuICAgICAgYmluZGluZ0NvbnRleHQuJHJhd0RhdGEsXG4gICAgICBudWxsLCAvLyBPcHRpb25hbGx5LCBwYXNzIGEgc3RyaW5nIGhlcmUgYXMgYW4gYWxpYXMgZm9yIHRoZSBkYXRhIGl0ZW0gaW4gZGVzY2VuZGFudCBjb250ZXh0c1xuICAgICAgZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICBrby51dGlscy5leHRlbmQoY29udGV4dCwgdmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgIH1cbiAgICApO1xuICAgIGtvLmFwcGx5QmluZGluZ3NUb0Rlc2NlbmRhbnRzKGNoaWxkQmluZGluZ0NvbnRleHQsIGVsZW1lbnQpO1xuXG4gICAgLy8gQWxzbyB0ZWxsIEtPICpub3QqIHRvIGJpbmQgdGhlIGRlc2NlbmRhbnRzIGl0c2VsZiwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBiZSBib3VuZCB0d2ljZVxuICAgIHJldHVybiB7XG4gICAgICBjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczogdHJ1ZVxuICAgIH07XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd3aXRoUHJvcGVydGllcyddID0gdHJ1ZTtcblxua28uYmluZGluZ0hhbmRsZXJzWydsb2cnXSA9IHtcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICBjb25zb2xlLmxvZyhcImxvZ1wiLCB2YWx1ZUFjY2Vzc29yKCkpO1xuICB9XG59O1xuXG5cbmtvLmJpbmRpbmdIYW5kbGVyc1snYmxvY2snXSA9IHtcblxuICB0ZW1wbGF0ZUV4aXN0czogZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZWwgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIGlmIChlbCkgcmV0dXJuIHRydWU7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgX2Nob29zZVRlbXBsYXRlOiBmdW5jdGlvbihpc0FycmF5LCBwcmVmaXgsIGFjdGlvbiwgZmFsbGJhY2spIHtcbiAgICB2YXIgaWQgPSBwcmVmaXggKyAnLScgKyBhY3Rpb247XG4gICAgaWYgKGtvLmJpbmRpbmdIYW5kbGVyc1snYmxvY2snXS50ZW1wbGF0ZUV4aXN0cyhpZCkpIHJldHVybiBpZDtcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrICE9ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBudWxsKSByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLl9jaG9vc2VUZW1wbGF0ZShpc0FycmF5LCBwcmVmaXgsIGZhbGxiYWNrKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBmYWxsQmFja0lkID0gaXNBcnJheSA/ICdhcnJheScgOiAnb2JqZWN0LScgKyBhY3Rpb247XG4gICAgICBpZiAoa28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLnRlbXBsYXRlRXhpc3RzKGZhbGxCYWNrSWQpKSByZXR1cm4gZmFsbEJhY2tJZDtcbiAgICAgIGVsc2UgdGhyb3cgXCJjYW5ub3QgZmluZCB0ZW1wbGF0ZSBmb3IgXCIgKyBpZCArIFwiL1wiICsgZmFsbEJhY2tJZDtcbiAgICB9XG4gIH0sXG5cbiAgLy8gY29tcHV0ZSBkaXNwbGF5TW9kZSBkZXBlbmRpbmcgb24gdGVtcGxhdGVNb2RlIHNldCB1c2luZyBcIndpdGhQcm9wZXJ0aWVzXCIgYmluZGluZy5cbiAgX2Rpc3BsYXlNb2RlOiBmdW5jdGlvbih1bndyYXBwZWQsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIHByZWZpeCA9IHR5cGVvZiB1bndyYXBwZWQudHlwZSAhPSAndW5kZWZpbmVkJyA/IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodW53cmFwcGVkLnR5cGUpIDogJ25vdGFibG9jay0nICsgdHlwZW9mKHVud3JhcHBlZCk7XG4gICAgdmFyIGlzQXJyYXkgPSB0eXBlb2YgdW53cmFwcGVkLnNwbGljZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIHRlbXBsYXRlTW9kZSA9IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA/IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA6ICdzaG93JztcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLl9jaG9vc2VUZW1wbGF0ZShpc0FycmF5LCBwcmVmaXgsIHRlbXBsYXRlTW9kZSwgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlRmFsbGJhY2spO1xuICB9LFxuXG4gIF9tYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yOiBmdW5jdGlvbih2YWx1ZUFjY2Vzc29yLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlQWNjZXNzb3IoKSxcbiAgICAgICAgdW53cmFwcGVkVmFsdWUgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZSh2YWx1ZSk7IC8vIFVud3JhcCB3aXRob3V0IHNldHRpbmcgYSBkZXBlbmRlbmN5IGhlcmVcblxuICAgICAgLy8gSWYgdW53cmFwcGVkVmFsdWUuZGF0YSBpcyB0aGUgYXJyYXksIHByZXNlcnZlIGFsbCByZWxldmFudCBvcHRpb25zIGFuZCB1bndyYXAgYWdhaW4gdmFsdWUgc28gd2UgZ2V0IHVwZGF0ZXNcbiAgICAgIHZhciBtb2RlbFZhbHVlO1xuICAgICAgdmFyIHRlbXBsYXRlO1xuXG4gICAgICBpZiAoKCF1bndyYXBwZWRWYWx1ZSkgfHwgKHR5cGVvZiB1bndyYXBwZWRWYWx1ZS5kYXRhICE9ICdvYmplY3QnICYmIHR5cGVvZiB1bndyYXBwZWRWYWx1ZS5kYXRhICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIG1vZGVsVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsVmFsdWUgPSB1bndyYXBwZWRWYWx1ZS5kYXRhO1xuICAgICAgICBpZiAodHlwZW9mIHVud3JhcHBlZFZhbHVlLnRlbXBsYXRlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIHRlbXBsYXRlUGFyYW0gPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHVud3JhcHBlZFZhbHVlLnRlbXBsYXRlKTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVNb2RlID0gYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID8gYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlIDogJ3Nob3cnO1xuICAgICAgICAgIHRlbXBsYXRlID0ga28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLl9jaG9vc2VUZW1wbGF0ZShmYWxzZSwgdGVtcGxhdGVQYXJhbSwgdGVtcGxhdGVNb2RlLCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGVGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVud3JhcHBlZE1vZGVsVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKG1vZGVsVmFsdWUpO1xuICAgICAgaWYgKGtvLmlzT2JzZXJ2YWJsZSh1bndyYXBwZWRNb2RlbFZhbHVlKSkgY29uc29sZS5sb2coXCJkb3VibGVPYnNlcnZhYmxlXCIsIHVud3JhcHBlZE1vZGVsVmFsdWUpO1xuXG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5PVEUgSUU4IHVzZWQgdG8gYnJlYWsgaGVyZSwgYnV0IHdlIGRvbid0IHN1cHBvcnQgaXQgYW55bW9yZSwgc28gbWF5YmUgdGhpcyBpcyBub3QgbmVlZGVkLlxuICAgICAgICBpZiAobW9kZWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSAnZW1wdHknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IGtvLmJpbmRpbmdIYW5kbGVyc1snYmxvY2snXS5fZGlzcGxheU1vZGUodW53cmFwcGVkTW9kZWxWYWx1ZSwgYmluZGluZ0NvbnRleHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUsIHVud3JhcHBlZE1vZGVsVmFsdWUsIGJpbmRpbmdDb250ZXh0WyckZGF0YSddLCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ25hbWUnOiB0ZW1wbGF0ZSxcbiAgICAgICAgJ2RhdGEnOiBtb2RlbFZhbHVlLFxuICAgICAgICAndGVtcGxhdGVFbmdpbmUnOiBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZS5pbnN0YW5jZVxuICAgICAgfTtcbiAgICB9O1xuICB9LFxuXG4gICdpbml0JzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlQWNjZXNzb3IoKSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUubG9nKFwiZm91bmQgYSBudWxsIGJsb2NrOiBjaGVjayBlbmRpbmcgY29tbWFzIGluIGFycmF5cyBkZWZzIGluIElFXCIpO1xuICAgIHZhciBuZXdWYWx1ZUFjY2Vzc29yID0ga28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLl9tYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IsIGJpbmRpbmdDb250ZXh0KTtcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd0ZW1wbGF0ZSddWydpbml0J10oZWxlbWVudCwgbmV3VmFsdWVBY2Nlc3Nvcik7XG4gIH0sXG4gICd1cGRhdGUnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciBuZXdWYWx1ZUFjY2Vzc29yID0ga28uYmluZGluZ0hhbmRsZXJzWydibG9jayddLl9tYWtlVGVtcGxhdGVWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IsIGJpbmRpbmdDb250ZXh0KTtcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd0ZW1wbGF0ZSddWyd1cGRhdGUnXShlbGVtZW50LCBuZXdWYWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gIH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLmJpbmRpbmdSZXdyaXRlVmFsaWRhdG9yc1snYmxvY2snXSA9IGZhbHNlOyAvLyBDYW4ndCByZXdyaXRlIGNvbnRyb2wgZmxvdyBiaW5kaW5nc1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snYmxvY2snXSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHNjcmlwdCB0ZW1wbGF0ZSBpcyB0aGUgb25lIHByb3ZpZGVkIGJ5IEtPIGFuZCBkZWFscyB3aXRoIHRlbXBhbHRlcyBkZWZpbmVkIGFzIDxzY3JpcHQgdHlwZT10ZXh0L2h0bWwuXG4vLyBzdHJpbmcgdGVtcGxhdGUgZGVmaW5lcyB0aGVtIGluIG1lbW9yeSBhbmQgYXZvaWRzIHBvbGx1dGluZyB0aGUgSFRNTDogc2VlbXMgdG8gd29yayBiZXR0ZXIgaW4gTW9zYWljby5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N0cmluZy10ZW1wbGF0ZS5qcycpO1xuLy8gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NjcmlwdC10ZW1wbGF0ZS5qcycpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG5yZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2V2b2wtY29sb3JwaWNrZXIvanMvZXZvbC5jb2xvcnBpY2tlci5taW4uanNcIik7XG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGtvanF1aSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wydrb2pxdWknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvanF1aSddIDogbnVsbCk7XG5cblxudmFyIENvbG9yUGlja2VyID0gZnVuY3Rpb24oKSB7XG4gIGtvanF1aS5CaW5kaW5nSGFuZGxlci5jYWxsKHRoaXMsICdjb2xvcnBpY2tlcicpO1xufTtcbkNvbG9yUGlja2VyLnByb3RvdHlwZSA9IGtvanF1aS51dGlscy5jcmVhdGVPYmplY3Qoa29qcXVpLkJpbmRpbmdIYW5kbGVyLnByb3RvdHlwZSk7XG5Db2xvclBpY2tlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xvclBpY2tlcjtcblxuQ29sb3JQaWNrZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuICB2YXIgdmEgPSB2YWx1ZUFjY2Vzc29yKCk7XG4gIHZhciB2YWx1ZSA9IHZhLmNvbG9yO1xuXG4gIC8vIEluIG9yZGVyIHRvIGhhdmUgYSBjb3JyZWN0IGRlcGVuZGVuY3kgdHJhY2tpbmcgaW4gXCJpZlN1YnNcIiB3ZSBoYXZlIHRvIGVuc3VyZSB3ZSB1c2UgYSBzaW5nbGUgY29tcHV0ZXIgZm9yIGVhY2ggZWRpdGFibGVcbiAgLy8gcHJvcGVydHkuIEdpdmVuIHRoaXMgYmluZGluZyBuZWVkcyAyIG9mIHRoZW0sIHdlIGNyZWF0ZSBhIGNvbXB1dGVkIHNvIHRvIFwicHJveHlcIiB0aGUgZGVwZW5kZW5jaWVzLlxuICB2YXIgbmV3RE8gPSBrby5jb21wdXRlZCh7XG4gICAgcmVhZDogdmFsdWUsXG4gICAgd3JpdGU6IHZhbHVlLFxuICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuICB9KTtcbiAgdmFyIG5ld1ZBID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ld0RPO1xuICB9O1xuXG4gIGtvLmJpbmRpbmdIYW5kbGVycy52YWx1ZS5pbml0KGVsZW1lbnQsIG5ld1ZBLCBhbGxCaW5kaW5ncyk7XG5cbiAgdmFyIGNoYW5nZVByb3BhZ2F0b3IgPSBmdW5jdGlvbihldmVudCwgY29sb3IpIHtcbiAgICBpZiAodHlwZW9mIGNvbG9yICE9PSAndW5kZWZpbmVkJykgbmV3RE8oY29sb3IpO1xuICB9O1xuICAkKGVsZW1lbnQpLm9uKCdjaGFuZ2UuY29sb3InLCBjaGFuZ2VQcm9wYWdhdG9yKTtcblxuICBrby5jb21wdXRlZCh7XG4gICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0ID0ge1xuICAgICAgICBjb2xvcjoga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShuZXdETyksXG4gICAgICAgIHNob3dPbjogJ2J1dHRvbidcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHZhKVxuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbG9yJyAmJiB2YS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgb3B0W3Byb3BdID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YVtwcm9wXSk7XG4gICAgICAkKGVsZW1lbnQpLmNvbG9ycGlja2VyKG9wdCk7XG4gICAgfSxcbiAgICBkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnRcbiAgfSk7XG5cbiAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAkKGVsZW1lbnQpLm9mZignY2hhbmdlLmNvbG9yJywgY2hhbmdlUHJvcGFnYXRvcik7XG4gICAgJChlbGVtZW50KS5jb2xvcnBpY2tlcignZGVzdHJveScpO1xuICB9KTtcblxufTtcbmtvanF1aS51dGlscy5yZWdpc3RlcihDb2xvclBpY2tlcik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xuXG4vKiBodHRwczovL2dpdGh1Yi5jb20va25vY2tvdXQva25vY2tvdXQvaXNzdWVzLzExNzEgKi9cbmtvLmJpbmRpbmdIYW5kbGVycy5jc3NUZXh0ID0ge1xuICAndXBkYXRlJzogZnVuY3Rpb24obm9kZSwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpIHtcbiAgICB2YXIgdGV4dCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICB0cnkge1xuICAgICAgbm9kZS5pbm5lclRleHQgPSB0ZXh0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghbm9kZS5zdHlsZVNoZWV0KSBub2RlLmlubmVySFRNTCA9IFwiYXt9XCI7XG4gICAgICBub2RlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgfVxuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcblxuLyoga25vY2tvdXQgZHJvcHBhYmxlLCB3aXRoIHNpbXBsaWZpZWQgVU1EICovXG47KGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgZmFjdG9yeShrbywgJCk7XG59KShmdW5jdGlvbihrbywgJCkge1xuICB2YXIgSVRFTUtFWSA9IFwia29fc29ydEl0ZW1cIixcbiAgICBJTkRFWEtFWSA9IFwia29fc291cmNlSW5kZXhcIixcbiAgICBMSVNUS0VZID0gXCJrb19zb3J0TGlzdFwiLFxuICAgIFBBUkVOVEtFWSA9IFwia29fcGFyZW50TGlzdFwiLFxuICAgIERSQUdLRVkgPSBcImtvX2RyYWdJdGVtXCIsXG4gICAgdW53cmFwID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSxcbiAgICBkYXRhR2V0ID0ga28udXRpbHMuZG9tRGF0YS5nZXQsXG4gICAgZGF0YVNldCA9IGtvLnV0aWxzLmRvbURhdGEuc2V0O1xuXG4gIGtvLmJpbmRpbmdIYW5kbGVycy5kcm9wcGFibGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KSxcbiAgICAgICAgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfHwge30sXG4gICAgICAgIGRyb3BwYWJsZSA9IHt9LFxuICAgICAgICBkcm9wQWN0dWFsO1xuXG4gICAgICAkLmV4dGVuZCh0cnVlLCBkcm9wcGFibGUsIGtvLmJpbmRpbmdIYW5kbGVycy5kcm9wcGFibGUpO1xuICAgICAgaWYgKHZhbHVlLmRhdGEpIHtcbiAgICAgICAgaWYgKHZhbHVlLm9wdGlvbnMgJiYgZHJvcHBhYmxlLm9wdGlvbnMpIHtcbiAgICAgICAgICBrby51dGlscy5leHRlbmQoZHJvcHBhYmxlLm9wdGlvbnMsIHZhbHVlLm9wdGlvbnMpO1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZS5vcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGtvLnV0aWxzLmV4dGVuZChkcm9wcGFibGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyb3BwYWJsZS5kYXRhID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGRyb3BBY3R1YWwgPSBkcm9wcGFibGUub3B0aW9ucy5kcm9wO1xuXG4gICAgICAkZWxlbWVudC5kcm9wcGFibGUoa28udXRpbHMuZXh0ZW5kKGRyb3BwYWJsZS5vcHRpb25zLCB7XG4gICAgICAgIGRyb3A6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG4gICAgICAgICAgdmFyIGVsID0gdWkuZHJhZ2dhYmxlWzBdLFxuICAgICAgICAgICAgaXRlbSA9IGRhdGFHZXQoZWwsIElURU1LRVkpIHx8IGRhdGFHZXQoZWwsIERSQUdLRVkpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0pIHtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uY2xvbmUpIHtcbiAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0uY2xvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyb3BwYWJsZS5kcmFnZ2VkKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSBkcm9wcGFibGUuZHJhZ2dlZC5jYWxsKHRoaXMsIGl0ZW0sIGV2ZW50LCB1aSkgfHwgaXRlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyb3BwYWJsZS5kYXRhKSB7XG4gICAgICAgICAgICAgIGRyb3BwYWJsZS5kYXRhKGl0ZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRyb3BBY3R1YWwpIHtcbiAgICAgICAgICAgIGRyb3BBY3R1YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvL2hhbmRsZSBlbmFibGluZy9kaXNhYmxpbmdcbiAgICAgIGlmIChkcm9wcGFibGUuaXNFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga28uY29tcHV0ZWQoe1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJGVsZW1lbnQuZHJvcHBhYmxlKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZHJvcHBhYmxlLmlzRW5hYmxlZCkgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpIHtcblxuICAgIH0sXG4gICAgdGFyZ2V0SW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJNb3ZlOiBudWxsLFxuICAgIGJlZm9yZU1vdmU6IG51bGwsXG4gICAgb3B0aW9uczoge31cbiAgfTtcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbi8qIHV0aWxpdHkgZm9yIHRvZ2V0aGVyanMgKi9cbmtvLmJpbmRpbmdIYW5kbGVycy5mb2N1c2FibGUgPSB7XG4gICdmb2N1cyc6IGZ1bmN0aW9uKCkge30sXG4gICdibHVyJzogZnVuY3Rpb24oKSB7fSxcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICQoZWxlbWVudCkub2ZmKFwiZm9jdXNpblwiLCBrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlLmZvY3VzKTtcbiAgICAgICQoZWxlbWVudCkub2ZmKFwiZm9jdXNvdXRcIiwga28uYmluZGluZ0hhbmRsZXJzLmZvY3VzYWJsZS5ibHVyKTtcbiAgICB9KTtcblxuICAgICQoZWxlbWVudCkub24oXCJmb2N1c2luXCIsIGtvLmJpbmRpbmdIYW5kbGVycy5mb2N1c2FibGUuZm9jdXMpO1xuICAgICQoZWxlbWVudCkub24oXCJmb2N1c291dFwiLCBrby5iaW5kaW5nSGFuZGxlcnMuZm9jdXNhYmxlLmJsdXIpO1xuXG4gIH1cbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxhYmxlID0ge1xuICAnc2Nyb2xsJzogZnVuY3Rpb24oKSB7fSxcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAga28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICQoZWxlbWVudCkub2ZmKFwic2Nyb2xsXCIsIGtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxhYmxlLnNjcm9sbCk7XG4gICAgfSk7XG5cbiAgICAkKGVsZW1lbnQpLm9uKFwic2Nyb2xsXCIsIGtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxhYmxlLnNjcm9sbCk7XG5cbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG5cbmtvLmV4dGVuZGVycy5wYWdpbmcgPSBmdW5jdGlvbih0YXJnZXQsIHBhZ2VTaXplKSB7XG4gIHZhciBfcGFnZVNpemUgPSBrby5vYnNlcnZhYmxlKHBhZ2VTaXplIHx8IDEwKSxcbiAgICAvLyBkZWZhdWx0IHBhZ2VTaXplIHRvIDEwXG4gICAgX2N1cnJlbnRQYWdlID0ga28ub2JzZXJ2YWJsZSgxKTsgLy8gZGVmYXVsdCBjdXJyZW50IHBhZ2UgdG8gMVxuICB0YXJnZXQucGFnZVNpemUgPSBrby5jb21wdXRlZCh7XG4gICAgcmVhZDogX3BhZ2VTaXplLFxuICAgIHdyaXRlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID4gMCkge1xuICAgICAgICBfcGFnZVNpemUobmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3BhZ2VTaXplKDEwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRhcmdldC5jdXJyZW50UGFnZSA9IGtvLmNvbXB1dGVkKHtcbiAgICByZWFkOiBfY3VycmVudFBhZ2UsXG4gICAgd3JpdGU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPiB0YXJnZXQucGFnZUNvdW50KCkpIHtcbiAgICAgICAgX2N1cnJlbnRQYWdlKHRhcmdldC5wYWdlQ291bnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlIDw9IDApIHtcbiAgICAgICAgX2N1cnJlbnRQYWdlKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2N1cnJlbnRQYWdlKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRhcmdldC5wYWdlQ291bnQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRhcmdldCgpLmxlbmd0aCAvIHRhcmdldC5wYWdlU2l6ZSgpKSB8fCAxO1xuICB9KTtcblxuICB0YXJnZXQuY3VycmVudFBhZ2VEYXRhID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhZ2VTaXplID0gX3BhZ2VTaXplKCksXG4gICAgICBwYWdlSW5kZXggPSBfY3VycmVudFBhZ2UoKSxcbiAgICAgIHN0YXJ0SW5kZXggPSBwYWdlU2l6ZSAqIChwYWdlSW5kZXggLSAxKSxcbiAgICAgIGVuZEluZGV4ID0gcGFnZVNpemUgKiBwYWdlSW5kZXg7XG5cbiAgICByZXR1cm4gdGFyZ2V0KCkuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICB9KTtcblxuICB0YXJnZXQubW92ZUZpcnN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGFyZ2V0LmN1cnJlbnRQYWdlKDEpO1xuICB9O1xuICB0YXJnZXQubW92ZVByZXZpb3VzID0gZnVuY3Rpb24oKSB7XG4gICAgdGFyZ2V0LmN1cnJlbnRQYWdlKHRhcmdldC5jdXJyZW50UGFnZSgpIC0gMSk7XG4gIH07XG4gIHRhcmdldC5tb3ZlTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRhcmdldC5jdXJyZW50UGFnZSh0YXJnZXQuY3VycmVudFBhZ2UoKSArIDEpO1xuICB9O1xuICB0YXJnZXQubW92ZUxhc3QgPSBmdW5jdGlvbigpIHtcbiAgICB0YXJnZXQuY3VycmVudFBhZ2UodGFyZ2V0LnBhZ2VDb3VudCgpKTtcbiAgfTtcblxuICByZXR1cm4gdGFyZ2V0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgZ2xvYmFsOiB0cnVlICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMva25vY2tvdXQtc29ydGFibGUvYnVpbGQva25vY2tvdXQtc29ydGFibGUubWluLmpzXCIpO1xuXG52YXIgaXNEcmFnZ2luZ0hlbHBlciA9IGZ1bmN0aW9uKHdyaXRhYmxlLCBlKSB7XG4gIGlmICh3cml0YWJsZSgpKSB7XG4gICAgaWYgKGUudHlwZSA9PSB3cml0YWJsZSgpICsgJ3N0b3AnKSB3cml0YWJsZShmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUudHlwZSA9PSAnZHJhZ3N0YXJ0JyB8fCBlLnR5cGUgPT0gJ3NvcnRzdGFydCcpIHdyaXRhYmxlKGUudHlwZS5zdWJzdHJpbmcoMCwgNCkpO1xuICB9XG59O1xuXG52YXIgbWFrZUV4dGVuZGVkVmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBtb2RlbFZhbHVlID0gdmFsdWVBY2Nlc3NvcigpLFxuICAgICAgdW53cmFwcGVkVmFsdWUgPSBrby51dGlscy5wZWVrT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTsgLy8gVW53cmFwIHdpdGhvdXQgc2V0dGluZyBhIGRlcGVuZGVuY3kgaGVyZVxuXG4gICAga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShtb2RlbFZhbHVlKTtcblxuICAgIGlmIChtb2RlbFZhbHVlLm9wdGlvbnMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG1vZGVsVmFsdWUub3B0aW9ucyA9IHt9O1xuICAgIH1cblxuXG5cbiAgICB2YXIgb3JpZ1N0YXJ0ID0gbW9kZWxWYWx1ZS5vcHRpb25zLnN0YXJ0O1xuICAgIG1vZGVsVmFsdWUub3B0aW9ucy5zdGFydCA9IGZ1bmN0aW9uKGUsIHVpKSB7XG4gICAgICBpZiAodHlwZW9mIG1vZGVsVmFsdWUuZHJhZ2dpbmcgIT0gJ3VuZGVmaW5lZCcgJiYga28uaXNXcml0YWJsZU9ic2VydmFibGUobW9kZWxWYWx1ZS5kcmFnZ2luZykpIGlzRHJhZ2dpbmdIZWxwZXIobW9kZWxWYWx1ZS5kcmFnZ2luZywgZSk7XG4gICAgICBpZiAodHlwZW9mIG1vZGVsVmFsdWUuZHJvcENvbnRhaW5lciAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2RlbFZhbHVlLnNjcm9sbEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBmb28gPSAkKG1vZGVsVmFsdWUuZHJvcENvbnRhaW5lcikuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgJChtb2RlbFZhbHVlLmRyb3BDb250YWluZXIpLnNjcm9sbFRvcChmb28gKyBtb2RlbFZhbHVlLmFkZGluZyk7XG4gICAgICAgIH0sIDIwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3JpZ1N0YXJ0ICE9ICd1bmRlZmluZWQnKSByZXR1cm4gb3JpZ1N0YXJ0KGUsIHVpKTtcbiAgICB9O1xuICAgIHZhciBvcmlnU3RvcCA9IG1vZGVsVmFsdWUub3B0aW9ucy5zdG9wO1xuICAgIG1vZGVsVmFsdWUub3B0aW9ucy5zdG9wID0gZnVuY3Rpb24oZSwgdWkpIHtcbiAgICAgIGlmICh0eXBlb2YgbW9kZWxWYWx1ZS5kcmFnZ2luZyAhPSAndW5kZWZpbmVkJyAmJiBrby5pc1dyaXRhYmxlT2JzZXJ2YWJsZShtb2RlbFZhbHVlLmRyYWdnaW5nKSkgaXNEcmFnZ2luZ0hlbHBlcihtb2RlbFZhbHVlLmRyYWdnaW5nLCBlKTtcbiAgICAgIGlmICh0eXBlb2YgbW9kZWxWYWx1ZS5kcm9wQ29udGFpbmVyICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGdsb2JhbC5jbGVhckludGVydmFsKG1vZGVsVmFsdWUuc2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcmlnU3RvcCAhPSAndW5kZWZpbmVkJykgcmV0dXJuIG9yaWdTdG9wKGUsIHVpKTtcbiAgICB9O1xuICAgIHZhciBvcmlnRHJhZyA9IG1vZGVsVmFsdWUub3B0aW9ucy5kcmFnO1xuICAgIG1vZGVsVmFsdWUub3B0aW9ucy5kcmFnID0gZnVuY3Rpb24oZSwgdWkpIHtcbiAgICAgIGlmICh0eXBlb2YgbW9kZWxWYWx1ZS5kcm9wQ29udGFpbmVyICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB0b3AgPSBlLnBhZ2VZIC0gJChtb2RlbFZhbHVlLmRyb3BDb250YWluZXIpLm9mZnNldCgpLnRvcDtcbiAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCAtICQobW9kZWxWYWx1ZS5kcm9wQ29udGFpbmVyKS5oZWlnaHQoKTtcbiAgICAgICAgLy8gSGFuZGxlIHNjcm9sbGluZyBzcGVlZCBkZXBlbmRpbmcgb24gZGlzdGFuY2UgZnJvbSBib3JkZXIuXG4gICAgICAgIGlmICh0b3AgPCAtMjApIHtcbiAgICAgICAgICBtb2RlbFZhbHVlLmFkZGluZyA9IC0yMDtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIjw8PFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3AgPCAwKSB7XG4gICAgICAgICAgbW9kZWxWYWx1ZS5hZGRpbmcgPSAtMTA7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCI8PFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3AgPCAxMCkge1xuICAgICAgICAgIG1vZGVsVmFsdWUuYWRkaW5nID0gLTU7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCI8XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbSA+IDIwKSB7XG4gICAgICAgICAgbW9kZWxWYWx1ZS5hZGRpbmcgPSAyMDtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIj4+PlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b20gPiAwKSB7XG4gICAgICAgICAgbW9kZWxWYWx1ZS5hZGRpbmcgPSAxMDtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIj4+XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGJvdHRvbSA+IC0xMCkge1xuICAgICAgICAgIG1vZGVsVmFsdWUuYWRkaW5nID0gNTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIj5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWxWYWx1ZS5hZGRpbmcgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9yaWdEcmFnICE9ICd1bmRlZmluZWQnKSByZXR1cm4gb3JpZ0RyYWcoZSwgdWkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbW9kZWxWYWx1ZTtcbiAgfTtcbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVycy5leHRzb3J0YWJsZSA9IHtcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnMuc29ydGFibGUuaW5pdChlbGVtZW50LCBtYWtlRXh0ZW5kZWRWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IpLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy5zb3J0YWJsZS51cGRhdGUoZWxlbWVudCwgbWFrZUV4dGVuZGVkVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCk7XG4gIH1cbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVycy5leHRkcmFnZ2FibGUgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpIHtcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLmRyYWdnYWJsZS5pbml0KGVsZW1lbnQsIG1ha2VFeHRlbmRlZFZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpIHtcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLmRyYWdnYWJsZS51cGRhdGUoZWxlbWVudCwgbWFrZUV4dGVuZGVkVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCk7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSwgSW1hZ2U6IGZhbHNlICovXG5cbi8vIFRoaXMgbW9kdWxlIGRlcGVuZHMgb24gdGhvc2UgZmlsZXMsIGJ1dCBpdCBkb2Vzbid0IGhhdmUgYSBkaXJlY3QgZGVwZW5kZW5jeSwgc28gd2UgZG9uJ3QgcmVxdWlyZSB0aGVtIGhlcmUuXG5cbi8vcmVxdWlyZShcImJsdWVpbXAtY2FudmFzLXRvLWJsb2JcIik7XG4vL3JlcXVpcmUoXCJqcXVlcnktZmlsZS11cGxvYWQvanMvanF1ZXJ5LmlmcmFtZS10cmFuc3BvcnQuanNcIik7XG4vL3JlcXVpcmUoXCJqcXVlcnktZmlsZS11cGxvYWQvanMvanF1ZXJ5LmZpbGV1cGxvYWQuanNcIik7XG4vL3JlcXVpcmUoXCJqcXVlcnktZmlsZS11cGxvYWQvanMvanF1ZXJ5LmZpbGV1cGxvYWQtcHJvY2Vzcy5qc1wiKTtcbi8vcmVxdWlyZShcImpxdWVyeS1maWxlLXVwbG9hZC9qcy9qcXVlcnkuZmlsZXVwbG9hZC1pbWFnZS5qc1wiKTtcbi8vcmVxdWlyZShcImpxdWVyeS1maWxlLXVwbG9hZC9qcy9qcXVlcnkuZmlsZXVwbG9hZC12YWxpZGF0ZS5qc1wiKTtcblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG4vLyBleHBlcmltZW50YWwgaW1hZ2UgcHJlbG9hZGluZy5cbmtvLmJpbmRpbmdIYW5kbGVyc1sncHJlbG9hZGVyJ10gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5wcmVsb2FkZWQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlLnByZWxvYWRlZCA9IGtvLm9ic2VydmFibGUoXCJcIik7XG5cbiAgICAgIHZhciBwcmVsb2FkZXIgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgIT0gdmFsdWUucHJlbG9hZGVkKCkpIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhbHVlLnByZWxvYWRlZChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFsdWUucHJlbG9hZGVkKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcuc3JjID0gbmV3VmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlLnByZWxvYWRlZChuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YWx1ZS5zdWJzY3JpYmUocHJlbG9hZGVyKTtcbiAgICAgIHByZWxvYWRlcih2YWx1ZSgpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFRPRE8gd2UgZG9uJ3QgdXNlIGFkdmF0dHIgYW5kIGFkdnN0eWxlLCBtYXliZSB3ZSBzaG91bGQgc2ltcGx5IHJlbW92ZSB0aGlzIGNvZGUuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2FkdmF0dHInXSA9IHtcbiAgJ2luaXQnOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpIHx8IHt9KTtcbiAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHZhbHVlLCBmdW5jdGlvbihhdHRyTmFtZSwgYXR0clZhbHVlQWNjZXNzb3IpIHtcbiAgICAgIHZhciBhdHRyVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgIGlmIChrby5pc1dyaXRlYWJsZU9ic2VydmFibGUoYXR0clZhbHVlQWNjZXNzb3IpKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGF0dHJWYWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICBhdHRyVmFsdWVBY2Nlc3NvcihhdHRyVmFsdWUpO1xuICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBZHZBdHRyIGZvdW5kIGEgdmFsdWUgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHRcIiwgYXR0ck5hbWUsIG9sZFZhbHVlLCBhdHRyVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MpIHtcbiAgICB2YXIgdmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgfHwge307XG4gICAga28udXRpbHMub2JqZWN0Rm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oYXR0ck5hbWUsIGF0dHJWYWx1ZSkge1xuICAgICAgYXR0clZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShhdHRyVmFsdWUpO1xuICAgICAgLy8gVG8gY292ZXIgY2FzZXMgbGlrZSBcImF0dHI6IHsgY2hlY2tlZDpzb21lUHJvcCB9XCIsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgZW50aXJlbHlcbiAgICAgIC8vIHdoZW4gc29tZVByb3AgaXMgYSBcIm5vIHZhbHVlXCItbGlrZSB2YWx1ZSAoc3RyaWN0bHkgbnVsbCwgZmFsc2UsIG9yIHVuZGVmaW5lZClcbiAgICAgIC8vIChiZWNhdXNlIHRoZSBhYnNlbmNlIG9mIHRoZSBcImNoZWNrZWRcIiBhdHRyIGlzIGhvdyB0byBtYXJrIGFuIGVsZW1lbnQgYXMgbm90IGNoZWNrZWQsIGV0Yy4pXG4gICAgICB2YXIgdG9SZW1vdmUgPSAoYXR0clZhbHVlID09PSBmYWxzZSkgfHwgKGF0dHJWYWx1ZSA9PT0gbnVsbCkgfHwgKGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgIGlmICh0b1JlbW92ZSkgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuICB9XG59O1xua28uYmluZGluZ0hhbmRsZXJzWydhZHZzdHlsZSddID0ge1xuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkgfHwge30pO1xuICAgIGtvLnV0aWxzLm9iamVjdEZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZUFjY2Vzc29yKSB7XG4gICAgICB2YXIgc3R5bGVWYWx1ZTtcbiAgICAgIGlmIChzdHlsZU5hbWUubWF0Y2goL1B4JC8pKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlTmFtZS5zdWJzdHIoMCwgc3R5bGVOYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICBzdHlsZVZhbHVlID0gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZS5tYXRjaCgvcHgkLykpIHtcbiAgICAgICAgICBzdHlsZVZhbHVlID0gc3R5bGVWYWx1ZS5yZXBsYWNlKC9weCQvLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBZHZTdHlsZSBiaW5kaW5nIGZvdW5kIGFuIHVuZXhwZWN0ZWQgZGVmYXVsdCB2YWx1ZVwiLCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZVZhbHVlID0gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoa28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHN0eWxlVmFsdWVBY2Nlc3NvcikpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gc3R5bGVWYWx1ZUFjY2Vzc29yKCk7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPSBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgc3R5bGVWYWx1ZUFjY2Vzc29yKHN0eWxlVmFsdWUpO1xuICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBZHZTdHlsZSBmb3VuZCBhIHZhbHVlIGRpZmZlcmVudCBmcm9tIHRoZSBkZWZhdWx0XCIsIHN0eWxlTmFtZSwgb2xkVmFsdWUsIHN0eWxlVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgIHZhciB2YWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpIHx8IHt9KTtcbiAgICBrby51dGlscy5vYmplY3RGb3JFYWNoKHZhbHVlLCBmdW5jdGlvbihzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgIHN0eWxlVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHN0eWxlVmFsdWUpO1xuXG4gICAgICBpZiAoc3R5bGVWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgc3R5bGVWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3R5bGVWYWx1ZSA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZU5hbWUubWF0Y2goL1B4JC8pKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlTmFtZS5zdWJzdHIoMCwgc3R5bGVOYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICBzdHlsZVZhbHVlID0gc3R5bGVWYWx1ZSArIFwicHhcIjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gVXRpbGl0eSB0byBsb2cgaW5pemlhbGl6YXRpb24gYW5kIGRpc3Bvc2FsIG9mIERPTSBlbGVtZW50cy5cbmtvLmJpbmRpbmdIYW5kbGVyc1snZG9tbG9nJ10gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICBjb25zb2xlLmxvZyhcImluaXRpYWxpemVkXCIsIGVsZW1lbnQpO1xuICAgIGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soZWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImRpc3Bvc2VkXCIsIGVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ2Z1ZHJvcHBhYmxlJ10gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICB2YXIgb3B0ID0gdmFsdWVBY2Nlc3NvcigpIHx8IHt9O1xuICAgIHZhciB0aW1lb3V0c09iaiA9IHt9O1xuXG4gICAgdmFyIG92ZXIgPSBmdW5jdGlvbih0aW1lb3V0cywgZHJvcFpvbmVUaW1lb3V0LCBlbGVtZW50LCBjbGFzc05hbWUsIG9ic2VydmFibGUsIGV2ZW50KSB7XG5cbiAgICAgIGlmICghdGltZW91dHNbZHJvcFpvbmVUaW1lb3V0XSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKG9ic2VydmFibGUpICYmICFvYnNlcnZhYmxlKCkpIHtcbiAgICAgICAgICBvYnNlcnZhYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbG9iYWwuY2xlYXJUaW1lb3V0KHRpbWVvdXRzW2Ryb3Bab25lVGltZW91dF0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lb3V0c1tkcm9wWm9uZVRpbWVvdXRdID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtvLmlzV3JpdGVhYmxlT2JzZXJ2YWJsZShvYnNlcnZhYmxlKSAmJiBvYnNlcnZhYmxlKCkpIHtcbiAgICAgICAgICBvYnNlcnZhYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gJ2RyYWdsZWF2ZScpIHN0b3AoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBVc2luZyAxMDAgaXQgZG9lbnMndCB3b3JrIGZpbmUgb24gTGludXggKGNob21lL2ZpcmVmb3gpLCB1c2luZyAyMDAgc3RpbGwgc2hvd3MgaXNzdWVzIG9uIHNsb3cgTGludXggYm94ZXNcbiAgICAgICAgdGltZW91dHNbZHJvcFpvbmVUaW1lb3V0XSA9IGdsb2JhbC5zZXRUaW1lb3V0KHN0b3AsIDUwMCk7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgaWYgKG9wdC5hY3RpdmUgfHwgb3B0LmFjdGl2ZUNsYXNzKSB7XG4gICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihnbG9iYWwsICdkcmFnb3ZlcicsIG92ZXIuYmluZCh1bmRlZmluZWQsIHRpbWVvdXRzT2JqLCAnYWN0aXZlVGltZW91dCcsIGVsZW1lbnQsIG9wdC5hY3RpdmVDbGFzcywgb3B0LmFjdGl2ZSkpO1xuICAgIH1cbiAgICBpZiAob3B0LmhvdmVyQ2xhc3MpIHtcbiAgICAgIC8vIGRyYWdlbnRlciBhbmQgZHJhZ2xlYXZlIGFyZSBub3QgcmVxdWlyZWQgYnV0IHRoZXkgc3BlZWR1cCBmZWVkYmFjayB3aGVuIHVzZWQuXG4gICAgICBrby51dGlscy5yZWdpc3RlckV2ZW50SGFuZGxlcihlbGVtZW50LCAnZHJhZ292ZXIgZHJhZ2VudGVyIGRyYWdsZWF2ZScsIG92ZXIuYmluZCh1bmRlZmluZWQsIHRpbWVvdXRzT2JqLCAnaG92ZXJUaW1lb3V0JywgZWxlbWVudCwgb3B0LmhvdmVyQ2xhc3MsIHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgfVxufTtcblxua28uYmluZGluZ0hhbmRsZXJzWydmaWxldXBsb2FkJ10gPSB7XG4gIGV4dGVuZE9wdGlvbnM6IHt9LFxuICByZW1vdGVGaWxlUHJlcHJvY2Vzc29yOiBmdW5jdGlvbih1cmwpIHsgcmV0dXJuIHVybDsgfSxcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgIC8vIFRPRE8gZG9tbm9kZWRpc3Bvc2FsIGRvZXNuJ3Qgd29yayB3aGVuIHRoZSB1cGxvYWQgaXMgZG9uZSBieSBcImNsaWNraW5nXCJcbiAgICAvLyBQcm9iYWJseSBqcXVlcnktZmlsZXVwbG9hZCBtb3ZlcyB0aGUgRE9NIHNvbWV3aGVyZSBlbHNlIHNvIHRoYXQgS08gZG9lc24ndCBcbiAgICAvLyBkZXRlY3QgdGhlIHJlbW92YWwgYW55bW9yZS5cbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgJChlbGVtZW50KS5maWxldXBsb2FkKCdkZXN0cm95Jyk7XG4gICAgfSk7XG5cbiAgICAvLyBpZiB3ZSBsZWF2ZSB0aGUgdGl0bGUgdGhlIG5hdGl2ZSBjb250cm9sIHdpbGwgc2hvdyB1cyBhIHRvb2x0aXAgd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBJbiBXZWJLaXQgdGhlIHJpZ2h0IHdheSB0byByZW1vdmUgaXQgaXMgbGVhdmluZyBhIFwid2hpdGVzcGFjZVwiLlxuICAgIC8vIEluIEdlY2tvIHdlIGhhdmUgdG8gc2V0IGl0IGVtcHR5LlxuICAgIGlmIChnbG9iYWwud2Via2l0VVJMKVxuICAgICAgJChlbGVtZW50KS5hdHRyKCd0aXRsZScsICcgJyk7XG4gICAgZWxzZVxuICAgICAgJChlbGVtZW50KS5hdHRyKCd0aXRsZScsICcnKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZhbHVlQWNjZXNzb3IoKSB8fCB7fTtcblxuICAgIHZhciAkZnUgPSAkKGVsZW1lbnQpO1xuICAgIHZhciAkcGFyZW50ID0gJGZ1LnBhcmVudHMoJy51cGxvYWR6b25lJyk7XG5cbiAgICB2YXIgZGF0YVZhbHVlID0gb3B0aW9ucy5kYXRhO1xuICAgIG9wdGlvbnMuZGF0YSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBjYW52YXNQcmV2aWV3ID0gb3B0aW9ucy5jYW52YXNQcmV2aWV3O1xuXG4gICAgLy8gVE9ETyByZW1vdmUgaGFyZGNvZGVkIHVybFxuICAgIGtvLnV0aWxzLmV4dGVuZChvcHRpb25zLCB7XG4gICAgICB1cmw6ICcvdXBsb2FkLycsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgZHJvcFpvbmU6ICRwYXJlbnQuZmluZCgnLm1vLXVwbG9hZHpvbmUnKVswXSxcbiAgICAgIGF1dG9VcGxvYWQ6IHRydWUsXG4gICAgICBhY2NlcHRGaWxlVHlwZXM6IC8oXFwufFxcLykoZ2lmfGpwZT9nfHBuZykkL2ksXG4gICAgICBtYXhGaWxlU2l6ZTogMTAyNCAqIDEwMjQsXG4gICAgICAvLyBFbmFibGUgaW1hZ2UgcmVzaXppbmcsIGV4Y2VwdCBmb3IgQW5kcm9pZCBhbmQgT3BlcmEsXG4gICAgICAvLyB3aGljaCBhY3R1YWxseSBzdXBwb3J0IGltYWdlIHJlc2l6aW5nLCBidXQgZmFpbCB0b1xuICAgICAgLy8gc2VuZCBCbG9iIG9iamVjdHMgdmlhIFhIUiByZXF1ZXN0czpcbiAgICAgIGRpc2FibGVJbWFnZVJlc2l6ZTogL0FuZHJvaWQoPyEuKkNocm9tZSl8T3BlcmEvLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpLFxuICAgICAgcHJldmlld01heFdpZHRoOiAyMDAsXG4gICAgICBwcmV2aWV3TWF4SGVpZ2h0OiAyMDAsXG4gICAgICBwcmV2aWV3Q3JvcDogZmFsc2UsXG4gICAgICByZXBsYWNlRmlsZUlucHV0OiBmYWxzZSwgLy8gcmVwbGFjZUZpbGVJbnB1dCB0cnVlIGJyZWFrcyBhZnRlciB1cGxvYWRpbmcgdXNpbmcgXCJpbnB1dFwiICh1c2luZyBtb3VzZSBjbGljIGluc3RlYWQgb2YgZHJvcHBpbmcpXG5cbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIC8vIGNsaWVudCBzaWRlXG4gICAgICAgIHVua25vd25FcnJvcjogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICB1cGxvYWRlZEJ5dGVzOiAnVXBsb2FkZWQgYnl0ZXMgZXhjZWVkIGZpbGUgc2l6ZScsXG4gICAgICAgIG1heE51bWJlck9mRmlsZXM6ICdNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZCcsXG4gICAgICAgIGFjY2VwdEZpbGVUeXBlczogJ0ZpbGUgdHlwZSBub3QgYWxsb3dlZCcsXG4gICAgICAgIG1heEZpbGVTaXplOiAnRmlsZSBpcyB0b28gbGFyZ2UnLFxuICAgICAgICBtaW5GaWxlU2l6ZTogJ0ZpbGUgaXMgdG9vIHNtYWxsJyxcbiAgICAgICAgLy8gc2VydmVyIHNpZGVcbiAgICAgICAgcG9zdF9tYXhfc2l6ZTogJ1RoZSB1cGxvYWRlZCBmaWxlIGV4Y2VlZHMgdGhlIHBvc3RfbWF4X3NpemUgZGlyZWN0aXZlIGluIHBocC5pbmknLFxuICAgICAgICBtYXhfZmlsZV9zaXplOiAnRmlsZSBpcyB0b28gYmlnJyxcbiAgICAgICAgbWluX2ZpbGVfc2l6ZTogJ0ZpbGUgaXMgdG9vIHNtYWxsJyxcbiAgICAgICAgYWNjZXB0X2ZpbGVfdHlwZXM6ICdGaWxldHlwZSBub3QgYWxsb3dlZCcsXG4gICAgICAgIG1heF9udW1iZXJfb2ZfZmlsZXM6ICdNYXhpbXVtIG51bWJlciBvZiBmaWxlcyBleGNlZWRlZCcsXG4gICAgICAgIG1heF93aWR0aDogJ0ltYWdlIGV4Y2VlZHMgbWF4aW11bSB3aWR0aCcsXG4gICAgICAgIG1pbl93aWR0aDogJ0ltYWdlIHJlcXVpcmVzIGEgbWluaW11bSB3aWR0aCcsXG4gICAgICAgIG1heF9oZWlnaHQ6ICdJbWFnZSBleGNlZWRzIG1heGltdW0gaGVpZ2h0JyxcbiAgICAgICAgbWluX2hlaWdodDogJ0ltYWdlIHJlcXVpcmVzIGEgbWluaW11bSBoZWlnaHQnLFxuICAgICAgICBhYm9ydDogJ0ZpbGUgdXBsb2FkIGFib3J0ZWQnLFxuICAgICAgICBpbWFnZV9yZXNpemU6ICdGYWlsZWQgdG8gcmVzaXplIGltYWdlJyxcbiAgICAgICAgZ2VuZXJpYzogJ1VuZXhwZWN0ZWQgdXBsb2FkIGVycm9yJ1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAga28udXRpbHMuZXh0ZW5kKG9wdGlvbnMsIGtvLmJpbmRpbmdIYW5kbGVyc1snZmlsZXVwbG9hZCddLmV4dGVuZE9wdGlvbnMpO1xuXG4gICAgdmFyIHdvcmtpbmcgPSAwO1xuICAgIHZhciBmaXJzdFdvcmtlZCA9ICcnO1xuXG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXdvcmtpbmcgPT09IDApIHtcbiAgICAgICAgaWYgKGRhdGFWYWx1ZSkge1xuICAgICAgICAgIGRhdGFWYWx1ZShmaXJzdFdvcmtlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RXb3JrZWQgPSAnJztcbiAgICAgICAgaWYgKGNhbnZhc1ByZXZpZXcpIHtcbiAgICAgICAgICAkcGFyZW50LmZpbmQoJ2ltZycpLnNob3coKTtcbiAgICAgICAgICAkcGFyZW50LmZpbmQoJ2NhbnZhcycpLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoXCJ1cGxvYWRpbmdcIik7XG4gICAgICAgICRwYXJlbnQuZmluZCgnLnByb2dyZXNzLWJhcicpLmNzcygnd2lkdGgnLCAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zbGF0ZWRNZXNzYWdlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1lc3NhZ2VzID09ICdvYmplY3QnICYmIG9wdGlvbnMubWVzc2FnZXMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXihbXiBdKykoLiopJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWVzc2FnZXNbbWF0Y2hbMV1dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZXNbbWF0Y2hbMV1dICsgbWF0Y2hbMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgJGZ1LmZpbGV1cGxvYWQob3B0aW9ucyk7XG5cbiAgICB2YXIgZXZlbnRzID0gWydmaWxldXBsb2FkYWRkJywgJ2ZpbGV1cGxvYWRwcm9jZXNzYWx3YXlzJywgJ2ZpbGV1cGxvYWRwcm9ncmVzc2FsbCcsICdmaWxldXBsb2FkZG9uZScsICdmaWxldXBsb2FkZmFpbCddO1xuICAgIHZhciBldmVudEhhbmRsZXIgPSBmdW5jdGlvbihlLCBkYXRhKSB7XG4gICAgICBpZiAoZS50eXBlID09ICdmaWxldXBsb2FkYWRkJykge1xuICAgICAgICB3b3JraW5nKys7XG4gICAgICB9XG4gICAgICBpZiAoZS50eXBlID09ICdmaWxldXBsb2FkZmFpbCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJmaWxldXBsb2FkZmFpbFwiLCBlLCBkYXRhKTtcbiAgICAgICAgaWYgKG9wdGlvbnMub25lcnJvcikge1xuICAgICAgICAgIGlmIChkYXRhLmVycm9yVGhyb3duID09PSAnJyAmJiBkYXRhLnRleHRTdGF0dXMgPT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgb3B0aW9ucy5vbmVycm9yKHRyYW5zbGF0ZWRNZXNzYWdlKCdnZW5lcmljJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uZXJyb3IodHJhbnNsYXRlZE1lc3NhZ2UoJ2dlbmVyaWMgKCcgKyBkYXRhLmVycm9yVGhyb3duICsgJyknKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT0gJ2ZpbGV1cGxvYWRkb25lJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEucmVzdWx0LmZpbGVzWzBdLnVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmZpbGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5yZXN1bHQuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZGF0YS5yZXN1bHQuZmlsZXNbaV0gPSBrby5iaW5kaW5nSGFuZGxlcnNbJ2ZpbGV1cGxvYWQnXS5yZW1vdGVGaWxlUHJlcHJvY2Vzc29yKGRhdGEucmVzdWx0LmZpbGVzW2ldKTtcbiAgICAgICAgICAgICAgb3B0aW9ucy5vbmZpbGUoZGF0YS5yZXN1bHQuZmlsZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaXJzdFdvcmtlZCA9PT0gJycpIGZpcnN0V29ya2VkID0gZGF0YS5yZXN1bHQuZmlsZXNbMF0udXJsO1xuXG4gICAgICAgICAgaWYgKGNhbnZhc1ByZXZpZXcpIHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBjbGVhbnVwO1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBjbGVhbnVwO1xuICAgICAgICAgICAgaW1nLnNyYyA9IGRhdGEucmVzdWx0LmZpbGVzWzBdLnVybDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YS5yZXN1bHQuZmlsZXNbMF0uZXJyb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJyZW1vdGUgZXJyb3JcIiwgZSwgZGF0YSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub25lcnJvcikge1xuICAgICAgICAgICAgb3B0aW9ucy5vbmVycm9yKHRyYW5zbGF0ZWRNZXNzYWdlKGRhdGEucmVzdWx0LmZpbGVzWzBdLmVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInVuZXhwZWN0ZWQgZXJyb3JcIiwgZSwgZGF0YSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub25lcnJvcikge1xuICAgICAgICAgICAgb3B0aW9ucy5vbmVycm9yKHRyYW5zbGF0ZWRNZXNzYWdlKCdnZW5lcmljIChVbmV4cGVjdGVkIEVycm9yIHJldHJpZXZpbmcgdXBsb2FkZWQgZmlsZSknKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUudHlwZSA9PSAnZmlsZXVwbG9hZHByb2Nlc3NhbHdheXMnKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgZmlsZSA9IGRhdGEuZmlsZXNbaW5kZXhdO1xuICAgICAgICBpZiAoZmlsZS5wcmV2aWV3ICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNhbnZhcyB3ZSBoYWQgbXVsdGlwbGUgdXBsb2FkZWQgZmlsZXNcbiAgICAgICAgICBpZiAoJHBhcmVudC5maW5kKCdjYW52YXMnKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjYW52YXNQcmV2aWV3KSB7XG4gICAgICAgICAgICAgIHZhciBlbCA9ICQoZmlsZS5wcmV2aWV3KS5jc3MoJ3dpZHRoJywgJzEwMCUnKTsgLy8gLmNzcygncG9zaXRpb24nLCAnYWJzb2x1dGUnKS5jc3MoJ2xlZnQnLCAnMCcpO1xuICAgICAgICAgICAgICAkcGFyZW50LmZpbmQoJ2ltZycpLmhpZGUoKTtcbiAgICAgICAgICAgICAgJHBhcmVudC5wcmVwZW5kKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRwYXJlbnQuYWRkQ2xhc3MoXCJ1cGxvYWRpbmdcIik7XG4gICAgICAgICAgICAkcGFyZW50LmZpbmQoJy5wcm9ncmVzcy1iYXInKS5jc3MoJ3dpZHRoJywgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlLmVycm9yKSB7XG4gICAgICAgICAgLy8gRmlsZSB0eXBlIG5vdCBhbGxvd2VkXG4gICAgICAgICAgLy8gRmlsZSBpcyB0b28gbGFyZ2VcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbmVycm9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uZXJyb3IodHJhbnNsYXRlZE1lc3NhZ2UoZmlsZS5lcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT0gJ2ZpbGV1cGxvYWRwcm9ncmVzc2FsbCcpIHtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gcGFyc2VJbnQoZGF0YS5sb2FkZWQgLyBkYXRhLnRvdGFsICogMTAwLCAxMCk7XG4gICAgICAgICRwYXJlbnQuZmluZCgnLnByb2dyZXNzLWJhcicpLmNzcygnd2lkdGgnLCBwcm9ncmVzcyArICclJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gZXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnRzW2ldO1xuICAgICAgJGZ1Lm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKCEkLnN1cHBvcnQuZmlsZUlucHV0KSB7XG4gICAgICAkZnUucHJvcCgnZGlzYWJsZWQnLCB0cnVlKS5wYXJlbnQoKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxua28uYmluZGluZ0hhbmRsZXJzWydpZlN1YnMnXSA9IHtcbiAgLy8gY2xvbmVOb2RlcyBmcm9tIGtvLnV0aWxzLmNsb25lTm9kZXMgKG1pc3NpbmcgaW4gbWluaW1pemVkIEtPKVxuICBjbG9uZU5vZGVzOiBmdW5jdGlvbihub2Rlc0FycmF5LCBzaG91bGRDbGVhbk5vZGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBub2Rlc0FycmF5Lmxlbmd0aCwgbmV3Tm9kZXNBcnJheSA9IFtdOyBpIDwgajsgaSsrKSB7XG4gICAgICB2YXIgY2xvbmVkTm9kZSA9IG5vZGVzQXJyYXlbaV0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgbmV3Tm9kZXNBcnJheS5wdXNoKHNob3VsZENsZWFuTm9kZXMgPyBrby5jbGVhbk5vZGUoY2xvbmVkTm9kZSkgOiBjbG9uZWROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld05vZGVzQXJyYXk7XG4gIH0sXG4gICdpbml0JzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSxcbiAgICAgIHNhdmVkTm9kZXMsXG4gICAgICB2YWx1ZUFjYyA9IHZhbHVlQWNjZXNzb3IoKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlQWNjLmRhdGEuc3Vic0NvdW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAga28uZXh0ZW5kZXJzWydzdWJzY3JpcHRpb25zQ291bnQnXSh2YWx1ZUFjYy5kYXRhKTtcbiAgICAgIC8vIE5PVEUgSSBjYW4ndCBzaW1wbHkgbGlzdGVuIG9uIFwidGhyZXNob2xkc1wiIGJlY2F1c2UgbXVsdGlwbGUgYmluZGluZ3MgdG8gdGhlIHNhbWUgb2JzZXJ2YWJsZSBjb3VsZCB1c2UgZGlmZmVyZW50IHRocmVzaG9sZHMuXG4gICAgfVxuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGFWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpLmRhdGEuc3Vic0NvdW50KSxcbiAgICAgICAgaXNGaXJzdFJlbmRlciA9ICFzYXZlZE5vZGVzLFxuICAgICAgICBzaG91bGREaXNwbGF5LCBuZWVkc1JlZnJlc2gsIGd1dHRlcjtcblxuICAgICAgZ3V0dGVyID0gLSh0eXBlb2YgdmFsdWVBY2Nlc3NvcigpLmd1dHRlciAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZUFjY2Vzc29yKCkuZ3V0dGVyIDogMSk7XG4gICAgICBzaG91bGREaXNwbGF5ID0gZGF0YVZhbHVlICsgKGRpZERpc3BsYXlPbkxhc3RVcGRhdGUgPyBndXR0ZXIgOiAwKSA+PSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjLnRocmVzaG9sZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlQWNjZXNzb3IoKS5ub3QgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlQWNjZXNzb3IoKS5ub3QpIHtcbiAgICAgICAgc2hvdWxkRGlzcGxheSA9ICFzaG91bGREaXNwbGF5O1xuICAgICAgfVxuICAgICAgbmVlZHNSZWZyZXNoID0gaXNGaXJzdFJlbmRlciB8fCAoc2hvdWxkRGlzcGxheSAhPT0gZGlkRGlzcGxheU9uTGFzdFVwZGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc1JlZnJlc2gpIHtcbiAgICAgICAgLy8gU2F2ZSBhIGNvcHkgb2YgdGhlIGlubmVyIG5vZGVzIG9uIHRoZSBpbml0aWFsIHVwZGF0ZSwgYnV0IG9ubHkgaWYgd2UgaGF2ZSBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGlmIChpc0ZpcnN0UmVuZGVyICYmIGtvLmNvbXB1dGVkQ29udGV4dC5nZXREZXBlbmRlbmNpZXNDb3VudCgpKSB7XG4gICAgICAgICAgc2F2ZWROb2RlcyA9IGtvLmJpbmRpbmdIYW5kbGVyc1snaWZTdWJzJ10uY2xvbmVOb2Rlcyhrby52aXJ0dWFsRWxlbWVudHMuY2hpbGROb2RlcyhlbGVtZW50KSwgdHJ1ZSAvKiBzaG91bGRDbGVhbk5vZGVzICovICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkRGlzcGxheSkge1xuICAgICAgICAgIGlmICghaXNGaXJzdFJlbmRlcikge1xuICAgICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLnNldERvbU5vZGVDaGlsZHJlbihlbGVtZW50LCBrby5iaW5kaW5nSGFuZGxlcnNbJ2lmU3VicyddLmNsb25lTm9kZXMoc2F2ZWROb2RlcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrby5hcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50cyhiaW5kaW5nQ29udGV4dCwgZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga28udmlydHVhbEVsZW1lbnRzLmVtcHR5Tm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZERpc3BsYXlPbkxhc3RVcGRhdGUgPSBzaG91bGREaXNwbGF5O1xuICAgICAgfVxuICAgIH0sIG51bGwsIHtcbiAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAnY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3MnOiB0cnVlXG4gICAgfTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ2lmU3VicyddID0gdHJ1ZTtcblxuLy8ga28uaXNXcml0YWJsZU9ic2VydmFibGUgKHdpdGhvdXQgXCJlXCIpIGhhcyBiZWVuIGludHJvZHVjZWQgaW4gMy4yLjAsIHRoYXQgaXMgYWxzbyBvdXIgbWluIHJlcXVpcmVtZW50LlxuLy8gbWluaW1pemVkIGtub2Nrb3V0IFwib2JmdXNjYXRlXCIgdGhlIGJlZm9yZVN1YnNjcmlwdGlvbkFkZCBhbmQgYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUgbWV0aG9kcyB0aGF0IHdlIGhhY2sgaGVyZS5cbi8vIHNvIHdlIGhhdmUgdG8gZXhwbGljaXRseSBrbm93IHRoYXQuXG52YXIgYmVmb3JlU3Vic2NyaXB0aW9uUHJvcDtcbnZhciBhZnRlclN1YnNjcmlwdGlvblByb3A7XG5pZiAodHlwZW9mIGtvLkRFQlVHICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Yga28uaXNXcml0YWJsZU9ic2VydmFibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIGJlZm9yZVN1YnNjcmlwdGlvblByb3AgPSAnYmVmb3JlU3Vic2NyaXB0aW9uQWRkJztcbiAgYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wID0gJ2FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlJztcbn0gZWxzZSBpZiAoa28udmVyc2lvbiA9PSBcIjMuMi4wXCIpIHtcbiAgYmVmb3JlU3Vic2NyaXB0aW9uUHJvcCA9ICd2YSc7XG4gIGFmdGVyU3Vic2NyaXB0aW9uUHJvcCA9ICduYic7XG59IGVsc2UgaWYgKGtvLnZlcnNpb24gPT0gXCIzLjMuMFwiKSB7XG4gIGJlZm9yZVN1YnNjcmlwdGlvblByb3AgPSAnamEnO1xuICBhZnRlclN1YnNjcmlwdGlvblByb3AgPSAndWEnO1xufSBlbHNlIGlmIChrby52ZXJzaW9uID09IFwiMy40LjBcIikge1xuICBiZWZvcmVTdWJzY3JpcHRpb25Qcm9wID0gJ3NhJztcbiAgYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wID0gJ0lhJztcbn1cbmVsc2UgdGhyb3cgXCJVbnN1cHBvcnRlZCBtaW5pbWl6ZWQgS25vY2tvdXQgdmVyc2lvbiBcIiArIGtvLnZlcnNpb24gKyBcIiAoc3VwcG9ydGVkIERFQlVHIG9yIG1pbmltaXplZCAzLjIuMCAuLi4gMy40LjApXCI7XG5cbi8vIGludGVybmFsbHkgdXNlZCBieSBpZnN1YnMgYmluZGluZy5cbi8vIFdBUk5JTkcgdGhpcyBicmVhayB3aGVuIHVzZWQgd2l0aCBwdXJlQ29tcHV0ZWQgb3IgZGVmZXJyZWRFdmFsdWF0ZWRcbmtvLmV4dGVuZGVyc1snc3Vic2NyaXB0aW9uc0NvdW50J10gPSBmdW5jdGlvbih0YXJnZXQsIGwxLCBsMikge1xuICBpZiAodHlwZW9mIHRhcmdldC5zdWJzQ291bnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGFyZ2V0LnN1YnNDb3VudCA9IGtvLm9ic2VydmFibGUodGFyZ2V0LmdldFN1YnNjcmlwdGlvbnNDb3VudCgpKS5leHRlbmQoe1xuICAgICAgbm90aWZ5OiAnYWx3YXlzJ1xuICAgIH0pO1xuICAgIHZhciB1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24gPSB0YXJnZXRbYmVmb3JlU3Vic2NyaXB0aW9uUHJvcF07XG4gICAgdmFyIHVuZGVybHlpbmdBZnRlclN1YnNjcmlwdGlvblJlbW92ZUZ1bmN0aW9uID0gdGFyZ2V0W2FmdGVyU3Vic2NyaXB0aW9uUHJvcF07XG4gICAgdGFyZ2V0W2JlZm9yZVN1YnNjcmlwdGlvblByb3BdID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmICh1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24pIHVuZGVybHlpbmdCZWZvcmVTdWJzY3JpcHRpb25BZGRGdW5jdGlvbi5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgdmFyIGMgPSB0YXJnZXQuZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCkgKyAxO1xuICAgICAgaWYgKHR5cGVvZiBsMSA9PT0gJ3VuZGVmaW5lZCcgfHwgYyA9PSBsMSB8fCB0eXBlb2YgbDIgPT09ICd1bmRlZmluZWQnIHx8IGMgPT0gbDIpIHRhcmdldC5zdWJzQ291bnQoYyk7XG4gICAgfTtcbiAgICB0YXJnZXRbYWZ0ZXJTdWJzY3JpcHRpb25Qcm9wXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAodW5kZXJseWluZ0FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlRnVuY3Rpb24pIHVuZGVybHlpbmdBZnRlclN1YnNjcmlwdGlvblJlbW92ZUZ1bmN0aW9uLmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICB2YXIgYyA9IHRhcmdldC5nZXRTdWJzY3JpcHRpb25zQ291bnQoKTtcbiAgICAgIGlmICh0eXBlb2YgbDEgPT09ICd1bmRlZmluZWQnIHx8IGMgPT0gbDEgfHwgdHlwZW9mIGwyID09PSAndW5kZWZpbmVkJyB8fCBjID09IGwyKSB0YXJnZXQuc3Vic0NvdW50KGMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coXCJhbHJlYWR5IGFwcGxpZWQgc3Vic2NyaXB0aW9uQ291bnQgdG8gb2JzZXJ2YWJsZVwiKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gT3ZlcnJpZGVzIG5hdGl2ZSBqUXVlcnkgc3Bpbm5lciB0byBhdm9pZCB2YWxpZGF0aW9uIG9mIHRoZSBcInN0ZXBcIi5cbi8vIFdlIHdhbnRzIHRvIHVzZSB0aGUgc3RlcCBidXQgYWxzbyB3YW50cyB0byBsZWF2ZSB0aGUgdXNlciB0aGUgYWJpbGl0eSB0byBzZWxlY3Qgc3BlY2lmaWMgdmFsdWVzLlxuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuJC53aWRnZXQoXCJ1aS5zcGlubmVyXCIsICQudWkuc3Bpbm5lciwge1xuICBfYWRqdXN0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGFkaiA9IHRoaXMuX3N1cGVyKHZhbHVlKTtcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgLy8gZml4IHByZWNpc2lvbiBmcm9tIGJhZCBKUyBmbG9hdGluZyBwb2ludCBtYXRoXG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKCkpKTtcblxuICAgIC8vIGNsYW1wIHRoZSB2YWx1ZVxuICAgIGlmIChvcHRpb25zLm1heCAhPT0gbnVsbCAmJiB2YWx1ZSA+IG9wdGlvbnMubWF4KSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5tYXg7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1pbiAhPT0gbnVsbCAmJiB2YWx1ZSA8IG9wdGlvbnMubWluKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5taW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gT3ZlcnJpZGVzIG5hdGl2ZSBqUXVlcnkgdGFicyB0byBtYWtlIHRhYnMgd29ya2luZyBhbHNvIHdoZW4gdXNpbmcgYSBiYXNlIHRhZ1xuLy8gaW4gb3JkZXIgdG8gYXZvaWQgY29uZmxpY3RzIHlvdSBoYXZlIHRvIGFkZCBhIGRhdGEtbG9jYWw9XCJ0cnVlXCIgYXR0cmlidXRlIHRvIHlvdXIgdGFiIGxpbmtzLlxuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuJC53aWRnZXQoXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuICBfaXNMb2NhbDogZnVuY3Rpb24oIGFuY2hvciApIHtcbiAgICBpZiAoYW5jaG9yLmdldEF0dHJpYnV0ZSgnZGF0YS1sb2NhbCcpID09IFwidHJ1ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIHJldHVybiB0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcbiAgfVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWxzIGdsb2JhbDogZmFsc2UgKi9cblxuZnVuY3Rpb24gcHVzaFRlbXBsYXRlKHRlbXBsYXRlTmFtZSwgdGVtcGxhdGVUZXh0KSB7XG4gIHZhciBzY3JpcHRUYWcgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdFRhZy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9odG1sJyk7XG4gIHNjcmlwdFRhZy5zZXRBdHRyaWJ1dGUoJ2lkJywgdGVtcGxhdGVOYW1lKTtcbiAgc2NyaXB0VGFnLnRleHQgPSB0ZW1wbGF0ZVRleHQ7XG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRlbXBsYXRlKHRlbXBsYXRlTmFtZSkge1xuICB2YXIgZWwgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGVtcGxhdGVOYW1lKTtcbiAgaWYgKGVsKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbn1cblxuZnVuY3Rpb24gaW5pdCgpIHt9XG5cbmZ1bmN0aW9uIGdldFRlbXBsYXRlQ29udGVudChpZCkge1xuICB2YXIgZWwgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICBpZiAoZWwpIHJldHVybiBlbC5pbm5lckhUTUw7XG4gIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXQ6IGluaXQsXG4gIGFkZFRlbXBsYXRlOiBwdXNoVGVtcGxhdGUsXG4gIHJlbW92ZVRlbXBsYXRlOiByZW1vdmVUZW1wbGF0ZSxcbiAgZ2V0VGVtcGxhdGVDb250ZW50OiBnZXRUZW1wbGF0ZUNvbnRlbnRcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgdGlueW1jZSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd0aW55bWNlJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd0aW55bWNlJ10gOiBudWxsKTtcblxudmFyIHRpbWVvdXQ7XG5cbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcblxuICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgdGlueW1jZS5hY3RpdmVFZGl0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGlueW1jZS5hY3RpdmVFZGl0b3IudGhlbWUucGFuZWwudmlzaWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBAc2VlIEZsb2F0UGFuZWwuanMgZnVuY3Rpb24gcmVwb3NpdGlvblBhbmVsKHBhbmVsKVxuICAgIC8vIEZpcnN0IGNvbmRpdGlvbiBncm91cCBpcyBmb3IgVGlueW1jZSA0LjAvNC4xXG4gICAgLy8gU2Vjb25kIGNvbmRpdGlvbiBncm91cCBpcyBmb3IgVGlueW1jZSA0LjIvNC4zIHdoZXJlIFwiLl9wcm9wZXJ0eVwiIGFyZSBub3cgYXZhaWxhYmxlIGFzIFwiLnN0YXRlLmdldCgncHJvcGVydHknKVwiLlxuICAgIGlmICgodHlwZW9mIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLl92aXNpYmxlICE9PSAndW5kZWZpbmVkJyAmJiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5fdmlzaWJsZSAmJiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5fZml4ZWQpIHx8IFxuICAgICAgICAodHlwZW9mIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLnN0YXRlICE9PSAndW5kZWZpbmVkJyAmJiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5zdGF0ZS5nZXQoJ3Zpc2libGUnKSAmJiB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5zdGF0ZS5nZXQoJ2ZpeGVkJykpKSB7XG4gICAgICB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5maXhlZChmYWxzZSk7XG4gICAgfVxuXG4gICAgdGlueW1jZS5hY3RpdmVFZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICB0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC52aXNpYmxlKHRydWUpO1xuICAgIGlmICh0aW55bWNlLmFjdGl2ZUVkaXRvci50aGVtZS5wYW5lbC5sYXlvdXRSZWN0KCkueSA8PSA0MClcbiAgICAgIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLm1vdmVCeSgwLCA0MCAtIHRpbnltY2UuYWN0aXZlRWRpdG9yLnRoZW1lLnBhbmVsLmxheW91dFJlY3QoKS55KTtcblxuICB9XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z1Njcm9sbGZpeCA9IHtcbiAgJ3Njcm9sbCc6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRpbWVvdXQpIGdsb2JhbC5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0KHJlbmRlciwgNTApO1xuICB9LFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrKGVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgJChlbGVtZW50KS5vZmYoXCJzY3JvbGxcIiwga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTY3JvbGxmaXguc2Nyb2xsKTtcbiAgICB9KTtcblxuICAgICQoZWxlbWVudCkub24oXCJzY3JvbGxcIiwga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTY3JvbGxmaXguc2Nyb2xsKTtcblxuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbnZhciBfc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbigkZWxlbWVudCwgYWxpZ25Ub3AsIHNjcm9sbFBhcmVudCwgbW92ZUJ5KSB7XG4gIHZhciBjdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xuICB2YXIgbmV3U2Nyb2xsVG9wID0gY3VycmVudFNjcm9sbFRvcCAtIG1vdmVCeSAtIChhbGlnblRvcCA/IDIwIDogLTIwKTtcbiAgLy8gaWZyYW1lIHNjcm9sbHMgdGhlIHdpbmRvdyBhbmQgYW5pbWF0aW9uIGlzIG5vdCBzdXBwb3J0ZWRcbiAgdmFyIGFuaW1hdGUgPSB0eXBlb2Ygc2Nyb2xsUGFyZW50WzBdLm5vZGVUeXBlICE9PSAndW5kZWZpbmVkJztcbiAgaWYgKGFuaW1hdGUpIHtcbiAgICB2YXIgYWN0aW9uID0ge1xuICAgICAgJ3Njcm9sbFRvcCc6IFwiXCIgKyBNYXRoLnJvdW5kKG5ld1Njcm9sbFRvcCkgKyBcInB4XCJcbiAgICB9O1xuICAgIHZhciB0aW1lID0gTWF0aC5yb3VuZChNYXRoLmFicyhuZXdTY3JvbGxUb3AgLSBjdXJyZW50U2Nyb2xsVG9wKSk7XG4gICAgc2Nyb2xsUGFyZW50LnN0b3AoKS5hbmltYXRlKGFjdGlvbiwgdGltZSk7XG4gIH0gZWxzZSB7XG4gICAgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcChuZXdTY3JvbGxUb3ApO1xuICB9XG4gIC8vIG5hdGl2ZSBzY3JvbGxJbnRvVmlldyBpcyBub3Qgd2VsbCBzdXBwb3J0ZWQgYW5kIGRvZXNuJ3Qgd29yayBmaW5lLlxuICAvLyBlbGVtZW50LnNjcm9sbEludG9WaWV3KGFsaWduVG9wKTtcbn07XG5cbmtvLmJpbmRpbmdIYW5kbGVycy5zY3JvbGxJbnRvVmlldyA9IHtcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIHNlbGVjdGVkID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIGlmICghc2VsZWN0ZWQpIHJldHVybjtcbiAgICB0cnkge1xuXG4gICAgICB3aGlsZSAoZWxlbWVudC5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBlbGVtZW50IGlzIGEgY29tbWVudCwgbW92ZSB0byB0aGUgbmV4dCBzaWJsaW5nLi4uXG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDgpIHtcbiAgICAgICAgdmFyIHNjcm9sbFBhcmVudCA9ICQoZWxlbWVudCkuc2Nyb2xsUGFyZW50KCk7XG5cbiAgICAgICAgdmFyIHBhcmVudFRvcDtcbiAgICAgICAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZmFsc2U7XG4gICAgICAgIGlmIChzY3JvbGxQYXJlbnRbMF0ubm9kZVR5cGUgPT0gOSkge1xuICAgICAgICAgIC8vIHNjcm9sbHBhcmVudCBpcyBkb2N1bWVudCwgcmVwbGFjaW5nIHdpdGggYm9keS4uLlxuICAgICAgICAgIHNjcm9sbFBhcmVudCA9ICQoc2Nyb2xsUGFyZW50WzBdLmRlZmF1bHRWaWV3KTtcbiAgICAgICAgICBwYXJlbnRUb3AgPSAwO1xuICAgICAgICAgIHJlbGF0aXZlT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRUb3AgPSBzY3JvbGxQYXJlbnQub2Zmc2V0KCkudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudEhlaWdodCA9IHNjcm9sbFBhcmVudC5oZWlnaHQoKTtcbiAgICAgICAgdmFyIHBhcmVudFNjcm9sbCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcbiAgICAgICAgdmFyIHBhcmVudEJvdHRvbSA9IHBhcmVudFRvcCArIHBhcmVudEhlaWdodDtcblxuICAgICAgICAvLyBzY3JvbGxQYXJlbnQgaXMgdGhlIGRvY3VtZW50LlxuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICB2YXIgZWxUb3AgPSAkZWxlbWVudC5vZmZzZXQoKS50b3A7XG4gICAgICAgIC8vIHdoZW4gd2UgYXJlIGluIFwiaWZyYW1lXCIgd2l0aCBzY3JvbGxiYXIgZXZlcnl0aGlqbmcgY2hhbmdlcy5cbiAgICAgICAgaWYgKHJlbGF0aXZlT2Zmc2V0KSBlbFRvcCA9IGVsVG9wIC0gcGFyZW50U2Nyb2xsO1xuICAgICAgICB2YXIgZWxIZWlnaHQgPSAkZWxlbWVudC5oZWlnaHQoKTtcbiAgICAgICAgdmFyIGVsQm90dG9tID0gZWxUb3AgKyBlbEhlaWdodDtcbiAgICAgICAgaWYgKGVsVG9wID4gcGFyZW50VG9wICYmIGVsVG9wICsgZWxIZWlnaHQgPCBwYXJlbnRCb3R0b20pIHtcbiAgICAgICAgICAvLyBib3RoIGJvcmRlcnMgYXJlIHZpc2libGUgPT4gZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgIH0gZWxzZSBpZiAoZWxIZWlnaHQgPCBwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgYmxvY2sgaXMgc21hbGxlciB0aGFuIHRoZSB2aWV3UG9ydFxuICAgICAgICAgIGlmIChlbFRvcCA8IHBhcmVudFRvcCkgX3Njcm9sbEludG9WaWV3KGVsZW1lbnQsIHRydWUsIHNjcm9sbFBhcmVudCwgcGFyZW50VG9wIC0gZWxUb3ApO1xuICAgICAgICAgIC8vIC0+IGlmIHRoZSB1cHBlciBib3JkZXIgaXMgaGlnaGVyIHRoYW4gdGhlIHRvcCwgdGhlbiBJIG1vdmUgaXQgdG8gdGhlIHRvcC5cbiAgICAgICAgICBpZiAoZWxCb3R0b20gPiBwYXJlbnRCb3R0b20pIF9zY3JvbGxJbnRvVmlldyhlbGVtZW50LCBmYWxzZSwgc2Nyb2xsUGFyZW50LCBwYXJlbnRCb3R0b20gLSBlbEJvdHRvbSk7XG4gICAgICAgICAgLy8gLT4gaWYgdGhlIGJvdHRvbSBib3JkZXIgaXMgbG93ZXIgdGhhbiB0aGUgYm90dG9tIHRoZW4gSSBtb3ZlIGl0IHRvIHRoZSBib3R0b20uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGJsb2NrIGlzIGxhcmdlciB0aGFuIHRoZSB2aWV3UG9ydCB3ZSBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgICAgICAgLy8gLT4gaWYgdGhlIHVwcGVyIGJvcmRlciBpcyBoaWdoZXIgdGhhbiB0aGUgdG9wIGFuZCB0aGUgbG93ZXIgaXMgaGlnaGVyIHRoYW4gdGhlIGJvdHRvbSBJIG1vdmUgdGhlIGxvd2VyIGl0IHRvIHRoZSBib3R0b20uXG4gICAgICAgICAgaWYgKGVsVG9wIDwgcGFyZW50VG9wICYmIGVsQm90dG9tIDwgcGFyZW50Qm90dG9tKSBfc2Nyb2xsSW50b1ZpZXcoZWxlbWVudCwgZmFsc2UsIHNjcm9sbFBhcmVudCwgcGFyZW50Qm90dG9tIC0gZWxCb3R0b20pO1xuICAgICAgICAgIC8vIC0+IGlmIHRoZSBib3R0b20gYm9yZGVyIGlsIGxvd2VyIHRoYW4gYm90dG9tIGFuZCB0aGUgdXBwZXIgaXMgbG93ZXIgdGhhbiB0aGUgdG9wIEkgbW92ZSB0aGUgdXBwZXIgYm9yZGVyIHRvIHRoZSB2aWV3cG9ydCB0b3BcbiAgICAgICAgICBpZiAoZWxUb3AgPiBwYXJlbnRUb3AgJiYgZWxCb3R0b20gPiBwYXJlbnRCb3R0b20pIF9zY3JvbGxJbnRvVmlldyhlbGVtZW50LCB0cnVlLCBzY3JvbGxQYXJlbnQsIHBhcmVudFRvcCAtIGVsVG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcodHJ1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coXCJUT0RPIGV4Y2VwdGlvbiBzY3JvbGxpbmcgaW50byB2aWV3XCIsIGUpO1xuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3Njcm9sbEludG9WaWV3J10gPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBvcmlnVGVtcGxhdGVTeXN0ZW0gPSByZXF1aXJlKFwiLi9zY3JpcHQtdGVtcGxhdGUuanNcIik7XG5cbnZhciB0ZW1wbGF0ZXMgPSB7fTtcblxuLy9kZWZpbmUgYSB0ZW1wbGF0ZSBzb3VyY2UgdGhhdCBzaW1wbHkgdHJlYXRzIHRoZSB0ZW1wbGF0ZSBuYW1lIGFzIGl0cyBjb250ZW50XG5rby50ZW1wbGF0ZVNvdXJjZXMuc3RyaW5nVGVtcGxhdGUgPSBmdW5jdGlvbih0ZW1wbGF0ZU5hbWUsIHRlbXBsYXRlKSB7XG4gIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIHRoaXMuX2RhdGEgPSB7fTtcbn07XG5cbmtvLnV0aWxzLmV4dGVuZChrby50ZW1wbGF0ZVNvdXJjZXMuc3RyaW5nVGVtcGxhdGUucHJvdG90eXBlLCB7XG4gIGRhdGE6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcImRhdGFcIiwga2V5LCB2YWx1ZSwgdGhpcy50ZW1wbGF0ZU5hbWUpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YVtrZXldO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGFba2V5XSA9IHZhbHVlO1xuICB9LFxuICB0ZXh0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwidGV4dFwiLCB2YWx1ZSwgdGhpcy50ZW1wbGF0ZU5hbWUpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlO1xuICAgIH1cbiAgICB0aGlzLnRlbXBsYXRlID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5cbi8vbW9kaWZ5IGFuIGV4aXN0aW5nIHRlbXBsYXRlRW5naW5lIHRvIHdvcmsgd2l0aCBzdHJpbmcgdGVtcGxhdGVzXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdUZW1wbGF0ZUVuZ2luZSh0ZW1wbGF0ZUVuZ2luZSkge1xuICB2YXIgb3JpZyA9IHRlbXBsYXRlRW5naW5lLm1ha2VUZW1wbGF0ZVNvdXJjZTtcbiAgdGVtcGxhdGVFbmdpbmUubWFrZVRlbXBsYXRlU291cmNlID0gZnVuY3Rpb24odGVtcGxhdGVOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZXNbdGVtcGxhdGVOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcga28udGVtcGxhdGVTb3VyY2VzLnN0cmluZ1RlbXBsYXRlKHRlbXBsYXRlTmFtZSwgdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3JpZyh0ZW1wbGF0ZU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRlbXBsYXRlRW5naW5lO1xufVxuXG5mdW5jdGlvbiBwdXNoVGVtcGxhdGUodGVtcGxhdGVOYW1lLCB0ZW1wbGF0ZVRleHQpIHtcbiAgdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV0gPSB0ZW1wbGF0ZVRleHQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRlbXBsYXRlKHRlbXBsYXRlTmFtZSkge1xuICBpZiAodHlwZW9mIHRlbXBsYXRlc1t0ZW1wbGF0ZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRlbXBsYXRlc1t0ZW1wbGF0ZU5hbWVdID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIG9yaWdUZW1wbGF0ZVN5c3RlbS5yZW1vdmVUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGtvLnNldFRlbXBsYXRlRW5naW5lKGNyZWF0ZVN0cmluZ1RlbXBsYXRlRW5naW5lKG5ldyBrby5uYXRpdmVUZW1wbGF0ZUVuZ2luZSgpKSk7XG59XG5cbmZ1bmN0aW9uIGdldFRlbXBsYXRlQ29udGVudChpZCkge1xuICBpZiAodHlwZW9mIHRlbXBsYXRlc1tpZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlc1tpZF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9yaWdUZW1wbGF0ZVN5c3RlbS5nZXRUZW1wbGF0ZUNvbnRlbnQoaWQpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBpbml0LFxuICBhZGRUZW1wbGF0ZTogcHVzaFRlbXBsYXRlLFxuICByZW1vdmVUZW1wbGF0ZTogcmVtb3ZlVGVtcGxhdGUsXG4gIGdldFRlbXBsYXRlQ29udGVudDogZ2V0VGVtcGxhdGVDb250ZW50XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrb2pxdWkgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna29qcXVpJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrb2pxdWknXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxudmFyIGV4dGVuZFZhbHVlQWNjZXNzb3IgPSBmdW5jdGlvbih2YWx1ZUFjY2Vzc29yLCBvYmopIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGtvLnV0aWxzLmV4dGVuZChvYmosIHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG5cbnZhciBvcHRpb25zID0ge1xuICBzaG93OiB7XG4gICAgZGVsYXk6IDUwMFxuICB9LFxuICB0cmFjazogdHJ1ZSxcbiAgaXRlbXM6ICdbdGl0bGVdW3RpdGxlIT1cIlwiXVt0aXRsZSE9XCIgXCJdJ1xufTtcblxua28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXBzID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiAkLmZuLnRvb2x0aXAgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBrby5iaW5kaW5nSGFuZGxlcnMudG9vbHRpcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHBvc2l0aW9uOiB7IG15OiBcImxlZnQrMTUgdG9wKzE1XCIsIGF0OiBcImNlbnRlciszMCBjZW50ZXIrMzBcIiB9XG4gICAgICAvLyBOT1RFIHRpdGxlIHdpdGggXCJcIiBhbmQgXCIgXCIgaXMgbmVlZGVkIHRvIGF2b2lkIGRlZmF1bHQgdG9vbHRpcHMgaW4gbmF0aXZlIGZpbGUgdXBsb2FkIGNvbnRyb2xzXG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXAuaW5pdChlbGVtZW50LCBleHRlbmRWYWx1ZUFjY2Vzc29yKHZhbHVlQWNjZXNzb3IsIG9wdGlvbnMpLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCBkYXRhLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3NvciwgZGF0YSwgY29udGV4dCkge1xuICAgIGlmICh0eXBlb2YgJC5mbi50b29sdGlwICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Yga28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnRvb2x0aXAudXBkYXRlKGVsZW1lbnQsIGV4dGVuZFZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3Nvciwgb3B0aW9ucyksIGFsbEJpbmRpbmdzQWNjZXNzb3IsIGRhdGEsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxuLy8gZXF1YWxzIHRvIFwidmFsdWVcIiBiaW5kaW5nIGJ1dCBhcHBseSBcImludmFsaWRcIiBjbGFzcyBpZiBcInBhdHRlcm5cIiBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhbmQgdmFsdWUgbWF0Y2hlcyB0aGUgcnVsZVxua28uYmluZGluZ0hhbmRsZXJzWyd2YWxpZGF0ZWRWYWx1ZSddID0ge1xuXHRpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncykge1xuXHRcdHZhciBuZXdWYWx1ZUFjY2Vzc29yID0gdmFsdWVBY2Nlc3Nvcjtcblx0XHRpZiAodHlwZW9mIGVsZW1lbnQucGF0dGVybiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHZhciByZSA9IG5ldyBSZWdFeHAoJ14oPzonICsgZWxlbWVudC5wYXR0ZXJuICsgJykkJyk7XG5cdFx0XHR2YXIgY29tcHV0ZWQgPSBrby5jb21wdXRlZCh7XG5cdFx0XHRcdHJlYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciByZXMgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG5cdFx0XHRcdFx0Ly8gVE9ETyBzdXBwb3J0IGZvciBlbGVtZW50LnJlcXVpcmVkID9cblx0XHRcdFx0XHR2YXIgdmFsaWQgPSByZXMgPT09IG51bGwgfHwgcmVzID09PSAnJyB8fCByZS50ZXN0KHJlcyk7XG5cdFx0XHRcdFx0Ly8gSUUxMSBkb2Vzbid0IHN1cHBvcnQgY2xhc3NMaXN0LnRvZ2dsZSgnaW52YWxpZCcsIHN0YXRlKVxuXHRcdFx0XHRcdGlmICh2YWxpZCkge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpbnZhbGlkJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaW52YWxpZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cml0ZToga28uaXNXcml0ZWFibGVPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkgJiYgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHR2YWx1ZUFjY2Vzc29yKCkodmFsdWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRkaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQ6IGVsZW1lbnRcblx0XHRcdH0pO1xuXHRcdFx0bmV3VmFsdWVBY2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gY29tcHV0ZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRrby5iaW5kaW5nSGFuZGxlcnNbJ3ZhbHVlJ10uaW5pdChlbGVtZW50LCBuZXdWYWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5ncyk7XG5cdH1cbn07XG5rby5leHByZXNzaW9uUmV3cml0aW5nLl90d29XYXlCaW5kaW5nc1sndmFsaWRhdGVkVmFsdWUnXSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWxzIGdsb2JhbDpmYWxzZSAqL1xuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1sndW5pcXVlSWQnXSA9IHtcbiAgY3VycmVudEluZGV4OiAwLFxuICAnaW5pdCc6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICB2YXIgZGF0YSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSB8fCB7fTtcbiAgICBpZiAoZGF0YS5pZCgpID09PSAnJykge1xuICAgICAgdmFyIGlkLCBlbCwgcHJlZml4O1xuICAgICAgLy8gVE9ETyB3ZSBuZWVkIGEgYmV0dGVyIHByZWZpeFxuICAgICAgcHJlZml4ID0gJ2tvXycgKyAodHlwZW9mIGRhdGEudHlwZSAhPT0gJ3VuZGVmaW5lZCcgPyBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEudHlwZSkgOiAnYmxvY2snKTtcbiAgICAgIC8vIHdoZW4gbG9hZGluZyBhbiBleGlzaW5nIG1vZGVsLCBJRHMgY291bGQgYmUgYWxyZWFkeSBhc3NpZ25lZC5cbiAgICAgIGRvIHtcbiAgICAgICAgaWQgPSBwcmVmaXggKyAnXycgKyAoKytrby5iaW5kaW5nSGFuZGxlcnNbJ3VuaXF1ZUlkJ10uY3VycmVudEluZGV4KTtcbiAgICAgICAgZWwgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAvLyB3aGVuIGxvYWRpbmcgYW4gZXhpc3RpbmcgbW9kZWwgbXkgXCJjdXJyZW50SW5kZXhcIiBpcyBlbXB0eS5cbiAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBleGlzdGluZyBibG9ja3MsIHNvIEkgbXVzdCBiZSBzdXJlIEkgZG9uJ3QgcmV1c2UgdGhlaXIgSURzLlxuICAgICAgICAgIC8vIFdlIHVzZSBkaWZmZXJlbnQgcHJlZml4ZXMgKHBlciBibG9jayB0eXBlKSBzbyB0aGF0IGEgaGlkZGVuIGJsb2NrIFxuICAgICAgICAgIC8vIChmb3Igd2hpY2ggd2UgaGF2ZSBubyBpZCBpbiB0aGUgcGFnZSwgZS5nOiBwcmVoZWFkZXIgaW4gdmVyc2FmaXgtMSlcbiAgICAgICAgICAvLyB3aWxsIGJyZWFrIGV2ZXJ0aGluZyBvbmNlIHdlIHJldXNlIGl0cyBuYW1lLlxuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChlbCk7XG4gICAgICBkYXRhLmlkKGlkKTtcbiAgICB9XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd1bmlxdWVJZCddID0gdHJ1ZTtcblxua28uYmluZGluZ0hhbmRsZXJzWyd2aXJ0dWFsQXR0ciddID0ge1xuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gOCkge1xuICAgICAga28uYmluZGluZ0hhbmRsZXJzWydhdHRyJ10udXBkYXRlKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3ZpcnR1YWxBdHRyJ10gPSB0cnVlO1xuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZpcnR1YWxBdHRyU3R5bGUnXSA9IHtcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDgpIHtcbiAgICAgIC8vIEluIFwicHJldmlld1wiIHdlIGFsc28gc2V0IFwicmVwbGFjZWRzdHlsZVwiIHNvIHRvIGhhdmUgYW4gYXR0cmlidXRlIHRvIGJlIHVzZWQgYnkgSUUgKElFIGJyZWFrcyB0aGUgU1RZTEUpIHRvIGRvIHRoZSBleHBvcnQuXG4gICAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuICAgICAgdmFyIGF0dHJzID0gW1wic3R5bGVcIl07XG4gICAgICBpZiAoaXNOb3RXeXNpd3lnTW9kZSkgYXR0cnMucHVzaChcInJlcGxhY2Vkc3R5bGVcIik7XG4gICAgICB2YXIgYXR0clZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gKGF0dHJWYWx1ZSA9PT0gZmFsc2UpIHx8IChhdHRyVmFsdWUgPT09IG51bGwpIHx8IChhdHRyVmFsdWUgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0b1JlbW92ZSlcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3ZpcnR1YWxBdHRyU3R5bGUnXSA9IHRydWU7XG5cbmtvLmJpbmRpbmdIYW5kbGVyc1sndmlydHVhbFN0eWxlJ10gPSB7XG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSA4KSB7XG4gICAgICBrby5iaW5kaW5nSGFuZGxlcnNbJ3N0eWxlJ10udXBkYXRlKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddID0gdHJ1ZTtcblxuXG5rby5iaW5kaW5nSGFuZGxlcnNbJ3ZpcnR1YWxIdG1sJ10gPSB7XG4gIGluaXQ6IGtvLmJpbmRpbmdIYW5kbGVyc1snaHRtbCddLmluaXQsXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcikge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSA4KSB7XG4gICAgICB2YXIgaHRtbCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcblxuICAgICAga28udmlydHVhbEVsZW1lbnRzLmVtcHR5Tm9kZShlbGVtZW50KTtcbiAgICAgIGlmICgoaHRtbCAhPT0gbnVsbCkgJiYgKGh0bWwgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGh0bWwgPSBodG1sLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyc2VkTm9kZXMgPSBrby51dGlscy5wYXJzZUh0bWxGcmFnbWVudChodG1sKTtcbiAgICAgICAgaWYgKHBhcnNlZE5vZGVzKSB7XG4gICAgICAgICAgdmFyIGVuZENvbW1lbnROb2RlID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHBhcnNlZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgIGVuZENvbW1lbnROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBhcnNlZE5vZGVzW2ldLCBlbmRDb21tZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBwbGFpbiBub2RlXG4gICAgICBrby5iaW5kaW5nSGFuZGxlcnNbJ2h0bWwnXS51cGRhdGUoZWxlbWVudCwgdmFsdWVBY2Nlc3Nvcik7XG4gICAgfVxuXG4gICAgLy8gQ29udGVudCBmb3IgdmlydHVhbEhUTUwgbXVzdCBub3QgYmUgcGFyc2VkIGJ5IEtPLCBpdCBpcyBzaW1wbGUgY29udGVudC5cbiAgICByZXR1cm4ge1xuICAgICAgY29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6IHRydWVcbiAgICB9O1xuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1sndmlydHVhbEh0bWwnXSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIgdGlueW1jZSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd0aW55bWNlJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd0aW55bWNlJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnJlcXVpcmUoXCIuL2V2ZW50YWJsZS5qc1wiKTtcblxua28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdPckh0bWwgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuXG4gICAgaWYgKGlzTm90V3lzaXd5Z01vZGUpXG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd2aXJ0dWFsSHRtbCddLmluaXQoKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWcuaW5pdChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICBpZiAoaXNOb3RXeXNpd3lnTW9kZSlcbiAgICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3ZpcnR1YWxIdG1sJ10udXBkYXRlKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xuICAgIC8vZWxzZSBcbiAgICAvLyAgcmV0dXJuIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLnVwZGF0ZShlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3d5c2l3eWdPckh0bWwnXSA9IHRydWU7XG5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnSHJlZiA9IHtcbiAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSA4KSB7XG4gICAgICB2YXIgdiA9IHZhbHVlQWNjZXNzb3IoKTtcblxuICAgICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiWFhYXCIsIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSwgaXNOb3RXeXNpd3lnTW9kZSwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKTtcbiAgICAgIGlmIChpc05vdFd5c2l3eWdNb2RlKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCAnX25ldycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLypqc2hpbnQgc2NyaXB0dXJsOnRydWUqL1xuICAgICAgICAvLyAyMDE1MDIyNjogcmVtb3ZlZCBocmVmIHRvIHdvcmsgYXJvdW5kIEZGIGlzc3VlcyB3aXRoIDxhIGhyZWY9XCJcIj48ZGl2IGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIj4uLjwvZGl2PjwvYT5cbiAgICAgICAgLy8gZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnamF2YXNjcmlwdDp2b2lkKDApJyk7XG4gICAgICAgIC8vIDIwMTUwMzA5OiBvbiBJRSwgYW4gZWRpdGFibGUgPGEgaHJlZj1cIlwiIGRhdGEtZWRpdGFibGU9XCJcIj4gcHJldmVudCB0aW55bWNlIHRvb2xiYXIgdG8gYmUgc2hvd24uXG4gICAgICAgIC8vICAgICAgICAgICBzbyBJIGNoYW5nZSBiZWhhdmlvdXIgYmFzZWQgb24gdGhlIHVzZSBvZiBcInd5c2l3eWdPckh0bWxcIlxuICAgICAgICAvLyBAc2VlOiBodHRwOi8vd3d3LnRpbnltY2UuY29tL2RldmVsb3AvYnVndHJhY2tlcl92aWV3LnBocD9pZD03NDMyXG4gICAgICAgIHZhciBhbGxiaW5kaW5ncyA9IGFsbEJpbmRpbmdzQWNjZXNzb3IoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGxiaW5kaW5ncy53eXNpd3lnT3JIdG1sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgJ2phdmFzY3JpcHQ6dm9pZCgwKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkaHJlZicsICcjJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3NBY2Nlc3Nvciwgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSA4KSB7XG4gICAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuICAgICAgLy8gTk9URSB0aGlzIHVud3JhcCBpcyBuZWVkZWQgYWxzbyBpbiBcInd5c2l3eWdcIiBtb2RlLCBvdGhlcndpc2UgZGVwZW5kZW5jeSB0cmFja2luZyBkaWVzLlxuICAgICAgdmFyIGF0dHJWYWx1ZSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKTtcbiAgICAgIGlmIChpc05vdFd5c2l3eWdNb2RlKSB7XG4gICAgICAgIGlmICgoYXR0clZhbHVlID09PSBmYWxzZSkgfHwgKGF0dHJWYWx1ZSA9PT0gbnVsbCkgfHwgKGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBhdHRyVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snd3lzaXd5Z0hyZWYnXSA9IHRydWU7XG5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnU3JjID0ge1xuICBjb252ZXJ0ZWRVcmw6IGZ1bmN0aW9uKHNyYywgbWV0aG9kLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHJlcyA9IHNyYyArIFwiP21ldGhvZD1cIiArIG1ldGhvZCArIFwiJndpZHRoPVwiICsgd2lkdGggKyAoaGVpZ2h0ICE9PSBudWxsID8gXCImaGVpZ2h0PVwiICsgaGVpZ2h0IDogJycpO1xuICAgIGNvbnNvbGUubG9nKFwiYmFzaWMgY29udmVydGVyVXJsXCIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgcGxhY2Vob2xkZXJVcmw6IGZ1bmN0aW9uKHBsd2lkdGgsIHBsaGVpZ2h0LCBwbHRleHQpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXJzcmMgPSBcIidodHRwOi8vbG9yZW1waXhlbC5jb20vZy8nK1wiICsgcGx3aWR0aCArIFwiKycvJytcIiArIHBsaGVpZ2h0ICsgXCIrJy9hYnN0cmFjdC8nK2VuY29kZVVSSUNvbXBvbmVudChcIiArIHBsdGV4dCArIFwiKVwiO1xuICAgIC8vIGh0dHA6Ly9wbGFjZWhvbGQuaXQvMjAweDE1MC5wbmcvY2NjY2NjLzMzMzMzMyZ0ZXh0PXBsYWNlaG9sZC5pdCNzdGhhc2gubkEzcjI2dlIuZHB1ZlxuICAgIC8vIHBsYWNlaG9sZGVyc3JjID0gXCInaHR0cDovL3BsYWNlaG9sZC5pdC8nK1wiK3dpZHRoK1wiKyd4JytcIitoZWlnaHQrXCIrJy5wbmcvY2NjY2NjLzMzMzMzMyZ0ZXh0PScrXCIrc2l6ZTtcbiAgICAvLyBwbGFjZWhvbGRlcnNyYyA9IFwiJ1wiK2NvbnZlcnRlclV0aWxzLmFkZFNsYXNoZXMoZGVmYXVsdFZhbHVlKStcIidcIjtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIHZhciBhdHRyVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlLnNyYyk7XG4gICAgdmFyIHBsYWNlaG9sZGVyVmFsdWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlLnBsYWNlaG9sZGVyKTtcbiAgICB2YXIgd2lkdGggPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlLndpZHRoKTtcbiAgICB2YXIgaGVpZ2h0ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWx1ZS5oZWlnaHQpO1xuICAgIGlmICgoYXR0clZhbHVlID09PSBmYWxzZSkgfHwgKGF0dHJWYWx1ZSA9PT0gbnVsbCkgfHwgKGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKSB8fCAoYXR0clZhbHVlID09PSAnJykpIHtcbiAgICAgIGlmICh0eXBlb2YgcGxhY2Vob2xkZXJWYWx1ZSA9PSAnb2JqZWN0JyAmJiBwbGFjZWhvbGRlclZhbHVlICE9PSBudWxsKSBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3JjJywga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMucGxhY2Vob2xkZXJVcmwocGxhY2Vob2xkZXJWYWx1ZS53aWR0aCwgcGxhY2Vob2xkZXJWYWx1ZS5oZWlnaHQsIHBsYWNlaG9sZGVyVmFsdWUudGV4dCkpO1xuICAgICAgZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtZXRob2QgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlLm1ldGhvZCk7XG4gICAgICBpZiAoIW1ldGhvZCkgbWV0aG9kID0gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyAnY292ZXInIDogJ3Jlc2l6ZSc7XG4gICAgICB2YXIgc3JjID0ga28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdTcmMuY29udmVydGVkVXJsKGF0dHJWYWx1ZS50b1N0cmluZygpLCBtZXRob2QsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnICYmIHdpZHRoICE9PSBudWxsKSBlbGVtZW50LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoKTtcbiAgICBlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwid2lkdGhcIik7XG4gICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnICYmIGhlaWdodCAhPT0gbnVsbCkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgICBlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiaGVpZ2h0XCIpO1xuICB9XG59O1xuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0lkID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICBpZiAoIWlzTm90V3lzaXd5Z01vZGUpXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSkpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuICAgIGlmICghaXNOb3RXeXNpd3lnTW9kZSlcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsdWVBY2Nlc3NvcigpKSk7XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd3eXNpd3lnSWQnXSA9IHRydWU7XG5cbi8vIHVzZWQgb24gZWRpdGFibGUgXCJpdGVtXCIgc28gdG8gYmluZCBjbGlja3Mgb25seSBpbiB3eXNpd3lnIG1vZGUuXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Z0NsaWNrID0ge1xuICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgdmFyIGlzTm90V3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSA9PSAndW5kZWZpbmVkJyB8fCBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgIT0gJ3d5c2l3eWcnKTtcbiAgICBpZiAoIWlzTm90V3lzaXd5Z01vZGUpXG4gICAgICBrby5iaW5kaW5nSGFuZGxlcnMuY2xpY2suaW5pdChlbGVtZW50LCB2YWx1ZUFjY2Vzc29yLCBhbGxCaW5kaW5nc0FjY2Vzc29yLCB2aWV3TW9kZWwsIGJpbmRpbmdDb250ZXh0KTtcbiAgfVxufTtcbmtvLnZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NbJ3d5c2l3eWdDbGljayddID0gdHJ1ZTtcblxuLy8gdXNlZCBvbiBlZGl0YWJsZSBcIml0ZW1cIiBzbyB0byBiaW5kIGNzcyBvbmx5IGluIHd5c2l3eWcgbW9kZS5cbmtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnQ3NzID0ge1xuICB1cGRhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICB2YXIgaXNOb3RXeXNpd3lnTW9kZSA9ICh0eXBlb2YgYmluZGluZ0NvbnRleHQudGVtcGxhdGVNb2RlID09ICd1bmRlZmluZWQnIHx8IGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAnd3lzaXd5ZycpO1xuICAgIGlmICghaXNOb3RXeXNpd3lnTW9kZSlcbiAgICAgIGtvLmJpbmRpbmdIYW5kbGVycy5jc3MudXBkYXRlKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpO1xuICB9XG59O1xua28udmlydHVhbEVsZW1lbnRzLmFsbG93ZWRCaW5kaW5nc1snd3lzaXd5Z0NzcyddID0gdHJ1ZTtcblxua28uYmluZGluZ0hhbmRsZXJzLnd5c2l3eWdJbWcgPSB7XG4gIG1ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3I6IGZ1bmN0aW9uKHZhbHVlQWNjZXNzb3IsIGJpbmRpbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzV3lzaXd5Z01vZGUgPSAodHlwZW9mIGJpbmRpbmdDb250ZXh0LnRlbXBsYXRlTW9kZSAhPSAndW5kZWZpbmVkJyAmJiBiaW5kaW5nQ29udGV4dC50ZW1wbGF0ZU1vZGUgPT0gJ3d5c2l3eWcnKTtcblxuICAgICAgdmFyIG1vZGVsVmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCksXG4gICAgICAgIHVud3JhcHBlZFZhbHVlID0ga28udXRpbHMucGVla09ic2VydmFibGUobW9kZWxWYWx1ZSk7IC8vIFVud3JhcCB3aXRob3V0IHNldHRpbmcgYSBkZXBlbmRlbmN5IGhlcmVcblxuICAgICAgLy8gSWYgdW53cmFwcGVkVmFsdWUuZGF0YSBpcyB0aGUgYXJyYXksIHByZXNlcnZlIGFsbCByZWxldmFudCBvcHRpb25zIGFuZCB1bndyYXAgYWdhaW4gdmFsdWUgc28gd2UgZ2V0IHVwZGF0ZXNcbiAgICAgIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobW9kZWxWYWx1ZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICduYW1lJzogaXNXeXNpd3lnTW9kZSA/IHVud3JhcHBlZFZhbHVlWydfZWRpdFRlbXBsYXRlJ10gOiB1bndyYXBwZWRWYWx1ZVsnX3RlbXBsYXRlJ10sXG4gICAgICAgICd0ZW1wbGF0ZUVuZ2luZSc6IGtvLm5hdGl2ZVRlbXBsYXRlRW5naW5lLmluc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gICdpbml0JzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4ga28uYmluZGluZ0hhbmRsZXJzWyd0ZW1wbGF0ZSddWydpbml0J10oZWxlbWVudCwga28uYmluZGluZ0hhbmRsZXJzWyd3eXNpd3lnSW1nJ10ubWFrZVRlbXBsYXRlVmFsdWVBY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yLCBiaW5kaW5nQ29udGV4dCkpO1xuICB9LFxuICAndXBkYXRlJzogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWVBY2Nlc3NvciwgYWxsQmluZGluZ3MsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICBiaW5kaW5nQ29udGV4dCA9IGJpbmRpbmdDb250ZXh0WydleHRlbmQnXSh2YWx1ZUFjY2Vzc29yKCkpO1xuICAgIHJldHVybiBrby5iaW5kaW5nSGFuZGxlcnNbJ3RlbXBsYXRlJ11bJ3VwZGF0ZSddKGVsZW1lbnQsIGtvLmJpbmRpbmdIYW5kbGVyc1snd3lzaXd5Z0ltZyddLm1ha2VUZW1wbGF0ZVZhbHVlQWNjZXNzb3IodmFsdWVBY2Nlc3NvciwgYmluZGluZ0NvbnRleHQpLCBhbGxCaW5kaW5ncywgdmlld01vZGVsLCBiaW5kaW5nQ29udGV4dCk7XG4gIH1cbn07XG5rby52aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzWyd3eXNpd3lnSW1nJ10gPSB0cnVlO1xuXG4vLyBOT1RFOiB0aGVyZSBhcmUgaXNzdWVzIHdpdGggdGhlIFwicmF3XCIgZm9ybWF0IGFuZCB0cmFzaCBsZWZ0IGFyb3VuZCBieSB0aW55bWNlIHdvcmthcm91bmRzIGZvciBjb250ZW50ZWRpdGFibGUgaXNzdWVzLlxuLy8gc2V0dGluZyBcImZvcmNlZF9yb290X2Jsb2NrOiBmYWxzZVwiIGRpc2FibGUgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIGFkZGluZyBhIHdyYXBwZXIgPHA+IHdoZW4gbmVlZGVkIGFuZCB0aGlzIHNlZW1zIHRvIGZpeCBtYW55IGlzc3VlcyBpbiBJRS5cbi8vIGFsc28sIG1heWJlIHdlIHNob3VsZCB1c2UgdGhlIFwicmF3XCIgb25seSBmb3IgdGhlIFwiYmVmb3JlIFNldENvbnRlbnRcIiBhbmQgaW5zdGVhZCByZWFkIHRoZSBcIm5vbi1yYXdcIiBjb250ZW50ICh0aGUgcmF3IGNvbnRlbnQgc29tZXRpbWVzIGhhdmUgZGF0YS0gYXR0cmlidXRlcyBhbmQgdG9vIG1hbnkgZW5kaW5nIDxicj4gaW4gdGhlIGNvZGUpXG5rby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5ZyA9IHtcbiAgY3VycmVudEluZGV4OiAwLFxuICBzdGFuZGFyZE9wdGlvbnM6IHt9LFxuICBmdWxsT3B0aW9uczoge1xuICAgIHRvb2xiYXIxOiAnYm9sZCBpdGFsaWMgZm9yZWNvbG9yIGJhY2tjb2xvciBociBzdHlsZXNlbGVjdCByZW1vdmVmb3JtYXQgfCBsaW5rIHVubGluayB8IHBhc3RldGV4dCBjb2RlJyxcbiAgICAvL3Rvb2xiYXIxOiBcImJvbGQgaXRhbGljIHwgZm9yZWNvbG9yIGJhY2tjb2xvciB8IGxpbmsgdW5saW5rIHwgaHIgfCBwYXN0ZXRleHQgY29kZVwiLCAvLyB8IG5ld3NsZXR0ZXJfcHJvZmlsZSBuZXdzbGV0dGVyX29wdGxpbmsgbmV3c2xldHRlcl91bnN1YnNjcmliZSBuZXdzbGV0dGVyX3Nob3dsaW5rXCI7XG4gICAgLy90b29sYmFyMjogXCJmb3JtYXRzZWxlY3QgZm9udHNlbGVjdCBmb250c2l6ZXNlbGVjdCB8IGFsaWdubGVmdCBhbGlnbmNlbnRlciBhbGlnbnJpZ2h0IGFsaWduanVzdGlmeSB8IGJ1bGxpc3QgbnVtbGlzdFwiLFxuICAgIHBsdWdpbnM6IFtcImxpbmsgaHIgcGFzdGUgbGlzdHMgdGV4dGNvbG9yIGNvZGVcIl0sXG4gICAgLy8gdmFsaWRfZWxlbWVudHM6ICdzdHJvbmcvYixlbS9pLCpbKl0nLFxuICAgIC8vIGV4dGVuZGVkX3ZhbGlkX2VsZW1lbnRzOiAnc3Ryb25nL2IsZW0vaSwqWypdJyxcbiAgICAvLyBSZW1vdmVkOiBpbWFnZSBmdWxsc2NyZWVuIGNvbnRleHRtZW51IFxuICAgIC8vIGRvd25sb2FkIGN1c3RvbTpcbiAgICAvLyBqcXVlcnkgdmVyc2lvbiBjb24gbGVnYWN5b3V0cHV0LCBhbmNob3IsIGNvZGUsIGltcG9ydGNzcywgbGluaywgcGFzdGUsIHRleHRjb2xvciwgaHIsIGxpc3RzXG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlQWNjZXNzb3IsIGFsbEJpbmRpbmdzQWNjZXNzb3IsIHZpZXdNb2RlbCwgYmluZGluZ0NvbnRleHQpIHtcbiAgICAvLyBUT0RPIHVnbHksIGJ1dCB3b3Jrcy4uLlxuICAgIGtvLmJpbmRpbmdIYW5kbGVycy5mb2N1c2FibGUuaW5pdChlbGVtZW50KTtcblxuICAgIGtvLnV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2soZWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICB0aW55bWNlLnJlbW92ZSgnIycgKyBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSk7XG4gICAgfSk7XG5cbiAgICB2YXIgdmFsdWUgPSB2YWx1ZUFjY2Vzc29yKCk7XG5cbiAgICBpZiAoIWtvLmlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHRocm93IFwiV3lzaXd5ZyBiaW5kaW5nIGNhbGxlZCB3aXRoIG5vbiBvYnNlcnZhYmxlXCI7XG4gICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDgpIHRocm93IFwiV3lzaXd5ZyBiaW5kaW5nIGNhbGxlZCBvbiB2aXJ0dWFsIG5vZGUsIGlnbm9yaW5nLi4uLlwiICsgZWxlbWVudC5pbm5lckhUTUw7XG5cbiAgICB2YXIgc2VsZWN0b3JJZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgIGlmICghc2VsZWN0b3JJZCkge1xuICAgICAgc2VsZWN0b3JJZCA9ICd3eXNpd3lnXycgKyAoKytrby5iaW5kaW5nSGFuZGxlcnNbJ3d5c2l3eWcnXS5jdXJyZW50SW5kZXgpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgc2VsZWN0b3JJZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxFZGl0b3IgPSBlbGVtZW50LnRhZ05hbWUgPT0gJ0RJVicgfHwgZWxlbWVudC50YWdOYW1lID09ICdURCc7XG4gICAgdmFyIGlzU3Vic2NyaWJlckNoYW5nZSA9IGZhbHNlO1xuICAgIHZhciB0aGlzRWRpdG9yO1xuICAgIHZhciBpc0VkaXRvckNoYW5nZSA9IGZhbHNlO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBzZWxlY3RvcjogJyMnICsgc2VsZWN0b3JJZCxcbiAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgIC8vIG1heWJlIG5vdCBuZWVkZWQsIGJ1dCB3b24ndCBodXJ0LlxuICAgICAgaGlkZGVuX2lucHV0OiBmYWxzZSxcbiAgICAgIHBsdWdpbnM6IFtcInBhc3RlXCJdLFxuICAgICAgdG9vbGJhcjE6IFwiYm9sZCBpdGFsaWNcIixcbiAgICAgIHRvb2xiYXIyOiBcIlwiLFxuICAgICAgLy8gd2UgaGF2ZSB0byBkaXNhYmxlIHByZXZpZXdfc3R5bGVzIG90aGVyd2lzZSB0aW55bWNlIHB1c2ggaW5saW5lIGV2ZXJ5IHN0eWxlIGhlIHRoaW5ncyB3aWxsIGJlIGFwcGxpZWQgYW5kIHRoaXMgbWFrZXMgdGhlIHN0eWxlIG1lbnUgdG8gaW5oZXJpdCBjb2xvci9mb250LWZhbWlseSBhbmQgbW9yZS5cbiAgICAgIHByZXZpZXdfc3R5bGVzOiBmYWxzZSxcbiAgICAgIHBhc3RlX2FzX3RleHQ6IHRydWUsXG4gICAgICBsYW5ndWFnZTogJ2VuJyxcbiAgICAgIHNjaGVtYTogXCJodG1sNVwiLFxuICAgICAgZXh0ZW5kZWRfdmFsaWRfZWxlbWVudHM6ICdzdHJvbmcvYixlbS9pLCpbKl0nLFxuICAgICAgbWVudWJhcjogZmFsc2UsXG4gICAgICBza2luOiAnZ3JheS1mbGF0JyxcbiAgICAgIHNldHVwOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgLy8gVE9ETyBjaGFuZ2Ugc29tZXRpbWVzIGRvZXNuJ3QgdHJpZ2dlciAod2UgaGF2ZSB0byBkb2N1bWVudCB3aGVuKVxuICAgICAgICAvLyBsaXN0ZW5pbmcgb24ga2V5dXAgd291bGQgaW5jcmVhc2UgY29ycmVjdG5lc3MgYnV0IHdlIHdvdWxkIG5lZWQgYSByYXRlTGltaXQgdG8gYXZvaWQgZmxvb2RpbmcuXG4gICAgICAgIGVkaXRvci5vbignY2hhbmdlIHJlZG8gdW5kbycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghaXNTdWJzY3JpYmVyQ2hhbmdlKSB7XG4gICAgICAgICAgICBpc0VkaXRvckNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAvLyB3ZSBmYWlsZWQgd2l0aCBvdGhlciB3YXlzIHRvIGRvIHRoaXM6XG4gICAgICAgICAgICAvLyB2YWx1ZSgkKGVsZW1lbnQpLmh0bWwoKSk7XG4gICAgICAgICAgICAvLyB2YWx1ZShlbGVtZW50LmlubmVySFRNTCk7XG4gICAgICAgICAgICB2YWx1ZShlZGl0b3IuZ2V0Q29udGVudCh7XG4gICAgICAgICAgICAgIGZvcm1hdDogJ3JhdydcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlzRWRpdG9yQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2xpY2tpbmcgb24gdGhlIGVsZW1lbnQgb24gZm9jdXMgY2hhbmdlIGFsbG93IHRoZSBcImNsaWNcIiBjb2RlIHRvIGJlIHRyaWdnZXJlZCBhbmQgcHJvcGFnYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIC8vIE5vdCBlbGVnYW50LCBtYXliZSB3ZSBoYXZlIGJldHRlciBvcHRpb25zLlxuICAgICAgICBlZGl0b3Iub24oJ2ZvY3VzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gVXNlZCBieSBzY3JvbGxmaXguanMgKG1heWJlIHRoaXMgaXMgbm90IG5lZWRlZCBieSBuZXcgc2Nyb2xsZml4LmpzKVxuICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICAgIGVkaXRvci5nZXRFbGVtZW50KCkuY2xpY2soKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTk9URTogdGhpcyBmaXhlcyBpc3N1ZSB3aXRoIFwibGVhZGluZyBzcGFjZXNcIiBpbiBkZWZhdWx0IGNvbnRlbnQgdGhhdCB3ZXJlIGxvc3QgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgICAgICBlZGl0b3Iub24oJ0JlZm9yZVNldENvbnRlbnQnLCBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgaWYgKGFyZ3MuaW5pdGlhbCkgYXJncy5mb3JtYXQgPSAncmF3JztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyogTk9URTogZGlzYWJsaW5nIFwiRU5URVJcIiBpbiB0aW55IGVkaXRvciwgbm90IGEgZ29vZCB0aGluZyBidXQgbWF5IGJlIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBjb250ZW50ZWRpdGFibGUgaXNzdWVzXG4gICAgICAgIGlmICghZnVsbEVkaXRvcikge1xuICAgICAgICAgIC8vIHNlIG5vbiBhYmJpYW1vIGlsIFwiZnVsbCBFZGl0b3JcIiwgZGlzYWJpbGl0aWFtbyBsJ2ludmlvLiAodmFyaSBidWcpXG4gICAgICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgICAgIHRoaXNFZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgIH1cbiAgICB9O1xuXG4gICAga28udXRpbHMuZXh0ZW5kKG9wdGlvbnMsIGtvLmJpbmRpbmdIYW5kbGVycy53eXNpd3lnLnN0YW5kYXJkT3B0aW9ucyk7XG4gICAgaWYgKGZ1bGxFZGl0b3IpIGtvLnV0aWxzLmV4dGVuZChvcHRpb25zLCBrby5iaW5kaW5nSGFuZGxlcnMud3lzaXd5Zy5mdWxsT3B0aW9ucyk7XG5cbiAgICAvLyB3ZSBoYXZlIHRvIHB1dCBpbml0aWFsaXphdGlvbiBpbiBhIHNldHRpbWVvdXQsIG90aGVyd2lzZSBzd2l0Y2hpbmcgZnJvbSBcIjFcIiB0byBcIjJcIiBjb2x1bW5zIGJsb2Nrc1xuICAgIC8vIHdpbGwgc3RhcnQgdGhlIG5ldyBlZGl0b3JzIGJlZm9yZSBkaXNwb3NpbmcgdGhlIG9sZCBvbmVzIGFuZCBJRHMgZ2V0IHRlbXBvcmFyaWx5IGR1cGxpY2F0ZWQuXG4gICAgLy8gdXNpbmcgc2V0VGltZW91dCB0aGUgZGlzcG9zZS9jcmVhdGUgb3JkZXIgaXMgY29ycmVjdCBvbiBldmVyeSBicm93c2VyIHRlc3RlZC5cbiAgICBnbG9iYWwuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHRpbnltY2UuaW5pdChvcHRpb25zKTtcbiAgICB9KTtcblxuICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZhbHVlQWNjZXNzb3IoKSk7XG4gICAgICBpZiAoIWlzRWRpdG9yQ2hhbmdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaXNTdWJzY3JpYmVyQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAvLyB3ZSBmYWlsZWQgc2V0dGluZyBjb250ZW50cyBpbiBvdGhlciB3YXlzLi4uXG4gICAgICAgICAgLy8gJChlbGVtZW50KS5odG1sKGNvbnRlbnQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpc0VkaXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXNFZGl0b3Iuc2V0Q29udGVudChjb250ZW50LCB7XG4gICAgICAgICAgICAgIGZvcm1hdDogJ3JhdydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrby51dGlscy5zZXRIdG1sKGVsZW1lbnQsIGNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyBleGNlcHRpb24gc2V0dGluZyBjb250ZW50IHRvIGVkaXRhYmxlIGVsZW1lbnRcIiwgdHlwZW9mIHRoaXNFZGl0b3IsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGlzU3Vic2NyaWJlckNoYW5nZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIG51bGwsIHtcbiAgICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogZWxlbWVudFxuICAgIH0pO1xuXG4gICAgLy8gZG8gbm90IHBhcnNlIGh0bWwgY29udGVudCBmb3IgS08gYmluZGluZ3MhIVxuICAgIHJldHVybiB7XG4gICAgICBjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczogdHJ1ZVxuICAgIH07XG5cbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbi8vIHJldHVybnMgMCBpZiBlcXVhbCAoMC4wLnggcmVsZWFzZSksIDEgd2l0aCBiYWNrd2FyZCBjb21wYXRpYmxlIGFkZGl0aW9ucyAoMC54LjAgcmVsZWFzZSksIDIgb24gbG9zdCBkYXRhIG9yIGluY29tcGF0aWJsZSBkYXRhICh4LjAuMCByZWxlYXNlKVxudmFyIGNoZWNrTW9kZWwgPSBmdW5jdGlvbihyZWZlcmVuY2UsIGJsb2NrRGVmcywgbW9kZWwsIG9yaWdQcmVmaXgsIHJldmVyc2UpIHtcbiAgdmFyIGJsb2NrRGVmc09iaiwgaSwgcHJlZml4O1xuICB2YXIgdmFsaWQgPSAwO1xuICBpZiAodHlwZW9mIHJldmVyc2UgPT0gJ3VuZGVmaW5lZCcpIHJldmVyc2UgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBibG9ja0RlZnMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBibG9ja0RlZnMuc3BsaWNlID09ICdmdW5jdGlvbicpIHtcbiAgICBibG9ja0RlZnNPYmogPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tEZWZzLmxlbmd0aDsgaSsrKSBibG9ja0RlZnNPYmpbYmxvY2tEZWZzW2ldLnR5cGVdID0gYmxvY2tEZWZzW2ldO1xuICB9IGVsc2Uge1xuICAgIGJsb2NrRGVmc09iaiA9IGJsb2NrRGVmcztcbiAgfVxuICBmb3IgKHZhciBwcm9wIGluIHJlZmVyZW5jZSlcbiAgICBpZiAocmVmZXJlbmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBwcmVmaXggPSB0eXBlb2Ygb3JpZ1ByZWZpeCAhPT0gJ3VuZGVmaW5lZCcgPyBvcmlnUHJlZml4ICsgXCIuXCIgKyBwcm9wIDogcHJvcDtcbiAgICAgIGlmICghbW9kZWwuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOIFByb3BlcnR5IFwiLCBwcmVmaXgsIFwiZm91bmQgaW4gbW9kZWwgaXMgbm90IGRlZmluZWQgYnkgdGVtcGxhdGU6IHJlbW92aW5nIGl0IVwiKTtcbiAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgICBkZWxldGUgcmVmZXJlbmNlW3Byb3BdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiSU5GTyBQcm9wZXJ0eSBcIiwgcHJlZml4LCBcIm1pc3NpbmcgaW4gbW9kZWwsIGNsb25pbmcgZnJvbSByZWZlcmVuY2UhXCIpO1xuICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDEpO1xuICAgICAgICAgIG1vZGVsW3Byb3BdID0gcmVmZXJlbmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlbFtwcm9wXSAhPSB0eXBlb2YgcmVmZXJlbmNlW3Byb3BdKSB7XG4gICAgICAgIC8vIHNlIHNvbm8gZGkgdGlwbyBkaXZlcnNvIGFsbG9yYSBwcm92byBhIHZlZGVyZSBzZSBsJ2FsdHJvLCBjb252ZXJ0aXRvIGRpIHRpcG8gbWFudGllbmUgdW4gdmFsb3JlIGVxdWl2YWxlbnRlLlxuICAgICAgICBpZiAobW9kZWxbcHJvcF0gIT09IG51bGwgJiYgcmVmZXJlbmNlW3Byb3BdICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RlbFtwcm9wXSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKFN0cmluZyhyZWZlcmVuY2VbcHJvcF0pICE9IHJlZmVyZW5jZVtwcm9wXSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPRE8gRGlmZmVyZW50IHR5cGUgMSBcIiwgcHJlZml4LCB0eXBlb2YgbW9kZWxbcHJvcF0sIHR5cGVvZiByZWZlcmVuY2VbcHJvcF0sIG1vZGVsW3Byb3BdLCByZWZlcmVuY2VbcHJvcF0pO1xuICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlbFtwcm9wXSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKE51bWJlcihyZWZlcmVuY2VbcHJvcF0pICE9IHJlZmVyZW5jZVtwcm9wXSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPRE8gRGlmZmVyZW50IHR5cGUgMiBcIiwgcHJlZml4LCB0eXBlb2YgbW9kZWxbcHJvcF0sIHR5cGVvZiByZWZlcmVuY2VbcHJvcF0sIG1vZGVsW3Byb3BdLCByZWZlcmVuY2VbcHJvcF0pO1xuICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIERpZmZlcmVudCB0eXBlIDMgXCIsIHByZWZpeCwgdHlwZW9mIG1vZGVsW3Byb3BdLCB0eXBlb2YgcmVmZXJlbmNlW3Byb3BdLCBtb2RlbFtwcm9wXSwgcmVmZXJlbmNlW3Byb3BdKTtcbiAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVmZXJlbmNlW3Byb3BdID09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZWZlcmVuY2VbcHJvcF0gIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlZmVyZW5jZVtwcm9wXS5zcGxpY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlW3Byb3BdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKG1vZGVsW3Byb3BdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG5lZWRzIHNvcnRpbmc/XG4gICAgICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2RlbFtwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RlbFtwcm9wXVtpXS50eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgcmVmZXJlbmNlW3Byb3BdLmxlbmd0aCAmJiByZWZlcmVuY2VbcHJvcF1bal0udHlwZSAhPT0gbW9kZWxbcHJvcF1baV0udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaWdub3JpbmcgXCIsIHByZWZpeCwgcmVmZXJlbmNlW3Byb3BdW2pdLnR5cGUsIFwiIGJsb2NrIHR5cGUgaW4gcmVmZXJlbmNlIG5vdCBmb3VuZCBpbiBtb2RlbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPj0gcmVmZXJlbmNlW3Byb3BdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTiBjYW5ub3QgZmluZCBcIiwgcHJlZml4LCBtb2RlbFtwcm9wXVtpXS50eXBlLCBcIiBibG9jayBpbiByZWZlcmVuY2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmV2ZXJzZSBjb25kaXRpb24gc28gdG8gc2tpcCBcImRlZXAgdHJhdmVyc2luZ1wiIG9uIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIGNoZWNrTW9kZWwocmVmZXJlbmNlW3Byb3BdW2pdLCB1bmRlZmluZWQsIG1vZGVsW3Byb3BdW2ldLCBwcmVmaXggKyBcIltcIiArIGkgKyBcIi5cIiArIG1vZGVsW3Byb3BdW2ldLnR5cGUgKyBcIl1cIikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgYXJyYXkgd2UgY2hlY2sgYmxvY2tEZWZzXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlZmVyZW5jZVtwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VbcHJvcF1baV0udHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIGZvdW5kIGFuIG9iamVjdCB3aXRoIG5vIHR5cGVcIiwgcHJlZml4LCByZWZlcmVuY2VbcHJvcF1baV0pO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJsb2NrRGVmc09iai5oYXNPd25Qcm9wZXJ0eShyZWZlcmVuY2VbcHJvcF1baV0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVE9ETyB0aGUgbW9kZWwgdXNlcyBhIGJsb2NrIHR5cGUgbm90IGRlZmluZWQgYnkgdGhlIHRlbXBsYXRlLiBSRU1PVklORyBJVCEhXCIsIHByZWZpeCwgcmVmZXJlbmNlW3Byb3BdW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlW3Byb3BdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIGNoZWNrTW9kZWwoYmxvY2tEZWZzT2JqW3JlZmVyZW5jZVtwcm9wXVtpXS50eXBlXSwgYmxvY2tEZWZzT2JqLCByZWZlcmVuY2VbcHJvcF1baV0sIHByZWZpeCArIFwiW1wiICsgaSArIFwiLlwiICsgcmVmZXJlbmNlW3Byb3BdW2ldLnR5cGUgKyBcIl1cIikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobW9kZWxbcHJvcF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk4gTnVsbCBvYmplY3QgaW4gbW9kZWwgXCIsIHByZWZpeCwgXCJpbnN0ZWFkIG9mXCIsIHJlZmVyZW5jZVtwcm9wXSwgXCJkZWxldGluZyBpdFwiKTtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVmZXJlbmNlW3Byb3BdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSU5GTyBOdWxsIG9iamVjdCBpbiBtb2RlbCBcIiwgcHJlZml4LCBcImluc3RlYWQgb2ZcIiwgcmVmZXJlbmNlW3Byb3BdLCBcImNsb25pbmcgaXQgZnJvbSB0aGUgcmVmZXJlbmNlXCIpO1xuICAgICAgICAgICAgICAgIHZhbGlkID0gTWF0aC5tYXgodmFsaWQsIDEpO1xuICAgICAgICAgICAgICAgIG1vZGVsW3Byb3BdID0gcmVmZXJlbmNlW3Byb3BdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCBjaGVja01vZGVsKHJlZmVyZW5jZVtwcm9wXSwgYmxvY2tEZWZzT2JqLCBtb2RlbFtwcm9wXSwgcHJlZml4LCByZXZlcnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsW3Byb3BdICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIE51bGwgaW4gcmVmZXJlbmNlIGJ1dCBub3QgbnVsbCBpbiBtb2RlbFwiLCBwcmVmaXgsIG1vZGVsW3Byb3BdKTtcbiAgICAgICAgICB2YWxpZCA9IE1hdGgubWF4KHZhbGlkLCAyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVmZXJlbmNlW3Byb3BdICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcmVmZXJlbmNlW3Byb3BdICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIHJlZmVyZW5jZVtwcm9wXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIHVuc3VwcG9ydGVkIHR5cGVcIiwgcHJlZml4LCB0eXBlb2YgcmVmZXJlbmNlW3Byb3BdKTtcbiAgICAgICAgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgMik7XG4gICAgICB9XG5cbiAgICB9XG4gIGlmICghcmV2ZXJzZSkgdmFsaWQgPSBNYXRoLm1heCh2YWxpZCwgY2hlY2tNb2RlbChtb2RlbCwgYmxvY2tEZWZzLCByZWZlcmVuY2UsIHR5cGVvZiBvcmlnUHJlZml4ICE9PSAndW5kZWZpbmVkJyA/IG9yaWdQcmVmaXggKyBcIiFSXCIgOiBcIiFSXCIsIHRydWUpKTtcbiAgcmV0dXJuIHZhbGlkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja01vZGVsOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBQYXJzZXMgQ1NTIGRlY2xhcmF0aW9ucyBhbmQgc3VwcG9ydHMgdGhlIHByb3BlcnR5IGxhbmd1YWdlICgta28tKikgZm91bmQgYmV0d2VlbiB0aGVtLlxuLy8gQ3JlYXRlIEtPIGJpbmRpbmdzIGJ1dCBkb2Vzbid0IGRlcGVuZCBvbiBLTy5cbi8vIE5lZWRzIGEgYmluZGluZ1Byb3ZpZGVyLlxuXG52YXIgY29udmVydGVyVXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbnZhciBjc3NQYXJzZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvbWVuc2NoL2xpYi9wYXJzZXIuanNcIik7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xudmFyIGRvbXV0aWxzID0gcmVxdWlyZShcIi4vZG9tdXRpbHMuanNcIik7XG5cbnZhciBfZGVjbGFyYXRpb25WYWx1ZUxvb2t1cCA9IGZ1bmN0aW9uKGRlY2xhcmF0aW9ucywgcHJvcGVydHluYW1lLCB0ZW1wbGF0ZVVybENvbnZlcnRlcikge1xuICBmb3IgKHZhciBpID0gZGVjbGFyYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGRlY2xhcmF0aW9uc1tpXS50eXBlID09ICdwcm9wZXJ0eScgJiYgZGVjbGFyYXRpb25zW2ldLm5hbWUgPT0gcHJvcGVydHluYW1lKSB7XG4gICAgICByZXR1cm4gX2RlY2xhcmF0aW9uVmFsdWVVcmxQcmVmaXhlcihkZWNsYXJhdGlvbnNbaV0udmFsdWUsIHRlbXBsYXRlVXJsQ29udmVydGVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgX3Byb3BUb0NhbWVsQ2FzZSA9IGZ1bmN0aW9uKHByb3BOYW1lKSB7XG4gIHJldHVybiBwcm9wTmFtZS5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbihtYXRjaCwgY29udGVudHMsIG9mZnNldCwgcykge1xuICAgIHJldHVybiBjb250ZW50cy50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn07XG5cbnZhciBfZGVjbGFyYXRpb25WYWx1ZVVybFByZWZpeGVyID0gZnVuY3Rpb24odmFsdWUsIHRlbXBsYXRlVXJsQ29udmVydGVyKSB7XG4gIGlmICh2YWx1ZS5tYXRjaCgvdXJsXFwoLipcXCkvKSkge1xuICAgIHZhciByZXBsYWNlZCA9IHZhbHVlLnJlcGxhY2UoLyh1cmxcXCgpKFteXFwpXSopKFxcKSkvZywgZnVuY3Rpb24obWF0Y2hlZCwgcHJlZml4LCB1cmwsIHBvc3RmaXgpIHtcbiAgICAgIHZhciB0cmltbWVkID0gdXJsLnRyaW0oKTtcbiAgICAgIHZhciBhcGljZSA9IHVybC50cmltKCkuY2hhckF0KDApO1xuICAgICAgaWYgKGFwaWNlID09ICdcXCcnIHx8IGFwaWNlID09ICdcIicpIHtcbiAgICAgICAgdHJpbW1lZCA9IHRyaW1tZWQuc3Vic3RyKDEsIHRyaW1tZWQubGVuZ3RoIC0gMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcGljZSA9ICcnO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1VybCA9IHRlbXBsYXRlVXJsQ29udmVydGVyKHRyaW1tZWQpO1xuICAgICAgaWYgKG5ld1VybCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgYXBpY2UgKyBuZXdVcmwgKyBhcGljZSArIHBvc3RmaXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVwbGFjZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG52YXIgZWxhYm9yYXRlRGVjbGFyYXRpb25zID0gZnVuY3Rpb24oc3R5bGUsIGRlY2xhcmF0aW9ucywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGJpbmRpbmdQcm92aWRlciwgZWxlbWVudCwgYmFzaWNCaW5kaW5ncywgcmVtb3ZlRGlzcGxheU5vbmUpIHtcbiAgdmFyIG5ld0JpbmRpbmdzID0gdHlwZW9mIGJhc2ljQmluZGluZ3MgPT0gJ29iamVjdCcgJiYgYmFzaWNCaW5kaW5ncyAhPT0gbnVsbCA/IGJhc2ljQmluZGluZ3MgOiB7fTtcbiAgdmFyIG5ld1N0eWxlID0gbnVsbDtcbiAgdmFyIHNraXBMaW5lcyA9IDA7XG4gIGlmICh0eXBlb2YgZGVjbGFyYXRpb25zID09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHN0eWxlU2hlZXQgPSBjc3NQYXJzZShcIiN7XFxuXCIgKyBzdHlsZSArIFwifVwiLCB7XG4gICAgICBjb21tZW50czogdHJ1ZSxcbiAgICAgIHBvc2l0aW9uOiB0cnVlXG4gICAgfSk7XG4gICAgZGVjbGFyYXRpb25zID0gc3R5bGVTaGVldC5zdHlsZXNoZWV0LnJ1bGVzWzBdLmRlY2xhcmF0aW9ucztcbiAgICBza2lwTGluZXMgPSAxO1xuICB9XG4gIGZvciAodmFyIGkgPSBkZWNsYXJhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgaWYgKGRlY2xhcmF0aW9uc1tpXS50eXBlID09ICdwcm9wZXJ0eScpIHtcbiAgICAgIGlmIChyZW1vdmVEaXNwbGF5Tm9uZSA9PT0gdHJ1ZSAmJiBkZWNsYXJhdGlvbnNbaV0ubmFtZSA9PSAnZGlzcGxheScgJiYgZGVjbGFyYXRpb25zW2ldLnZhbHVlID09ICdub25lJykge1xuICAgICAgICBpZiAobmV3U3R5bGUgPT09IG51bGwpIG5ld1N0eWxlID0gc3R5bGU7XG4gICAgICAgIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIGRlY2xhcmF0aW9uc1tpXS5wb3NpdGlvbi5zdGFydCwgZGVjbGFyYXRpb25zW2ldLnBvc2l0aW9uLmVuZCwgc2tpcExpbmVzLCAwLCAwLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVjbCA9IGRlY2xhcmF0aW9uc1tpXS5uYW1lLm1hdGNoKC9eLWtvLShiaW5kLXxhdHRyLSk/KFthLXowLTktXSo/KSgtaWZ8LWlmbm90KT8kLyk7XG4gICAgICAgIGlmIChkZWNsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gcmltb3ppb25lIGRlbGxvIHN0aWxlIC1rby0gZGFsbCdhdHRyaWJ1dG8gc3R5bGUuXG4gICAgICAgICAgaWYgKG5ld1N0eWxlID09PSBudWxsICYmIHR5cGVvZiBzdHlsZSAhPSAndW5kZWZpbmVkJykgbmV3U3R5bGUgPSBzdHlsZTtcblxuICAgICAgICAgIHZhciBpc0F0dHIgPSBkZWNsWzFdID09ICdhdHRyLSc7XG4gICAgICAgICAgdmFyIGlzQmluZCA9IGRlY2xbMV0gPT0gJ2JpbmQtJztcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBkZWNsWzJdO1xuXG4gICAgICAgICAgdmFyIGlzSWYgPSBkZWNsWzNdID09ICctaWYnIHx8IGRlY2xbM10gPT0gJy1pZm5vdCc7XG4gICAgICAgICAgdmFyIGNvbmREZWNsO1xuICAgICAgICAgIHZhciBiaW5kVmFsdWU7XG4gICAgICAgICAgdmFyIHByb3BEZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgICBpZiAoaXNJZikge1xuICAgICAgICAgICAgY29uZERlY2wgPSBkZWNsYXJhdGlvbnNbaV0ubmFtZS5zdWJzdHIoMCwgZGVjbGFyYXRpb25zW2ldLm5hbWUubGVuZ3RoIC0gZGVjbFszXS5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbmVkRGVjbGFyYXRpb24gPSBfZGVjbGFyYXRpb25WYWx1ZUxvb2t1cChkZWNsYXJhdGlvbnMsIGNvbmREZWNsLCB0ZW1wbGF0ZVVybENvbnZlcnRlcik7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uZWREZWNsYXJhdGlvbiA9PT0gbnVsbCkgdGhyb3cgXCJVbmFibGUgdG8gZmluZCBkZWNsYXJhdGlvbiBcIiArIGNvbmREZWNsICsgXCIgZm9yIFwiICsgZGVjbGFyYXRpb25zW2ldLm5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKChpc0F0dHIgfHwgaXNCaW5kKSAmJiAodHlwZW9mIGVsZW1lbnQgPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHN0eWxlICE9ICd1bmRlZmluZWQnKSkgdGhyb3cgXCJBdHRyaWJ1dGVzIGFuZCBiaW5kIGRlY2xhcmF0aW9ucyBhcmUgb25seSBhbGxvd2VkIGluIGlubGluZSBzdHlsZXMhXCI7XG5cbiAgICAgICAgICAgIHZhciBuZWVkRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBiaW5kVHlwZTtcbiAgICAgICAgICAgIGlmIChpc0F0dHIpIHtcbiAgICAgICAgICAgICAgcHJvcERlZmF1bHRWYWx1ZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgIG5lZWREZWZhdWx0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYmluZFR5cGUgPSAndmlydHVhbEF0dHInO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNCaW5kKSB7XG4gICAgICAgICAgICAgIG5lZWREZWZhdWx0VmFsdWUgPSB0eXBlb2Ygc3R5bGUgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgICBpZiAobmVlZERlZmF1bHRWYWx1ZSkgcHJvcERlZmF1bHRWYWx1ZSA9IF9kZWNsYXJhdGlvblZhbHVlTG9va3VwKGRlY2xhcmF0aW9ucywgcHJvcE5hbWUsIHRlbXBsYXRlVXJsQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgYmluZFR5cGUgPSAndmlydHVhbFN0eWxlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJpbmRUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHByb3BOYW1lID09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIHByb3BEZWZhdWx0VmFsdWUgPSBkb211dGlscy5nZXRJbm5lclRleHQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5lZWREZWZhdWx0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgcHJvcERlZmF1bHRWYWx1ZSA9IGRvbXV0aWxzLmdldElubmVySHRtbChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmVlZERlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWVkRGVmYXVsdFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lZWREZWZhdWx0VmFsdWUgJiYgcHJvcERlZmF1bHRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IGZpbmQgZGVmYXVsdCB2YWx1ZSBmb3JcIiwgZGVjbGFyYXRpb25zW2ldLm5hbWUsIGRlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICAgIHRocm93IFwiQ2Fubm90IGZpbmQgZGVmYXVsdCB2YWx1ZSBmb3IgXCIgKyBkZWNsYXJhdGlvbnNbaV0ubmFtZSArIFwiOiBcIiArIGRlY2xhcmF0aW9uc1tpXS52YWx1ZSArIFwiIGluIFwiICsgZWxlbWVudCArIFwiIChcIiArIHR5cGVvZiBzdHlsZSArIFwiL1wiICsgcHJvcE5hbWUgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaW5kRGVmYXVsdFZhbHVlID0gcHJvcERlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdmFyIGJpbmROYW1lID0gX3Byb3BUb0NhbWVsQ2FzZShwcm9wTmFtZSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGJpbmRWYWx1ZSA9IGNvbnZlcnRlclV0aWxzLmV4cHJlc3Npb25CaW5kaW5nKGRlY2xhcmF0aW9uc1tpXS52YWx1ZSwgYmluZGluZ1Byb3ZpZGVyLCBiaW5kRGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1vZGVsIGVuc3VyZSBwYXRoIGZhaWxlZFwiLCBlLnN0YWNrLCBcIm5hbWVcIiwgZGVjbGFyYXRpb25zW2ldLm5hbWUsIFwidmFsdWVcIiwgZGVjbGFyYXRpb25zW2ldLnZhbHVlLCBcImRlZmF1bHRcIiwgcHJvcERlZmF1bHRWYWx1ZSwgXCJlbGVtZW50XCIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmluZFR5cGUgIT09IG51bGwgJiYgdHlwZW9mIG5ld0JpbmRpbmdzW2JpbmRUeXBlXSA9PSAndW5kZWZpbmVkJykgbmV3QmluZGluZ3NbYmluZFR5cGVdID0ge307XG5cblxuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgSFJFRnNcbiAgICAgICAgICAgIGlmIChiaW5kVHlwZSA9PSAndmlydHVhbEF0dHInICYmIGJpbmROYW1lID09ICdocmVmJykge1xuICAgICAgICAgICAgICBiaW5kVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgIGJpbmROYW1lID0gJ3d5c2l3eWdIcmVmJztcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byByZW1vdmUgaXQsIG90aGVyd2lzZSB3ZSBlbmRzIHVwIHdpdGggMiBydWxlcyB3cml0aW5nIGl0LlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBcImhyZWZcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETyBldmFsdWF0ZSB0aGUgdXNlIG9mIFwiLXRoZW5cIiAoYW5kIC1lbHNlKSBwb3N0Zml4ZXMgdG8gY29tcGxldGUgdGhlIC1pZiBpbnN0ZWFkIG9mIHJlbGF5aW5nXG4gICAgICAgICAgICAvLyBvbiB0aGUgc2FtZSBiYXNpYyBzaW50YXggKG9yIG1heWJlIGl0IGlzIGJldHRlciB0byBzdXBwb3J0IHRlcm5hcnkgb3BlcmF0b3IgQ09ORCA/IFRIRU4gOiBFTFNFKS5cbiAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbkNvbmRpdGlvbiA9IF9kZWNsYXJhdGlvblZhbHVlTG9va3VwKGRlY2xhcmF0aW9ucywgZGVjbGFyYXRpb25zW2ldLm5hbWUgKyAnLWlmJywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgdmFyIG5vdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uQ29uZGl0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGRlY2xhcmF0aW9uQ29uZGl0aW9uID0gX2RlY2xhcmF0aW9uVmFsdWVMb29rdXAoZGVjbGFyYXRpb25zLCBkZWNsYXJhdGlvbnNbaV0ubmFtZSArICctaWZub3QnLCB0ZW1wbGF0ZVVybENvbnZlcnRlcik7XG4gICAgICAgICAgICAgIG5vdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoX2RlY2xhcmF0aW9uVmFsdWVMb29rdXAoZGVjbGFyYXRpb25zLCBkZWNsYXJhdGlvbnNbaV0ubmFtZSArICctaWZub3QnLCB0ZW1wbGF0ZVVybENvbnZlcnRlcikgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZXJyb3I6IGNhbm5vdCB1c2UgYm90aCAtaWYgYW5kIC1pZm5vdCBwcm9wZXJ0eSBjb25kaXRpb25zXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbkNvbmRpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nQ29uZCA9IGNvbnZlcnRlclV0aWxzLmNvbmRpdGlvbkJpbmRpbmcoZGVjbGFyYXRpb25Db25kaXRpb24sIGJpbmRpbmdQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgYmluZFZhbHVlID0gKG5vdCA/ICchJyA6ICcnKSArIFwiKFwiICsgYmluZGluZ0NvbmQgKyBcIikgPyBcIiArIGJpbmRWYWx1ZSArIFwiIDogbnVsbFwiO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBkZWFsIHdpdGggLWtvIHN0eWxlIGJpbmRpbmcgY29uZGl0aW9uXCIsIGRlY2xhcmF0aW9uQ29uZGl0aW9uLCBkZWNsYXJhdGlvbnNbaV0ubmFtZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmluZFR5cGUgIT09IG51bGwpIG5ld0JpbmRpbmdzW2JpbmRUeXBlXVtiaW5kTmFtZV0gPSBiaW5kVmFsdWU7XG4gICAgICAgICAgICBlbHNlIG5ld0JpbmRpbmdzW2JpbmROYW1lXSA9IGJpbmRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwYXJzaW5nIEBzdXBwb3J0cyA6cHJldmlld1xuICAgICAgICAgIGlmIChuZXdTdHlsZSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBpZiBcImVsZW1lbnRcIiBpcyBkZWZpbmVkIHRoZW4gd2UgYXJlIHBhcnNpbmcgYW4gXCJpbmxpbmVcIiBzdHlsZSBhbmQgd2Ugd2FudCB0byByZW1vdmUgaXQuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPSAndW5kZWZpbmVkJyAmJiBlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgZGVjbGFyYXRpb25zW2ldLnBvc2l0aW9uLnN0YXJ0LCBkZWNsYXJhdGlvbnNbaV0ucG9zaXRpb24uZW5kLCBza2lwTGluZXMsIDAsIDAsICcnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYXJlIHBhcnNpbmcgYSBmdWxsIHN0eWxlc2hlZXQuLiBsZXQncyByZXdyaXRlIHRoZSBmdWxsIFwicHJvcDogdmFsdWVcIiB3aXRob3V0IGNhcmluZyBhYm91dCB0aGUgb3JpZ2luYWwgc3ludGF4LlxuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlZFdpdGggPSAnJztcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhbiBcImlmXCIgd2Ugc2ltcGx5IGhhdmUgdG8gcmVtb3ZlIGl0LCBvdGhlcndpc2Ugd2UgcmVwbGFjZSB0aGUgaW5wdXQgY29kZSB3aXRoIFwicHJvcDogdmFsdWVcIiBnZW5lcmF0aW5nIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgaWYgKCFpc0lmKSByZXBsYWNlZFdpdGggPSBwcm9wTmFtZSArICc6IDwhLS0ga28gdGV4dDogJyArIGJpbmRWYWx1ZSArICcgLS0+JyArIHByb3BEZWZhdWx0VmFsdWUgKyAnPCEtLSAva28gLS0+JztcbiAgICAgICAgICAgICAgICBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBkZWNsYXJhdGlvbnNbaV0ucG9zaXRpb24uc3RhcnQsIGRlY2xhcmF0aW9uc1tpXS5wb3NpdGlvbi5lbmQsIHNraXBMaW5lcywgMCwgMCwgcmVwbGFjZWRXaXRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJSZW1vdmUgc3R5bGUgZmFpbGVkXCIsIGUsIFwibmFtZVwiLCBkZWNsYXJhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcHJlZml4aW5nIHVybHNcbiAgICAgICAgICB2YXIgcmVwbGFjZWRWYWx1ZSA9IF9kZWNsYXJhdGlvblZhbHVlVXJsUHJlZml4ZXIoZGVjbGFyYXRpb25zW2ldLnZhbHVlLCB0ZW1wbGF0ZVVybENvbnZlcnRlcik7XG4gICAgICAgICAgaWYgKHJlcGxhY2VkVmFsdWUgIT0gZGVjbGFyYXRpb25zW2ldLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobmV3U3R5bGUgPT09IG51bGwgJiYgdHlwZW9mIHN0eWxlICE9PSAndW5kZWZpbmVkJykgbmV3U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIGlmIChuZXdTdHlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ld1N0eWxlID0gY29udmVydGVyVXRpbHMucmVtb3ZlU3R5bGUobmV3U3R5bGUsIGRlY2xhcmF0aW9uc1tpXS5wb3NpdGlvbi5zdGFydCwgZGVjbGFyYXRpb25zW2ldLnBvc2l0aW9uLmVuZCwgc2tpcExpbmVzLCAwLCAwLCBkZWNsYXJhdGlvbnNbaV0ubmFtZSArIFwiOiBcIiArIHJlcGxhY2VkVmFsdWUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZW1vdmUgc3R5bGUgZmFpbGVkIHJlcGxhY2luZyB1cmxcIiwgZSwgXCJuYW1lXCIsIGRlY2xhcmF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN0eWxlIGhhbmRsaW5nIGJ5IGNvbmNhdGVuYXRlZCBcInN0eWxlIGF0dHJpYnV0ZVwiICh3b3JzZSBwZXJmb3JtYW5jZSBidXQgbW9yZSBzdGFibGUgdGhhbiBkaXJlY3Qgc3R5bGUgaGFuZGxpbmcpXG4gICAgICAgICAgdmFyIGJpbmROYW1lMiA9IF9wcm9wVG9DYW1lbENhc2UoZGVjbGFyYXRpb25zW2ldLm5hbWUpO1xuICAgICAgICAgIHZhciBiaW5kID0gJ3ZpcnR1YWxBdHRyU3R5bGUnO1xuICAgICAgICAgIHZhciBiaW5kVmFsMiA9IHR5cGVvZiBuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ10gIT09ICd1bmRlZmluZWQnID8gbmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddW2JpbmROYW1lMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgZGlzdCA9ICcgJztcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld0JpbmRpbmdzW2JpbmRdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBuZXdCaW5kaW5nc1tiaW5kXSA9IFwiJydcIjtcbiAgICAgICAgICAgIGRpc3QgPSAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGJpbmRWYWwyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbmV3QmluZGluZ3NbYmluZF0gPSBcIidcIiArIGRlY2xhcmF0aW9uc1tpXS5uYW1lICsgXCI6ICcrKFwiICsgYmluZFZhbDIgKyBcIikrJztcIiArIGRpc3QgKyBcIicrXCIgKyBuZXdCaW5kaW5nc1tiaW5kXTtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ11bYmluZE5hbWUyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3QmluZGluZ3NbYmluZF0gPSBcIidcIiArIGRlY2xhcmF0aW9uc1tpXS5uYW1lICsgXCI6IFwiICsgY29udmVydGVyVXRpbHMuYWRkU2xhc2hlcyhyZXBsYWNlZFZhbHVlKSArIFwiO1wiICsgZGlzdCArIFwiJytcIiArIG5ld0JpbmRpbmdzW2JpbmRdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIGlmICh0eXBlb2YgZWxlbWVudCAhPSAndW5kZWZpbmVkJyAmJiBlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ10pXG4gICAgICBpZiAobmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5leHBlY3RlZCB2aXJ0dWFsU3R5bGUgYmluZGluZyBhZnRlciBjb252ZXJzaW9uIHRvIHZpcnR1YWxBdHRyLnN0eWxlXCIsIHByb3AsIG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXVtwcm9wXSwgc3R5bGUpO1xuICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgdmlydHVhbFN0eWxlIGJpbmRpbmcgYWZ0ZXIgY29udmVyc2lvbiB0byB2aXJ0dWFsQXR0ci5zdHlsZSBmb3IgXCIgKyBwcm9wO1xuICAgICAgfVxuICAgIGRlbGV0ZSBuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ107XG5cbiAgICB2YXIgY3VycmVudEJpbmRpbmdzID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnKTtcbiAgICB2YXIgZGF0YUJpbmQgPSAoY3VycmVudEJpbmRpbmdzICE9PSBudWxsID8gY3VycmVudEJpbmRpbmdzICsgXCIsIFwiIDogXCJcIikgKyBfYmluZGluZ1NlcmlhbGl6ZXIobmV3QmluZGluZ3MpO1xuICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJywgZGF0YUJpbmQpO1xuICB9XG5cbiAgLy8gVE9ETyBhIGZ1bmN0aW9uIHdob3NlIHJldHVybiB0eXBlIGRlcGVuZHMgb24gdGhlIGlucHV0IHBhcmFtZXRlcnMgaXMgdmVyeSB1Z2x5Li4gcGxlYXNlIEZJWCBNRS5cbiAgaWYgKHR5cGVvZiBzdHlsZSA9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNsZWFuIHZpcnR1YWxTdHlsZSBpZiBlbXB0eVxuICAgIHZhciBoYXNWaXJ0dWFsU3R5bGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwcm9wMSBpbiBuZXdCaW5kaW5nc1sndmlydHVhbFN0eWxlJ10pXG4gICAgICBpZiAobmV3QmluZGluZ3NbJ3ZpcnR1YWxTdHlsZSddLmhhc093blByb3BlcnR5KHByb3AxKSkge1xuICAgICAgICBoYXNWaXJ0dWFsU3R5bGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBpZiAoIWhhc1ZpcnR1YWxTdHlsZSkgZGVsZXRlIG5ld0JpbmRpbmdzWyd2aXJ0dWFsU3R5bGUnXTtcbiAgICBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBhbmQgYWRkIGJhY2sgdmlydHVhbEF0dHJTdHlsZSBzbyBpdCBnZXRzIGFwcGVuZGVkIEJFRk9SRSB2aXJ0dWFsQXR0clN0eWxlIChfYmluZGluZ1NlcmlhbGl6ZXIgcmV2ZXJzZSB0aGVtLi4uKVxuICAgICAgaWYgKHR5cGVvZiBuZXdCaW5kaW5nc1sndmlydHVhbEF0dHJTdHlsZSddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdnMgPSBuZXdCaW5kaW5nc1sndmlydHVhbEF0dHJTdHlsZSddO1xuICAgICAgICBkZWxldGUgbmV3QmluZGluZ3NbJ3ZpcnR1YWxBdHRyU3R5bGUnXTtcbiAgICAgICAgbmV3QmluZGluZ3NbJ3ZpcnR1YWxBdHRyU3R5bGUnXSA9IHZzO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm5zIG5ldyBzZXJpYWxpemVkIGJpbmRpbmdzXG4gICAgcmV0dXJuIF9iaW5kaW5nU2VyaWFsaXplcihuZXdCaW5kaW5ncyk7XG4gIH1cblxuICByZXR1cm4gbmV3U3R5bGU7XG59O1xuXG52YXIgX2JpbmRpbmdTZXJpYWxpemVyID0gZnVuY3Rpb24odmFsKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgcHJvcCBpbiB2YWwpXG4gICAgaWYgKHZhbC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWxbcHJvcF0gPT0gJ29iamVjdCcpIHJlcy5wdXNoKHByb3AgKyBcIjogXCIgKyBcInsgXCIgKyBfYmluZGluZ1NlcmlhbGl6ZXIodmFsW3Byb3BdKSArIFwiIH1cIik7XG4gICAgICBlbHNlIHJlcy5wdXNoKHByb3AgKyBcIjogXCIgKyB2YWxbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIHJlcy5yZXZlcnNlKCkuam9pbignLCAnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZWxhYm9yYXRlRGVjbGFyYXRpb25zOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGlzIGRlYWxzIHdpdGggQ2hlZXJpby9qUXVlcnkgaXNzdWVzLlxuLy8gTW9zdCBvZiB0aGlzIGNvdWxkIGJlIGRvbmUgd2l0aG91dCBqUXVlcnksIHRvbywgYnV0IGpRdWVyeSBpcyBlYXNpZXIgdG8gYmUgbW9ja2VkIHdpdGggQ2hlZXJpb1xuLy8gT3RoZXJ3aXNlIHdlIHdvdWxkIG5lZWQganNEb20gdG8gcnVuIHRoZSBjb21waWxlciBpbiB0aGUgc2VydmVyICh3aXRob3V0IGEgcmVhbCBicm93c2VyKVxuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG5cbmZ1bmN0aW9uIF9leHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIG9iakV4dGVuZCA9IGZ1bmN0aW9uKG9iaiwgZXh0ZW5kZXIpIHtcbiAgaWYgKHR5cGVvZiAkLmV4dGVuZCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICQuZXh0ZW5kKHRydWUsIG9iaiwgZXh0ZW5kZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBfZXh0ZW5kKG9iaiwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShleHRlbmRlcikpKTtcbiAgfVxufTtcblxudmFyIGdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICB2YXIgcmVzID0gJChlbGVtZW50KS5hdHRyKGF0dHJpYnV0ZSk7XG4gIGlmICh0eXBlb2YgcmVzID09ICd1bmRlZmluZWQnKSByZXMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xuICAvLyByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn07XG5cbnZhciBzZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICQoZWxlbWVudCkuYXR0cihhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgLy8gZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59O1xuXG52YXIgcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gICQoZWxlbWVudCkucmVtb3ZlQXR0cihhdHRyaWJ1dGUpO1xuICAvLyBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xufTtcblxudmFyIGdldElubmVyVGV4dCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuICQoZWxlbWVudCkudGV4dCgpO1xuICAvLyBpZiAodHlwZW9mIGVsZW1lbnQuaW5uZXJUZXh0ICE9ICd1bmRlZmluZWQnKSByZXR1cm4gZWxlbWVudC5pbm5lclRleHQ7XG4gIC8vIGVsc2UgcmV0dXJuIGVsZW1lbnQudGV4dENvbnRlbnQ7XG59O1xuXG52YXIgZ2V0SW5uZXJIdG1sID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gJChlbGVtZW50KS5odG1sKCk7XG4gIC8vIHJldHVybiBlbGVtZW50LmlubmVySFRNTDtcbn07XG5cbnZhciBnZXRMb3dlclRhZ05hbWUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIC8vIHNvbWV0aW1lcyBjaGVlcmlvIGRvZXNuJ3QgaGF2ZSB0YWdOYW1lIGJ1dCBcIm5hbWVcIi5cbiAgLy8gQnJvd3NlcnMgaGF2ZSBcIm5hbWVcIiB3aXRoIGVtcHR5IHN0cmluZ1xuICAvLyBTb21ldGltZXMgY2hlZXJpbyBoYXMgdGFnTmFtZSBidXQgbm8gcHJvcCBmdW5jdGlvbi5cbiAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJycgJiYgdHlwZW9mIGVsZW1lbnQubmFtZSA9PSAnc3RyaW5nJykgcmV0dXJuIGVsZW1lbnQubmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoZWxlbWVudC50YWdOYW1lICE9PSAnJykgcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gJChlbGVtZW50KS5wcm9wKFwidGFnTmFtZVwiKS50b0xvd2VyQ2FzZSgpO1xuICAvLyByZXR1cm4gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgc2V0Q29udGVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgJChlbGVtZW50KS5odG1sKGNvbnRlbnQpO1xuICAvLyBlbGVtZW50LmlubmVySFRNTCA9IGNvbnRlbnQ7XG59O1xuXG52YXIgcmVwbGFjZUh0bWwgPSBmdW5jdGlvbihlbGVtZW50LCBodG1sKSB7XG4gICQoZWxlbWVudCkucmVwbGFjZVdpdGgoaHRtbCk7XG4gIC8vIGVsZW1lbnQub3V0ZXJIVE1MID0gaHRtbDtcbn07XG5cbnZhciByZW1vdmVFbGVtZW50cyA9IGZ1bmN0aW9uKCRlbGVtZW50cywgdHJ5RGV0YWNoKSB7XG4gIGlmICh0cnlEZXRhY2ggJiYgdHlwZW9mICRlbGVtZW50cy5kZXRhY2ggIT09ICd1bmRlZmluZWQnKSAkZWxlbWVudHMuZGV0YWNoKCk7XG4gIC8vIE5PVEU6IHdlIGRvbid0IG5lZWQgYW4gZWxzZSwgYXMgZGV0YWNoIGlzIHNpbXBseSBhbiBvcHRpbWl6YXRpb25cbiAgJGVsZW1lbnRzLnJlbW92ZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuICBzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZSxcbiAgcmVtb3ZlQXR0cmlidXRlOiByZW1vdmVBdHRyaWJ1dGUsXG4gIGdldElubmVyVGV4dDogZ2V0SW5uZXJUZXh0LFxuICBnZXRJbm5lckh0bWw6IGdldElubmVySHRtbCxcbiAgZ2V0TG93ZXJUYWdOYW1lOiBnZXRMb3dlclRhZ05hbWUsXG4gIHNldENvbnRlbnQ6IHNldENvbnRlbnQsXG4gIHJlcGxhY2VIdG1sOiByZXBsYWNlSHRtbCxcbiAgcmVtb3ZlRWxlbWVudHM6IHJlbW92ZUVsZW1lbnRzLFxuICBvYmpFeHRlbmQ6IG9iakV4dGVuZFxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBlbGFib3JhdGVEZWNsYXJhdGlvbnMgPSByZXF1aXJlKFwiLi9kZWNsYXJhdGlvbnMuanNcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG52YXIgbW9kZWxEZWYgPSByZXF1aXJlKCcuL21vZGVsLmpzJyk7XG5cbnZhciBfZ2V0T3B0aW9uc09iamVjdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnNDb3VwbGVzID0gb3B0aW9ucy5zcGxpdCgnfCcpO1xuICB2YXIgb3B0cyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnNDb3VwbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG9wdCA9IG9wdGlvbnNDb3VwbGVzW2ldLnNwbGl0KCc9Jyk7XG4gICAgb3B0c1tvcHRbMF1dID0gb3B0Lmxlbmd0aCA+IDEgPyBvcHRbMV0gOiBvcHRbMF07XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59O1xuXG4vLyBUT0RPIHRoaXMgc2hvdWxkIG5vdCBoYXZlIGhhcmRjb2RlZCBydWxlcyAod2Ugbm93IGhhdmUgYSB3YXkgdG8gZGVjbGFyZSB0aGVtIGluIHRoZSB0ZW1wbGF0ZSBkZWZpbml0aW9uKVxuLy8gQ2F0ZWdvcnkgXCJzdHlsZVwiIGlzIHVzZWQgYnkgZWRpdFR5cGUgXCJzdHlsZXJcIlxuLy8gQ2F0ZW9ncnkgXCJjb250ZW50XCIgaXMgdXNlZCBieSBlZGl0VHlwZSBcImVkaXRcIlxuLy8gVE9ETyBtYXliZSB3ZSBzaG91bGQgdXNlIGEgY29tbW9uIHN0cmluZyBoZXJlLCBhbmQgcmVseSBvbmx5IG9uIHRoZSBvcmlnaW5hbCBjYXRlZ29yeS5cbnZhciBfZmlsdGVyUHJvcHMgPSBmdW5jdGlvbihtb2RlbCwgZWRpdFR5cGUsIGxldmVsKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgcHJvcCBpbiBtb2RlbClcbiAgICBpZiAoIXByb3AubWF0Y2goL15jdXN0b21TdHlsZSQvKSAmJiAhcHJvcC5tYXRjaCgvXl8vKSAmJiBtb2RlbC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIGlzU3R5bGVQcm9wID0gbW9kZWxbcHJvcF0gIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsW3Byb3BdLl9jYXRlZ29yeSAhPSAndW5kZWZpbmVkJyAmJiBtb2RlbFtwcm9wXS5fY2F0ZWdvcnkgPT0gJ3N0eWxlJztcbiAgICAgIGlmIChwcm9wID09ICdpZCcgfHwgcHJvcCA9PSAndHlwZScgfHwgcHJvcC5tYXRjaCgvQmxvY2tzJC8pKSB7fSBlbHNlIGlmIChlZGl0VHlwZSA9PSAnc3R5bGVyJykge1xuICAgICAgICBpZiAoaXNTdHlsZVByb3AgfHwgbGV2ZWwgPiAwKSByZXMucHVzaChwcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAoZWRpdFR5cGUgPT0gJ2VkaXQnKSB7XG4gICAgICAgIC8vIEVkaXRpbmcgZm9yIHByb3BlcnRpZXMgaW4gdGhlIFwiY29udGVudFwiIGNhdGVnb3J5IGJ1dCBub3QgZGVmaW5lZCBpbiB0aGUgY29udGV4dCBvZiBhIGJsb2NrXG4gICAgICAgIHZhciBpc0NvbnRlbnRQcm9wID0gbW9kZWxbcHJvcF0gIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsW3Byb3BdLl9jYXRlZ29yeSAhPSAndW5kZWZpbmVkJyAmJiBtb2RlbFtwcm9wXS5fY2F0ZWdvcnkgPT0gJ2NvbnRlbnQnICYmXG4gICAgICAgICAgKHR5cGVvZiBtb2RlbFtwcm9wXS5fY29udGV4dCA9PSAndW5kZWZpbmVkJyB8fCBtb2RlbFtwcm9wXS5fY29udGV4dCAhPSAnYmxvY2snKTtcbiAgICAgICAgaWYgKGlzQ29udGVudFByb3ApIHJlcy5wdXNoKHByb3ApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWRpdFR5cGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gcmVzO1xufTtcblxudmFyIF9wcm9wSW5wdXQgPSBmdW5jdGlvbihtb2RlbCwgcHJvcCwgcHJvcEFjY2Vzc29yLCBlZGl0VHlwZSwgd2lkZ2V0cykge1xuICB2YXIgaHRtbCA9IFwiXCI7XG4gIHZhciB3aWRnZXQ7XG4gIGlmIChtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX3dpZGdldCAhPSAndW5kZWZpbmVkJykgd2lkZ2V0ID0gbW9kZWwuX3dpZGdldDtcblxuICBpZiAodHlwZW9mIHdpZGdldCA9PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IFwiVW5rbm93biBkYXRhIHR5cGUgZm9yIFwiICsgcHJvcDtcbiAgfVxuXG4gIC8vIEZvciBjb250ZW50IGVkaXRvcnMgd2UgZGVhbCB3aXRoIGZvY3VzaW5nIChjbGlja2luZyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250YWluZXIgRElWKS5cbiAgdmFyIG9uZm9jdXNiaW5kaW5nID0gJ2ZvY3VzYWJsZTogdHJ1ZSc7XG4gIGlmIChlZGl0VHlwZSA9PSAnZWRpdCcpIHtcbiAgICBvbmZvY3VzYmluZGluZyArPSAnLCBldmVudDogeyBmb2N1czogZnVuY3Rpb24odWksIGV2ZW50KSB7ICQoJGVsZW1lbnQpLmNsaWNrKCk7IH0gfSAnO1xuICB9XG5cbiAgaHRtbCArPSAnPGxhYmVsIGNsYXNzPVwiZGF0YS0nICsgd2lkZ2V0ICsgJ1wiJyArICh3aWRnZXQgPT0gJ2Jvb2xlYW4nID8gJyBkYXRhLWJpbmQ9XCJldmVudDogeyBtb3VzZWRvd246IGZ1bmN0aW9uKHVpLCBldnQpIHsgaWYgKGV2dC5idXR0b24gPT0gMCkgeyB2YXIgaW5wdXQgPSAkKCRlbGVtZW50KS5maW5kKFxcJ2lucHV0XFwnKTsgdmFyIGNoID0gaW5wdXQucHJvcChcXCdjaGVja2VkXFwnKTsgc2V0VGltZW91dChmdW5jdGlvbigpIHsgaW5wdXQuY2xpY2soKTsgaW5wdXQucHJvcChcXCdjaGVja2VkXFwnLCAhY2gpOyBpbnB1dC50cmlnZ2VyKFxcJ2NoYW5nZVxcJyk7IH0sIDApOyB9IH0gfSwgY2xpY2s6IGZ1bmN0aW9uKHVpLCBldnQpIHsgZXZ0LnByZXZlbnREZWZhdWx0KCk7IH0sIGNsaWNrQnViYmxlOiBmYWxzZVwiJyA6ICcnKSArICc+JztcblxuICBpZiAodHlwZW9mIHdpZGdldHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aWRnZXRzW3dpZGdldF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHcgPSB3aWRnZXRzW3dpZGdldF07XG4gICAgdmFyIHBhcmFtZXRlcnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHcucGFyYW1ldGVycyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBmb3IgKHZhciBwIGluIHcucGFyYW1ldGVycylcbiAgICAgICAgaWYgKHcucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShwKSAmJiB0eXBlb2YgbW9kZWxbJ18nK3BdICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICBwYXJhbWV0ZXJzW3BdID0gbW9kZWxbJ18nK3BdO1xuICAgIGh0bWwgKz0gdy5odG1sKHByb3BBY2Nlc3Nvciwgb25mb2N1c2JpbmRpbmcsIHBhcmFtZXRlcnMpO1xuICB9IGVsc2UgaWYgKHdpZGdldCA9PSAnYm9vbGVhbicpIHtcbiAgICBodG1sICs9ICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJub3RoaW5nXCIgZGF0YS1iaW5kPVwiY2hlY2tlZDogJyArIHByb3BBY2Nlc3NvciArICcsICcgKyBvbmZvY3VzYmluZGluZyArICdcIiAvPic7XG4gICAgaHRtbCArPSAnPHNwYW4gY2xhc3M9XCJjaGVja2JveC1yZXBsYWNlclwiID48L3NwYW4+JzsgLyogZGF0YS1iaW5kPVwiY3NzOiB7IGNoZWNrZWQ6ICcrcHJvcEFjY2Vzc29yKycgfVwiICovXG4gIH0gZWxzZSBpZiAod2lkZ2V0ID09ICdjb2xvcicpIHtcbiAgICBodG1sICs9ICc8aW5wdXQgc2l6ZT1cIjdcIiB0eXBlPVwidGV4dFwiIGRhdGEtYmluZD1cImNvbG9ycGlja2VyOiB7IGNvbG9yOiAnICsgcHJvcEFjY2Vzc29yICsgJywgc3RyaW5nczogJHJvb3QudChcXCdUaGVtZSBDb2xvcnMsU3RhbmRhcmQgQ29sb3JzLFdlYiBDb2xvcnMsVGhlbWUgQ29sb3JzLEJhY2sgdG8gUGFsZXR0ZSxIaXN0b3J5LE5vIGhpc3RvcnkgeWV0LlxcJykgfSwgJyArICcsICcgKyBvbmZvY3VzYmluZGluZyArICdcIiAvPic7XG4gIH0gZWxzZSBpZiAod2lkZ2V0ID09ICdzZWxlY3QnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlbC5fb3B0aW9ucyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIG9wdHMgPSBfZ2V0T3B0aW9uc09iamVjdChtb2RlbC5fb3B0aW9ucyk7XG4gICAgICAvLyB2YXIgb3B0cyA9IG1vZGVsLl9vcHRpb25zO1xuICAgICAgaHRtbCArPSAnPHNlbGVjdCBkYXRhLWJpbmQ9XCJ2YWx1ZTogJyArIHByb3BBY2Nlc3NvciArICcsICcgKyBvbmZvY3VzYmluZGluZyArICdcIj4nO1xuICAgICAgZm9yICh2YXIgb3B0IGluIG9wdHMpXG4gICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIG9wdCArICdcIiBkYXRhLWJpbmQ9XCJ0ZXh0OiAkcm9vdC51dChcXCd0ZW1wbGF0ZVxcJywgXFwnJyArIHV0aWxzLmFkZFNsYXNoZXMob3B0c1tvcHRdKSArICdcXCcpXCI+JyArIG9wdHNbb3B0XSArICc8L29wdGlvbj4nO1xuICAgICAgICB9XG4gICAgICBodG1sICs9ICc8L3NlbGVjdD4nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh3aWRnZXQgPT0gJ2ZvbnQnKSB7XG4gICAgaHRtbCArPSAnPHNlbGVjdCB0eXBlPVwidGV4dFwiIGRhdGEtYmluZD1cInZhbHVlOiAnICsgcHJvcEFjY2Vzc29yICsgJywgJyArIG9uZm9jdXNiaW5kaW5nICsgJ1wiPic7XG4gICAgaHRtbCArPSAnPG9wdGdyb3VwIGxhYmVsPVwiU2Fucy1TZXJpZiBGb250c1wiPic7XG4gICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIkFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmXCI+QXJpYWw8L29wdGlvbj4nO1xuICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJcXCdDb21pYyBTYW5zIE1TXFwnLGN1cnNpdmUsc2Fucy1zZXJpZlwiPkNvbWljIFNhbnMgTVM8L29wdGlvbj4nO1xuICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJJbXBhY3QsQ2hhcmNvYWwsc2Fucy1zZXJpZlwiPkltcGFjdDwvb3B0aW9uPic7XG4gICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIlxcJ1RyZWJ1Y2hldCBNU1xcJyxIZWx2ZXRpY2Esc2Fucy1zZXJpZlwiPlRyZWJ1Y2hldCBNUzwvb3B0aW9uPic7XG4gICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIlZlcmRhbmEsR2VuZXZhLHNhbnMtc2VyaWZcIj5WZXJkYW5hPC9vcHRpb24+JztcbiAgICBodG1sICs9ICc8L29wdGdyb3VwPic7XG4gICAgaHRtbCArPSAnPG9wdGdyb3VwIGxhYmVsPVwiU2VyaWYgRm9udHNcIj4nO1xuICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJHZW9yZ2lhLHNlcmlmXCI+R2VvcmdpYTwvb3B0aW9uPic7XG4gICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIlxcJ1RpbWVzIE5ldyBSb21hblxcJyxUaW1lcyxzZXJpZlwiPlRpbWVzIE5ldyBSb21hbjwvb3B0aW9uPic7XG4gICAgaHRtbCArPSAnPC9vcHRncm91cD4nO1xuICAgIGh0bWwgKz0gJzxvcHRncm91cCBsYWJlbD1cIk1vbm9zcGFjZSBGb250c1wiPic7XG4gICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIlxcJ0NvdXJpZXIgTmV3XFwnLENvdXJpZXIsbW9ub3NwYWNlXCI+Q291cmllciBOZXc8L29wdGlvbj4nO1xuICAgIGh0bWwgKz0gJzwvb3B0Z3JvdXA+JztcbiAgICBodG1sICs9ICc8L3NlbGVjdD4nO1xuICB9IGVsc2UgaWYgKHdpZGdldCA9PSAndXJsJykge1xuICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJ1aS10ZXh0YnV0dG9uXCI+JztcbiAgICAvLyA8YSBjbGFzcz1cInVpLXNwaW5uZXItYnV0dG9uIHVpLXNwaW5uZXItZG93biB1aS1jb3JuZXItYnIgdWktYnV0dG9uIHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWJ1dHRvbi10ZXh0LW9ubHlcIiB0YWJpbmRleD1cIi0xXCIgcm9sZT1cImJ1dHRvblwiPjxzcGFuIGNsYXNzPVwidWktYnV0dG9uLXRleHRcIj48c3BhbiBjbGFzcz1cInVpLWljb24gZmEgZmEtZncgY2FyZXQtZG93blwiPuKWvDwvc3Bhbj48L3NwYW4+PC9hPlxuICAgIGh0bWwgKz0gJzxpbnB1dCBjbGFzcz1cInVpLXRleHRidXR0b24taW5wdXRcIiBzaXplPVwiN1wiIHR5cGU9XCJ1cmxcIiBwYXR0ZXJuPVwiKG1haWx0bzouK0AuK3xodHRwcz86Ly8uK1xcXFwuLit8XFxcXFsuKlxcXFxdLiopXCIgdmFsdWU9XCJub3RoaW5nXCIgZGF0YS1iaW5kPVwiY3NzOiB7IHdpdGhCdXR0b246IHR5cGVvZiAkcm9vdC5saW5rRGlhbG9nICE9PSBcXCd1bmRlZmluZWRcXCcgfSwgdmFsaWRhdGVkVmFsdWU6ICcgKyBwcm9wQWNjZXNzb3IgKyAnLCAnICsgb25mb2N1c2JpbmRpbmcgKyAnXCIgLz4nO1xuICAgIGh0bWwgKz0gJzxhIGNsYXNzPVwidWktdGV4dGJ1dHRvbi1idXR0b25cIiBkYXRhLWJpbmQ9XCJ2aXNpYmxlOiB0eXBlb2YgJHJvb3QubGlua0RpYWxvZyAhPT0gXFwndW5kZWZpbmVkXFwnLCBjbGljazogdHlwZW9mICRyb290LmxpbmtEaWFsb2cgIT09IFxcJ3VuZGVmaW5lZFxcJyA/ICRyb290LmxpbmtEaWFsb2cuYmluZCgkZWxlbWVudC5wcmV2aW91c1NpYmxpbmcpIDogZmFsc2UsIGJ1dHRvbjogeyBpY29uczogeyBwcmltYXJ5OiBcXCdmYSBmYS1mdyBmYS1lbGxpcHNpcy1oXFwnIH0sIGxhYmVsOiBcXCdPcHppb25pXFwnLCB0ZXh0OiBmYWxzZSB9XCI+T3B6aW9uaTwvYT4nO1xuICAgIGh0bWwgKz0gJzwvZGl2Pic7XG4gIH0gZWxzZSBpZiAod2lkZ2V0ID09ICdpbnRlZ2VyJykge1xuICAgIC8vIGF0IHRoaXMgdGltZSB0aGUgXCJzdGVwXCIgZGVwZW5kcyBvbiBtYXggYmVpbmcgZ3JlYXRlciB0aGFuIDEwMC5cbiAgICAvLyBtYXliZSB3ZSBzaG91bGQgZXhwb3NlIFwic3RlcFwiIGFzIGEgY29uZmlndXJhdGlvbiwgdG9vXG4gICAgdmFyIG1pbiA9IDA7XG4gICAgdmFyIG1heCA9IDEwMDA7XG4gICAgaWYgKG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fbWF4ICE9PSAndW5kZWZpbmVkJykgbWF4ID0gbW9kZWwuX21heDtcbiAgICBpZiAobW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl9taW4gIT09ICd1bmRlZmluZWQnKSBtaW4gPSBtb2RlbC5fbWluO1xuICAgIHZhciBzdGVwID0gKG1heCAtIG1pbikgPj0gMTAwID8gMTAgOiAxO1xuICAgIHZhciBwYWdlID0gc3RlcCAqIDU7XG4gICAgaHRtbCArPSAnPGlucHV0IGNsYXNzPVwibnVtYmVyLXNwaW5uZXJcIiBzaXplPVwiN1wiIHN0ZXA9XCInICsgc3RlcCArICdcIiB0eXBlPVwibnVtYmVyXCIgdmFsdWU9XCItMVwiIGRhdGEtYmluZD1cInNwaW5uZXI6IHsgbWluOiAnICsgbWluICsgJywgbWF4OiAnICsgbWF4ICsgJywgcGFnZTogJyArIHBhZ2UgKyAnLCB2YWx1ZTogJyArIHByb3BBY2Nlc3NvciArICcgfSwgdmFsdWVVcGRhdGU6IFtcXCdjaGFuZ2VcXCcsIFxcJ3NwaW5cXCddJyArICcsICcgKyBvbmZvY3VzYmluZGluZyArICdcIiAvPic7XG4gIH0gZWxzZSB7XG4gICAgaHRtbCArPSAnPGlucHV0IHNpemU9XCI3XCIgdHlwZT1cInRleHRcIiB2YWx1ZT1cIm5vdGhpbmdcIiBkYXRhLWJpbmQ9XCJ2YWx1ZTogJyArIHByb3BBY2Nlc3NvciArICcsICcgKyBvbmZvY3VzYmluZGluZyArICdcIiAvPic7XG4gIH1cblxuICBodG1sICs9ICc8L2xhYmVsPic7XG5cbiAgcmV0dXJuIGh0bWw7XG59O1xuXG52YXIgX2dldEdsb2JhbFN0eWxlUHJvcCA9IGZ1bmN0aW9uKGdsb2JhbFN0eWxlcywgbW9kZWwsIHByb3AsIHBhdGgpIHtcbiAgdmFyIGdsb2JhbFN0eWxlUHJvcDtcbiAgaWYgKHR5cGVvZiBtb2RlbCAhPT0gJ29iamVjdCcgfHwgbW9kZWwgPT09IG51bGwgfHwgdHlwZW9mIG1vZGVsLl93aWRnZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgcGF0aC5sZW5ndGggPiAwICYmIHR5cGVvZiBnbG9iYWxTdHlsZXMgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGdsb2JhbFN0eWxlc1twYXRoXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsU3R5bGVQcm9wID0gZ2xvYmFsU3R5bGVzW3BhdGhdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2xvYmFsU3R5bGVQcm9wO1xufTtcblxudmFyIF9wcm9wRWRpdG9yID0gZnVuY3Rpb24od2l0aEJpbmRpbmdQcm92aWRlciwgd2lkZ2V0cywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG1vZGVsLCB0aGVtZU1vZGVsLCBwYXRoLCBwcm9wLCBlZGl0VHlwZSwgbGV2ZWwsIGJhc2VUaHJlc2hvbGQsIGdsb2JhbFN0eWxlcywgZ2xvYmFsU3R5bGVQcm9wLCB0cmFja1VzYWdlLCByb290UHJldmlld0JpbmRpbmcsIHByZXZpZXdCYWNrZ3JvdW5kKSB7XG4gIGlmICh0eXBlb2YgbGV2ZWwgPT0gJ3VuZGVmaW5lZCcpIGxldmVsID0gMDtcblxuICBpZiAodHlwZW9mIHByb3AgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2RlbCA9PSAnb2JqZWN0JyAmJiBtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX3VzZWNvdW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUubG9nKFwiVE9ETyBFRElUT1IgaWdub3JpbmdcIiwgcGF0aCwgXCJwcm9wZXJ0eSBiZWNhdXNlIGl0IGlzIG5vdCB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZVwiLCBcInByb3A6XCIsIHByb3AsIFwidHlwZTpcIiwgZWRpdFR5cGUsIFwibGV2ZWw6XCIsIGxldmVsLCB3aXRoQmluZGluZ1Byb3ZpZGVyLl90ZW1wbGF0ZU5hbWUpO1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgdmFyIHByb3BBY2Nlc3NvciA9IHR5cGVvZiBnbG9iYWxTdHlsZVByb3AgIT0gJ3VuZGVmaW5lZCcgPyBwcm9wICsgJy5fZGVmYXVsdENvbXB1dGVkJyA6IHByb3A7XG5cbiAgdmFyIGh0bWwgPSBcIlwiO1xuICB2YXIgdGl0bGU7XG4gIHZhciBpZlN1YnNQcm9wID0gcHJvcEFjY2Vzc29yO1xuICB2YXIgaWZTdWJzR3V0dGVyID0gMTtcbiAgLy8gdHlwZW9mIGdsb2JhbFN0eWxlUHJvcCAhPSAndW5kZWZpbmVkJyA/IDEgOiAyO1xuICB2YXIgaWZTdWJzVGhyZXNob2xkID0gMTtcblxuICAvLyBUaGUgdmlzaWJpbGl0eSBoYW5kbGluZyBpcyBhIFBJVEFcbiAgLy8gXG4gIC8vIEhlcmUgYXJlIHNvbWUgXCJlZGdlIGNhc2VzXCIgdG8gdGVzdCB3aGVuZXZlciB3ZSBjaGFuZ2Ugc29tZXRoaW5nIGhlcmU6XG4gIC8vIExNIHNvY2lhbCBmb290ZXI6IHJlbW92aW5nIHNoYXJlVmlzaWJpbGUgbXVzdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGJvb2xlYW5zIHN1Yi1jaGVja3NcbiAgLy8gRkxVSUQgc29jaWFsIGJsb2NrOiBtdWx0aXBsZSBjbGlja3Mgb24gdGhlIFwid2FuZFwiIHNob3VsZCBub3QgbWFrZSB0aGUgZWRpdG9yIGludmlzaWJsZVxuICAvLyBCSVMgaGVyb01lbnUgLSBCeSBjaGFuZ2luZyB0aGUgbWVudSB2aXNpYmlsaXR5IGl0IHNob3VsZCBiZSByZWZsZWN0ZWQgaW4gc3R5bGUgZWRpdG9ycyBmb3IgdGhlIG1lbnUgbGlua3NcbiAgLy8gRkxVSUQgYWxtb3N0IGV2ZXJ5IGJsb2NrIHdpdGggYSBjb2xvciB2YXJpYW50IHNvbWV0aW1lcyBrZWVwcyBzaG93aW5nIHN0eWxlIGVkaXRvciBmb3IgdGhlIGhpZGRlbiB2YXJpYW50LlxuICBpZiAodHlwZW9mIG1vZGVsID09ICdvYmplY3QnICYmIG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fd2lkZ2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRG8gbm90aGluZyBoZXJlXG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxTdHlsZVByb3AgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmU3Vic0d1dHRlciArPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIE5PVEUgYmFzZVRocmVzaG9sZCBpcyBhZGRlZCBvbmx5IHdoZW4gZ2xvYmFsU3R5bGUgaXMgbm90IGRlZmluZWQgYmVjYXVzZSB3aGVuIHdlIGhhdmUgZ2xvYmFsU3R5bGVcbiAgLy8gd2UncmUgZ29pbmcgdG8gYmluZCB0aGUgY29tcHV0ZWQgdmFsdWVzIGFuZCBub3QgdGhlIG9yaWdpbmFsIGFuZCB0aGlzIHdheSB3ZSBkb24ndCBhZGQgb3Vyc2VyZiB0byB0aGUgZGVwZW5kZW5jeSBcbiAgLy8gdHJhY2tpbmcgKHN1YnNjcmlwdGlvbkNvdW50KVxuICAvLyBOT1RFIGJhc2VUaHJlc2hvbGQgaXMgYW4gXCJleHByZXNzaW9uXCIgYW5kIG5vdCBhIGZpeGVkIG51bWJlciwgc28gdGhpcyBpcyBhIGNvbmNhdGVuYXRpb25cbiAgaWYgKHR5cGVvZiBnbG9iYWxTdHlsZVByb3AgPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGJhc2VUaHJlc2hvbGQgIT09ICd1bmRlZmluZWQnKSBpZlN1YnNUaHJlc2hvbGQgKz0gYmFzZVRocmVzaG9sZDtcblxuICBpZiAodHlwZW9mIHByb3AgIT0gJ3VuZGVmaW5lZCcgJiYgISF0cmFja1VzYWdlKSB7XG4gICAgaHRtbCArPSAnPCEtLSBrbyBpZlN1YnM6IHsgZGF0YTogJyArIGlmU3Vic1Byb3AgKyAnLCB0aHJlc2hvbGQ6ICcgKyBpZlN1YnNUaHJlc2hvbGQgKyAnLCBndXR0ZXI6ICcgKyBpZlN1YnNHdXR0ZXIgKyAnIH0gLS0+JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcCAhPSAndW5kZWZpbmVkJyAmJiAobW9kZWwgPT09IG51bGwgfHwgdHlwZW9mIG1vZGVsLl9uYW1lID09ICd1bmRlZmluZWQnKSkge1xuICAgIC8vIFRPRE8gdGhyb3cgZXhjZXB0aW9uP1xuICAgIGNvbnNvbGUubG9nKFwiVE9ETyBXQVJOIE1pc3NpbmcgbGFiZWwgZm9yIHByb3BlcnR5IFwiLCBwcm9wKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3AgPT0gJ3VuZGVmaW5lZCcgJiYgbW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl9uYW1lID09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5sb2coXCJUT0RPIFdBUk4gTWlzc2luZyBsYWJlbCBmb3Igb2JqZWN0IFwiLCBtb2RlbC50eXBlIC8qLCBtb2RlbCAqLyApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtb2RlbCA9PSAnb2JqZWN0JyAmJiBtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX3dpZGdldCA9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBwcm9wcyA9IF9maWx0ZXJQcm9wcyhtb2RlbCwgZWRpdFR5cGUsIGxldmVsKTtcblxuICAgIHZhciBoYXNDdXN0b21TdHlsZSA9IGVkaXRUeXBlID09ICdzdHlsZXInICYmIG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5jdXN0b21TdHlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbFN0eWxlUHJvcCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIHNlbGVjdGVkSXRlbUJpbmRpbmcgPSAnJztcbiAgICB2YXIgYWRkaXRpb25hbENsYXNzZXMgPSAnJztcbiAgICBpZiAodHlwZW9mIHByb3AgIT09ICd1bmRlZmluZWQnICYmIGVkaXRUeXBlID09ICdlZGl0Jykge1xuICAgICAgc2VsZWN0ZWRJdGVtQmluZGluZyA9ICcsIGNsaWNrOiBmdW5jdGlvbihvYmosIGV2dCkgeyAkcm9vdC5zZWxlY3RJdGVtKCcgKyBwcm9wICsgJywgJGRhdGEpOyByZXR1cm4gZmFsc2UgfSwgY2xpY2tCdWJibGU6IGZhbHNlLCBjc3M6IHsgc2VsZWN0ZWRpdGVtOiAkcm9vdC5pc1NlbGVjdGVkSXRlbSgnICsgcHJvcCArICcpIH0sIHNjcm9sbEludG9WaWV3OiAkcm9vdC5pc1NlbGVjdGVkSXRlbSgnICsgcHJvcCArICcpLCAnO1xuICAgICAgYWRkaXRpb25hbENsYXNzZXMgKz0gJyBzZWxlY3RhYmxlJztcbiAgICB9XG4gICAgaWYgKGhhc0N1c3RvbVN0eWxlKSB7XG4gICAgICBhZGRpdGlvbmFsQ2xhc3NlcyArPSAnIHN1cHBvcnRzQ3VzdG9tU3R5bGVzJztcbiAgICB9XG4gICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm9iakVkaXQgbGV2ZWwnICsgbGV2ZWwgKyBhZGRpdGlvbmFsQ2xhc3NlcyArICdcIiBkYXRhLWJpbmQ9XCJ0b29sdGlwczoge30nICsgc2VsZWN0ZWRJdGVtQmluZGluZyArICdcIj4nO1xuICAgIHZhciBtb2RlbE5hbWUgPSAobW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl9uYW1lICE9ICd1bmRlZmluZWQnID8gbW9kZWwuX25hbWUgOiAodHlwZW9mIHByb3AgIT09ICd1bmRlZmluZWQnID8gJ1snICsgcHJvcCArICddJyA6ICcnKSk7XG4gICAgaWYgKGhhc0N1c3RvbVN0eWxlKSB7XG4gICAgICB2YXIgdGhlbWVTZWN0aW9uTmFtZSA9ICdTdGlsZSc7XG4gICAgICBpZiAodHlwZW9mIHRoZW1lTW9kZWwgIT09ICd1bmRlZmluZWQnICYmIHRoZW1lTW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIHRoZW1lTW9kZWwuX25hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoZW1lU2VjdGlvbk5hbWUgPSB0aGVtZU1vZGVsLl9uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIG1pc3NpbmcgbGFiZWwgZm9yIHRoZW1lIHNlY3Rpb24gXCIsIHByb3AsIG1vZGVsICE9PSBudWxsID8gbW9kZWwudHlwZSA6ICctJyk7XG4gICAgICB9XG5cbiAgICAgIG1vZGVsTmFtZSA9ICc8c3BhbiBjbGFzcz1cImJsb2NrU2VsZWN0aW9uTWV0aG9kXCIgZGF0YS1iaW5kPVwidGV4dDogY3VzdG9tU3R5bGUoKSA/ICRyb290LnV0KFxcJ3RlbXBsYXRlXFwnLCBcXCcnICsgdXRpbHMuYWRkU2xhc2hlcyhtb2RlbE5hbWUpICsgJ1xcJykgOiAkcm9vdC51dChcXCd0ZW1wbGF0ZVxcJywgXFwnJyArIHV0aWxzLmFkZFNsYXNoZXModGhlbWVTZWN0aW9uTmFtZSkgKyAnXFwnKVwiPkJsb2NrPC9zcGFuPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsTmFtZSA9ICc8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiAkcm9vdC51dChcXCd0ZW1wbGF0ZVxcJywgXFwnJyArIHV0aWxzLmFkZFNsYXNoZXMobW9kZWxOYW1lKSArICdcXCcpXCI+JyArIG1vZGVsTmFtZSArICc8L3NwYW4+JztcbiAgICB9XG4gICAgdGl0bGUgPSBtb2RlbCAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWwuX2hlbHAgIT09ICd1bmRlZmluZWQnID8gJyB0aXRsZT1cIicgKyB1dGlscy5hZGRTbGFzaGVzKG1vZGVsLl9oZWxwKSArICdcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC51dChcXCd0ZW1wbGF0ZVxcJywgXFwnJyArIHV0aWxzLmFkZFNsYXNoZXMobW9kZWwuX2hlbHApICsgJ1xcJykgfVwiJyA6ICcnO1xuICAgIGh0bWwgKz0gJzxzcGFuJyArIHRpdGxlICsgJyBjbGFzcz1cIm9iakxhYmVsIGxldmVsJyArIGxldmVsICsgJ1wiPicgKyBtb2RlbE5hbWUgKyAnPC9zcGFuPic7XG5cbiAgICBpZiAoZWRpdFR5cGUgPT0gJ2VkaXQnICYmIHR5cGVvZiBtb2RlbC5fYmxvY2tEZXNjcmlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJibG9ja0Rlc2NyaXB0aW9uXCIgZGF0YS1iaW5kPVwiaHRtbDogJHJvb3QudXQoXFwndGVtcGxhdGVcXCcsIFxcJycgKyB1dGlscy5hZGRTbGFzaGVzKG1vZGVsLl9ibG9ja0Rlc2NyaXB0aW9uKSArICdcXCcpXCI+JyArIG1vZGVsLl9ibG9ja0Rlc2NyaXB0aW9uICsgJzwvZGl2Pic7XG4gICAgfVxuXG4gICAgLyogQ1VTVE9NIFNUWUxFICovXG4gICAgaWYgKGhhc0N1c3RvbVN0eWxlKSB7XG4gICAgICBodG1sICs9ICc8bGFiZWwgY2xhc3M9XCJkYXRhLWJvb2xlYW4gYmxvY2tDaGVja1wiIGRhdGEtYmluZD1cInRvb2x0aXBzOiB7IH1cIj4nO1xuICAgICAgaHRtbCArPSAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwibm90aGluZ1wiIGRhdGEtYmluZD1cImZvY3VzYWJsZTogdHJ1ZSwgY2hlY2tlZDogY3VzdG9tU3R5bGVcIiAvPic7XG4gICAgICBodG1sICs9ICc8c3BhbiB0aXRsZT1cIlN3aXRjaCBiZXR3ZWVuIGdsb2JhbCBhbmQgYmxvY2sgbGV2ZWwgc3R5bGVzIGVkaXRpbmdcIiBkYXRhLWJpbmQ9XCJhdHRyOiB7IHRpdGxlOiAkcm9vdC50KFxcJ1N3aXRjaCBiZXR3ZWVuIGdsb2JhbCBhbmQgYmxvY2sgbGV2ZWwgc3R5bGVzIGVkaXRpbmdcXCcpIH1cIiBjbGFzcz1cImNoZWNrYm94LXJlcGxhY2VyIGNoZWNrYm94LXJlcGxhY2VyLW9ub2ZmXCI+PC9zcGFuPic7IC8vICBkYXRhLWJpbmQ9XCJ0b29sdGlwOiB7IGNvbnRlbnQ6IFxcJ3BlcnNvbmFsaXp6YSB0dXR0aVxcJyB9XCJcbiAgICAgIGh0bWwgKz0gJzwvbGFiZWw+JztcbiAgICAgIGh0bWwgKz0gJzwhLS0ga28gdGVtcGxhdGU6IHsgbmFtZTogXFwnY3VzdG9tc3R5bGVcXCcsIGlmOiBjdXN0b21TdHlsZSB9IC0tPjwhLS0gL2tvIC0tPic7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9wICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBodG1sICs9ICc8IS0tIGtvIHdpdGg6ICcgKyBwcm9wICsgJyAtLT4nO1xuXG4gICAgICAvKiBQUkVWSUVXICovXG4gICAgICBpZiAobGV2ZWwgPT0gMSAmJiB0eXBlb2YgcHJvcCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIG1vZGVsLl9wcmV2aWV3QmluZGluZ3MgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpdGhCaW5kaW5nUHJvdmlkZXIgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJvb3RQcmV2aWV3QmluZGluZyAhPSAndW5kZWZpbmVkJykgaHRtbCArPSAnPCEtLSBrbyB3aXRoOiAkcm9vdC5jb250ZW50KCkgLS0+PGRpdiBjbGFzcz1cIm9ialByZXZpZXdcIiBkYXRhLWJpbmQ9XCInICsgcm9vdFByZXZpZXdCaW5kaW5nICsgJ1wiPjwvZGl2PjwhLS0gL2tvIC0tPic7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmV2aWV3QmFja2dyb3VuZCAhPSAndW5kZWZpbmVkJykgaHRtbCArPSAnPCEtLSBrbyB3aXRoOiAkcGFyZW50IC0tPjxkaXYgY2xhc3M9XCJvYmpQcmV2aWV3XCIgZGF0YS1iaW5kPVwiJyArIHByZXZpZXdCYWNrZ3JvdW5kICsgJ1wiPjwvZGl2PjwhLS0gL2tvIC0tPic7XG4gICAgICAgICAgdmFyIHByZXZpZXdCaW5kaW5ncyA9IGVsYWJvcmF0ZURlY2xhcmF0aW9ucyh1bmRlZmluZWQsIG1vZGVsLl9wcmV2aWV3QmluZGluZ3MsIHRlbXBsYXRlVXJsQ29udmVydGVyLCB3aXRoQmluZGluZ1Byb3ZpZGVyLmJpbmQodGhpcywgcGF0aCArICcuJykpO1xuICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJvYmpQcmV2aWV3XCI+PGRpdiBjbGFzcz1cIm9ialByZXZpZXdJbm5lclwiIGRhdGEtYmluZD1cIicgKyBwcmV2aWV3QmluZGluZ3MgKyAnXCI+PC9kaXY+PC9kaXY+JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFBSRVZJRVcgKi9cbiAgICB2YXIgcHJldmlld0JHO1xuICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgaWYgKHR5cGVvZiBtb2RlbC5fcHJldmlld0JpbmRpbmdzICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByZXZpZXdCRyA9IGVsYWJvcmF0ZURlY2xhcmF0aW9ucyh1bmRlZmluZWQsIG1vZGVsLl9wcmV2aWV3QmluZGluZ3MsIHRlbXBsYXRlVXJsQ29udmVydGVyLCB3aXRoQmluZGluZ1Byb3ZpZGVyLmJpbmQodGhpcywgcGF0aC5sZW5ndGggPiAwID8gcGF0aCArICcuJyA6ICcnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGksIG5ld1BhdGg7XG5cbiAgICB2YXIgYmVmb3JlID0gaHRtbC5sZW5ndGg7XG5cbiAgICB2YXIgbmV3VGhlbWVNb2RlbDtcbiAgICB2YXIgbmV3R2xvYmFsU3R5bGVQcm9wO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdQYXRoID0gcGF0aC5sZW5ndGggPiAwID8gcGF0aCArIFwiLlwiICsgcHJvcHNbaV0gOiBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgbW9kZWxbcHJvcHNbaV1dICE9ICdvYmplY3QnIHx8IG1vZGVsW3Byb3BzW2ldXSA9PT0gbnVsbCB8fCB0eXBlb2YgbW9kZWxbcHJvcHNbaV1dLl93aWRnZXQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbmV3R2xvYmFsU3R5bGVQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobGV2ZWwgPT09IDAgJiYgcHJvcHNbaV0gPT0gJ3RoZW1lJylcbiAgICAgICAgICBodG1sICs9IF9wcm9wRWRpdG9yKHdpdGhCaW5kaW5nUHJvdmlkZXIsIHdpZGdldHMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBtb2RlbFtwcm9wc1tpXV0sIG5ld1RoZW1lTW9kZWwsIG5ld1BhdGgsIHByb3BzW2ldLCBlZGl0VHlwZSwgMCwgYmFzZVRocmVzaG9sZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRyYWNrVXNhZ2UsIHJvb3RQcmV2aWV3QmluZGluZyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5ld0dsb2JhbFN0eWxlUHJvcCA9IF9nZXRHbG9iYWxTdHlsZVByb3AoZ2xvYmFsU3R5bGVzLCBtb2RlbFtwcm9wc1tpXV0sIHByb3BzW2ldLCBuZXdQYXRoKTtcbiAgICAgICAgICBodG1sICs9IF9wcm9wRWRpdG9yKHdpdGhCaW5kaW5nUHJvdmlkZXIsIHdpZGdldHMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBtb2RlbFtwcm9wc1tpXV0sIG5ld1RoZW1lTW9kZWwsIG5ld1BhdGgsIHByb3BzW2ldLCBlZGl0VHlwZSwgbGV2ZWwgKyAxLCBiYXNlVGhyZXNob2xkLCBnbG9iYWxTdHlsZXMsIG5ld0dsb2JhbFN0eWxlUHJvcCwgdHJhY2tVc2FnZSwgcm9vdFByZXZpZXdCaW5kaW5nLCBwcmV2aWV3QkcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3UGF0aCA9IHBhdGgubGVuZ3RoID4gMCA/IHBhdGggKyBcIi5cIiArIHByb3BzW2ldIDogcHJvcHNbaV07XG4gICAgICBpZiAoISh0eXBlb2YgbW9kZWxbcHJvcHNbaV1dICE9ICdvYmplY3QnIHx8IG1vZGVsW3Byb3BzW2ldXSA9PT0gbnVsbCB8fCB0eXBlb2YgbW9kZWxbcHJvcHNbaV1dLl93aWRnZXQgIT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIG5ld0dsb2JhbFN0eWxlUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGxldmVsID09PSAwICYmIHByb3BzW2ldID09ICd0aGVtZScpXG4gICAgICAgICAgaHRtbCArPSBfcHJvcEVkaXRvcih3aXRoQmluZGluZ1Byb3ZpZGVyLCB3aWRnZXRzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbW9kZWxbcHJvcHNbaV1dLCBuZXdUaGVtZU1vZGVsLCBuZXdQYXRoLCBwcm9wc1tpXSwgZWRpdFR5cGUsIDAsIGJhc2VUaHJlc2hvbGQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cmFja1VzYWdlLCByb290UHJldmlld0JpbmRpbmcpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdHbG9iYWxTdHlsZVByb3AgPSBfZ2V0R2xvYmFsU3R5bGVQcm9wKGdsb2JhbFN0eWxlcywgbW9kZWxbcHJvcHNbaV1dLCBwcm9wc1tpXSwgbmV3UGF0aCk7XG4gICAgICAgICAgaHRtbCArPSBfcHJvcEVkaXRvcih3aXRoQmluZGluZ1Byb3ZpZGVyLCB3aWRnZXRzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbW9kZWxbcHJvcHNbaV1dLCBuZXdUaGVtZU1vZGVsLCBuZXdQYXRoLCBwcm9wc1tpXSwgZWRpdFR5cGUsIGxldmVsICsgMSwgYmFzZVRocmVzaG9sZCwgZ2xvYmFsU3R5bGVzLCBuZXdHbG9iYWxTdHlsZVByb3AsIHRyYWNrVXNhZ2UsIHJvb3RQcmV2aWV3QmluZGluZywgcHJldmlld0JHKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGRlZCA9IGh0bWwubGVuZ3RoIC0gYmVmb3JlO1xuICAgIGlmIChhZGRlZCA9PT0gMCkge1xuICAgICAgLy8gTm8gZWRpdGFibGUgY29udGVudDogaWYgdGhpcyBpcyBpbiBjb250ZXh0IFwidGVtcGxhdGVcIiB3ZSBsZWF2ZSBpdCBlbXB0eSwgb3RoZXJ3aXNlIHdlIHNob3cgYW4gaGVscC5cbiAgICAgIGlmICh0eXBlb2YgbW9kZWwgPT0gJ29iamVjdCcgJiYgbW9kZWwgIT09IG51bGwgJiYgbW9kZWwuX2NvbnRleHQgPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIG1vdmUgbWUgdG8gYSB0bXBsP1xuICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwib2JqRW1wdHlcIiBkYXRhLWJpbmQ9XCJodG1sOiAkcm9vdC50KFxcJ1NlbGVjdGVkIGVsZW1lbnQgaGFzIG5vIGVkaXRhYmxlIHByb3BlcnRpZXNcXCcpXCI+U2VsZWN0ZWQgZWxlbWVudCBoYXMgbm8gZWRpdGFibGUgcHJvcGVydGllczwvZGl2Pic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9wICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBodG1sICs9ICc8IS0tIC9rbyAtLT4nO1xuICAgIH1cbiAgICBodG1sICs9ICc8L2Rpdj4nO1xuXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNoZWNrYm94ZXMgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxTdHlsZXMgPT0gJ3VuZGVmaW5lZCcpIGNoZWNrYm94ZXMgPSBmYWxzZTtcblxuICAgIGlmIChtb2RlbCA9PT0gbnVsbCB8fCB0eXBlb2YgbW9kZWwgIT0gJ29iamVjdCcgfHwgdHlwZW9mIG1vZGVsLl93aWRnZXQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBiaW5kaW5ncyA9IFtdO1xuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFN0eWxlUHJvcCAhPSAndW5kZWZpbmVkJykgYmluZGluZ3MucHVzaCgnY3NzOiB7IG5vdG51bGw6ICcgKyBwcm9wICsgJygpICE9PSBudWxsIH0nKTtcbiAgICAgIHRpdGxlID0gbW9kZWwgIT09IG51bGwgJiYgdHlwZW9mIG1vZGVsLl9oZWxwICE9PSAndW5kZWZpbmVkJyA/ICcgdGl0bGU9XCInICsgdXRpbHMuYWRkU2xhc2hlcyhtb2RlbC5faGVscCkgKyAnXCIgZGF0YS1iaW5kPVwiYXR0cjogeyB0aXRsZTogJHJvb3QudXQoXFwndGVtcGxhdGVcXCcsIFxcJycgKyB1dGlscy5hZGRTbGFzaGVzKG1vZGVsLl9oZWxwKSArICdcXCcpIH1cIicgOiAnJztcbiAgICAgIGlmICh0aXRsZS5sZW5ndGggPiAwKSBiaW5kaW5ncy5wdXNoKCd0b29sdGlwczoge30nKTtcbiAgICAgIHZhciBiaW5kID0gYmluZGluZ3MubGVuZ3RoID4gMCA/ICdkYXRhLWJpbmQ9XCInICsgdXRpbHMuYWRkU2xhc2hlcyhiaW5kaW5ncy5qb2luKCkpICsgJ1wiJyA6ICcnO1xuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInByb3BFZGl0b3IgJyArIChjaGVja2JveGVzID8gJ2NoZWNrYm94ZXMnIDogJycpICsgJ1wiJyArIGJpbmQgKyAnPic7XG5cbiAgICAgIHZhciBtb2RlbE5hbWUyID0gKG1vZGVsICE9PSBudWxsICYmIHR5cGVvZiBtb2RlbC5fbmFtZSAhPSAndW5kZWZpbmVkJyA/IG1vZGVsLl9uYW1lIDogKHR5cGVvZiBwcm9wICE9PSAndW5kZWZpbmVkJyA/ICdbJyArIHByb3AgKyAnXScgOiAnJykpO1xuICAgICAgbW9kZWxOYW1lMiA9ICc8c3BhbiBkYXRhLWJpbmQ9XCJ0ZXh0OiAkcm9vdC51dChcXCd0ZW1wbGF0ZVxcJywgXFwnJyArIHV0aWxzLmFkZFNsYXNoZXMobW9kZWxOYW1lMikgKyAnXFwnKVwiPicgKyBtb2RlbE5hbWUyICsgJzwvc3Bhbj4nO1xuICAgICAgaHRtbCArPSAnPHNwYW4nICsgdGl0bGUgKyAnIGNsYXNzPVwicHJvcExhYmVsXCI+JyArIG1vZGVsTmFtZTIgKyAnPC9zcGFuPic7XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicHJvcElucHV0ICcgKyAodHlwZW9mIGdsb2JhbFN0eWxlcyAhPSAndW5kZWZpbmVkJyA/ICdsb2NhbCcgOiAnJykgKyAnXCIgZGF0YS1iaW5kPVwiY3NzOiB7IGRlZmF1bHQ6ICcgKyBwcm9wICsgJygpID09PSBudWxsIH1cIj4nO1xuICAgICAgaHRtbCArPSBfcHJvcElucHV0KG1vZGVsLCBwcm9wLCBwcm9wQWNjZXNzb3IsIGVkaXRUeXBlLCB3aWRnZXRzKTtcbiAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFN0eWxlUHJvcCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicHJvcElucHV0IGdsb2JhbFwiIGRhdGEtYmluZD1cImNzczogeyBvdmVycmlkZGVuOiAnICsgcHJvcCArICcoKSAhPT0gbnVsbCB9XCI+JztcbiAgICAgICAgaHRtbCArPSBfcHJvcElucHV0KG1vZGVsLCBwcm9wLCBnbG9iYWxTdHlsZVByb3AsIGVkaXRUeXBlLCB3aWRnZXRzKTtcbiAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcblxuICAgICAgICBpZiAoY2hlY2tib3hlcykge1xuICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJwcm9wQ2hlY2tcIj48bGFiZWwgZGF0YS1iaW5kPVwidG9vbHRpcHM6IHt9XCI+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGRhdGEtYmluZD1cImZvY3VzYWJsZTogdHJ1ZSwgY2xpY2s6IGZ1bmN0aW9uKGV2dCwgb2JqKSB7ICRyb290LmxvY2FsR2xvYmFsU3dpdGNoKCcgKyBwcm9wICsgJywgJyArIGdsb2JhbFN0eWxlUHJvcCArICcpOyByZXR1cm4gdHJ1ZTsgfSwgY2hlY2tlZDogJyArIHByb3AgKyAnKCkgIT09IG51bGxcIj4nO1xuICAgICAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwiY2hlY2tib3gtcmVwbGFjZXJcIiBkYXRhLWJpbmQ9XCJjc3M6IHsgY2hlY2tlZDogJyArIHByb3AgKyAnKCkgIT09IG51bGwgfSwgYXR0cjogeyB0aXRsZTogJHJvb3QudChcXCdUaGlzIHN0eWxlIGlzIHNwZWNpZmljIGZvciB0aGlzIGJsb2NrOiBjbGljayBoZXJlIHRvIHJlbW92ZSB0aGUgY3VzdG9tIHN0eWxlIGFuZCByZXZlcnQgdG8gdGhlIHRoZW1lIHZhbHVlXFwnKSB9XCI+PC9zcGFuPic7XG4gICAgICAgICAgaHRtbCArPSAnPC9sYWJlbD48L2Rpdj4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgIH0gZWxzZSBpZiAobW9kZWwgPT09IG51bGwgfHwgdHlwZW9mIG1vZGVsICE9ICdvYmplY3QnKSB7XG4gICAgICAvLyBUT0RPIHJlbW92ZSBkZWJ1ZyBvdXRwdXRcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJwcm9wRWRpdG9yIHVua25vd25cIj5bQXwnICsgcHJvcCArIFwifFwiICsgdHlwZW9mIG1vZGVsICsgJ108L2Rpdj4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPIHJlbW92ZSBkZWJ1ZyBvdXRwdXRcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJwcm9wRWRpdG9yIHVua25vd25cIj5bQnwnICsgcHJvcCArIFwifFwiICsgdHlwZW9mIG1vZGVsICsgJ108L2Rpdj4nO1xuICAgIH1cblxuXG4gIH1cblxuICBpZiAodHlwZW9mIHByb3AgIT0gJ3VuZGVmaW5lZCcgJiYgISF0cmFja1VzYWdlKSB7XG4gICAgaHRtbCArPSAnPCEtLSAva28gLS0+JztcbiAgICBodG1sICs9ICc8IS0tIGtvIGlmU3ViczogeyBub3Q6IHRydWUsIGRhdGE6ICcgKyBpZlN1YnNQcm9wICsgJywgdGhyZXNob2xkOiAnICsgaWZTdWJzVGhyZXNob2xkICsgJywgZ3V0dGVyOiAwIH0gLS0+JztcbiAgICBodG1sICs9ICc8c3BhbiBjbGFzcz1cImxhYmVsIG5vdHVzZWRcIj4oJyArIHByb3AgKyAnKTwvc3Bhbj4nO1xuICAgIGh0bWwgKz0gJzwhLS0gL2tvIC0tPic7XG4gIH1cblxuICByZXR1cm4gaHRtbDtcbn07XG5cblxudmFyIGNyZWF0ZUJsb2NrRWRpdG9yID0gZnVuY3Rpb24oZGVmcywgd2lkZ2V0cywgdGhlbWVVcGRhdGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCBlZGl0VHlwZSwgdGVtcGxhdGVDcmVhdG9yLCBiYXNlVGhyZXNob2xkLCB0cmFja0dsb2JhbFN0eWxlcywgdHJhY2tVc2FnZSwgZnJvbUxldmVsKSB7XG4gIGlmICh0eXBlb2YgdHJhY2tVc2FnZSA9PSAndW5kZWZpbmVkJykgdHJhY2tVc2FnZSA9IHRydWU7XG4gIHZhciBtb2RlbCA9IG1vZGVsRGVmLmdldERlZihkZWZzLCB0ZW1wbGF0ZU5hbWUpO1xuXG4gIHZhciByb290TW9kZWwgPSBtb2RlbERlZi5nZXREZWYoZGVmcywgcm9vdE1vZGVsTmFtZSk7XG4gIHZhciByb290UHJldmlld0JpbmRpbmdzO1xuICBpZiAodHlwZW9mIHJvb3RNb2RlbC5fcHJldmlld0JpbmRpbmdzICE9ICd1bmRlZmluZWQnICYmIHRlbXBsYXRlTmFtZSAhPSAndGhhZW1lJyAmJiBlZGl0VHlwZSA9PSAnc3R5bGVyJykge1xuICAgIHJvb3RQcmV2aWV3QmluZGluZ3MgPSBlbGFib3JhdGVEZWNsYXJhdGlvbnModW5kZWZpbmVkLCByb290TW9kZWwuX3ByZXZpZXdCaW5kaW5ncywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG1vZGVsRGVmLmdldEJpbmRWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgZGVmcywgdGhlbWVVcGRhdGVyLCByb290TW9kZWxOYW1lLCByb290TW9kZWxOYW1lLCAnJykpO1xuICB9XG5cbiAgdmFyIGdsb2JhbFN0eWxlcyA9IHR5cGVvZiB0cmFja0dsb2JhbFN0eWxlcyAhPSAndW5kZWZpbmVkJyAmJiB0cmFja0dsb2JhbFN0eWxlcyA/IGRlZnNbdGVtcGxhdGVOYW1lXS5fZ2xvYmFsU3R5bGVzIDogdW5kZWZpbmVkO1xuICB2YXIgZ2xvYmFsU3R5bGVQcm9wID0gdHlwZW9mIHRyYWNrR2xvYmFsU3R5bGVzICE9ICd1bmRlZmluZWQnICYmIHRyYWNrR2xvYmFsU3R5bGVzID8gZGVmc1t0ZW1wbGF0ZU5hbWVdLl9nbG9iYWxTdHlsZSA6IHVuZGVmaW5lZDtcblxuXG4gIHZhciB0aGVtZU1vZGVsO1xuICBpZiAodHlwZW9mIGdsb2JhbFN0eWxlUHJvcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbW0gPSBtb2RlbERlZi5nZXREZWYoZGVmcywgJ3RoZW1lJyk7XG4gICAgLy8gVE9ETyByZW1vdmUgZGVwcmVjYXRlZCAkdGhlbWVcbiAgICB0aGVtZU1vZGVsID0gbW1bZ2xvYmFsU3R5bGVQcm9wLnJlcGxhY2UoL14oXFwkdGhlbWV8X3RoZW1lXylcXC4vLCAnJyldO1xuICB9XG5cblxuICB2YXIgd2l0aEJpbmRpbmdQcm92aWRlciA9IG1vZGVsRGVmLmdldEJpbmRWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgZGVmcywgdGhlbWVVcGRhdGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUpO1xuICB3aXRoQmluZGluZ1Byb3ZpZGVyLl90ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZU5hbWU7XG5cbiAgdmFyIGh0bWwgPSAnPGRpdiBjbGFzcz1cImVkaXRvclwiPic7XG4gIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPVxcXCJibG9ja1R5cGVcIiArICh0eXBlb2YgZ2xvYmFsU3R5bGVzICE9ICd1bmRlZmluZWQnID8gXCIgd2l0aGRlZmF1bHRzXCIgOiBcIlwiKSArIFwiXFxcIj5cIiArIG1vZGVsLnR5cGUgKyBcIjwvZGl2PlwiO1xuXG4gIHZhciBlZGl0b3JDb250ZW50ID0gX3Byb3BFZGl0b3Iod2l0aEJpbmRpbmdQcm92aWRlciwgd2lkZ2V0cywgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIG1vZGVsLCB0aGVtZU1vZGVsLCBcIlwiLCB1bmRlZmluZWQsIGVkaXRUeXBlLCBmcm9tTGV2ZWwsIGJhc2VUaHJlc2hvbGQsIGdsb2JhbFN0eWxlcywgZ2xvYmFsU3R5bGVQcm9wLCB0cmFja1VzYWdlLCByb290UHJldmlld0JpbmRpbmdzKTtcbiAgaWYgKGVkaXRvckNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgIGh0bWwgKz0gZWRpdG9yQ29udGVudDtcbiAgfVxuXG4gIGh0bWwgKz0gJzwvZGl2Pic7XG5cbiAgdGVtcGxhdGVDcmVhdG9yKGh0bWwsIHRlbXBsYXRlTmFtZSwgZWRpdFR5cGUpO1xufTtcblxudmFyIGNyZWF0ZUJsb2NrRWRpdG9ycyA9IGZ1bmN0aW9uKGRlZnMsIHdpZGdldHMsIHRoZW1lVXBkYXRlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgdGVtcGxhdGVDcmVhdG9yLCBiYXNlVGhyZXNob2xkKSB7XG4gIGNyZWF0ZUJsb2NrRWRpdG9yKGRlZnMsIHdpZGdldHMsIHRoZW1lVXBkYXRlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgJ2VkaXQnLCB0ZW1wbGF0ZUNyZWF0b3IsIGJhc2VUaHJlc2hvbGQpO1xuICBjcmVhdGVCbG9ja0VkaXRvcihkZWZzLCB3aWRnZXRzLCB0aGVtZVVwZGF0ZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUsICdzdHlsZXInLCB0ZW1wbGF0ZUNyZWF0b3IsIGJhc2VUaHJlc2hvbGQsIHRydWUpO1xufTtcblxudmFyIGdlbmVyYXRlRWRpdG9ycyA9IGZ1bmN0aW9uKHRlbXBsYXRlRGVmLCB3aWRnZXRzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgdGVtcGxhdGVDcmVhdG9yLCBiYXNlVGhyZXNob2xkKSB7XG4gIHZhciBkZWZzID0gdGVtcGxhdGVEZWYuX2RlZnM7XG4gIHZhciB0ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZURlZi50ZW1wbGF0ZU5hbWU7XG4gIHZhciBibG9ja3MgPSB0ZW1wbGF0ZURlZi5fYmxvY2tzO1xuICB2YXIgaWR4O1xuICB2YXIgYmxvY2tEZWZzID0gW107XG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgYmxvY2tzLmxlbmd0aDsgaWR4KyspIHtcbiAgICBpZiAodHlwZW9mIGJsb2Nrc1tpZHhdLmNvbnRhaW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGJsb2NrRGVmcy5wdXNoKG1vZGVsRGVmLmdlbmVyYXRlTW9kZWwoZGVmcywgYmxvY2tzW2lkeF0uYmxvY2spKTtcbiAgICB9XG4gICAgY3JlYXRlQmxvY2tFZGl0b3JzKGRlZnMsIHdpZGdldHMsIHVuZGVmaW5lZCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGJsb2Nrc1tpZHhdLnJvb3QsIGJsb2Nrc1tpZHhdLmJsb2NrLCB0ZW1wbGF0ZUNyZWF0b3IsIGJhc2VUaHJlc2hvbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZzWyd0aGVtZSddICE9ICd1bmRlZmluZWQnKSBjcmVhdGVCbG9ja0VkaXRvcihkZWZzLCB3aWRnZXRzLCB1bmRlZmluZWQsIHRlbXBsYXRlVXJsQ29udmVydGVyLCB0ZW1wbGF0ZU5hbWUsICd0aGVtZScsICdzdHlsZXInLCB0ZW1wbGF0ZUNyZWF0b3IsIHVuZGVmaW5lZCwgZmFsc2UsIGZhbHNlLCAtMSk7XG4gIHJldHVybiBibG9ja0RlZnM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlRWRpdG9ycztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UgKi9cblxudmFyIG1vZGVsRGVmID0gcmVxdWlyZShcIi4vbW9kZWwuanNcIik7XG5cbnZhciB3cmFwcGVkUmVzdWx0TW9kZWwgPSBmdW5jdGlvbih0ZW1wbGF0ZURlZikge1xuICB2YXIgZGVmcyA9IHRlbXBsYXRlRGVmLl9kZWZzO1xuICB2YXIgdGVtcGxhdGVOYW1lID0gdGVtcGxhdGVEZWYudGVtcGxhdGVOYW1lO1xuICB2YXIgZmluYWxNb2RlbENvbnRlbnREZWYgPSBtb2RlbERlZi5nZXREZWYoZGVmcywgdGVtcGxhdGVOYW1lKTtcblxuICB2YXIgZmluYWxNb2RlbENvbnRlbnQgPSBtb2RlbERlZi5nZW5lcmF0ZVJlc3VsdE1vZGVsKHRlbXBsYXRlRGVmKTtcblxuICB2YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuL3dyYXBwZXIuanNcIik7XG4gIHZhciByZXMgPSB3cmFwcGVyKGZpbmFsTW9kZWxDb250ZW50LCBmaW5hbE1vZGVsQ29udGVudERlZiwgZGVmcyk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIHJlcXVpcmVzIG9ubHkgd2hlbiBpbXBvcnRlZFxudmFyIHRyYW5zbGF0ZVRlbXBsYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0dCA9IHJlcXVpcmUoJy4vcGFyc2VyLmpzJyk7XG4gIHJldHVybiB0dC5hcHBseSh0dCwgYXJndW1lbnRzKTtcbn07XG5cbi8vIHJlcXVpcmVzIG9ubHkgd2hlbiBpbXBvcnRlZFxudmFyIGdlbmVyYXRlRWRpdG9ycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZ2UgPSByZXF1aXJlKCcuL2VkaXRvci5qcycpO1xuICByZXR1cm4gZ2UuYXBwbHkoZ2UsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgY2hlY2tNb2RlbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY20gPSByZXF1aXJlKCcuL2NoZWNrbW9kZWwuanMnKTtcbiAgcmV0dXJuIGNtLmFwcGx5KGNtLCBhcmd1bWVudHMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRyYW5zbGF0ZVRlbXBsYXRlOiB0cmFuc2xhdGVUZW1wbGF0ZSxcbiAgd3JhcHBlZFJlc3VsdE1vZGVsOiB3cmFwcGVkUmVzdWx0TW9kZWwsXG4gIGdlbmVyYXRlUmVzdWx0TW9kZWw6IG1vZGVsRGVmLmdlbmVyYXRlUmVzdWx0TW9kZWwsXG4gIGdlbmVyYXRlRWRpdG9yczogZ2VuZXJhdGVFZGl0b3JzLFxuICBjaGVja01vZGVsOiBjaGVja01vZGVsXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgb2JqRXh0ZW5kID0gcmVxdWlyZShcIi4vZG9tdXRpbHMuanNcIikub2JqRXh0ZW5kO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcblxudmFyIF92YWx1ZVNldCA9IGZ1bmN0aW9uKGRlZnMsIG1vZGVsLCBwcm9wLCB2YWx1ZSkge1xuICB2YXIgZG90UG9zID0gcHJvcC5pbmRleE9mKCcuJyk7XG4gIGlmIChkb3RQb3MgPT0gLTEpIHtcbiAgICBpZiAodHlwZW9mIG1vZGVsW3Byb3BdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVuZGVmaW5lZCBwcm9wIFwiICsgcHJvcCArIFwiIHdoaWxlIHNldHRpbmcgdmFsdWUgXCIgKyB2YWx1ZSArIFwiIGluIG1vZGVsLl92YWx1ZVNldFwiKTtcbiAgICB9IGVsc2UgaWYgKG1vZGVsW3Byb3BdID09PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5wdXNoID09ICd1bmRlZmluZWQnKSBjb25zb2xlLmxvZyhcIm51bGxwcm9wb2JqZWN0dmFsdWVcIiwgcHJvcCwgdmFsdWUpO1xuICAgICAgbW9kZWxbcHJvcF0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlbFtwcm9wXSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kZWxbcHJvcF0ucHVzaCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdmFsdWVzO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IHZhbHVlLm1hdGNoKC9eXFxbKC4qKVxcXSQvKTtcbiAgICAgICAgaWYgKHZhbHVlc1N0cmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlcyA9IHZhbHVlc1N0cmluZ1sxXS5zcGxpdCgnLCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBkZWZhdWx0IHZhbHVlIGZvciBhcnJheSBwcm9wZXJ0eSBcIiArIHByb3AgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5wdXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBkZWZhdWx0IHZhbHVlIGZvciBhcnJheSBwcm9wZXJ0eSBcIiArIHByb3AgKyBcIjogXCIgKyB2YWx1ZSArIFwiIHR5cGVvZiBcIiArICh0eXBlb2YgdmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlc1tpXS5zdWJzdHIoMCwgMSkgPT0gJ0AnKSB7XG4gICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCAoQCksIHNvIHdlIGNhbiByZW1vdmUgXCJkZWZzXCIgZnJvbSB0aGlzIGZ1bmN0aW9uLCB0b28uXG4gICAgICAgICAgcmVzLnB1c2goX2dlbmVyYXRlTW9kZWwoZGVmcywgdmFsdWVzW2ldLnN1YnN0cigxKSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlc1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzLnB1c2godmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbW9kZWxbcHJvcF0gPSByZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZWxbcHJvcF0gPT0gJ3N0cmluZycgfHwgdHlwZW9mIG1vZGVsW3Byb3BdID09ICdib29sZWFuJykge1xuICAgICAgLy8gVE9ETyBkb2VzIHRoaXMgc3RpbGwgaGFwcGVuPyBEZWJ1Zy90ZXN0IG1lLlxuICAgICAgbW9kZWxbcHJvcF0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlbFtwcm9wXSA9PSAnb2JqZWN0JyAmJiBtb2RlbFtwcm9wXSAhPT0gbnVsbCAmJiB0eXBlb2YgbW9kZWxbcHJvcF0uX3dpZGdldCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkgY29uc29sZS5sb2coXCJvYmplY3R2YWx1ZVwiLCBwcm9wLCBtb2RlbFtwcm9wXS5fd2lkZ2V0LCB2YWx1ZSk7XG4gICAgICAvLyBfZGF0YSBpcyBkZWZpbmVkIGZvciBwcmltaXRpdmUgdHlwZXNcbiAgICAgIG1vZGVsW3Byb3BdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic2V0dGluZ1wiLCB0eXBlb2YgbW9kZWxbcHJvcF0sIG1vZGVsW3Byb3BdLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwcm9wTmFtZSA9IHByb3Auc3Vic3RyKDAsIGRvdFBvcyk7XG4gICAgX3ZhbHVlU2V0KGRlZnMsIG1vZGVsW3Byb3BOYW1lXSwgcHJvcC5zdWJzdHIoZG90UG9zICsgMSksIHZhbHVlKTtcbiAgfVxufTtcblxudmFyIF9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWYgPSBmdW5jdGlvbihkZWZzLCB0ZW1wbGF0ZU5hbWUsIHByb3BlcnRpZXMsIG5hbWVkUHJvcGVydGllcykge1xuICBpZiAodHlwZW9mIGRlZnNbdGVtcGxhdGVOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9pbml0aWFsaXplZCAmJiAhZGVmc1t0ZW1wbGF0ZU5hbWVdLl93cml0ZWFibGUpIHtcbiAgICBjb25zb2xlLmxvZyhcIl9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWZcIiwgZGVmcywgdGVtcGxhdGVOYW1lLCBwcm9wZXJ0aWVzLCBuYW1lZFByb3BlcnRpZXMpO1xuICAgIHRocm93IFwiVHJ5aW5nIHRvIGFsdGVyIG5vbiB3cml0ZWFibGUgbW9kZWw6IFwiICsgdGVtcGxhdGVOYW1lICsgXCIgLyBcIiArIHByb3BlcnRpZXM7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZnNbdGVtcGxhdGVOYW1lXSA9PSAndW5kZWZpbmVkJykge1xuICAgIGRlZnNbdGVtcGxhdGVOYW1lXSA9IHtcbiAgICAgIF93cml0ZWFibGU6IHRydWVcbiAgICB9O1xuICAgIC8vIEZhbGxiYWNrIGNvbXB1dGF0aW9uIG9mIFwiY2F0ZWdvcnlcIiBkZXBlbmRpbmcgb24gdGhlIHByb3BlcnR5IG5hbWVcbiAgICAvLyBUT0RPIHJlbW92ZSBtZTogdGhpcyBzaG91bGQgYmUgYWx3YXlzIGRlZmluZWQgaW4gdGhlIHRlbXBsYXRlIGRlZmluaXRpb24sIG5vIG5lZWQgdG8gaGFyZGNvZGUgdGhpcyBzdHVmZi5cbiAgICBpZiAodHlwZW9mIG5hbWVkUHJvcGVydGllcyA9PSAndW5kZWZpbmVkJykgbmFtZWRQcm9wZXJ0aWVzID0ge307XG4gICAgaWYgKHR5cGVvZiBuYW1lZFByb3BlcnRpZXMuY2F0ZWdvcnkgPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlZnNbdGVtcGxhdGVOYW1lXS5fY2F0ZWdvcnkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0ZW1wbGF0ZU5hbWUubWF0Y2goLyhedHwuVCloZW1lJC8pIHx8IHRlbXBsYXRlTmFtZS5tYXRjaCgvKF5zfC5TKXR5bGUkLykgfHwgdGVtcGxhdGVOYW1lLm1hdGNoKC8oXmN8LkMpb2xvciQvKSB8fCB0ZW1wbGF0ZU5hbWUubWF0Y2goLyhecnwuUilhZGl1cyQvKSkge1xuICAgICAgICBuYW1lZFByb3BlcnRpZXMuY2F0ZWdvcnkgPSAnc3R5bGUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZWRQcm9wZXJ0aWVzLmNhdGVnb3J5ID0gJ2NvbnRlbnQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgaWYgKHR5cGVvZiBuYW1lZFByb3BlcnRpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gVE9ETyBjaGVjayBpZiB0aGlzIGlzIG5lZWRlZCBiZWZvcmUgdGhlIGVuZGluZyBuYW1lZFByb3BlcnR5IFwibG9vcFwiIG9yIG5vdC5cbiAgICBpZiAodHlwZW9mIG5hbWVkUHJvcGVydGllcy5uYW1lICE9ICd1bmRlZmluZWQnKSBkZWZzW3RlbXBsYXRlTmFtZV0uX25hbWUgPSBuYW1lZFByb3BlcnRpZXMubmFtZTtcblxuICAgIGlmICh0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzLnRoZW1lT3ZlcnJpZGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlZnNbdGVtcGxhdGVOYW1lXS5fdGhlbWVPdmVycmlkZSA9IG5hbWVkUHJvcGVydGllcy50aGVtZU92ZXJyaWRlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVkUHJvcGVydGllcy5nbG9iYWxTdHlsZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9nbG9iYWxTdHlsZSA9IG5hbWVkUHJvcGVydGllcy5nbG9iYWxTdHlsZTtcbiAgICAgIC8vIFRPRE8gcmVtb3ZlIGRlcHJlY2F0ZWQgJHRoZW1lXG4gICAgICB2YXIgZ2xvYmFsU3R5bGVTdWIgPSBuYW1lZFByb3BlcnRpZXMuZ2xvYmFsU3R5bGUucmVwbGFjZSgvXihcXCR0aGVtZXxfdGhlbWVfKVxcLi8sICcnKTtcbiAgICAgIHZhciBwID0gZ2xvYmFsU3R5bGVTdWIuaW5kZXhPZignLicpO1xuICAgICAgdmFyIGdzID0gcCAhPSAtMSA/IGdsb2JhbFN0eWxlU3ViLnN1YnN0cigwLCBwKSA6IGdsb2JhbFN0eWxlU3ViO1xuICAgICAgX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCAndGhlbWUnLCBncyk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGVmc1t0ZW1wbGF0ZU5hbWVdLl90aGVtZU92ZXJyaWRlID09PSAndW5kZWZpbmVkJyB8fCAhIWRlZnNbdGVtcGxhdGVOYW1lXS5fdGhlbWVPdmVycmlkZSkge1xuICAgICAgICBfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsIHRlbXBsYXRlTmFtZSwgXCJjdXN0b21TdHlsZT1mYWxzZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lZFByb3BlcnRpZXMuY29udGV4dE5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWZzW3RlbXBsYXRlTmFtZV0uX2NvbnRleHQgPSBuYW1lZFByb3BlcnRpZXMuY29udGV4dE5hbWU7XG4gICAgICAvLyBUT0RPIGlzIGl0IGNvcnJlY3QgdG8gZmFsbGJhY2sgdG8gXCJib2R5VGhlbWVcIiBmb3IgYmxvY2tzIG5vdCBkZWNsYXJpbmcgYSBkZWZhdWx0IHRoZW1lP1xuICAgICAgLy8gTWF5YmUgaXQgd291bGQgYmUgYmV0dGVyIHRvIHNpbXBseSBkZWNsYXJlIGl0IGFzIG1hbmRhdG9yeSBidXQgbGVhdmUgdGhlIGRlZmF1bHQgY29uZmlndXRhdGlvblxuICAgICAgLy8gdG8gdGhlIHRlbXBsYXRlIGRlZmluaXRpb24uXG4gICAgICBpZiAobmFtZWRQcm9wZXJ0aWVzLmNvbnRleHROYW1lID09ICdibG9jaycgJiYgdHlwZW9mIGRlZnNbdGVtcGxhdGVOYW1lXS5fZ2xvYmFsU3R5bGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9nbG9iYWxTdHlsZSA9ICdfdGhlbWVfLmJvZHlUaGVtZSc7XG4gICAgICAgIF9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgJ3RoZW1lJywgJ2JvZHlUaGVtZScpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGVmc1t0ZW1wbGF0ZU5hbWVdLl90aGVtZU92ZXJyaWRlID09ICd1bmRlZmluZWQnIHx8IGRlZnNbdGVtcGxhdGVOYW1lXS5fdGhlbWVPdmVycmlkZSkge1xuICAgICAgICAgIF9tb2RlbENyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgdGVtcGxhdGVOYW1lLCBcImN1c3RvbVN0eWxlPWZhbHNlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzLmV4dGVuZCAhPSAndW5kZWZpbmVkJykgZGVmc1t0ZW1wbGF0ZU5hbWVdLnR5cGUgPSBuYW1lZFByb3BlcnRpZXMuZXh0ZW5kO1xuICB9XG5cbiAgZm9yICh2YXIgbnAgaW4gbmFtZWRQcm9wZXJ0aWVzKSBpZiAobmFtZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5wKSAmJiB0eXBlb2YgbmFtZWRQcm9wZXJ0aWVzW25wXSAhPT0gJ3VuZGVmaW5lZCcgJiYgWyduYW1lJywgJ2V4dGVuZCcsICdjb250ZXh0TmFtZScsICdnbG9iYWxTdHlsZScsJ3RoZW1lT3ZlcnJpZGUnXS5pbmRleE9mKG5wKSA9PSAtMSkge1xuICAgIGRlZnNbdGVtcGxhdGVOYW1lXVsnXycrbnBdID0gbmFtZWRQcm9wZXJ0aWVzW25wXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPSAndW5kZWZpbmVkJyAmJiBwcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICBkZWZzW3RlbXBsYXRlTmFtZV0uX3Byb3BzID0gdHlwZW9mIGRlZnNbdGVtcGxhdGVOYW1lXS5fcHJvcHMgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmc1t0ZW1wbGF0ZU5hbWVdLl9wcm9wcy5sZW5ndGggPiAwID8gZGVmc1t0ZW1wbGF0ZU5hbWVdLl9wcm9wcyArIFwiIFwiICsgcHJvcGVydGllcyA6IHByb3BlcnRpZXM7XG4gIH1cbn07XG5cbi8vIHJlbW92ZSB0aGUgZmlyc3QgXCJzZXF1ZW5jZVwiIGluIGEgY2FtZWxjYXNlZCB3b3JkIChlLmc6IG15Q2FtZWxDYXNlID0+IGNhbWVsQ2FzZSkuXG52YXIgX3JlbW92ZVByZWZpeCA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcmVzID0gc3RyLm1hdGNoKC9eW15BLVpdKyhbQS1aXSkoLiopJC8pO1xuICByZXR1cm4gcmVzICE9PSBudWxsID8gcmVzWzFdLnRvTG93ZXJDYXNlKCkgKyByZXNbMl0gOiBudWxsO1xufTtcblxuLy8gVE9ETyBkZWZzIGlzIG5lZWRlZCBvbmx5IGJlY2F1c2UgX3ZhbHVlU2V0IG5lZWRzIGl0Li4gd2Ugc2hvdWxkIHJlbW92ZSBpdCBkb3duc3RyZWFtLlxudmFyIF9nZW5lcmF0ZU1vZGVsRnJvbURlZiA9IGZ1bmN0aW9uKG1vZGVsRGVmLCBkZWZzKSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIG1vZGVsRGVmKVxuICAgIGlmICghcHJvcC5tYXRjaCgvXl8uKi8pICYmIG1vZGVsRGVmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICB2YXIgdmFsdWUgPSBtb2RlbERlZltwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLl9jb21wbGV4ICE9ICd1bmRlZmluZWQnICYmIHZhbHVlLl9jb21wbGV4KSB7XG4gICAgICAgIHJlc1twcm9wXSA9IF9nZW5lcmF0ZU1vZGVsRnJvbURlZih2YWx1ZSwgZGVmcyk7XG4gICAgICB9IGVsc2UgaWYgKHByb3AgPT0gJ3R5cGUnKSB7XG4gICAgICAgIHJlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gbW9zdCB0aW1lcyB0aGlzIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgX3ZhbHVlU2V0XG4gICAgICAgIHJlc1twcm9wXSA9IG51bGw7XG4gICAgICAgIC8vIGZvciBjdXN0b21TdHlsZSB0aGlzIGlzIHNldCB0byBudWxsLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgbW9kZWwgZGVmXCIsIHByb3AsIHZhbHVlLCBtb2RlbERlZik7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBtb2RlbCBkZWYgW1wiICsgcHJvcCArIFwiXT1cIiArIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICBpZiAodHlwZW9mIG1vZGVsRGVmLl9kZWZhdWx0VmFsdWVzICE9ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGRlZmF1bHRzID0gbW9kZWxEZWYuX2RlZmF1bHRWYWx1ZXM7XG4gICAgZm9yICh2YXIgcHJvcDIgaW4gZGVmYXVsdHMpXG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkocHJvcDIpKSB7XG4gICAgICAgIF92YWx1ZVNldChkZWZzLCByZXMsIHByb3AyLCBkZWZhdWx0c1twcm9wMl0pO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBfZ2VuZXJhdGVNb2RlbCA9IGZ1bmN0aW9uKGRlZnMsIG5hbWUpIHtcbiAgdmFyIG1vZGVsRGVmID0gX2dldE1vZGVsRGVmKGRlZnMsIG5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgcmV0dXJuIF9nZW5lcmF0ZU1vZGVsRnJvbURlZihtb2RlbERlZiwgZGVmcyk7XG59O1xuXG52YXIgX2dldERlZiA9IGZ1bmN0aW9uKGRlZnMsIG5hbWUpIHtcbiAgcmV0dXJuIF9nZXRNb2RlbERlZihkZWZzLCBuYW1lLCBmYWxzZSwgdHJ1ZSk7XG59O1xuXG52YXIgX2dldE1vZGVsRGVmID0gZnVuY3Rpb24oZGVmcywgbmFtZSwgcmV0dXJuQ2xvbmUsIHJlYWRvbmx5KSB7XG4gIC8vIGxvb2t1cCBcIm5hbWVcIiBpbiB0aGUgdGVtcGxhdGUgZGVmaW5pdGlvblxuICBpZiAodHlwZW9mIGRlZnNbbmFtZV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBpZiB0aGUgbmFtZSBoYXMgYSBzcGFjZSB0aGVuIHJldHVybnMuXG4gICAgaWYgKG5hbWUuaW5kZXhPZignICcpICE9IC0xKSByZXR1cm4gbnVsbDtcbiAgICAvLyBvdGhlcndpc2UgdHJ5IGxvb2tpbmcgdXAgdXNpbmcgYSBkZXByZWZpeGVkIG5hbWUuXG4gICAgdmFyIHJlcyA9IF9yZW1vdmVQcmVmaXgobmFtZSk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETyB0aGUgZGVwcmVmaXhpbmcgaXMgcG93ZXJmdWwsIGJ1dCBtYXliZSBub3QgcmVhbGx5IG5lZWRlZC5cbiAgICAgIHJldHVybiBfZ2V0TW9kZWxEZWYoZGVmcywgcmVzLCByZXR1cm5DbG9uZSwgcmVhZG9ubHkpO1xuICAgIH1cbiAgICAvLyBub3QgYSBwcmVmaXhlZCBuYW1lXG4gICAgLy8gVE9ETyBzaG91bGQgd2UgcmFpc2UgYW4gZXJyb3I/XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiB0aGUgbmFtZSBpcyBhbHJlYWR5IGRlZmluZWQuLi5cbiAgICB2YXIgZGVmT2JqID0gZGVmc1tuYW1lXTtcbiAgICBpZiAodHlwZW9mIGRlZk9iaiAhPSAnb2JqZWN0JykgdGhyb3cgXCJCbG9jayBkZWZpbml0aW9uIG11c3QgYmUgYW4gb2JqZWN0OiBmb3VuZCBcIiArIGRlZk9iaiArIFwiIGZvciBcIiArIG5hbWU7XG5cbiAgICBpZiAodHlwZW9mIGRlZk9iai5faW5pdGlhbGl6ZWQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFBvcHVsYXRlIFwidHlwZVwiIGRlcGVuZGluZyBvbiBuYW1lXG4gICAgICBpZiAodHlwZW9mIGRlZk9iai50eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJyAnKSA9PSAtMSkge1xuICAgICAgICAgIGRlZk9iai50eXBlID0gbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZPYmoudHlwZSA9IG5hbWUuc3Vic3RyKG5hbWUuaW5kZXhPZignICcpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgbm90IGEgXCJkYXRhXCIgdHlwZSB0aGVuIGxldCdzIGRlYWwgd2l0aCBpbmhlcml0YW5jZVxuICAgICAgaWYgKGRlZk9iai50eXBlICE9IG5hbWUgJiYgdHlwZW9mIGRlZk9iai5fd2lkZ2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB0eXBlRGVmID0gX2dldE1vZGVsRGVmKGRlZnMsIGRlZk9iai50eXBlLCB0cnVlKTtcbiAgICAgICAgdmFyIGV4dGVuZGVkID0gb2JqRXh0ZW5kKHR5cGVEZWYsIGRlZk9iaik7XG4gICAgICAgIGRlZk9iaiA9IGV4dGVuZGVkO1xuICAgICAgICBkZWZzW25hbWVdID0gZGVmT2JqO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmT2JqLl93aWRnZXQgPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlZk9iai5fcHJvcHMgPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlZk9iai5fY29tcGxleCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBUT0RPIGhlcmUgSSB0cmllZCB0byBkZWFsIHdpdGggaW5oZXJpdGFuY2UgZm9yIGV2ZXJ5IG9iamVjdCB3aXRob3V0IGEgXCJ0eXBlXCIgYnkgdXNpbmcgYSBzaW1wbGUgZGVwcmVmaXguXG4gICAgICAgIC8vIGJ1dCB0aGlzIGJyZWFrIG9uIHRoZW1lIGNvbnRhaW5pbmcgXCJwYWdlVGhlbWVcIiB0aGF0IHdvdWxkIGluaGVyaXQgZnJvbSBpcyBwYXJlbnQuIChjcmVhdGluZyBhIGxvb3ApXG4gICAgICAgIC8qXG4gICAgICAgIHZhciBzdXBlclR5cGUgPSBfcmVtb3ZlUHJlZml4KGRlZk9iai50eXBlKTtcbiAgICAgICAgaWYgKHN1cGVyVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXh0ZW5kaW5nXCIsIHR5cGVEZWYsIG5hbWUsIHN1cGVyVHlwZSwgZGVmT2JqLnR5cGUpO1xuICAgICAgICAgIHZhciB0eXBlRGVmID0gX2dldE1vZGVsRGVmKGRlZnMsIHN1cGVyVHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGV4dGVuZGVkID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB0eXBlRGVmLCBkZWZPYmopO1xuICAgICAgICAgIGRlZk9iaiA9IGV4dGVuZGVkO1xuICAgICAgICAgIGRlZnNbbmFtZV0gPSBkZWZPYmo7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgIH1cbiAgICAgIGRlZk9iai5fd3JpdGVhYmxlID0gdHJ1ZTtcbiAgICAgIGRlZk9iai5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGVmT2JqLl9wcm9wcyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGRlZiA9IGRlZk9iai5fcHJvcHM7XG4gICAgICBkZWYgPSBkZWYuc3BsaXQoXCIgXCIpO1xuXG4gICAgICBpZiAoZGVmLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGRlZk9iai5fd3JpdGVhYmxlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBbHRlcmluZyBhIG5vbiB3cml0YWJsZSBvYmplY3QgXCIsIG5hbWUsIGRlZiwgZGVmT2JqKTtcbiAgICAgICAgdGhyb3cgXCJBbHRlcmluZyBhIG5vbiB3cml0YWJsZSBvYmplY3Q6IFwiICsgbmFtZSArIFwiIGRlZjogXCIgKyBkZWY7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVmT2JqLl9wcm9jZXNzZWREZWZzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlZk9iai5fcHJvY2Vzc2VkRGVmcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlZk9iai5fZ2xvYmFsU3R5bGVzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlZk9iai5fZ2xvYmFsU3R5bGVzID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGVmT2JqLl9kZWZhdWx0VmFsdWVzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlZk9iai5fZGVmYXVsdFZhbHVlcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IGRlZltpXTtcbiAgICAgICAgaWYgKHByb3AubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgICAgdmFyIG9yaWdQcm9wID0gcHJvcDtcbiAgICAgICAgdmFyIGRlZlZhbHVlID0gbnVsbDtcbiAgICAgICAgLy8gcGFyc2VzICBcInByb3BcIiBcInByb3A9dmFsdWVcIiBhbmQgXCJwcm9wW11cIiBkZWNsYXJhdGlvbnNcbiAgICAgICAgdmFyIHByb3BEZWYgPSBwcm9wLm1hdGNoKC9eKFtePVxcW1xcXV0rKShcXFtcXF0pPyg9PykoLiopJC8pO1xuICAgICAgICBpZiAocHJvcERlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHByb3AgPSBwcm9wRGVmWzFdO1xuICAgICAgICAgIC8vIFRPRE8gYXJyYXkgZGVmaW5pdGlvbiBzaG91bGQgYmUgZG9uZSBkaWZmZXJlbnRseVxuICAgICAgICAgIGlmIChwcm9wRGVmWzJdID09ICdbXScpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdHlwZSBzaG91bGQgbm90IGJlIGRlZmluZWQgaW4gdGhpcyBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZPYmpbcHJvcF0gPT0gJ3VuZGVmaW5lZCcpIGRlZk9ialtwcm9wXSA9IFtdO1xuICAgICAgICAgICAgZGVmVmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BEZWZbM10gPT0gJz0nKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSBoYXJkY29kZWQgXCJ2aXNpYmxlXCIgbWF0Y2hpbmcgKHRoaXMgc2hvdWxkIGJlIGRlZmluZWQgaW4gdGhlIHRlbXBsYXRlIGRlZmluaXRpb24pXG4gICAgICAgICAgICBpZiAocHJvcC5tYXRjaCgvKF52fFYpaXNpYmxlJC8pKSBkZWZWYWx1ZSA9IFN0cmluZyhwcm9wRGVmWzRdKS50b0xvd2VyQ2FzZSgpID09ICd0cnVlJztcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3AubWF0Y2goL15jdXN0b21TdHlsZSQvKSkge1xuICAgICAgICAgICAgICBkZWZWYWx1ZSA9IFN0cmluZyhwcm9wRGVmWzRdKS50b0xvd2VyQ2FzZSgpID09ICd0cnVlJztcbiAgICAgICAgICAgIH0gZWxzZSBkZWZWYWx1ZSA9IHByb3BEZWZbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzIGZvdW5kIGluIFwicHJvcGVydGllc1wiIGFyZSBub3QgYmVpbmcgcHJvY2Vzc2VkIGJ5IFwibW9kZWxFbnN1cmVWYWx1ZVwiIGFuZCBieSBjb25zZXF1ZW5jZSBkbyBub3QgY2FsbCBcInRoZW1lVXBkYXRlclwiLlxuICAgICAgICAvLyBUT0RPIGRvY3VtZW50IHdoeSB0aGlzIGlzIG5lZWRlZCwgb3IgcmVtb3ZlLlxuICAgICAgICBpZiAoZGVmVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRlZk9iai5fZGVmYXVsdFZhbHVlc1twcm9wXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaWYgKHByb3AubWF0Y2goL15fLykpIGNvbnNvbGUubG9nKFwiZGVmVmFsdWUgZm9yXCIsIHByb3AsIFwiaW5cIiwgbmFtZSk7XG4gICAgICAgICAgICBkZWZPYmouX2RlZmF1bHRWYWx1ZXNbcHJvcF0gPSBkZWZWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlZk9ialtwcm9wXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciB2YWwgPSBfZ2V0TW9kZWxEZWYoZGVmcywgbmFtZSArICcgJyArIHByb3AsIHRydWUpO1xuICAgICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbCA9IF9nZXRNb2RlbERlZihkZWZzLCBwcm9wLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmT2JqW3Byb3BdID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmT2JqLl9wcm9jZXNzZWREZWZzW3Byb3BdID0gb3JpZ1Byb3A7XG4gICAgICAgIGRlZk9iai5fY29tcGxleCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBkZWZPYmouX3Byb3BzO1xuICAgIH1cblxuICAgIGlmIChyZXR1cm5DbG9uZSkge1xuICAgICAgZGVmT2JqLl93cml0ZWFibGUgPSBmYWxzZTtcbiAgICAgIHZhciBjbG9uZWQgPSBvYmpFeHRlbmQoe30sIGRlZk9iaik7XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH0gZWxzZSBpZiAocmVhZG9ubHkpIHtcbiAgICAgIGRlZk9iai5fd3JpdGVhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm4gZGVmT2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGRlZk9iai5fd3JpdGVhYmxlID09ICd1bmRlZmluZWQnIHx8IGRlZk9iai5fd3JpdGVhYmxlID09PSBmYWxzZSkgdGhyb3cgXCJSZXRyaWV2aW5nIG5vbiB3cml0ZWFibGUgb2JqZWN0IGRlZmluaXRpb246IFwiICsgbmFtZTtcbiAgICAgIHJldHVybiBkZWZPYmo7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2luY3JlYXNlVXNlQ291bnQgPSBmdW5jdGlvbihyZWFkb25seSwgbW9kZWwpIHtcbiAgaWYgKCFyZWFkb25seSkge1xuICAgIGlmICh0eXBlb2YgbW9kZWwuX3VzZWNvdW50ID09ICd1bmRlZmluZWQnKSBtb2RlbC5fdXNlY291bnQgPSAwO1xuICAgIG1vZGVsLl91c2Vjb3VudCsrO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlbC5fdXNlY291bnQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRVJST1IgdHJ5aW5nIHRvIGJpbmQgYW4gdW51c2VkIHByb3BlcnR5IHdoaWxlIHJlYWRvbmx5XCIsIG1vZGVsKTtcbiAgICB0aHJvdyBcIkVSUk9SIHRyeWluZyB0byBiaW5kIGFuIHVudXNlZCBwcm9wZXJ0eVwiO1xuICB9XG59O1xuXG52YXIgZW5zdXJlR2xvYmFsU3R5bGUgPSBmdW5jdGlvbihkZWZzLCByZWFkb25seSwgZ3NCaW5kaW5nUHJvdmlkZXIsIG1vZGVsTmFtZSwgcGF0aCwgZ3NGdWxsUGF0aCwgZGVmYXVsdFZhbHVlLCBvdmVycmlkZURlZmF1bHQpIHtcblxuICB2YXIgZ2xvYmFsU3R5bGVCaW5kaW5nQmluZFZhbHVlID0gZ3NCaW5kaW5nUHJvdmlkZXIoZ3NGdWxsUGF0aCwgZGVmYXVsdFZhbHVlLCBvdmVycmlkZURlZmF1bHQpO1xuXG4gIGlmICh0eXBlb2YgZGVmc1ttb2RlbE5hbWVdLl9nbG9iYWxTdHlsZXNbcGF0aF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAocmVhZG9ubHkpIHRocm93IFwiQ2Fubm90IGZpbmQgX2dsb2JhbFN0eWxlIGZvciBcIiArIHBhdGggKyBcIiBpbiBcIiArIG1vZGVsTmFtZSArIFwiIVwiO1xuICAgIGlmIChwYXRoLmluZGV4T2YoJy4nKSAhPSAtMSB8fCAodHlwZW9mIGRlZnNbbW9kZWxOYW1lXVtwYXRoXSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZGVmc1ttb2RlbE5hbWVdW3BhdGhdLl93aWRnZXQgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgZGVmc1ttb2RlbE5hbWVdLl9nbG9iYWxTdHlsZXNbcGF0aF0gPSBnbG9iYWxTdHlsZUJpbmRpbmdCaW5kVmFsdWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRlZnNbbW9kZWxOYW1lXS5fZ2xvYmFsU3R5bGVzW3BhdGhdICE9IGdsb2JhbFN0eWxlQmluZGluZ0JpbmRWYWx1ZSkgdGhyb3cgXCJVbmV4cGVjdGVkIGNvbmZsaWN0aW5nIGdsb2JhbFN0eWxlIFsyXSBmb3IgXCIgKyBtb2RlbE5hbWUgKyBcIi9cIiArIHBhdGggKyBcIjogb2xkPVwiICsgZGVmc1ttb2RlbE5hbWVdLl9nbG9iYWxTdHlsZXNbcGF0aF0gKyBcIiBuZXc9XCIgKyBnbG9iYWxTdHlsZUJpbmRpbmdCaW5kVmFsdWU7XG59O1xuXG4vLyB0aGVtZVVwZGF0ZXIsIGRlZmF1bHRWYWx1ZSwgb3ZlcnJpZGVEZWZhdWx0LCBzZXRjYXRlZ29yeSBhcmUgb25seSB1c2VkIGluICFyZWFkb25seSBtb2RlXG52YXIgbW9kZWxFbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlID0gZnVuY3Rpb24ocmVhZG9ubHksIGRlZnMsIHRoZW1lVXBkYXRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCB3aXRoaW4sIGZ1bGxQYXRoLCBkZWZhdWx0VmFsdWUsIG92ZXJyaWRlRGVmYXVsdCwgc2V0Y2F0ZWdvcnkpIHtcbiAgdmFyIG1vZGVsTmFtZTtcbiAgdmFyIHJlcztcbiAgdmFyIHBhdGg7XG4gIC8vIFRPRE8gcmVtb3ZlICckJyBhbmQgJyMnIGhhbmRpbmdcbiAgaWYgKGZ1bGxQYXRoLnN1YnN0cigwLCAxKSA9PSAnJCcpIHtcbiAgICBjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEICQgaW4gYmluZGluZ1Byb3ZpZGVyOiBcIiwgZnVsbFBhdGgsIHRlbXBsYXRlTmFtZSk7XG4gICAgdmFyIHAgPSBmdWxsUGF0aC5pbmRleE9mKCcuJyk7XG4gICAgaWYgKHAgPT0gLTEpIHtcbiAgICAgIHRocm93IFwiVW5leHBlY3RlZCBmdWxsUGF0aDogXCIgKyBmdWxsUGF0aCArIFwiL1wiICsgd2l0aGluICsgXCIvXCIgKyB0ZW1wbGF0ZU5hbWUgKyBcIi9cIiArIGRlZmF1bHRWYWx1ZSArIFwiL1wiICsgb3ZlcnJpZGVEZWZhdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbE5hbWUgPSBmdWxsUGF0aC5zdWJzdHIoMSwgcCAtIDEpO1xuICAgICAgcGF0aCA9IGZ1bGxQYXRoLnN1YnN0cihwICsgMSk7XG4gICAgICAvLyBUT0RPIHJlZmFjdG9yIG1lIHBsZWFzZVxuICAgICAgaWYgKG1vZGVsTmFtZSA9PSAndGhlbWUnKSB7XG4gICAgICAgIHZhciBwMiA9IHBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBtb2RlbE5hbWUgPSBwYXRoLnN1YnN0cigwLCBwMik7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cihwMiArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkICQgc2VxdWVuY2U6IFwiICsgbW9kZWxOYW1lICsgXCIgaW4gXCIgKyBmdWxsUGF0aDtcbiAgICAgIH1cbiAgICAgIHJlcyA9IFwiJHJvb3QuY29udGVudCgpLnRoZW1lKCkuXCIgKyBtb2RlbE5hbWUgKyBcIigpLlwiICsgcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwuJywgJ2cnKSwgJygpLicpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmdWxsUGF0aC5zdWJzdHIoMCwgMSkgPT0gJyMnKSB7XG4gICAgY29uc29sZS53YXJuKFwiREVQUkVDQVRFRCAjIGluIGJpbmRpbmdQcm92aWRlcjogXCIsIGZ1bGxQYXRoLCB0ZW1wbGF0ZU5hbWUpO1xuICAgIG1vZGVsTmFtZSA9IHJvb3RNb2RlbE5hbWU7XG4gICAgcGF0aCA9IGZ1bGxQYXRoLnN1YnN0cigxKTtcbiAgICByZXMgPSBcIiRyb290LmNvbnRlbnQoKS5cIiArIHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcLicsICdnJyksICcoKS4nKTtcbiAgfSBlbHNlIGlmIChmdWxsUGF0aC5zdWJzdHIoMCwgOCkgPT0gJ190aGVtZV8uJykge1xuICAgIHZhciBwMyA9IGZ1bGxQYXRoLmluZGV4T2YoJy4nLCA4KTtcbiAgICBtb2RlbE5hbWUgPSBmdWxsUGF0aC5zdWJzdHIoOCwgcDMgLSA4KTtcbiAgICBwYXRoID0gZnVsbFBhdGguc3Vic3RyKHAzICsgMSk7XG4gICAgcmVzID0gXCIkcm9vdC5jb250ZW50KCkudGhlbWUoKS5cIiArIG1vZGVsTmFtZSArIFwiKCkuXCIgKyBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXC4nLCAnZycpLCAnKCkuJyk7XG4gIH0gZWxzZSBpZiAoZnVsbFBhdGguc3Vic3RyKDAsIDcpID09ICdfcm9vdF8uJykge1xuICAgIG1vZGVsTmFtZSA9IHJvb3RNb2RlbE5hbWU7XG4gICAgcGF0aCA9IGZ1bGxQYXRoLnN1YnN0cig3KTtcbiAgICByZXMgPSBcIiRyb290LmNvbnRlbnQoKS5cIiArIHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcLicsICdnJyksICcoKS4nKTtcbiAgfSBlbHNlIHtcbiAgICBtb2RlbE5hbWUgPSB0ZW1wbGF0ZU5hbWU7XG4gICAgcGF0aCA9IHdpdGhpbiArIGZ1bGxQYXRoO1xuICAgIHJlcyA9IGZ1bGxQYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXC4nLCAnZycpLCAnKCkuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZnNbbW9kZWxOYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IFwiQ2Fubm90IGZpbmQgbW9kZWwgZGVmIGZvciBbXCIgKyBtb2RlbE5hbWUgKyBcIl1cIjtcblxuICB2YXIgcHJvcFBvcyA9IHBhdGguaW5kZXhPZignLicpO1xuICB2YXIgcHJvcE5hbWUgPSBwcm9wUG9zID09IC0xID8gcGF0aCA6IHBhdGguc3Vic3RyKDAsIHByb3BQb3MpO1xuXG4gIGlmIChtb2RlbE5hbWUuaW5kZXhPZignLScpICE9IC0xKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVSUk9SIGNhbm5vdCB1c2UgLSBmb3IgYmxvY2sgbmFtZXNcIiwgbW9kZWxOYW1lKTtcbiAgICB0aHJvdyBcIkVSUk9SIHVuZXhwZWN0ZWQgY2hhciBpbiBibG9jayBuYW1lOiBcIiArIG1vZGVsTmFtZTtcbiAgfVxuICBpZiAocHJvcE5hbWUuaW5kZXhPZignLScpICE9IC0xKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVSUk9SIGNhbm5vdCB1c2UgLSBmb3IgcHJvcGVydHkgbmFtZXNcIiwgcHJvcE5hbWUpO1xuICAgIHRocm93IFwiRVJST1IgdW5leHBlY3RlZCBjaGFyIGluIHByb3BlcnR5IG5hbWU6IFwiICsgbW9kZWxOYW1lO1xuICB9XG5cbiAgLy8gRmFzdHBhdGhcbiAgaWYgKHJlYWRvbmx5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZzW21vZGVsTmFtZV0uX2dsb2JhbFN0eWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXS5fY2F0ZWdvcnkgPT0gJ3N0eWxlJykge1xuICAgICAgcmVzICs9ICcuX2RlZmF1bHRDb21wdXRlZCc7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBnZXRzIHRoZSB3cml0YWJsZSBtb2RlbCB3aGVuIFwiIXJlYWRvbmx5XCIgb3IgdGhlIHJlYWRvbmx5IG1vZGVsIG90aGVyd2lzZVxuICB2YXIgbW9kZWw7XG4gIGlmIChyZWFkb25seSkge1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykgdGhyb3cgXCJDYW5ub3QgdXNlIGRlZmF1bHRWYWx1ZSBpbiByZWFkb25seSBtb2RlIVwiO1xuICAgIGlmIChvdmVycmlkZURlZmF1bHQpIHRocm93IFwiQ2Fubm90IHVzZSBvdmVycmlkZURlZmF1bHQgaW4gcmVhZG9ubHkgbW9kZSBmb3IgXCIgKyBtb2RlbE5hbWUgKyBcIi9cIiArIHBhdGggKyBcIi9cIiArIG92ZXJyaWRlRGVmYXVsdCArIFwiIVwiO1xuICAgIGlmICh0eXBlb2Ygc2V0Y2F0ZWdvcnkgIT09ICd1bmRlZmluZWQnKSB0aHJvdyBcIkNhbm5vdCBzZXQgY2F0ZWdvcnkgZm9yIFwiICsgbW9kZWxOYW1lICsgXCIvXCIgKyBwYXRoICsgXCIvXCIgKyBzZXRjYXRlZ29yeSArIFwiIGluIHJlYWRvbmx5IG1vZGUhXCI7XG4gICAgbW9kZWwgPSBfZ2V0TW9kZWxEZWYoZGVmcywgbW9kZWxOYW1lLCBmYWxzZSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlZnNbbW9kZWxOYW1lXS5fd3JpdGVhYmxlID09PSBmYWxzZSkgY29uc29sZS5sb2coXCJUT0RPIGRlYnVnIHVzZSBjYXNlcyBmb3IgdGhpcyBjb25kaXRpb25cIiwgbW9kZWxOYW1lLCBwYXRoKTtcbiAgICBtb2RlbCA9IF9nZXRNb2RlbERlZihkZWZzLCBtb2RlbE5hbWUsIGRlZnNbbW9kZWxOYW1lXS5fd3JpdGVhYmxlID09PSBmYWxzZSk7XG4gIH1cblxuICBpZiAobW9kZWwgPT09IG51bGwpIHRocm93IFwiVW5leHBlY3RlZCBtb2RlbCBmb3IgW1wiICsgbW9kZWxOYW1lICsgXCJdXCI7XG5cbiAgLy8gaWYgdGhlIHByb3BlcnR5IGRvZXMgbm90IGV4aXN0cyB3ZSBoYXZlIHRvIGNyZWF0ZSBpdC5cbiAgaWYgKHR5cGVvZiBtb2RlbFtwcm9wTmFtZV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyB3aGVuIGluIHJlYWRvbmx5IG1vZGUgdGhpcyBjYW5ub3QgYmUgZG9uZSFcbiAgICBpZiAocmVhZG9ubHkpIHRocm93IFwiQ2Fubm90IGZpbmQgcGF0aCBcIiArIHByb3BOYW1lICsgXCIgZm9yIFwiICsgbW9kZWxOYW1lICsgXCIhXCI7XG4gICAgX21vZGVsQ3JlYXRlT3JVcGRhdGVCbG9ja0RlZihkZWZzLCBtb2RlbE5hbWUsIHByb3BOYW1lKTtcbiAgICBtb2RlbCA9IF9nZXRNb2RlbERlZihkZWZzLCBtb2RlbE5hbWUsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIE5lZWRzIHRvIGRvIHRoaXMgYWdhaW4sIGJlY2F1c2UgXCJfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmXCIgY291bGQgaGF2ZSBiZWVuIGp1c3QgY3JlYXRlZCB0aGUgcHJvcGVydHkgKGUuZzogYmFja2dyb3VuZENvbG9yIGJ1dHRvbkJsb2NrIG5vdCBnZXR0aW5nIGRlZmF1bHRDb21wdXRlZCBpbiB0ZW1wbGF0ZS1sbSlcbiAgaWYgKHR5cGVvZiBkZWZzW21vZGVsTmFtZV0uX2dsb2JhbFN0eWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXSAhPT0gbnVsbCAmJiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdLl9jYXRlZ29yeSA9PSAnc3R5bGUnKSB7XG4gICAgcmVzICs9ICcuX2RlZmF1bHRDb21wdXRlZCc7XG4gIH1cblxuICB2YXIgY2hpbGRNb2RlbCA9IG1vZGVsO1xuICB0cnkge1xuICAgIF9pbmNyZWFzZVVzZUNvdW50KHJlYWRvbmx5LCBjaGlsZE1vZGVsKTtcbiAgICBpZiAocHJvcFBvcyAhPSAtMSkge1xuICAgICAgdmFyIG15cGF0aCA9IHBhdGg7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBwcm9wID0gbXlwYXRoLnN1YnN0cigwLCBwcm9wUG9zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZE1vZGVsW3Byb3BdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgXCJGb3VuZCBhbiB1bmV4cGVjdGVkIHByb3AgXCIgKyBwcm9wICsgXCIgZm9yIG1vZGVsIFwiICsgbW9kZWxOYW1lICsgXCIgZm9yIFwiICsgcGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkTW9kZWwgPSBjaGlsZE1vZGVsW3Byb3BdO1xuICAgICAgICBfaW5jcmVhc2VVc2VDb3VudChyZWFkb25seSwgY2hpbGRNb2RlbCk7XG4gICAgICAgIG15cGF0aCA9IG15cGF0aC5zdWJzdHIocHJvcFBvcyArIDEpO1xuICAgICAgICBwcm9wUG9zID0gbXlwYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgIH0gd2hpbGUgKHByb3BQb3MgIT0gLTEpO1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkTW9kZWxbbXlwYXRoXSA9PSAndW5kZWZpbmVkJyB8fCBjaGlsZE1vZGVsW215cGF0aF0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJGb3VuZCBhbiB1bmV4cGVjdGVkIHBhdGggdGVybWluYXRpb24gXCIgKyBteXBhdGggKyBcIiBmb3IgbW9kZWwgXCIgKyBtb2RlbE5hbWUgKyBcIiBmb3IgXCIgKyBwYXRoO1xuICAgICAgfVxuICAgICAgY2hpbGRNb2RlbCA9IGNoaWxkTW9kZWxbbXlwYXRoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRNb2RlbCA9IGNoaWxkTW9kZWxbcGF0aF07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjaGlsZE1vZGVsID09PSAndW5kZWZpbmVkJyB8fCBjaGlsZE1vZGVsID09PSBudWxsKSB0aHJvdyBcIlVuZXhwZWN0ZWQgbnVsbCBtb2RlbCBmb3IgXCIgKyBtb2RlbE5hbWUgKyBcIi9cIiArIHdpdGhpbiArIFwiL1wiICsgZnVsbFBhdGg7XG5cbiAgICBpZiAodHlwZW9mIHNldGNhdGVnb3J5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY2hpbGRNb2RlbC5fY2F0ZWdvcnkgPSBzZXRjYXRlZ29yeTtcbiAgICB9XG5cbiAgICBfaW5jcmVhc2VVc2VDb3VudChyZWFkb25seSwgY2hpbGRNb2RlbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVE9ETyBFUlJPUiBQcm9wZXJ0eSBsb29rdXAgZXhjZXB0aW9uXCIsIGUsIG1vZGVsTmFtZSwgcGF0aCwgdGVtcGxhdGVOYW1lLCBmdWxsUGF0aCwgZGVmcyk7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmc1ttb2RlbE5hbWVdLl9nbG9iYWxTdHlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0gPT0gJ29iamVjdCcgJiYgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXSAhPT0gbnVsbCAmJiB0eXBlb2YgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXS5fY2F0ZWdvcnkgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmc1ttb2RlbE5hbWVdW3Byb3BOYW1lXS5fY2F0ZWdvcnkgPT0gJ3N0eWxlJykge1xuICAgIC8vIFRPRE8gY2FuIEkgcmVzdHJpY3QgdGhpcyBjb2RlIHRvICFyZWFkb25seSBtb2RlP1xuICAgIHZhciBnc0JpbmRpbmdQcm92aWRlciA9IG1vZGVsRW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZS5iaW5kKHVuZGVmaW5lZCwgcmVhZG9ubHksIGRlZnMsIHRoZW1lVXBkYXRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCAnJyk7XG5cbiAgICB2YXIgc3ViUGF0aCA9IHBhdGguaW5kZXhPZignLicpICE9IC0xID8gcGF0aC5zdWJzdHIocGF0aC5pbmRleE9mKCcuJykpIDogJyc7XG5cbiAgICAvLyBUaGUgbmV4dCBjb2RlIHN1cHBvcnRzIG9ubHkgcHJvcGVydGllcyB3aXRoIG9uZSBkb3QgKG9iamVjdC5wcm9wZXJ0eSkuXG4gICAgaWYgKHN1YlBhdGguaW5kZXhPZignLicsIDEpICE9IC0xKSB0aHJvdyBcIlRPRE8gdW5zdXBwb3J0ZWQgb2JqZWN0IG5lc3RpbmchIFwiICsgcGF0aDtcblxuICAgIHZhciBnc1BhdGggPSBkZWZzW21vZGVsTmFtZV0uX2dsb2JhbFN0eWxlICsgJy4nICsgcHJvcE5hbWU7XG4gICAgaWYgKHR5cGVvZiBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdID09ICdvYmplY3QnICYmIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0gIT09IG51bGwgJiYgdHlwZW9mIGRlZnNbbW9kZWxOYW1lXVtwcm9wTmFtZV0uX2dsb2JhbFN0eWxlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBnc1BhdGggPSBkZWZzW21vZGVsTmFtZV1bcHJvcE5hbWVdLl9nbG9iYWxTdHlsZTtcbiAgICB9XG5cbiAgICBlbnN1cmVHbG9iYWxTdHlsZShkZWZzLCByZWFkb25seSwgZ3NCaW5kaW5nUHJvdmlkZXIsIG1vZGVsTmFtZSwgcHJvcE5hbWUsIGdzUGF0aCwgdW5kZWZpbmVkLCBmYWxzZSk7XG5cbiAgICB2YXIgZ3NGdWxsUGF0aCA9IGdzUGF0aCArIHN1YlBhdGg7XG5cbiAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PSAndW5kZWZpbmVkJyAmJiBkZWZzW21vZGVsTmFtZV0uX2RlZmF1bHRWYWx1ZXNbcGF0aF0gIT09IG51bGwpIGRlZmF1bHRWYWx1ZSA9IGRlZnNbbW9kZWxOYW1lXS5fZGVmYXVsdFZhbHVlc1twYXRoXTtcblxuICAgIGVuc3VyZUdsb2JhbFN0eWxlKGRlZnMsIHJlYWRvbmx5LCBnc0JpbmRpbmdQcm92aWRlciwgbW9kZWxOYW1lLCBwYXRoLCBnc0Z1bGxQYXRoLCBkZWZhdWx0VmFsdWUsIG92ZXJyaWRlRGVmYXVsdCk7XG5cbiAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChyZWFkb25seSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IHNldCBhIG5ldyB0aGVtZSBkZWZhdWx0IHZhbHVlXCIsIGdzRnVsbFBhdGguc3Vic3RyKDcpLCBkZWZhdWx0VmFsdWUsIFwid2hpbGUgaW4gcmVhZG9ubHkgbW9kZVwiKTtcbiAgICAgICAgdGhyb3cgXCJDYW5ub3Qgc2V0IGEgbmV3IHRoZW1lIGRlZmF1bHQgdmFsdWUgKFwiICsgZGVmYXVsdFZhbHVlICsgXCIpIGZvciBcIiArIGdzRnVsbFBhdGguc3Vic3RyKDcpICsgXCIgd2hpbGUgaW4gcmVhZG9ubHkgbW9kZSFcIjtcbiAgICAgIH1cbiAgICAgIHRoZW1lVXBkYXRlcignZGVmYXVsdCcsIGdzRnVsbFBhdGguc3Vic3RyKDcpLCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFRPRE8gY29tcGxleCBzdHVmZi4gSWYgdGhlIHRoZW1lIHVzZXMgaW5oZXJpdGFuY2Ugd2UgZW5mb3JjZSBpdCB1c2luZyB3aXRoIHRoZSBzYW1lIHZhbHVlLCBidXQgdGhpcyBpcyBhIGxpbWl0LlxuICAgIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZzW21vZGVsTmFtZV0uX2RlZmF1bHRWYWx1ZXNbcGF0aF0gPT0gJ3VuZGVmaW5lZCcgfHwgKHR5cGVvZiBvdmVycmlkZURlZmF1bHQgIT0gJ3VuZGVmaW5lZCcgJiYgb3ZlcnJpZGVEZWZhdWx0KSkge1xuICAgICAgaWYgKHJlYWRvbmx5KSB0aHJvdyBcIkNhbm5vdCBzZXQgbmV3IF9kZWZhdWx0VmFsdWVzIFsxXSBmb3IgXCIgKyBwYXRoICsgXCIgaW4gXCIgKyBtb2RlbE5hbWUgKyBcIiFcIjtcbiAgICAgIGRlZnNbbW9kZWxOYW1lXS5fZGVmYXVsdFZhbHVlc1twYXRoXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAocmVhZG9ubHkgJiYgZGVmc1ttb2RlbE5hbWVdLl9kZWZhdWx0VmFsdWVzW3BhdGhdICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgXCJDYW5ub3Qgc2V0IG5ldyBfZGVmYXVsdFZhbHVlcyBbMl0gZm9yIFwiICsgcGF0aCArIFwiIGluIFwiICsgbW9kZWxOYW1lICsgXCIhXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyByZW1vdmUgZGVmYXVsdCB2YWx1ZS4gVWdseS4gKE5lZWRzIHRoaXMgZm9yIGRlZmF1bHRzIGluIHRlbXBsYXRlLWxtIHNvY2lhbExpbmtzSWNvbilcbiAgICAgICAgZGVmc1ttb2RlbE5hbWVdLl9kZWZhdWx0VmFsdWVzW3BhdGhdID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoZGVmc1ttb2RlbE5hbWVdLl9kZWZhdWx0VmFsdWVzW3BhdGhdICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVE9ETyBlcnJvciEhISBUcnlpbmcgdG8gc2V0IGEgbmV3IGRlZmF1bHQgdmFsdWUgZm9yIFwiICsgbW9kZWxOYW1lICsgXCIgXCIgKyBwYXRoICsgXCIgd2hpbGUgaXQgYWxyZWFkeSBleGlzdHMgKGN1cnJlbnQ6IFwiICsgZGVmc1ttb2RlbE5hbWVdLl9kZWZhdWx0VmFsdWVzW3BhdGhdICsgXCIsIG5ldzogXCIgKyBkZWZhdWx0VmFsdWUgKyBcIilcIik7XG4gICAgICAgIHRocm93IFwiVHJ5aW5nIHRvIHNldCBhIG5ldyBkZWZhdWx0IHZhbHVlIGZvciBcIiArIG1vZGVsTmFtZSArIFwiIFwiICsgcGF0aCArIFwiIHdoaWxlIGl0IGFscmVhZHkgZXhpc3RzIChjdXJyZW50OiBcIiArIGRlZnNbbW9kZWxOYW1lXS5kZWZhdWx0VmFsdWVzW3BhdGhdICsgXCIsIG5ldzogXCIgKyBkZWZhdWx0VmFsdWUgKyBcIilcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxudmFyIGdlbmVyYXRlUmVzdWx0TW9kZWwgPSBmdW5jdGlvbih0ZW1wbGF0ZURlZikge1xuICB2YXIgZGVmcyA9IHRlbXBsYXRlRGVmLl9kZWZzO1xuICB2YXIgdGVtcGxhdGVOYW1lID0gdGVtcGxhdGVEZWYudGVtcGxhdGVOYW1lO1xuXG4gIHZhciBmaW5hbE1vZGVsQ29udGVudCA9IF9nZW5lcmF0ZU1vZGVsKGRlZnMsIHRlbXBsYXRlTmFtZSk7XG5cbiAgLy8gVE9ETyB1Z2x5IHRvIGFkZCB0aGlzIG1hbnVhbGx5XG4gIGlmICh0eXBlb2YgZGVmc1sndGhlbWUnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmaW5hbE1vZGVsQ29udGVudC50aGVtZSA9IF9nZW5lcmF0ZU1vZGVsKGRlZnMsICd0aGVtZScpO1xuICB9XG5cbiAgcmV0dXJuIGZpbmFsTW9kZWxDb250ZW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIHVzZWQgdG8gY29tcGlsZSB0aGUgdGVtcGxhdGVcbiAgZW5zdXJlUGF0aEFuZEdldEJpbmRWYWx1ZTogbW9kZWxFbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlLmJpbmQodW5kZWZpbmVkLCBmYWxzZSksXG4gIC8vIHVzZWQgaW4gcnVudGltZSB0aGUgdGVtcGxhdGVcbiAgZ2V0QmluZFZhbHVlOiBtb2RlbEVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUuYmluZCh1bmRlZmluZWQsIHRydWUpLFxuICBnZW5lcmF0ZU1vZGVsOiBfZ2VuZXJhdGVNb2RlbCxcbiAgZ2VuZXJhdGVSZXN1bHRNb2RlbDogZ2VuZXJhdGVSZXN1bHRNb2RlbCxcbiAgZ2V0RGVmOiBfZ2V0RGVmLFxuICBjcmVhdGVPclVwZGF0ZUJsb2NrRGVmOiBfbW9kZWxDcmVhdGVPclVwZGF0ZUJsb2NrRGVmXG59OyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UgKi9cblxudmFyICQgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snalF1ZXJ5J10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydqUXVlcnknXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBjb252ZXJ0ZXJVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xudmFyIGVsYWJvcmF0ZURlY2xhcmF0aW9ucyA9IHJlcXVpcmUoXCIuL2RlY2xhcmF0aW9ucy5qc1wiKTtcbnZhciBwcm9jZXNzU3R5bGVzaGVldFJ1bGVzID0gcmVxdWlyZShcIi4vc3R5bGVzaGVldC5qc1wiKTtcbnZhciBtb2RlbERlZiA9IHJlcXVpcmUoXCIuL21vZGVsLmpzXCIpO1xudmFyIGRvbXV0aWxzID0gcmVxdWlyZShcIi4vZG9tdXRpbHMuanNcIik7XG5cbnZhciB3cmFwRWxlbWVudFdpdGhDb25kaXRpb24gPSBmdW5jdGlvbihhdHRyaWJ1dGUsIGVsZW1lbnQsIGJpbmRpbmdQcm92aWRlcikge1xuICB2YXIgY29uZCA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpO1xuXG4gIHRyeSB7XG4gICAgdmFyIGJpbmRpbmcgPSBjb252ZXJ0ZXJVdGlscy5jb25kaXRpb25CaW5kaW5nKGNvbmQsIGJpbmRpbmdQcm92aWRlcik7XG4gICAgJChlbGVtZW50KS5iZWZvcmUoJzwhLS0ga28gaWY6ICcgKyBiaW5kaW5nICsgJyAtLT4nKTtcbiAgICAkKGVsZW1lbnQpLmFmdGVyKCc8IS0tIC9rbyAtLT4nKTtcbiAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihcIk1vZGVsIGVuc3VyZSBwYXRoIGZhaWxlZCBpbiBpZi92YXJpYW50XCIsIGVsZW1lbnQsIGNvbmQsIGF0dHJpYnV0ZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG59O1xuXG52YXIgcmVwbGFjZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsIFwicmVwbGFjZWRcIiArIGF0dHJpYnV0ZU5hbWUpKTtcbn07XG5cbnZhciBwcm9jZXNzU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgYmluZGluZ1Byb3ZpZGVyLCBhZGRVbmlxdWVJZCkge1xuICB2YXIgc3R5bGUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ3JlcGxhY2Vkc3R5bGUnKTtcbiAgdmFyIG5ld1N0eWxlID0gbnVsbDtcbiAgdmFyIG5ld0JpbmRpbmdzO1xuICBpZiAoYWRkVW5pcXVlSWQpIG5ld0JpbmRpbmdzID0ge1xuICAgIHVuaXF1ZUlkOiAnJGRhdGEnLFxuICAgIGF0dHI6IHtcbiAgICAgIGlkOiAnaWQnXG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmVEaXNwbGF5Tm9uZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1kaXNwbGF5JykgIT09IG51bGw7XG5cbiAgbmV3U3R5bGUgPSBlbGFib3JhdGVEZWNsYXJhdGlvbnMoc3R5bGUsIHVuZGVmaW5lZCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIGJpbmRpbmdQcm92aWRlciwgZWxlbWVudCwgbmV3QmluZGluZ3MsIHJlbW92ZURpc3BsYXlOb25lKTtcblxuICAvLyBvbmx5IHdoZW4gdXNpbmcgXCJyZXBsYWNlZFwiXG4gIGlmIChuZXdTdHlsZSA9PT0gbnVsbCkge1xuICAgIG5ld1N0eWxlID0gc3R5bGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gYmluZGluZ3Mgd2Uga2VlcCByZXBsYWNlZHN0eWxlIHRvIGJlIHVzZWQgYnkgSUUgZHVyaW5nIG91dHB1dFxuICAgIC8vIG90aGVyd2lzZSBJIHJlbW92ZSBpdCBiZWNhdXNlIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdmlydHVhbEF0dHJTdHlsZSBiaW5kaW5nLlxuICAgIC8vIFRPRE8gbWF5YmUgd2UgYmV0dGVyIHVzZSBkaWZmZXJlbnQgbmFtZXMgZm9yIFwicmVwbGFjZWRcIiB1c2VkIGR1cmluZyB0ZW1wbGF0ZSBjb252ZXJzaW9uXG4gICAgLy8gYW5kIHRoZSBvbmVzIHVzZWQgdG8gY3JlYXRlIHRoZSBvdXRwdXQuXG4gICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdyZXBsYWNlZHN0eWxlJyk7XG4gIH1cblxuICBpZiAobmV3U3R5bGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV3U3R5bGUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnc3R5bGUnLCBuZXdTdHlsZSk7XG4gICAgfSBlbHNlIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnc3R5bGUnKTtcbiAgfVxufTtcblxuXG4vLyBUT0RPIGZpeGluZyBVUkxzIGlzIGFsc28gbmVlZGVkIHdoZXJlIHN0eWxlcyB1c2VzIHBhdGggKGUuZzogYmFja2dyb3VuZC1pbWFnZSwgQGltcG9ydClcbnZhciBfZml4UmVsYXRpdmVQYXRoID0gZnVuY3Rpb24oYXR0cmlidXRlLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgdmFyIHVybCA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpO1xuICB2YXIgbmV3VXJsID0gdGVtcGxhdGVVcmxDb252ZXJ0ZXIodXJsKTtcbiAgaWYgKG5ld1VybCAhPT0gbnVsbCkge1xuICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIG5ld1VybCk7XG4gIH1cbn07XG5cblxudmFyIHByb2Nlc3NCbG9jayA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRlZnMsIHRoZW1lVXBkYXRlciwgYmxvY2tQdXNoZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBjb250ZXh0TmFtZSwgcm9vdE1vZGVsTmFtZSwgY29udGFpbmVyTmFtZSwgZ2VuZXJhdGVVbmlxdWVJZCwgdGVtcGxhdGVDcmVhdG9yKSB7XG5cbiAgdHJ5IHtcblxuICB2YXIgdGVtcGxhdGVOYW1lO1xuICB2YXIgdmFyaWFudE5hbWUgPSAnJyxcbiAgICB2YXJpYW50RGVmID0gJyc7XG4gIGlmIChjb250ZXh0TmFtZSA9PSAnYmxvY2snKSB7XG4gICAgdGVtcGxhdGVOYW1lID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWJsb2NrJyk7XG4gICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWJsb2NrJyk7XG4gIH0gZWxzZSBpZiAoY29udGV4dE5hbWUgPT0gJ3RlbXBsYXRlJykge1xuICAgIHRlbXBsYXRlTmFtZSA9IHJvb3RNb2RlbE5hbWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJVbmV4cGVjdGVkIGNvbnRleHQgbmFtZSB3aGlsZSBwcm9jZXNzaW5nIGJsb2NrOiBcIiArIGNvbnRleHROYW1lO1xuICB9XG5cbiAgLy8gY29uc29sZS5sb2coXCJwcm9jZXNzQmxvY2tcIiwgY29udGV4dE5hbWUsIHJvb3RNb2RlbE5hbWUsIGNvbnRhaW5lck5hbWUsIHRlbXBsYXRlTmFtZSk7XG5cbiAgLy8gUmVtb3ZlIGVsZW1lbnRcbiAgJCgnW2RhdGEta28tcmVtb3ZlXScsIGVsZW1lbnQpLnJlbW92ZSgpO1xuXG4gIHZhciBmaXhlZEJsb2NrcyA9ICQoJ1tkYXRhLWtvLWJsb2NrXScsIGVsZW1lbnQpLnJlcGxhY2VXaXRoKCc8cmVwbGFjZWRibG9jaz4nKTtcblxuICAvLyBVcmxzIGluIHRoZXNlIGF0dHJpYnV0ZXMgbmVlZHMgXCJyZWxhdGl2aXphdGlvblwiXG4gIHZhciB1cmxhdHRycyA9IFsnaHJlZicsICdzcmMnLCAnZGF0YS1rby1wbGFjZWhvbGRlci1zcmMnLCAnYmFja2dyb3VuZCddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVybGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZmFjY2lvIGlsIGJpbmQgcGVyIG5vbiBkZWZpbmlyZSBmdW56aW9uaSBpbiB1biBsb29wIChqc2hpbnQpXG4gICAgdmFyIGZ1bmMgPSBfZml4UmVsYXRpdmVQYXRoLmJpbmQodW5kZWZpbmVkLCB1cmxhdHRyc1tpXSwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIpO1xuICAgICQoJ1snICsgdXJsYXR0cnNbaV0gKyAnXScsIGVsZW1lbnQpLmVhY2goZnVuYyk7XG4gIH1cblxuICB2YXIgZGF0YURlZnMgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcHJvcGVydGllcycpO1xuICBpZiAoZGF0YURlZnMgPT09IG51bGwpIGRhdGFEZWZzID0gXCJcIjtcbiAgJChcIltkYXRhLWtvLXByb3BlcnRpZXNdXCIsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICBpZiAoZGF0YURlZnMubGVuZ3RoID4gMCkgZGF0YURlZnMgPSBkYXRhRGVmcyArIFwiIFwiO1xuICAgIGRhdGFEZWZzID0gZGF0YURlZnMgKyBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tcHJvcGVydGllcycpO1xuICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wcm9wZXJ0aWVzJyk7XG4gIH0pO1xuXG4gIG1vZGVsRGVmLmNyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgdGVtcGxhdGVOYW1lLCBkYXRhRGVmcywgeyBjb250ZXh0TmFtZTogY29udGV4dE5hbWUgfSk7XG5cbiAgdmFyIGJpbmRpbmdQcm92aWRlciA9IG1vZGVsRGVmLmVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUuYmluZCh1bmRlZmluZWQsIGRlZnMsIHRoZW1lVXBkYXRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCAnJyk7XG4gIGlmIChjb250ZXh0TmFtZSA9PSAnYmxvY2snKSBiaW5kaW5nUHJvdmlkZXIoJ2lkJywgJycpO1xuXG4gICQoJ3N0eWxlJywgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHZhciBzdHlsZSA9IGRvbXV0aWxzLmdldElubmVySHRtbChlbGVtZW50KTtcblxuICAgIHZhciBibG9ja0RlZnNVcGRhdGVyID0gbW9kZWxEZWYuY3JlYXRlT3JVcGRhdGVCbG9ja0RlZi5iaW5kKHVuZGVmaW5lZCwgZGVmcyk7XG4gICAgdmFyIGxvY2FsV2l0aEJpbmRpbmdQcm92aWRlciA9IG1vZGVsRGVmLmVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUuYmluZCh1bmRlZmluZWQsIGRlZnMsIHRoZW1lVXBkYXRlciwgcm9vdE1vZGVsTmFtZSk7XG4gICAgdmFyIG5ld1N0eWxlID0gcHJvY2Vzc1N0eWxlc2hlZXRSdWxlcyhzdHlsZSwgdW5kZWZpbmVkLCBsb2NhbFdpdGhCaW5kaW5nUHJvdmlkZXIsIGJsb2NrRGVmc1VwZGF0ZXIsIHRoZW1lVXBkYXRlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSk7XG5cbiAgICBpZiAobmV3U3R5bGUgIT0gc3R5bGUpIHtcbiAgICAgIGlmIChuZXdTdHlsZS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIHZhciB0bXBOYW1lID0gdGVtcGxhdGVDcmVhdG9yKG5ld1N0eWxlKTtcbiAgICAgICAgZG9tdXRpbHMuc2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnLCAndGVtcGxhdGU6IHsgbmFtZTogXFwnJyArIHRtcE5hbWUgKyAnXFwnIH0nKTtcbiAgICAgICAgLy8gaG8gY3JlYXRvIGlsIHRlbXBsYXRlIHF1aW5kaSBwb3NzbyBzdnVvdGFyZSBpbCBzb3JnZW50ZS5cbiAgICAgICAgZG9tdXRpbHMuc2V0Q29udGVudChlbGVtZW50LCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgZW1wdHkgc3R5bGVzIGJsb2Nrc1xuICAgICAgICBkb211dGlscy5yZW1vdmVFbGVtZW50cygkKGVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHByb2Nlc3NTdHlsZShlbGVtZW50LCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgYmluZGluZ1Byb3ZpZGVyLCBnZW5lcmF0ZVVuaXF1ZUlkKTtcblxuICAvLyBUT0RPIGhyZWYgc2hvdWxkIGJlIHN1cHBvcnRlZC4gZGF0YS1rby1kaXNwbGF5IGFuZCBkYXRhLWtvLXdyYXAgc2hvdWxkIG5ldmVyIGhhcHBlbiBpbiBoZXJlLlxuICB2YXIgbm90c3VwcG9ydGVkID0gWydkYXRhLWtvLWRpc3BsYXknLCAnZGF0YS1rby1lZGl0YWJsZScsICdkYXRhLWtvLXdyYXAnLCAnaHJlZiddO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdHN1cHBvcnRlZC5sZW5ndGg7IGorKykge1xuICAgIHZhciBhdHRyID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsIG5vdHN1cHBvcnRlZFtqXSk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkVSUk9SOiBVbnN1cHBvcnRlZCBcIiArIG5vdHN1cHBvcnRlZFtqXSArIFwiIHVzZWQgdG9nZXRoZXIgd2l0aCBkYXRhLWtvLWJsb2NrXCIsIGVsZW1lbnQpO1xuICAgICAgdGhyb3cgXCJFUlJPUjogVW5zdXBwb3J0ZWQgXCIgKyBub3RzdXBwb3J0ZWRbal0gKyBcIiB1c2VkIHRvZ2V0aGVyIHdpdGggZGF0YS1rby1ibG9ja1wiO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNpbXBseSBwcmVwcm9jZXNzZWQgYXMgZGF0YS1rby13cmFwICsgLWtvLWF0dHItaHJlZlxuICAkKFwiW2RhdGEta28tbGlua11cIiwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHZhciB1cmxWYXIgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tbGluaycpO1xuICAgIHZhciByZXBTdHlsZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAncmVwbGFjZWRzdHlsZScpO1xuICAgIGlmICh0eXBlb2YgcmVwU3R5bGUgPT0gJ3VuZGVmaW5lZCcgfHwgcmVwU3R5bGUgPT09IG51bGwpIHJlcFN0eWxlID0gJyc7XG4gICAgaWYgKHJlcFN0eWxlICE9PSAnJykgcmVwU3R5bGUgPSAnLWtvLWF0dHItaHJlZjogQCcgKyB1cmxWYXIgKyBcIjsgXCIgKyByZXBTdHlsZTtcbiAgICBlbHNlIHJlcFN0eWxlID0gJy1rby1hdHRyLWhyZWY6IEAnICsgdXJsVmFyO1xuICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAncmVwbGFjZWRzdHlsZScsIHJlcFN0eWxlKTtcbiAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28td3JhcCcsIHVybFZhcik7XG4gICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWxpbmsnKTtcbiAgfSk7XG5cbiAgJChcIltyZXBsYWNlZHN0eWxlXVwiLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgcHJvY2Vzc1N0eWxlKGVsZW1lbnQsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBiaW5kaW5nUHJvdmlkZXIsIGZhbHNlKTtcbiAgfSk7XG5cbiAgJChcIltyZXBsYWNlZGh0dHAtZXF1aXZdXCIsIGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICByZXBsYWNlZEF0dHJpYnV0ZXMoZWxlbWVudCwgXCJodHRwLWVxdWl2XCIpO1xuICB9KTtcblxuICAkKFwiW2RhdGEta28tZGlzcGxheV1cIiwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHdyYXBFbGVtZW50V2l0aENvbmRpdGlvbignZGF0YS1rby1kaXNwbGF5JywgZWxlbWVudCwgYmluZGluZ1Byb3ZpZGVyKTtcbiAgfSk7XG5cbiAgJChcIltkYXRhLWtvLWVkaXRhYmxlXVwiLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIG5ld0JpbmRpbmcsIGRlZmF1bHRWYWx1ZSwgbW9kZWwsIGN1cnJlbnRCaW5kaW5ncywgZGF0YUJpbmQ7XG5cblxuICAgIHZhciBkYXRhRWRpdGFibGUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJkYXRhLWtvLWVkaXRhYmxlXCIpO1xuXG4gICAgLy8gVE9ETyBhZGQgdmFsaWRhdGlvbiBvZiB0aGUgZWRpdGFibGVcblxuICAgIHZhciBpdGVtQmluZFZhbHVlO1xuICAgIHZhciBzZWxlY3RCaW5kaW5nO1xuICAgIGlmIChkYXRhRWRpdGFibGUubGFzdEluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgIHZhciBzdWJzID0gZGF0YUVkaXRhYmxlLnN1YnN0cigwLCBkYXRhRWRpdGFibGUubGFzdEluZGV4T2YoJy4nKSk7XG4gICAgICBpdGVtQmluZFZhbHVlID0gYmluZGluZ1Byb3ZpZGVyKHN1YnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtQmluZFZhbHVlID0gYmluZGluZ1Byb3ZpZGVyKGRhdGFFZGl0YWJsZSk7XG4gICAgfVxuICAgIHNlbGVjdEJpbmRpbmcgPSBcInd5c2l3eWdDbGljazogZnVuY3Rpb24ob2JqLCBldnQpIHsgJHJvb3Quc2VsZWN0SXRlbShcIiArIGl0ZW1CaW5kVmFsdWUgKyBcIiwgJGRhdGEpOyByZXR1cm4gZmFsc2UgfSwgY2xpY2tCdWJibGU6IGZhbHNlLCB3eXNpd3lnQ3NzOiB7IHNlbGVjdGVkaXRlbTogJHJvb3QuaXNTZWxlY3RlZEl0ZW0oXCIgKyBpdGVtQmluZFZhbHVlICsgXCIpIH0sIHNjcm9sbEludG9WaWV3OiAkcm9vdC5pc1NlbGVjdGVkSXRlbShcIiArIGl0ZW1CaW5kVmFsdWUgKyBcIilcIjtcblxuICAgIGlmIChkb211dGlscy5nZXRMb3dlclRhZ05hbWUoZWxlbWVudCkgIT0gJ2ltZycpIHtcblxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSBkb211dGlscy5nZXRJbm5lckh0bWwoZWxlbWVudCk7XG4gICAgICB2YXIgbW9kZWxCaW5kVmFsdWUgPSBiaW5kaW5nUHJvdmlkZXIoZGF0YUVkaXRhYmxlLCBkZWZhdWx0VmFsdWUsIHRydWUsICd3eXNpd3lnJyk7XG4gICAgICBuZXdCaW5kaW5nID0gXCJcIjtcblxuICAgICAgaWYgKCFkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJpZFwiKSkge1xuICAgICAgICBuZXdCaW5kaW5nICs9IFwid3lzaXd5Z0lkOiBpZCgpKydfXCIgKyBkYXRhRWRpdGFibGUucmVwbGFjZSgnLicsICdfJykgKyBcIicsIFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdEJpbmRpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5ld0JpbmRpbmcgKz0gc2VsZWN0QmluZGluZyArIFwiLCBcIjtcbiAgICAgIH1cblxuICAgICAgbmV3QmluZGluZyArPSBcInd5c2l3eWdPckh0bWw6IFwiICsgbW9kZWxCaW5kVmFsdWU7XG5cbiAgICAgIGlmIChkb211dGlscy5nZXRMb3dlclRhZ05hbWUoZWxlbWVudCkgPT0gJ3RkJykge1xuICAgICAgICB2YXIgd3JhcHBpbmdEaXYgPSAkKCc8ZGl2IGRhdGEta28td3JhcD1cImZhbHNlXCIgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlXCI+PC9kaXY+JylbMF07XG4gICAgICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZSh3cmFwcGluZ0RpdiwgJ2RhdGEtYmluZCcsIG5ld0JpbmRpbmcpO1xuICAgICAgICB2YXIgbmV3Q29udGVudCA9IGRvbXV0aWxzLmdldElubmVySHRtbCgkKCc8ZGl2PjwvZGl2PicpLmFwcGVuZCh3cmFwcGluZ0RpdikpO1xuICAgICAgICBkb211dGlscy5zZXRDb250ZW50KGVsZW1lbnQsIG5ld0NvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudEJpbmRpbmdzID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWJpbmQnKTtcbiAgICAgICAgZGF0YUJpbmQgPSAoY3VycmVudEJpbmRpbmdzICE9PSBudWxsID8gY3VycmVudEJpbmRpbmdzICsgXCIsIFwiIDogXCJcIikgKyBuZXdCaW5kaW5nO1xuICAgICAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcsIGRhdGFCaW5kKTtcbiAgICAgICAgZG9tdXRpbHMuc2V0Q29udGVudChlbGVtZW50LCAnJyk7XG4gICAgICB9XG4gICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tZWRpdGFibGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdpZHRoID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICd3aWR0aCcpO1xuICAgICAgaWYgKHdpZHRoID09PSAnJykgd2lkdGggPSBudWxsO1xuICAgICAgaWYgKHdpZHRoID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFUlJPUjogZGF0YS1rby1lZGl0YWJsZSBpbWFnZXMgbXVzdCBkZWNsYXJlIGEgV0lEVEggYXR0cmlidXRlIVwiLCBlbGVtZW50KTtcbiAgICAgICAgdGhyb3cgXCJFUlJPUjogZGF0YS1rby1lZGl0YWJsZSBpbWFnZXMgbXVzdCBkZWNsYXJlIGEgV0lEVEggYXR0cmlidXRlIVwiO1xuICAgICAgfVxuICAgICAgdmFyIGhlaWdodCA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoaGVpZ2h0ID09PSAnJykgaGVpZ2h0ID0gbnVsbDtcblxuICAgICAgdmFyIGFsaWduID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdhbGlnbicpO1xuXG4gICAgICBjdXJyZW50QmluZGluZ3MgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcpO1xuXG4gICAgICAvLyBUT0RPIHRoaXMgaXMgdWdseS4uLiBtYXliZSBhIGJldHRlciBzdHJhdGVneSBpcyB0byBwYXNzIHRoaXMgYXJvdW5kIHVzaW5nIFwiZGF0YS1cIiBhdHRyaWJ1dGVzXG4gICAgICB2YXIgZHluSGVpZ2h0ID0gY3VycmVudEJpbmRpbmdzICYmIGN1cnJlbnRCaW5kaW5ncy5tYXRjaCgvdmlydHVhbEF0dHI6IHtbXn1dKiBoZWlnaHQ6IChbXix9XSopWyx9XS8pO1xuICAgICAgaWYgKGR5bkhlaWdodCkgaGVpZ2h0ID0gZHluSGVpZ2h0WzFdO1xuICAgICAgdmFyIGR5bldpZHRoID0gY3VycmVudEJpbmRpbmdzICYmIGN1cnJlbnRCaW5kaW5ncy5tYXRjaCgvdmlydHVhbEF0dHI6IHtbXn1dKiB3aWR0aDogKFteLH1dKilbLH1dLyk7XG4gICAgICBpZiAoZHluV2lkdGgpIHdpZHRoID0gZHluV2lkdGhbMV07XG5cbiAgICAgIHZhciBtZXRob2Q7XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wbGFjZWhvbGRlci1zcmMnKTtcbiAgICAgIC8vIFRPRE8gbWFrZSBzdXJlIHRoaXMgZGVmYXVsdCB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgb25lIGNoZWNrZWQgYnkgaW1nLXd5c2l3eWcgdGVtcGxhdGUuXG4gICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgIGlmIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ3NyYycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdzcmMnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpemU7XG4gICAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgIHNpemUgPSB3aWR0aCArIFwiKyd4JytcIiArIGhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoIWhlaWdodCkge1xuICAgICAgICBzaXplID0gXCIndycrXCIgKyB3aWR0aCArIFwiKycnXCI7XG4gICAgICB9IGVsc2UgaWYgKCF3aWR0aCkge1xuICAgICAgICBzaXplID0gXCInaCcrXCIgKyBoZWlnaHQgKyBcIisnJ1wiO1xuICAgICAgfVxuICAgICAgdmFyIHBsYWNlaG9sZGVyc3JjO1xuICAgICAgdmFyIHBsaGVpZ2h0ID0gaGVpZ2h0IHx8IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wbGFjZWhvbGRlci1oZWlnaHQnKTtcbiAgICAgIHZhciBwbHdpZHRoID0gd2lkdGggfHwgZG9tdXRpbHMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXBsYWNlaG9sZGVyLXdpZHRoJyk7XG5cbiAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnc3JjJyk7XG4gICAgICBkb211dGlscy5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tZWRpdGFibGUnKTtcbiAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wbGFjZWhvbGRlci1oZWlnaHQnKTtcbiAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby1wbGFjZWhvbGRlci13aWR0aCcpO1xuICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXBsYWNlaG9sZGVyLXNyYycpO1xuXG4gICAgICBpZiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyc3JjID0gXCJ7IHdpZHRoOiBcIiArIHBsd2lkdGggKyBcIiwgaGVpZ2h0OiBcIiArIHBsaGVpZ2h0ICsgXCIsIHRleHQ6IFwiICsgc2l6ZSArIFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBsd2lkdGggfHwgIXBsaGVpZ2h0KSB7XG4gICAgICAgIC8vIFRPRE8gcmFpc2UgYW4gZXhjZXB0aW9uP1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiSU1HIGRhdGEta28tZWRpdGFibGUgbXVzdCBkZWNsYXJlIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlcywgb3IgdGhlaXIgcGxhY2Vob2xkZXIgY291bnRlcnBhcnRzIGRhdGEta28tcGxhY2Vob2xkZXItd2lkdGgvZGF0YS1rby1wbGFjZWhvbGRlci1oZWlnaHRcIiwgZWxlbWVudCk7XG4gICAgICAgIHRocm93IFwiRVJST1I6IElNRyBkYXRhLWtvLWVkaXRhYmxlIE1VU1QgZGVjbGFyZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMsIG9yIHRoZWlyIHBsYWNlaG9sZGVyIGNvdW50ZXJwYXJ0cyBkYXRhLWtvLXBsYWNlaG9sZGVyLXdpZHRoL2RhdGEta28tcGxhY2Vob2xkZXItaGVpZ2h0XCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBiaW5kaW5nVmFsdWUgPSBiaW5kaW5nUHJvdmlkZXIoZGF0YUVkaXRhYmxlLCB2YWx1ZSwgZmFsc2UsICd3eXNpd3lnJyk7XG4gICAgICBuZXdCaW5kaW5nID0gXCJ3eXNpd3lnU3JjOiB7IHdpZHRoOiBcIiArIHdpZHRoICsgXCIsIGhlaWdodDogXCIgKyBoZWlnaHQgKyBcIiwgc3JjOiBcIiArIGJpbmRpbmdWYWx1ZSArIFwiLCBwbGFjZWhvbGRlcjogXCIgKyBwbGFjZWhvbGRlcnNyYyArIFwiIH1cIjtcbiAgICAgIGRhdGFCaW5kID0gKGN1cnJlbnRCaW5kaW5ncyAhPT0gbnVsbCA/IGN1cnJlbnRCaW5kaW5ncyArIFwiLCBcIiA6IFwiXCIpICsgbmV3QmluZGluZztcbiAgICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJywgZGF0YUJpbmQpO1xuXG4gICAgICB2YXIgdG1wbE5hbWUgPSB0ZW1wbGF0ZUNyZWF0b3IoZWxlbWVudCk7XG5cbiAgICAgIHZhciBjb250YWluZXJCaW5kID0gJ3sgd2lkdGg6ICcgKyB3aWR0aDtcbiAgICAgIGlmIChhbGlnbiA9PSAnbGVmdCcpIGNvbnRhaW5lckJpbmQgKz0gJywgZmxvYXQ6IFxcJ2xlZnRcXCcnO1xuICAgICAgZWxzZSBpZiAoYWxpZ24gPT0gJ3JpZ2h0JykgY29udGFpbmVyQmluZCArPSAnLCBmbG9hdDogXFwncmlnaHRcXCcnO1xuICAgICAgZWxzZSBpZiAoYWxpZ24gPT0gJ2NlbnRlcicpIGNvbnNvbGUubG9nKCdub24gc28gY29zYSBmYSBhbGlnbj1jZW50ZXIgc3UgdW5hIGltZyBlIHF1aW5kaSBub24gc28gY29tZSBzaW11bGFybmUgbFxcJ2VkaXRpbmcnKTtcbiAgICAgIGVsc2UgaWYgKGFsaWduID09ICd0b3AnKSBjb250YWluZXJCaW5kICs9ICcsIHZlcnRpY2FsQWxpZ246IFxcJ3RvcFxcJyc7XG4gICAgICBlbHNlIGlmIChhbGlnbiA9PSAnbWlkZGxlJykgY29udGFpbmVyQmluZCArPSAnLCB2ZXJ0aWNhbEFsaWduOiBcXCdtaWRkbGVcXCcnO1xuICAgICAgZWxzZSBpZiAoYWxpZ24gPT0gJ2JvdHRvbScpIGNvbnRhaW5lckJpbmQgKz0gJywgdmVydGljYWxBbGlnbjogXFwnYm90dG9tXFwnJztcbiAgICAgIGNvbnRhaW5lckJpbmQgKz0gJ30nO1xuXG4gICAgICAkKGVsZW1lbnQpLmJlZm9yZSgnPCEtLSBrbyB3eXNpd3lnSW1nOiB7IF9kYXRhOiAkZGF0YSwgX2l0ZW06ICcgKyBpdGVtQmluZFZhbHVlICsgJywgX3RlbXBsYXRlOiBcXCcnICsgdG1wbE5hbWUgKyAnXFwnLCBfZWRpdFRlbXBsYXRlOiBcXCdpbWctd3lzaXd5Z1xcJywgX3NyYzogJyArIGJpbmRpbmdWYWx1ZSArICcsIF93aWR0aDogJyArIHdpZHRoICsgJywgX2hlaWdodDogJyArIGhlaWdodCArICcsIF9hbGlnbjogJyArIChhbGlnbiA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6ICdcXCcnICsgYWxpZ24gKyAnXFwnJykgKyAnLCBfc2l6ZTogJyArIHNpemUgKyAnLCBfbWV0aG9kOiAnICsgbWV0aG9kICsgJywgX3BsYWNlaG9sZGVyc3JjOiAnICsgcGxhY2Vob2xkZXJzcmMgKyAnLCBfc3R5bGViaW5kOiAnICsgY29udGFpbmVyQmluZCArICcgfSAtLT4nKTtcbiAgICAgICQoZWxlbWVudCkuYWZ0ZXIoJzwhLS0gL2tvIC0tPicpO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBBcHBsaWVkIGFmdGVyIHRoZSBkYXRhLWVkaXRhYmxlIHNvIHRvIGF2b2lkIHByb2Nlc3NpbmcgaHJlZnMgZm9yIGVkaXRhYmxlIGNvbnRlbnRcbiAgJChcIltocmVmXVwiLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIGF0dHJWYWx1ZSA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnaHJlZicpO1xuICAgIHZhciBuZXdCaW5kaW5nID0gJ3d5c2l3eWdIcmVmOiBcXCcnICsgY29udmVydGVyVXRpbHMuYWRkU2xhc2hlcyhhdHRyVmFsdWUpICsgJ1xcJyc7XG4gICAgdmFyIGN1cnJlbnRCaW5kaW5ncyA9IGRvbXV0aWxzLmdldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJyk7XG4gICAgdmFyIGRhdGFCaW5kID0gKGN1cnJlbnRCaW5kaW5ncyAhPT0gbnVsbCA/IGN1cnJlbnRCaW5kaW5ncyArIFwiLCBcIiA6IFwiXCIpICsgbmV3QmluZGluZztcbiAgICBkb211dGlscy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcsIGRhdGFCaW5kKTtcbiAgfSk7XG5cbiAgJChcInJlcGxhY2VkYmxvY2tcIiwgZWxlbWVudCkuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgIHZhciBibG9ja0VsZW1lbnQgPSBmaXhlZEJsb2Nrc1tpbmRleF07XG5cbiAgICB2YXIgYmxvY2tOYW1lID0gcHJvY2Vzc0Jsb2NrKGJsb2NrRWxlbWVudCwgZGVmcywgdGhlbWVVcGRhdGVyLCBibG9ja1B1c2hlciwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsICdibG9jaycsIHRlbXBsYXRlTmFtZSwgY29udGFpbmVyTmFtZSwgdHJ1ZSwgdGVtcGxhdGVDcmVhdG9yKTtcbiAgICAvLyByZXBsYWNlZCBibG9ja3MgYXJlIGRlZmluZWQgaW4gdGhlIG1vZGVsIHJvb3RcbiAgICB2YXIgbW9kZWxCaW5kVmFsdWUgPSBtb2RlbERlZi5lbnN1cmVQYXRoQW5kR2V0QmluZFZhbHVlKGRlZnMsIHRoZW1lVXBkYXRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lLCAnJywgYmxvY2tOYW1lKTtcblxuICAgIC8vIHRoaXMgd2F5IHdlIGNhbGwgYmxvY2std3lzaXd5ZyBvciBibG9jay1zaG93IGFuZCBub3QgZGlyZWN0bHkgdGhlIHJpZ2h0IGJsb2NrXG4gICAgJChlbGVtZW50KS5iZWZvcmUoJzwhLS0ga28gYmxvY2s6IHsgZGF0YTogJyArIGNvbnZlcnRlclV0aWxzLmFkZFNsYXNoZXMobW9kZWxCaW5kVmFsdWUpICsgJywgdGVtcGxhdGU6IFxcJ2Jsb2NrXFwnIH0gLS0+Jyk7XG4gICAgJChlbGVtZW50KS5hZnRlcignPCEtLSAva28gLS0+Jyk7XG4gICAgJChlbGVtZW50KS5yZW1vdmUoKTtcbiAgfSk7XG5cbiAgLy8gVE9ETyBkbyB3ZSByZWFsbHkgbmVlZCB0byBsb29wIGluIHJldmVyc2Ugb3JkZXI/XG4gIC8vIGRhdGEta28td3JhcCBoYXZlIHRvIGJlIHByb2Nlc3NlZCBhdCB0aGUgZW5kLCBleHBlY2lhbGx5IGFmdGVyIFwicmVwbGFjZWJsb2Nrc1wiXG4gIC8vIG90aGVyd2lzZSBhIGRhdGEta28td3JhcCB3cmFwcGluZyBhIGRhdGEta28tYmxvY2sgd291bGQgYnJlYWsgZXZlcnl0aGluZy5cbiAgJCgkKFwiW2RhdGEta28td3JhcF1cIiwgZWxlbWVudCkuZ2V0KCkucmV2ZXJzZSgpLCBlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIGNvbmQgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28td3JhcCcpO1xuICAgIGlmICh0eXBlb2YgY29uZCA9PT0gJ3VuZGVmaW5lZCcgfHwgY29uZCA9PT0gJycgfHwgY29uZCA9PT0gJ3RydWUnKSB7XG4gICAgICB0aHJvdyBcIlVuc3VwcG9ydGVkIGVtcHR5IHZhbHVlIGZvciBkYXRhLWtvLXdyYXA6IHVzZSBmYWxzZSB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhbHdheXMgcmVtb3ZlIHRoZSB0YWdcIjtcbiAgICB9XG5cbiAgICB2YXIgY29uZEJpbmRpbmcgPSBjb252ZXJ0ZXJVdGlscy5jb25kaXRpb25CaW5kaW5nKGNvbmQsIGJpbmRpbmdQcm92aWRlcik7XG5cbiAgICAvKlxuICAgICAgICAgIHZhciBjb25kQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgY29uZCA9PT0gJ3VuZGVmaW5lZCcgfHwgY29uZCA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IFwiVW5zdXBwb3J0ZWQgZW1wdHkgdmFsdWUgZm9yIGRhdGEta28td3JhcDogdXNlIGZhbHNlIHZhbHVlIGlmIHlvdSB3YW50IHRvIGFsd2F5cyByZW1vdmUgdGhlIHRhZ1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgY29uZEJpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbmQgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgdGhyb3cgXCJVbnN1cHBvcnRlZCB0cnVlIHZhbHVlIGZvciBkYXRhLWtvLXdyYXAuIFRoaXMgbWFrZXMgbm8gc2Vuc2U6IHVzZSBmYWxzZSBvciBhIHZhcmlhYmxlXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmRCaW5kaW5nID0gYmluZGluZ1Byb3ZpZGVyKGNvbmQpKycoKSc7XG4gICAgICAgICAgfVxuICAgICovXG5cbiAgICB2YXIgZGF0YUJpbmQgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtYmluZCcpO1xuXG4gICAgdmFyIGlubmVyVG1wbE5hbWUsIG91dGVyVG1wbE5hbWU7XG4gICAgLy8gVE9ETyB1Z2x5IGhhcmRjb2RlZCBoYW5kbGluZzogYXQgdGhlIHZlcnkgbGVhc3QgdGhpcyBzaG91bGQgYmUgaW52b2tlZCBieSB0aGUgZGF0YS1jb250YWluZXIgY2FsbGVyLlxuICAgIGlmIChkYXRhQmluZCAhPT0gJycgJiYgZGF0YUJpbmQgIT09IG51bGwgJiYgZGF0YUJpbmQubWF0Y2goLyhibG9ja3x3eXNpd3lnT3JIdG1sKTovKSkge1xuICAgICAgLy8gd2UgY2FuJ3QgcHV0IHRoZSBjb250ZW50IGluIGEgdGVtcGxhdGUgYmVjYXVzZSBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBiaW5kaW5nXG4gICAgICB2YXIgaW5uZXJUbXBsQ29udGVudCA9ICc8IS0tIGtvICcgKyBkYXRhQmluZCArICcgLS0+JyArIGRvbXV0aWxzLmdldElubmVySHRtbChlbGVtZW50KSArICc8IS0tIC9rbyAtLT4nO1xuICAgICAgaW5uZXJUbXBsTmFtZSA9IHRlbXBsYXRlQ3JlYXRvcihpbm5lclRtcGxDb250ZW50KTtcbiAgICAgIGRvbXV0aWxzLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1rby13cmFwJyk7XG4gICAgICBvdXRlclRtcGxOYW1lID0gdGVtcGxhdGVDcmVhdG9yKGVsZW1lbnQpO1xuICAgICAgZG9tdXRpbHMucmVwbGFjZUh0bWwoZWxlbWVudCwgJzwhLS0ga28gdGVtcGxhdGU6IC8qIHNwZWNpYWwgKi8gKHR5cGVvZiB0ZW1wbGF0ZU1vZGUgIT0gXFwndW5kZWZpbmVkXFwnICYmIHRlbXBsYXRlTW9kZSA9PSBcXCd3eXNpd3lnXFwnKSB8fCAnICsgY29uZEJpbmRpbmcgKyAnID8gXFwnJyArIG91dGVyVG1wbE5hbWUgKyAnXFwnIDogXFwnJyArIGlubmVyVG1wbE5hbWUgKyAnXFwnIC0tPjwhLS0gL2tvIC0tPicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBwdXQgdGhlIGNvbnRlbnQgaW4gYSB0ZW1wbGF0ZSBhbmQgdGhlIGZyYW1lIGluIGFub3RoZXIgdGVtcGxhdGUgaW5jbHVkaW5nIHRoaXMgb25lLlxuICAgICAgaW5uZXJUbXBsTmFtZSA9IHRlbXBsYXRlQ3JlYXRvcihkb211dGlscy5nZXRJbm5lckh0bWwoZWxlbWVudCkpO1xuICAgICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLXdyYXAnKTtcbiAgICAgIGRvbXV0aWxzLnNldENvbnRlbnQoZWxlbWVudCwgJzwhLS0ga28gdGVtcGxhdGU6IFxcJycgKyBpbm5lclRtcGxOYW1lICsgJ1xcJyAtLT48IS0tIC9rbyAtLT4nKTtcbiAgICAgIG91dGVyVG1wbE5hbWUgPSB0ZW1wbGF0ZUNyZWF0b3IoZWxlbWVudCk7XG4gICAgICBkb211dGlscy5yZXBsYWNlSHRtbChlbGVtZW50LCAnPCEtLSBrbyB0ZW1wbGF0ZTogKHR5cGVvZiB0ZW1wbGF0ZU1vZGUgIT0gXFwndW5kZWZpbmVkXFwnICYmIHRlbXBsYXRlTW9kZSA9PSBcXCd3eXNpd3lnXFwnKSB8fCAnICsgY29uZEJpbmRpbmcgKyAnID8gXFwnJyArIG91dGVyVG1wbE5hbWUgKyAnXFwnIDogXFwnJyArIGlubmVyVG1wbE5hbWUgKyAnXFwnIC0tPjwhLS0gL2tvIC0tPicpO1xuICAgIH1cblxuICB9KTtcblxuICB0ZW1wbGF0ZUNyZWF0b3IoZWxlbWVudCwgdGVtcGxhdGVOYW1lLCAnc2hvdycpO1xuXG4gIGJsb2NrUHVzaGVyKHJvb3RNb2RlbE5hbWUsIHRlbXBsYXRlTmFtZSwgY29udGV4dE5hbWUsIGNvbnRhaW5lck5hbWUpO1xuXG4gIHJldHVybiB0ZW1wbGF0ZU5hbWU7XG5cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFeGNlcHRpb24gd2hpbGUgcGFyc2luZyB0aGUgdGVtcGxhdGVcIiwgZSwgZWxlbWVudCk7XG4gICAgdGhyb3cgZTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBjb25kaXRpb25hbF9yZXBsYWNlKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgvPCEtLVxcW2lmIChbXlxcXV0qKVxcXT4oW1xcc1xcU10qPyk8IVxcW2VuZGlmXFxdLS0+L2csIGZ1bmN0aW9uKG1hdGNoLCBjb25kaXRpb24sIGJvZHkpIHtcbiAgICB2YXIgZGQgPSAnPCEtLSBjYzpzdGFydCAtLT4nO1xuICAgIGRkICs9IGJvZHkucmVwbGFjZSgvPChcXC8/KShbQS1aYS16XSopL2csICc8JDFjYyQyJykucmVwbGFjZSgvPFxcLyhbXj5dKik+L2csJzwhLS0gY2M6YmVmb3JlOiQxIC0tPjwvJDE+PCEtLSBjYzphZnRlcjokMSAtLT4nKTtcbiAgICBkZCArPSAnPCEtLSBjYzplbmQgLS0+JztcbiAgICB2YXIgb3V0cHV0ID0gJzxyZXBsYWNlZGNjIGNvbmRpdGlvbj1cIicrY29uZGl0aW9uKydcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmVcIj4nO1xuICAgIG91dHB1dCArPSAkKCc8ZGl2PicpLmFwcGVuZCgkKGRkKSkuaHRtbCgpLnJlcGxhY2UoLzwhLS0gY2M6YmVmb3JlOihbXiBdKikgLS0+PFxcL1xcMT48IS0tIGNjOmFmdGVyOlxcMSAtLT4vZywgJzwvJDE+JylcbiAgICAgIC5yZXBsYWNlKC9ePCEtLSBjYzpzdGFydCAtLT4vLCAnJylcbiAgICAgIC5yZXBsYWNlKC88IS0tIGNjOmVuZCAtLT4kLywgJycpO1xuICAgIG91dHB1dCArPSAnPC9yZXBsYWNlZGNjPic7XG4gICAgLy8gY29uc29sZS5sb2coXCJSZXR1cm5pbmcgZW1wdHkgc3RyaW5nIGluc3RlYWQgb2ZcIiwgb3V0cHV0KTtcbiAgICAvLyBpZiAodHJ1ZSkgcmV0dXJuICcnO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0pO1xufVxuXG5cbnZhciB0cmFuc2xhdGVUZW1wbGF0ZSA9IGZ1bmN0aW9uKHRlbXBsYXRlTmFtZSwgaHRtbCwgdGVtcGxhdGVVcmxDb252ZXJ0ZXIsIHRlbXBsYXRlQ3JlYXRvcikge1xuICB2YXIgZGVmcyA9IHt9O1xuICB2YXIgcmVwbGFjZWRIdG1sID0gY29uZGl0aW9uYWxfcmVwbGFjZShodG1sLnJlcGxhY2UoLyg8W14+XStcXHMpKHN0eWxlfGh0dHAtZXF1aXYpKD1cIlteXCJdKlwiW14+XSo+KS9naSwgZnVuY3Rpb24obWF0Y2gsIHAxLCBwMiwgcDMpIHtcbiAgICByZXR1cm4gcDEgKyAncmVwbGFjZWQnICsgcDIgKyBwMztcbiAgfSkpO1xuICB2YXIgY29udGVudCA9ICQocmVwbGFjZWRIdG1sKTtcbiAgdmFyIGVsZW1lbnQgPSBjb250ZW50WzBdO1xuXG4gIHZhciBibG9ja3MgPSBbXTsgLy8ge3Jvb3ROYW1lLCBibG9ja05hbWUsIGNvbnRhaW5lck5hbWV9XG4gIHZhciBfYmxvY2tQdXNoZXIgPSBmdW5jdGlvbihyb290TmFtZSwgYmxvY2tOYW1lLCBjb250ZXh0TmFtZSwgY29udGFpbmVyTmFtZSkge1xuICAgIGJsb2Nrcy5wdXNoKHtcbiAgICAgIHJvb3Q6IHJvb3ROYW1lLFxuICAgICAgYmxvY2s6IGJsb2NrTmFtZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHROYW1lLFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXJOYW1lXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyBoYXZlIHRvIGFjY2VwdCBudWxscyBhcyB1bmRlZmluZWRzIChiZWNhdXNlIG9mIG1vZGVsLmpzIGJlaGF2aW91cilcbiAgdmFyIHRoZW1lVXBkYXRlciA9IGZ1bmN0aW9uKG5hbWUsIGtleSwgdmFsKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZzWyd0aGVtZXMnXSA9PT0gJ3VuZGVmaW5lZCcpIGRlZnNbJ3RoZW1lcyddID0ge307XG4gICAgaWYgKHR5cGVvZiBkZWZzWyd0aGVtZXMnXVtuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIGRlZnNbJ3RoZW1lcyddW25hbWVdID0ge307XG4gICAgaWYgKHR5cGVvZiBkZWZzWyd0aGVtZXMnXVtuYW1lXVtrZXldID09PSAndW5kZWZpbmVkJyB8fCBkZWZzWyd0aGVtZXMnXVtuYW1lXVtrZXldID09PSBudWxsKSBkZWZzWyd0aGVtZXMnXVtuYW1lXVtrZXldID0gdmFsO1xuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZWNWYWwgPSBkZWZzWyd0aGVtZXMnXVtuYW1lXVtrZXldO1xuICAgICAgaWYgKHByZWNWYWwgIT0gdmFsKSBjb25zb2xlLmxvZyhcIkVycm9yIHNldHRpbmcgYSBuZXcgZGVmYXVsdCBmb3IgcHJvcGVydHkgXCIgKyBrZXkgKyBcIiBpbiB0aGVtZSBcIiArIG5hbWUgKyBcIi4gb2xkOlwiICsgcHJlY1ZhbCArIFwiIG5ldzpcIiArIHZhbCArIFwiIVwiKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNvbnRhaW5lcnMgPSAkKFwiW2RhdGEta28tY29udGFpbmVyXVwiLCBjb250ZW50KTtcbiAgdmFyIGNvbnRhaW5lcnNEb20gPSB7fTtcbiAgY29udGFpbmVycy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIGNvbnRhaW5lck5hbWUgPSBkb211dGlscy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEta28tY29udGFpbmVyJykgKyBcIkJsb2Nrc1wiO1xuXG4gICAgZG9tdXRpbHMucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLWtvLWNvbnRhaW5lcicpO1xuICAgIGRvbXV0aWxzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS1iaW5kJywgJ2Jsb2NrOiAnICsgY29udGFpbmVyTmFtZSk7XG5cbiAgICB2YXIgY29udGFpbmVyQmxvY2tzID0gJChcIj4gW2RhdGEta28tYmxvY2tdXCIsIGVsZW1lbnQpO1xuICAgIGRvbXV0aWxzLnJlbW92ZUVsZW1lbnRzKGNvbnRhaW5lckJsb2NrcywgdHJ1ZSk7XG5cbiAgICBjb250YWluZXJzRG9tW2NvbnRhaW5lck5hbWVdID0gY29udGFpbmVyQmxvY2tzO1xuICB9KTtcblxuICAvLyBUT0RPIHJlbW92ZSBoYXJkY29kZWQgcHJvcGVydGllczogd2UgbmVlZCB0aGVtIGJlY2F1c2Ugd2l0aG91dCB0aGVzZSBsb2FkaW5nIGEgYmFzaWMgdGVtcGxhdGUgZmFpbHMuXG4gIC8vIE5lZWRlZCBpbiBvcmRlciB0byB1c2UgZGF0YS1rby1ibG9ja1xuICBtb2RlbERlZi5jcmVhdGVPclVwZGF0ZUJsb2NrRGVmKGRlZnMsICdpZCcpO1xuICAvLyBOZWVkZWQgYWx3YXlzIGFzIGl0IGlzIHRoZSBkZWZhdWx0IHRoZW1lIHNlY3Rpb24uXG4gIG1vZGVsRGVmLmNyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgJ2JvZHlUaGVtZScpO1xuICAvLyBOZWVkZWQgZm9yIGRhdGEta28tY29udGFpbmVyXG4gIG1vZGVsRGVmLmNyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgJ2Jsb2NrcycsICdibG9ja3NbXScpO1xuXG4gIC8vIE5lZWRlZCBpZiB5b3Ugd2FudCB0byB1c2UgYSB0ZXh0IHZhcmlhYmxlPyBUT0RPIHRoaXMgc2hvdWxkIG5vdCBiZSBuZWVkZWQhXG4gIG1vZGVsRGVmLmNyZWF0ZU9yVXBkYXRlQmxvY2tEZWYoZGVmcywgJ3RleHQnKTtcblxuICBwcm9jZXNzQmxvY2soZWxlbWVudCwgZGVmcywgdGhlbWVVcGRhdGVyLCBfYmxvY2tQdXNoZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCAndGVtcGxhdGUnLCB0ZW1wbGF0ZU5hbWUsIHVuZGVmaW5lZCwgZmFsc2UsIHRlbXBsYXRlQ3JlYXRvcik7XG5cbiAgdmFyIGJsb2NrUHJvY2VzcyA9IGZ1bmN0aW9uKGNvbnRhaW5lck5hbWUsIGluZGV4LCBlbGVtZW50KSB7XG4gICAgcHJvY2Vzc0Jsb2NrKGVsZW1lbnQsIGRlZnMsIHRoZW1lVXBkYXRlciwgX2Jsb2NrUHVzaGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgJ2Jsb2NrJywgdGVtcGxhdGVOYW1lLCBjb250YWluZXJOYW1lLCB0cnVlLCB0ZW1wbGF0ZUNyZWF0b3IpO1xuICB9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gY29udGFpbmVyc0RvbSlcbiAgICBpZiAoY29udGFpbmVyc0RvbS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIGNvbnRhaW5lckJsb2NrcyA9IGNvbnRhaW5lcnNEb21bcHJvcF07XG4gICAgICB2YXIgY29udGFpbmVyTmFtZSA9IHByb3A7XG5cbiAgICAgIG1vZGVsRGVmLmVuc3VyZVBhdGhBbmRHZXRCaW5kVmFsdWUoZGVmcywgdGhlbWVVcGRhdGVyLCB0ZW1wbGF0ZU5hbWUsIHRlbXBsYXRlTmFtZSwgJycsIGNvbnRhaW5lck5hbWUgKyBcIi5ibG9ja3NcIiwgXCJbXVwiKTtcblxuICAgICAgY29udGFpbmVyQmxvY2tzLmVhY2goYmxvY2tQcm9jZXNzLmJpbmQodW5kZWZpbmVkLCBjb250YWluZXJOYW1lKSk7XG4gICAgfVxuXG4gIHZhciB0ZW1wbGF0ZURlZiA9IHtcbiAgICBfZGVmczogZGVmcyxcbiAgICB0ZW1wbGF0ZU5hbWU6IHRlbXBsYXRlTmFtZSxcbiAgICBfYmxvY2tzOiBibG9ja3NcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZnNbdGVtcGxhdGVOYW1lXS5fdmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0ZW1wbGF0ZURlZi52ZXJzaW9uID0gZGVmc1t0ZW1wbGF0ZU5hbWVdLl92ZXJzaW9uO1xuICB9XG5cbiAgcmV0dXJuIHRlbXBsYXRlRGVmO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zbGF0ZVRlbXBsYXRlOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBQYXJzZXMgQ1NTL3N0eWxlc2hlZXRzIGRlY2xhcmF0aW9ucyAta28tYmxvY2tkZWZzLy1rby10aGVtZXNcbi8vIEl0IHJldHVybnMgS08gYmluZGluZ3MgYnV0IGRvZXNuJ3QgZGVwZW5kIG9uIEtPXG4vLyBOZWVkcyBhIGJpbmRpbmdQcm92aWRlclxuLy8gQWxzbyB1c2VzIGEgYmxvY2tEZWZzVXBkYXRlciB0byB1cGRhdGUgZGVmaW5pdGlvbnMgd2hpbGUgcGFyc2luZyB0aGUgc3R5bGVzaGVldC5cblxudmFyIGNzc1BhcnNlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9tZW5zY2gvbGliL3BhcnNlci5qc1wiKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIgY29udmVydGVyVXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbnZhciBlbGFib3JhdGVEZWNsYXJhdGlvbnMgPSByZXF1aXJlKFwiLi9kZWNsYXJhdGlvbnMuanNcIik7XG5cbi8qIFRlbXBvcmFyeSBleHBlcmltZW50YWwgY29kZSBub3QgdXNlZFxudmFyIF9wcm9jZXNzU3R5bGVTaGVldFJ1bGVzX3Byb2Nlc3NUaGVtZXMgPSBmdW5jdGlvbiAoYmluZGluZ1Byb3ZpZGVyLCB0aGVtZVVwZGF0ZXIsIHJ1bGVzKSB7XG4gIHZhciBzZWxzLCBkZWNscywgaSwgaiwgaztcbiAgZm9yKCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJ1bGVzW2ldLnR5cGUgPT0gJ3J1bGUnKSB7XG4gICAgICBzZWxzID0gcnVsZXNbaV0uc2VsZWN0b3JzO1xuICAgICAgZGVjbHMgPSBydWxlc1tpXS5kZWNsYXJhdGlvbnM7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc2Vscy5sZW5ndGg7IGorKykge1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZGVjbHMubGVuZ3RoOyBrKyspIGlmIChkZWNsc1trXS50eXBlID09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGJpbmRWYWwgPSBiaW5kaW5nUHJvdmlkZXIoJyQnK2RlY2xzW2tdLm5hbWUpO1xuICAgICAgICAgICAgdGhlbWVVcGRhdGVyKHNlbHNbal0sIGRlY2xzW2tdLm5hbWUsIGRlY2xzW2tdLnZhbHVlLCBiaW5kVmFsKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkV4Y2VwdGlvbiBzZXR0aW5nIHRoZW1lIGZvclwiLCBkZWNsc1trXS5uYW1lLCBkZWNsc1trXS52YWx1ZSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuKi9cblxudmFyIF9wcm9jZXNzU3R5bGVTaGVldFJ1bGVzX3Byb2Nlc3NCbG9ja0RlZiA9IGZ1bmN0aW9uKGJsb2NrRGVmc1VwZGF0ZXIsIHJ1bGVzKSB7XG4gIHZhciBwcm9wZXJ0aWVzLCBuYW1lZFByb3BzLCBkZWNscztcbiAgLy8gbmFtZSwgY29udGV4dE5hbWUsIGdsb2JhbFN0eWxlLCB0aGVtZU92ZXJyaWRlLCBleHRlbmQsIG1pbiwgbWF4LCB3aWRnZXQsIG9wdGlvbnMsIGNhdGVnb3J5LCB2YXJpYW50LCBoZWxwLCBibG9ja0Rlc2NyaXB0aW9uLCB2ZXJzaW9uLCBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChydWxlc1tpXS50eXBlID09ICdydWxlJykge1xuICAgICAgdmFyIHNlbHMgPSBydWxlc1tpXS5zZWxlY3RvcnM7XG4gICAgICB2YXIgaGFzRGVjbGFyYXRpb25zID0gZmFsc2U7XG4gICAgICB2YXIgaGFzUHJldmlld3MgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2Vscy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoc2Vsc1tqXS5tYXRjaCgvOnByZXZpZXckLykpIHtcbiAgICAgICAgICBoYXNQcmV2aWV3cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzRGVjbGFyYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc1ByZXZpZXdzICYmIGhhc0RlY2xhcmF0aW9ucykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNhbm5vdCBtaXggc2VsZWN0b3JzIHR5cGUgKDpwcmV2aWV3IGFuZCBkZWNsYXJhdGlvbnMpIGluIEBzdXBwb3J0cyAta28tYmxvY2tkZWZzIFwiLCBzZWxzKTtcbiAgICAgICAgdGhyb3cgXCJDYW5ub3QgbWl4IHNlbGVjdG9ycyB0eXBlICg6cHJldmlldyBhbmQgZGVjbGFyYXRpb25zKSBpbiBAc3VwcG9ydHMgLWtvLWJsb2NrZGVmc1wiO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNQcmV2aWV3cyAmJiAhaGFzRGVjbGFyYXRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY2Fubm90IGZpbmQga25vd24gc2VsZWN0b3JzIGluIEBzdXBwb3J0cyAta28tYmxvY2tkZWZzIFwiLCBzZWxzKTtcbiAgICAgICAgdGhyb3cgXCJDYW5ub3QgZmluZCBrbm93biBzZWxlY3RvcnMgaW4gQHN1cHBvcnRzIC1rby1ibG9ja2RlZnNcIjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNEZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcyA9ICcnO1xuICAgICAgICBuYW1lZFByb3BzID0ge307XG5cbi8qXG4gICAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRleHROYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBnbG9iYWxTdHlsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhlbWVPdmVycmlkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZXh0ZW5kID0gdW5kZWZpbmVkO1xuICAgICAgICBtYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIG1pbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgd2lkZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICBjYXRlZ29yeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyaWFudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaGVscCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYmxvY2tEZXNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgKi9cbiAgICAgICAgZGVjbHMgPSBydWxlc1tpXS5kZWNsYXJhdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGVjbHMubGVuZ3RoOyBrKyspIGlmIChkZWNsc1trXS50eXBlID09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICBpZiAoZGVjbHNba10ubmFtZSA9PSAnbGFiZWwnKSBuYW1lZFByb3BzLm5hbWUgPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICdjb250ZXh0JykgbmFtZWRQcm9wcy5jb250ZXh0TmFtZSA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ3Byb3BlcnRpZXMnKSBwcm9wZXJ0aWVzID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAndGhlbWUnKSBuYW1lZFByb3BzLmdsb2JhbFN0eWxlID0gJ190aGVtZV8uJyArIGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ3RoZW1lT3ZlcnJpZGUnKSBuYW1lZFByb3BzLnRoZW1lT3ZlcnJpZGUgPSBTdHJpbmcoZGVjbHNba10udmFsdWUpLnRvTG93ZXJDYXNlKCkgPT0gJ3RydWUnO1xuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ2V4dGVuZCcpIGV4dGVuZCA9IGRlY2xzW2tdLnZhbHVlO1xuXG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnbWF4JykgbWF4ID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnbWluJykgbWluID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnb3B0aW9ucycpIG9wdGlvbnMgPSBkZWNsc1trXS52YWx1ZTtcblxuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ3dpZGdldCcpIHdpZGdldCA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ2NhdGVnb3J5JykgY2F0ZWdvcnkgPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICd2YXJpYW50JykgdmFyaWFudCA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIC8vIGVsc2UgaWYgKGRlY2xzW2tdLm5hbWUgPT0gJ2hlbHAnKSBoZWxwID0gZGVjbHNba10udmFsdWU7XG4gICAgICAgICAgLy8gZWxzZSBpZiAoZGVjbHNba10ubmFtZSA9PSAnYmxvY2tEZXNjcmlwdGlvbicpIGJsb2NrRGVzY3JpcHRpb24gPSBkZWNsc1trXS52YWx1ZTtcbiAgICAgICAgICAvLyBlbHNlIGlmIChkZWNsc1trXS5uYW1lID09ICd2ZXJzaW9uJykgdmVyc2lvbiA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFtZWRQcm9wc1tkZWNsc1trXS5uYW1lXSA9IGRlY2xzW2tdLnZhbHVlO1xuICAgICAgICAgICAgLy8gVE9ETyBpbiBwYXN0IHdlIGRldGVjdGVkIHVuc3VwcG9ydGVkIHByb3BlcnRpZXMsIHdoaWxlIG5vdyB3ZSBzaW1wbGUgcHVzaCBldmVyeSBkZWNsYXJhdGlvbiBpbiBhIG5hbWVkUHJvcGVydHkuXG4gICAgICAgICAgICAvLyBUaGlzIG1ha2UgaXQgaGFyZGVyIHRvIHNwb3QgZXJyb3JzIGluIGRlY2xhcmF0aW9ucy5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcIlVua25vd24gcHJvcGVydHkgcHJvY2Vzc2luZyBAc3VwcG9ydHMgLWtvLWJsb2NrZGVmcyBcIiwgZGVjbHNba10sIHNlbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNlbHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICBibG9ja0RlZnNVcGRhdGVyKHNlbHNbbF0sIHByb3BlcnRpZXMsIG5hbWVkUHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzUHJldmlld3MpIHtcbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBzZWxzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgICAgdmFyIGxvY2FsQmxvY2tOYW1lID0gc2Vsc1ttXS5zdWJzdHIoMCwgc2Vsc1ttXS5pbmRleE9mKCc6JykpO1xuICAgICAgICAgIHZhciBwcmV2aWV3QmluZGluZ3MgPSBydWxlc1tpXS5kZWNsYXJhdGlvbnM7XG4gICAgICAgICAgYmxvY2tEZWZzVXBkYXRlcihsb2NhbEJsb2NrTmFtZSwgdW5kZWZpbmVkLCB7IHByZXZpZXdCaW5kaW5nczogcHJldmlld0JpbmRpbmdzIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWdub3JpbmcgY29tbWVudHMgb3Igb3RoZXIgY29udGVudFxuICAgIH1cbiAgfVxufTtcblxudmFyIHByb2Nlc3NTdHlsZXNoZWV0UnVsZXMgPSBmdW5jdGlvbihzdHlsZSwgcnVsZXMsIGxvY2FsV2l0aEJpbmRpbmdQcm92aWRlciwgYmxvY2tEZWZzVXBkYXRlciwgdGhlbWVVcGRhdGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgcm9vdE1vZGVsTmFtZSwgdGVtcGxhdGVOYW1lKSB7XG4gIHZhciBuZXdTdHlsZSA9IHN0eWxlO1xuICB2YXIgbGFzdFN0YXJ0ID0gbnVsbDtcblxuICBpZiAodHlwZW9mIHJ1bGVzID09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHN0eWxlU2hlZXQgPSBjc3NQYXJzZShzdHlsZSwge1xuICAgICAgY29tbWVudHM6IHRydWUsXG4gICAgICBwb3NpdGlvbjogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChzdHlsZVNoZWV0LnR5cGUgIT0gJ3N0eWxlc2hlZXQnIHx8IHR5cGVvZiBzdHlsZVNoZWV0LnN0eWxlc2hlZXQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwidW5hYmxlIHRvIHByb2Nlc3Mgc3R5bGVTaGVldFwiLCBzdHlsZVNoZWV0KTtcbiAgICAgIHRocm93IFwiVW5hYmxlIHRvIHBhcnNlIHN0eWxlc2hlZXRcIjtcbiAgICB9XG4gICAgcnVsZXMgPSBzdHlsZVNoZWV0LnN0eWxlc2hlZXQucnVsZXM7XG4gIH1cblxuICAvLyBXQVJOIGN1cnJlbmx0eSB0aGlzIHBhcnNlcyBydWxlcyBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgc3RyaW5nIHJlcGxhY2VtZW50cyB3b3JrcyB1c2luZyBpbnB1dCBcInBvc2l0aW9uc1wiXG4gIC8vIG90aGVyd2lzZSBpdCBzaG91bGQgY29tcHV0ZSBuZXcgb2Zmc2V0cyBvbiBldmVyeSByZXBsYWNlbWVudC5cbiAgLy8gQnV0IHRoaXMgY3JlYXRlIGlzc3VlcyBiZWNhdXNlIG9mIGRlZmluaXRpb25zIGJlaW5nIHBhcnNlZCBpbiByZXZlcnNlIG9yZGVyLCBzbyB0aGlzIGlzIG5vdCBhIGdvb2QgaWRlYS5cbiAgLy8gU29tZXRpbWVzLCB0byB3b3JrIGFyb3VuZCB0aGlzIGlzc3VlcywgeW91IG5lZWQgdG8gY3JlYXRlIDIgZGlmZmVyZW50IDxzdHlsZT4gYmxvY2tzLlxuICB2YXIgYmluZGluZ1Byb3ZpZGVyO1xuXG4gIGZvciAodmFyIGkgPSBydWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChydWxlc1tpXS50eXBlID09ICdzdXBwb3J0cycgJiYgcnVsZXNbaV0ubmFtZSA9PSAnLWtvLWJsb2NrZGVmcycpIHtcbiAgICAgIF9wcm9jZXNzU3R5bGVTaGVldFJ1bGVzX3Byb2Nlc3NCbG9ja0RlZihibG9ja0RlZnNVcGRhdGVyLCBydWxlc1tpXS5ydWxlcyk7XG4gICAgICBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBydWxlc1tpXS5wb3NpdGlvbi5zdGFydCwgbGFzdFN0YXJ0LCAwLCAwLCAwLCAnJyk7XG4gICAgICAvKiB0ZW1wb3JhcnkgZXhwZXJpbWVudGFsIGNvZGUgbm90IHVzZWRcbiAgICAgIH0gZWxzZSBpZiAocnVsZXNbaV0udHlwZSA9PSAnc3VwcG9ydHMnICYmIHJ1bGVzW2ldLm5hbWUgPT0gJy1rby10aGVtZXMnKSB7XG4gICAgICAgIGJpbmRpbmdQcm92aWRlciA9IGxvY2FsV2l0aEJpbmRpbmdQcm92aWRlci5iaW5kKHRoaXMsICd0aGVtZScsICcnKTtcbiAgICAgICAgX3Byb2Nlc3NTdHlsZVNoZWV0UnVsZXNfcHJvY2Vzc1RoZW1lcyhiaW5kaW5nUHJvdmlkZXIsIHRoZW1lVXBkYXRlciwgcnVsZXNbaV0ucnVsZXMpO1xuICAgICAgICBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBydWxlc1tpXS5wb3NpdGlvbi5zdGFydCwgbGFzdFN0YXJ0LCAwLCAwLCAwLCAnJyk7XG4gICAgICAqL1xuICAgIH0gZWxzZSBpZiAocnVsZXNbaV0udHlwZSA9PSAnbWVkaWEnIHx8IHJ1bGVzW2ldLnR5cGUgPT0gJ3N1cHBvcnRzJykge1xuICAgICAgbmV3U3R5bGUgPSBwcm9jZXNzU3R5bGVzaGVldFJ1bGVzKG5ld1N0eWxlLCBydWxlc1tpXS5ydWxlcywgbG9jYWxXaXRoQmluZGluZ1Byb3ZpZGVyLCBibG9ja0RlZnNVcGRhdGVyLCB0aGVtZVVwZGF0ZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCByb290TW9kZWxOYW1lLCB0ZW1wbGF0ZU5hbWUpO1xuICAgIH0gZWxzZSBpZiAocnVsZXNbaV0udHlwZSA9PSAnY29tbWVudCcpIHtcbiAgICAgIC8vIGlnbm9yZSBjb21tZW50c1xuICAgIH0gZWxzZSBpZiAocnVsZXNbaV0udHlwZSA9PSAncnVsZScpIHtcbiAgICAgIHZhciBzZWxzID0gcnVsZXNbaV0uc2VsZWN0b3JzO1xuICAgICAgdmFyIG5ld1NlbCA9IFwiXCI7XG4gICAgICB2YXIgZm91bmRCbG9ja01hdGNoID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2Vscy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAobmV3U2VsLmxlbmd0aCA+IDApIG5ld1NlbCArPSBcIiwgXCI7XG4gICAgICAgIHZhciBtYXRjaCA9IHNlbHNbal0ubWF0Y2goL1xcW2RhdGEta28tYmxvY2s9KFteIF0qKVxcXS8pO1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoZm91bmRCbG9ja01hdGNoICE9PSBudWxsICYmIGZvdW5kQmxvY2tNYXRjaCAhPSBtYXRjaFsxXSkgdGhyb3cgXCJGb3VuZCBtdWx0aXBsZSBibG9jay1tYXRjaCBhdHRyaWJ1dGUgc2VsZWN0b3JzOiBjYW5ub3QgdHJhbnNsYXRlIGl0IChcIiArIGZvdW5kQmxvY2tNYXRjaCArIFwiIHZzIFwiICsgbWF0Y2hbMV0gKyBcIilcIjtcbiAgICAgICAgICBmb3VuZEJsb2NrTWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgICBuZXdTZWwgKz0gJzwhLS0ga28gdGV4dDogdGVtcGxhdGVNb2RlID09XFwnd3lzaXd5Z1xcJyA/IFxcJyNtYWluLXd5c2l3eWctYXJlYSBcXCcgOiBcXCdcXCcgLS0+PCEtLSAva28gLS0+JyArIHNlbHNbal07XG4gICAgICB9XG4gICAgICBpZiAoZm91bmRCbG9ja01hdGNoKSB7XG4gICAgICAgIHZhciBsb29wUHJlZml4ID0gJzwhLS0ga28gZm9yZWFjaDogJHJvb3QuZmluZE9iamVjdHNPZlR5cGUoJGRhdGEsIFxcJycgKyBmb3VuZEJsb2NrTWF0Y2ggKyAnXFwnKSAtLT4nO1xuICAgICAgICB2YXIgbG9vcFBvc3RmaXggPSAnPCEtLSAva28gLS0+JztcbiAgICAgICAgdmFyIGVuZCA9IGxhc3RTdGFydDtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBcIiBcIjtcbiAgICAgICAgaWYgKHJ1bGVzW2ldLmRlY2xhcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHJ1bGVzW2ldLmRlY2xhcmF0aW9uc1swXS5wb3NpdGlvbi5zdGFydC5saW5lICE9IHJ1bGVzW2ldLnBvc2l0aW9uLmVuZC5saW5lKSB7XG4gICAgICAgICAgICBzcGFjaW5nID0gXCJcXG5cIiArIChuZXcgQXJyYXkocnVsZXNbaV0ucG9zaXRpb24uc3RhcnQuY29sKSkuam9pbihcIiBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZCA9IHJ1bGVzW2ldLmRlY2xhcmF0aW9uc1tydWxlc1tpXS5kZWNsYXJhdGlvbnMubGVuZ3RoIC0gMV0ucG9zaXRpb24uZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IG51bGwpIG5ld1N0eWxlICs9IHNwYWNpbmcgKyBsb29wUG9zdGZpeDtcbiAgICAgICAgZWxzZSBpZiAoZW5kID09IGxhc3RTdGFydCkgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgZW5kLCBsYXN0U3RhcnQsIDAsIDAsIDAsIHNwYWNpbmcgKyBsb29wUG9zdGZpeCk7XG4gICAgICAgIGVsc2UgbmV3U3R5bGUgPSBjb252ZXJ0ZXJVdGlscy5yZW1vdmVTdHlsZShuZXdTdHlsZSwgZW5kLCBsYXN0U3RhcnQsIDAsIDAsIDAsIHNwYWNpbmcgKyAnfScgKyBzcGFjaW5nICsgbG9vcFBvc3RmaXgpO1xuICAgICAgICBuZXdTZWwgPSBsb29wUHJlZml4ICsgc3BhY2luZyArIG5ld1NlbC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxbZGF0YS1rby1ibG9jaz0nICsgZm91bmRCbG9ja01hdGNoICsgJ1xcXFxdJywgJ2cnKSwgJzwhLS0ga28gdGV4dDogXFwnI1xcJytpZCgpIC0tPicgKyBmb3VuZEJsb2NrTWF0Y2ggKyAnPCEtLSAva28gLS0+Jyk7XG5cbiAgICAgICAgYmxvY2tEZWZzVXBkYXRlcihmb3VuZEJsb2NrTWF0Y2gsICcnLCB7IGNvbnRleHROYW1lOiAnYmxvY2snIH0pO1xuICAgICAgfVxuICAgICAgLy8gVE9ETyBtZW5zY2ggdXBkYXRlICh1c2luZyBvcmlnaW5hbCBtZW5zY2ggbGlicmFyeSB3ZSBuZWVkZWQgdGhpcyBsaW5lLCB3aGlsZSB0aGUgcGF0Y2hlZCBvbmUgZG9lc24ndCBuZWVkIHRoaXMgY29kZSlcbiAgICAgIC8vIG5ld1NlbCArPSBcIiB7XCI7XG4gICAgICB2YXIgbG9jYWxCbG9ja05hbWUgPSBmb3VuZEJsb2NrTWF0Y2ggPyBmb3VuZEJsb2NrTWF0Y2ggOiB0ZW1wbGF0ZU5hbWU7XG4gICAgICBiaW5kaW5nUHJvdmlkZXIgPSBsb2NhbFdpdGhCaW5kaW5nUHJvdmlkZXIuYmluZCh0aGlzLCBsb2NhbEJsb2NrTmFtZSwgJycpO1xuICAgICAgdmFyIGVsYWJvcmF0ZWRTdHlsZSA9IGVsYWJvcmF0ZURlY2xhcmF0aW9ucyhuZXdTdHlsZSwgcnVsZXNbaV0uZGVjbGFyYXRpb25zLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgYmluZGluZ1Byb3ZpZGVyKTtcbiAgICAgIGlmIChlbGFib3JhdGVkU3R5bGUgIT09IG51bGwpIG5ld1N0eWxlID0gZWxhYm9yYXRlZFN0eWxlO1xuXG4gICAgICBuZXdTdHlsZSA9IGNvbnZlcnRlclV0aWxzLnJlbW92ZVN0eWxlKG5ld1N0eWxlLCBydWxlc1tpXS5wb3NpdGlvbi5zdGFydCwgcnVsZXNbaV0ucG9zaXRpb24uZW5kLCAwLCAwLCAwLCBuZXdTZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gcnVsZSB0eXBlXCIsIHJ1bGVzW2ldLnR5cGUsIFwid2hpbGUgcGFyc2luZyA8c3R5bGU+IHJ1bGVzXCIpO1xuICAgIH1cbiAgICBsYXN0U3RhcnQgPSBydWxlc1tpXS5wb3NpdGlvbi5zdGFydDtcbiAgfVxuICByZXR1cm4gbmV3U3R5bGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3NTdHlsZXNoZWV0UnVsZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xudmFyIGpzZXAgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2pzZXAvc3JjL2pzZXAuanNcIik7XG5cbmpzZXAuYWRkQmluYXJ5T3AoXCJvclwiLCAxKTtcbmpzZXAuYWRkQmluYXJ5T3AoXCJhbmRcIiwgMik7XG5qc2VwLmFkZEJpbmFyeU9wKFwiZXFcIiwgNik7XG5qc2VwLmFkZEJpbmFyeU9wKFwibmVxXCIsIDYpO1xuanNlcC5hZGRCaW5hcnlPcChcImx0XCIsIDcpO1xuanNlcC5hZGRCaW5hcnlPcChcImx0ZVwiLCA3KTtcbmpzZXAuYWRkQmluYXJ5T3AoXCJndFwiLCA3KTtcbmpzZXAuYWRkQmluYXJ5T3AoXCJndGVcIiwgNyk7XG5cbnZhciBhZGRTbGFzaGVzID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFxcIiddL2csICdcXFxcJCYnKS5yZXBsYWNlKC9cXHUwMDAwL2csICdcXFxcMCcpO1xufTtcblxudmFyIHJlbW92ZVN0eWxlID0gZnVuY3Rpb24oc3R5bGUsIHN0YXJ0UG9zLCBlbmRQb3MsIHNraXBSb3dzLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBpbnNlcnQpIHtcbiAgdmFyIHN0eWxlUm93cyA9IHN0eWxlLnNwbGl0KFwiXFxuXCIpO1xuICB2YXIgc3RhcnQgPSBzdGFydE9mZnNldDtcbiAgdmFyIGVuZCA9IGVuZE9mZnNldDtcbiAgZm9yICh2YXIgciA9IDEgKyBza2lwUm93czsgciA8IHN0YXJ0UG9zLmxpbmU7IHIrKykgc3RhcnQgKz0gc3R5bGVSb3dzW3IgLSAxIC0gc2tpcFJvd3NdLmxlbmd0aCArIDE7XG4gIHN0YXJ0ICs9IHN0YXJ0UG9zLmNvbDtcbiAgaWYgKGVuZFBvcyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIHIyID0gMSArIHNraXBSb3dzOyByMiA8IGVuZFBvcy5saW5lOyByMisrKSBlbmQgKz0gc3R5bGVSb3dzW3IyIC0gMSAtIHNraXBSb3dzXS5sZW5ndGggKyAxO1xuICAgIGVuZCArPSBlbmRQb3MuY29sO1xuICB9IGVsc2UgZW5kICs9IHN0eWxlLmxlbmd0aCArIDE7XG4gIHZhciBuZXdTdHlsZSA9IHN0eWxlLnN1YnN0cigwLCBzdGFydCAtIDEpICsgaW5zZXJ0ICsgc3R5bGUuc3Vic3RyKGVuZCAtIDEpO1xuICByZXR1cm4gbmV3U3R5bGU7XG59O1xuXG52YXIgZXhwcmVzc2lvbkdlbmVyYXRvciA9IGZ1bmN0aW9uKG5vZGUsIGJpbmRpbmdQcm92aWRlciwgZGVmVmFsKSB7XG4gIGZ1bmN0aW9uIG1hcE9wZXJhdG9yKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSAnb3InOlxuICAgICAgICByZXR1cm4gJ3x8JztcbiAgICAgIGNhc2UgJ2FuZCc6XG4gICAgICAgIHJldHVybiAnJiYnO1xuICAgICAgY2FzZSAnbHQnOlxuICAgICAgICByZXR1cm4gJzwnO1xuICAgICAgY2FzZSAnbHRlJzpcbiAgICAgICAgcmV0dXJuICc8PSc7XG4gICAgICBjYXNlICdndCc6XG4gICAgICAgIHJldHVybiAnPic7XG4gICAgICBjYXNlICdndGUnOlxuICAgICAgICByZXR1cm4gJz49JztcbiAgICAgIGNhc2UgJ2VxJzpcbiAgICAgICAgcmV0dXJuICc9PSc7XG4gICAgICBjYXNlICduZXEnOlxuICAgICAgICByZXR1cm4gJyE9JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW4obm9kZSwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIsIGRlZlZhbCkge1xuICAgIGlmICh0eXBlb2YgbG9va3VwbWVtYmVyID09ICd1bmRlZmluZWQnKSBsb29rdXBtZW1iZXIgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZWZWYWwgIT09ICd1bmRlZmluZWQnICYmIG5vZGUudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikgY29uc29sZS5sb2coXCJDYW5ub3QgYXBwbHkgZGVmYXVsdCB2YWx1ZSB0byB2YXJpYWJsZSB3aGVuIHVzaW5nIGV4cHJlc3Npb25zXCIpO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiAnKCcgKyBnZW4obm9kZS5sZWZ0LCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlcikgKyAnICcgKyBtYXBPcGVyYXRvcihub2RlLm9wZXJhdG9yKSArICcgJyArIGdlbihub2RlLnJpZ2h0LCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlcikgKyAnKSc7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdDYWxsRXhwcmVzc2lvbicpIHtcbiAgICAgIHZhciBhcmdzID0gbm9kZS5hcmd1bWVudHMubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGdlbihuLCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnZW4obm9kZS5jYWxsZWUsIGJpbmRpbmdQcm92aWRlciwgbG9va3VwbWVtYmVyKSArICcoJyArIGFyZ3Muam9pbignLCAnKSArICcpJztcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIG5vZGUub3BlcmF0b3IgKyBnZW4obm9kZS5hcmd1bWVudCwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiBub2RlLmNvbXB1dGVkKSB7XG4gICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgY29tcHV0ZWQgbWVtYmVyIGV4cHJlc3Npb25cIjtcbiAgICAgIC8vIHJldHVybiBnZW4obm9kZS5vYmplY3QpICsgJ1snICsgZ2VuKG5vZGUucHJvcGVydHkpICsgJ10nO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiAhbm9kZS5jb21wdXRlZCkge1xuICAgICAgdmFyIG1lID0gZ2VuKG5vZGUub2JqZWN0LCBiaW5kaW5nUHJvdmlkZXIsIGZhbHNlKSArICcuJyArIGdlbihub2RlLnByb3BlcnR5LCBiaW5kaW5nUHJvdmlkZXIsIGZhbHNlKTtcbiAgICAgIGlmIChsb29rdXBtZW1iZXIgJiYgbm9kZS5vYmplY3QubmFtZSAhPT0gJ01hdGgnICYmIG5vZGUub2JqZWN0Lm5hbWUgIT09ICdDb2xvcicpIHJldHVybiBiaW5kaW5nUHJvdmlkZXIobWUsIGRlZlZhbCkgKyAnKCknO1xuICAgICAgcmV0dXJuIG1lO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgcmV0dXJuIG5vZGUucmF3O1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHZhciBpZCA9IG5vZGUubmFtZTtcbiAgICAgIGlmIChsb29rdXBtZW1iZXIpIHJldHVybiBiaW5kaW5nUHJvdmlkZXIoaWQsIGRlZlZhbCkgKyAnKCknO1xuICAgICAgZWxzZSByZXR1cm4gaWQ7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdDb25kaXRpb25hbEV4cHJlc3Npb24nKSB7XG4gICAgICByZXR1cm4gJygnICsgZ2VuKG5vZGUudGVzdCwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIpICsgJyA/ICcgKyBnZW4obm9kZS5jb25zZXF1ZW50LCBiaW5kaW5nUHJvdmlkZXIsIGxvb2t1cG1lbWJlcikgKyAnIDogJyArIGdlbihub2RlLmFsdGVybmF0ZSwgYmluZGluZ1Byb3ZpZGVyLCBsb29rdXBtZW1iZXIpICsgJyknO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnQ29tcG91bmQnKSB7XG4gICAgICB0aHJvdyBcIlN5bnRheCBlcnJvciBpbiBleHByZXNzaW9uOiBvcGVyYXRvciBleHBlY3RlZCBhZnRlciBcIiArIGdlbihub2RlLmJvZHlbMF0sIGJpbmRpbmdQcm92aWRlciwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBcIkZvdW5kIGFuIHVuc3VwcG9ydGVkIGV4cHJlc3Npb24gdHlwZTogXCIgKyBub2RlLnR5cGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdlbihub2RlLCBiaW5kaW5nUHJvdmlkZXIsIHVuZGVmaW5lZCwgZGVmVmFsKTtcbn07XG5cbnZhciBleHByZXNzaW9uQmluZGluZyA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIGJpbmRpbmdQcm92aWRlciwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciBtYXRjaGVzO1xuICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFyIGNoZWNrID0gZXhwcmVzc2lvbi50cmltKCkucmVwbGFjZSgvQFxcWyhbXlxcXV0rKVxcXXxAKFthLXpBLVowLTlcXC5fXSspXFxiL2csICcjIyN2YXIjIyMnKTtcbiAgICBjaGVjayA9IGNoZWNrLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKTtcbiAgICBpZiAoY2hlY2sgPT0gJyMjI3ZhciMjIycpIG1hdGNoZXMgPSBbbnVsbCwgZGVmYXVsdFZhbHVlXTtcbiAgICBlbHNlIHtcbiAgICAgIGNoZWNrID0gJ14nICsgY2hlY2sucmVwbGFjZSgvIyMjdmFyIyMjL2csICcoLispJykgKyAnJCc7XG4gICAgICBtYXRjaGVzID0gZGVmYXVsdFZhbHVlLnRyaW0oKS5tYXRjaChuZXcgUmVnRXhwKGNoZWNrKSk7XG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgLy8gVE9ETyB0aHJvdyBlcnJvcj9cbiAgICAgICAgY29uc29sZS5sb2coXCJDYW5ub3QgZmluZCBtYXRjaGVzXCIsIG1hdGNoZXMsIFwiZm9yXCIsIGRlZmF1bHRWYWx1ZSwgZXhwcmVzc2lvbiwgY2hlY2ssIGV4cHJlc3Npb24pO1xuICAgICAgICB0aHJvdyBcIkNhbm5vdCBmaW5kIGRlZmF1bHQgdmFsdWUgZm9yIFwiICsgZXhwcmVzc2lvbiArIFwiIGluIFwiICsgZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciB2YXJzID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gXCInXCIgKyBleHByZXNzaW9uLnJlcGxhY2UoL0BcXFsoW15cXF1dKylcXF18QChbYS16QS1aMC05XFwuX10rKVxcYnwoJykvZywgZnVuY3Rpb24obWF0Y2gsIHAxLCBwMiwgcDMpIHtcbiAgICAgIC8vIGVzY2FwaW5nLi5cbiAgICAgIGlmIChwMykgcmV0dXJuIFwiXFxcXFwiICsgcDM7XG4gICAgICB2YXJzKys7XG4gICAgICB2YXIgdmFyTmFtZSA9IHAxIHx8IHAyO1xuICAgICAgdmFyIGRlZlZhbDtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlc1t2YXJzXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZWZWYWwgPSBtYXRjaGVzW3ZhcnNdLnRyaW0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFCWlpaIENhbm5vdCBmaW5kIGRlZmF1bHQgdmFsdWUgZm9yXCIsIHZhck5hbWUsIFwiaW5cIiwgbWF0Y2hlcywgXCJhc1wiLCB2YXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW4gY2FzZSB3ZSBmb3VuZCBwMSB3ZSBhcmUgaW4gYSBAW3NlcXVlbmNlXSBzbyB3ZSBzdGFydCBhbiBleHByZXNzaW9uIHBhcnNlclxuICAgICAgaWYgKHAxKSB7XG4gICAgICAgIHZhciBwYXJzZXRyZWUgPSBqc2VwKHAxKTtcbiAgICAgICAgdmFyIGdlbnRyZWUgPSBleHByZXNzaW9uR2VuZXJhdG9yKHBhcnNldHJlZSwgYmluZGluZ1Byb3ZpZGVyLCBkZWZWYWwpO1xuICAgICAgICByZXR1cm4gXCInK1wiICsgZ2VudHJlZSArIFwiKydcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIicrXCIgKyBiaW5kaW5nUHJvdmlkZXIodmFyTmFtZSwgZGVmVmFsKSArIFwiKCkrJ1wiO1xuICAgIH0pICsgXCInXCI7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLyhefFteXFxcXF0pJydcXCsvZywgJyQxJykucmVwbGFjZSgvXFwrJycvZywgJycpO1xuXG4gICAgaWYgKHZhcnMgPT09IDAgJiYgcmVzdWx0ICE9PSAnZmFsc2UnICYmIHJlc3VsdCAhPT0gJ3RydWUnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBleHByZXNzaW9uIHdpdGggbm8gdmFsaWQgQHZhcmlhYmxlIHJlZmVyZW5jZXNcIiwgZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBcIkV4Y2VwdGlvbiBwYXJzaW5nIGV4cHJlc3Npb24gXCIgKyBleHByZXNzaW9uICsgXCIgXCIgKyBlO1xuICB9XG59O1xuXG52YXIgY29uZGl0aW9uQmluZGluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYmluZGluZ1Byb3ZpZGVyKSB7XG4gIHZhciBwYXJzZXRyZWUgPSBqc2VwKGNvbmRpdGlvbik7XG4gIHZhciBnZW50cmVlID0gZXhwcmVzc2lvbkdlbmVyYXRvcihwYXJzZXRyZWUsIGJpbmRpbmdQcm92aWRlcik7XG4gIHJldHVybiBnZW50cmVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZFNsYXNoZXM6IGFkZFNsYXNoZXMsXG4gIHJlbW92ZVN0eWxlOiByZW1vdmVTdHlsZSxcbiAgY29uZGl0aW9uQmluZGluZzogY29uZGl0aW9uQmluZGluZyxcbiAgZXhwcmVzc2lvbkJpbmRpbmc6IGV4cHJlc3Npb25CaW5kaW5nXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGlzIGlzIGNvbXBsZXggY29kZSB0byBoYW5kbGUgXCJsaXZlXCIgbW9kZWwgaW5zdHJ1bWVudGF0aW9uIGFuZCBkZXBlbmRlbmN5IHRyYWNraW5nLlxuLy8gVGhpcyBhZGRzIF93cmFwIGFuZCBfdW53cmFwIG1ldGhvZHMgdG8gdGhlIG1vZGVsIGFuZCBhbHNvIGluc3RydW1lbnQgdGhlIGJsb2NrIGxpc3Qgc28gdG8gYXV0b21hdGljYWxseVxuLy8gd3JhcC91cHdyYXAgb2JqZWN0cyBvbiBzaW1wbGUgYXJyYXkgbWV0aG9kcyAocHVzaCwgc3BsaWNlKVxuXG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBrb3dyYXAgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2tub2Nrb3V0LndyYXAva25vY2tvdXQud3JhcC5qc1wiKTtcbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG5cbnZhciBfZ2V0T3B0aW9uc09iamVjdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnNDb3VwbGVzID0gb3B0aW9ucy5zcGxpdCgnfCcpO1xuICB2YXIgb3B0cyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnNDb3VwbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG9wdCA9IG9wdGlvbnNDb3VwbGVzW2ldLnNwbGl0KCc9Jyk7XG4gICAgb3B0c1tvcHRbMF1dID0gb3B0Lmxlbmd0aCA+IDEgPyBvcHRbMV0gOiBvcHRbMF07XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59O1xuXG4vLyBnZW5lcmF0ZSBhIGNvbXB1dGVkIHZhcmlhYmxlIGhhbmRsaW5nIHRoZSBmYWxsYmFjayB0byB0aGVtZSB2YXJpYWJsZVxudmFyIF9tYWtlQ29tcHV0ZWQgPSBmdW5jdGlvbih0YXJnZXQsIGRlZiwgbnVsbElmRXF1YWwsIHNjaGVtZVNlbGVjdG9yLCB0aGVtZVBhdGgsIHRoZW1lcykge1xuICB2YXIgcmVzID0ga28uY29tcHV0ZWQoe1xuICAgICdyZWFkJzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsID0gdGFyZ2V0KCk7XG4gICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHNjaGVtZVNlbGVjdG9yKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWUgPT0gJ3VuZGVmaW5lZCcgfHwgc2NoZW1lID09ICdjdXN0b20nKSB7XG4gICAgICAgICAgcmV0dXJuIGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoZGVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhlbWVzW3NjaGVtZV1bdGhlbWVQYXRoXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgICd3cml0ZSc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgc2NoZW1lID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShzY2hlbWVTZWxlY3Rvcik7XG4gICAgICB2YXIgZGVmVmFsO1xuICAgICAgaWYgKHR5cGVvZiBzY2hlbWUgPT0gJ3VuZGVmaW5lZCcgfHwgc2NoZW1lID09ICdjdXN0b20nKSB7XG4gICAgICAgIGRlZlZhbCA9IGtvLnV0aWxzLnBlZWtPYnNlcnZhYmxlKGRlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZWYWwgPSB0aGVtZXNbc2NoZW1lXVt0aGVtZVBhdGhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoISFudWxsSWZFcXVhbCkge1xuICAgICAgICBpZiAodmFsdWUgPT0gZGVmVmFsKSB0YXJnZXQobnVsbCk7XG4gICAgICAgIGVsc2UgdGFyZ2V0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0ga28udXRpbHMucGVla09ic2VydmFibGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKHZhbHVlICE9IGRlZlZhbCB8fCBjdXJyZW50ICE9PSBudWxsKSB0YXJnZXQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBfbmV4dFZhcmlhbnRGdW5jdGlvbiA9IGZ1bmN0aW9uKGtvLCBwcm9wLCB2YXJpYW50cykge1xuICB2YXIgY3VycmVudFZhbHVlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShwcm9wKTtcbiAgdmFyIHZhcmlhbnRWYWx1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcmlhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyaWFudFZhbHVlID0ga28udXRpbHMucGVla09ic2VydmFibGUodmFyaWFudHNbaV0pO1xuICAgIGlmICh2YXJpYW50VmFsdWUgPT0gY3VycmVudFZhbHVlKSBicmVhaztcbiAgfVxuXG4gIGlmIChpID09IHZhcmlhbnRzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUud2FybihcIkRpZG4ndCBmaW5kIGEgdmFyaWFudCFcIiwgcHJvcCwgY3VycmVudFZhbHVlLCB2YXJpYW50cyk7XG4gICAgaSA9IHZhcmlhbnRzLmxlbmd0aCAtIDE7XG4gIH1cblxuICB2YXIgbmV4dFZhcmlhbnQgPSBpICsgMTtcbiAgaWYgKG5leHRWYXJpYW50ID09IHZhcmlhbnRzLmxlbmd0aCkgbmV4dFZhcmlhbnQgPSAwO1xuICB2YXIgbmV4dFZhbHVlID0ga28udXRpbHMucGVla09ic2VydmFibGUodmFyaWFudHNbbmV4dFZhcmlhbnRdKTtcblxuICBwcm9wKG5leHRWYWx1ZSk7XG59O1xuXG52YXIgX2dldFZhcmlhbnRzID0gZnVuY3Rpb24oZGVmKSB7XG4gIHZhciB2YXJpYW50UHJvcCA9IGRlZi5fdmFyaWFudDtcbiAgdmFyIHZhcmlhbnRPcHRpb25zO1xuICBpZiAodHlwZW9mIGRlZlt2YXJpYW50UHJvcF0gIT09ICdvYmplY3QnIHx8IHR5cGVvZiBkZWZbdmFyaWFudFByb3BdLl93aWRnZXQgPT09ICd1bmRlZmluZWQnIHx8ICh0eXBlb2YgZGVmW3ZhcmlhbnRQcm9wXS5fb3B0aW9ucyAhPT0gJ3N0cmluZycgJiYgZGVmW3ZhcmlhbnRQcm9wXS5fd2lkZ2V0ICE9PSAnYm9vbGVhbicpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgdmFyaWFudCBkZWNsYXJhdGlvblwiLCB2YXJpYW50UHJvcCwgZGVmW3ZhcmlhbnRQcm9wXSk7XG4gICAgdGhyb3cgXCJVbmV4cGVjdGVkIHZhcmlhbnQgZGVjbGFyYXRpb246IGNhbm5vdCBmaW5kIHByb3BlcnR5IFwiICsgdmFyaWFudFByb3AgKyBcIiBvciBpdHMgX29wdGlvbnMgc3RyaW5nIGFuZCBpdCBpcyBub3QgYSBib29sZWFuXCI7XG4gIH1cbiAgLy8gVE9ETyBJIHJlYWQgdGhlIFwia2V5c1wiIGJ1dCB0aGlzIGlzIG5vdCAxMDAlIGNvcnJlY3QgYmVjYXVzZSB0aGV5IGFyZSBub3QgZ2FyYW50ZWVkIHRvIGJlIHNvcnRlZCBhcyBpbiBkZWNsYXJhdGlvblxuICBpZiAodHlwZW9mIGRlZlt2YXJpYW50UHJvcF0uX29wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICB2YXJpYW50T3B0aW9ucyA9IE9iamVjdC5rZXlzKF9nZXRPcHRpb25zT2JqZWN0KGRlZlt2YXJpYW50UHJvcF0uX29wdGlvbnMpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXJpYW50T3B0aW9ucyA9IFt0cnVlLCBmYWxzZV07XG4gIH1cbiAgcmV0dXJuIHZhcmlhbnRPcHRpb25zO1xufTtcblxudmFyIF9tYWtlQ29tcHV0ZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKGRlZiwgZGVmcywgdGhtcywga28sIGNvbnRlbnRNb2RlbCwgaXNDb250ZW50LCB0KSB7XG4gIGlmICh0eXBlb2YgZGVmID09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHQpLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlRPRE8gRVJST1IgRm91bmQgYSBub24tdHlwZWQgZGVmIFwiLCBkZWYsIHQpO1xuICAgICAgdGhyb3cgXCJGb3VuZCBhIG5vbi10eXBlZCBkZWYgXCIgKyBkZWY7XG4gICAgfVxuICAgIHZhciB0eXBlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHQpLnR5cGUpO1xuICAgIGRlZiA9IGRlZnNbdHlwZV07XG4gICAgaWYgKHR5cGVvZiBkZWYgIT09ICdvYmplY3QnKSBjb25zb2xlLmxvZyhcIlRPRE8gRVJST1IgRm91bmQgYSBub24tb2JqZWN0IGRlZiBcIiwgZGVmLCBcImZvclwiLCB0eXBlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGVudE1vZGVsID09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpc0NvbnRlbnQgIT0gJ3VuZGVmaW5lZCcgJiYgaXNDb250ZW50KSB7XG4gICAgY29udGVudE1vZGVsID0gdDtcbiAgfVxuXG4gIHZhciBzZWxmUGF0aCA9ICckcm9vdC5jb250ZW50KCkuJztcblxuICB2YXIgcHAgPSBkZWYuX2dsb2JhbFN0eWxlcztcbiAgaWYgKHR5cGVvZiBwcCAhPSAndW5kZWZpbmVkJylcbiAgICBmb3IgKHZhciBwIGluIHBwKVxuICAgICAgaWYgKHBwLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIHZhciBzY2hlbWVQYXRoT3JpZyA9ICckcm9vdC5jb250ZW50KCkudGhlbWUoKS5zY2hlbWUnO1xuICAgICAgICB2YXIgc2NoZW1lUGF0aCwgdm0sIHBhdGg7XG5cbiAgICAgICAgaWYgKHBwW3BdLnN1YnN0cigwLCBzZWxmUGF0aC5sZW5ndGgpID09IHNlbGZQYXRoKSB7XG4gICAgICAgICAgcGF0aCA9IHBwW3BdLnN1YnN0cihzZWxmUGF0aC5sZW5ndGgpO1xuICAgICAgICAgIHZtID0gY29udGVudE1vZGVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiVU5FWFBFQ1RFRCBnbG9iYWxTdHlsZSBwYXRoIChcIiArIHBwW3BdICsgXCIpIG91dHNpZGUgc2VsZlBhdGggKFwiICsgc2VsZlBhdGggKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1lUGF0aE9yaWcuc3Vic3RyKDAsIHNlbGZQYXRoLmxlbmd0aCkgPT0gc2VsZlBhdGgpIHtcbiAgICAgICAgICBzY2hlbWVQYXRoID0gc2NoZW1lUGF0aE9yaWcuc3Vic3RyKHNlbGZQYXRoLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJJUyBUSElTIENPUlJFQ1Q/XCIsIHNjaGVtZVBhdGhPcmlnLCBzZWxmUGF0aCk7XG4gICAgICAgICAgc2NoZW1lUGF0aCA9IHNjaGVtZVBhdGhPcmlnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjaGVtZVNlbGVjdG9yID0gdm07XG5cbiAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IHBhdGguc3BsaXQoJygpLicpO1xuICAgICAgICB2YXIgdGhlbWVQYXRoID0gJyc7XG4gICAgICAgIHZhciBza2lwID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2bSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodm0pW3BhdGhQYXJ0c1tpXV07XG4gICAgICAgICAgLy8gdWdseSB0aGluZyB0byBmaW5kIHRoZSBwYXRoIHRvIHRoZSBzY2hlbWEgY29sb3IgcHJvcGVydHkgKHNvbWV0aW1lcyB3ZSBoYXZlIHRoZW1lLmJvZHlUaGVtZSwgc29tZSBvdGhlciB3ZSBoYXZlIGNvbnRlbnQudGhlbWUuYm9keVRoZW1lLi4uKVxuICAgICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgICBpZiAocGF0aFBhcnRzW2ldID09ICd0aGVtZScpIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoZW1lUGF0aC5sZW5ndGggPiAwKSB0aGVtZVBhdGggKz0gJy4nO1xuICAgICAgICAgICAgdGhlbWVQYXRoICs9IHBhdGhQYXJ0c1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NoZW1lUGFydHMgPSBzY2hlbWVQYXRoLnNwbGl0KCcoKS4nKTtcbiAgICAgICAgZm9yICh2YXIgaTMgPSAwOyBpMyA8IHNjaGVtZVBhcnRzLmxlbmd0aDsgaTMrKykge1xuICAgICAgICAgIHNjaGVtZVNlbGVjdG9yID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShzY2hlbWVTZWxlY3Rvcilbc2NoZW1lUGFydHNbaTNdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudWxsSWZFcXVhbCA9IHRydWU7XG4gICAgICAgIHZhciB0UGFydHMgPSBwLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0O1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgdFBhcnRzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIHRhcmdldCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodGFyZ2V0KVt0UGFydHNbaTJdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha28uaXNPYnNlcnZhYmxlKHRhcmdldCkpIHRocm93IFwiVW5leHBlY3RlZCBub24gb2JzZXJ2YWJsZSB0YXJnZXQgXCIgKyBwICsgXCIvXCIgKyB0aGVtZVBhdGg7XG5cbiAgICAgICAgdGFyZ2V0Ll9kZWZhdWx0Q29tcHV0ZWQgPSBfbWFrZUNvbXB1dGVkKHRhcmdldCwgdm0sIG51bGxJZkVxdWFsLCBzY2hlbWVTZWxlY3RvciwgdGhlbWVQYXRoLCB0aG1zKTtcbiAgICAgIH1cblxuICBpZiAodHlwZW9mIGRlZi5fdmFyaWFudCAhPSAndW5kZWZpbmVkJykge1xuICAgIHZhciBwUGFydHMgPSBkZWYuX3ZhcmlhbnQuc3BsaXQoJy4nKTtcbiAgICAvLyBsb29rcyBpbiB0IGFuZCBub3QgY29udGVudE1vZGVsIGJlY2F1c2UgdmFyaWFudHMgYXJlIGRlY2xhcmVkIG9uIHNpbmdsZSBibG9ja3MuXG4gICAgdmFyIHBUYXJnZXQgPSB0O1xuICAgIHZhciBwUGFyZW50ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh0KTtcbiAgICBmb3IgKHZhciBpNCA9IDA7IGk0IDwgcFBhcnRzLmxlbmd0aDsgaTQrKykge1xuICAgICAgcFRhcmdldCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUocFRhcmdldClbcFBhcnRzW2k0XV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcFRhcmdldC5fZGVmYXVsdENvbXB1dGVkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIHZhcmlhbnQgb24gYSBzdHlsZSBwcm9wZXJ0eTogYmV3YXJlIHZhcmlhbnRzIHNob3VsZCBiZSBvbmx5IHVzZWQgb24gY29udGVudCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBtYXRjaCB0aGUgdGhlbWUgZmFsbGJhY2sgYmVoYXZpb3VyXCIsIGRlZi5fdmFyaWFudCk7XG4gICAgICBwVGFyZ2V0ID0gcFRhcmdldC5fZGVmYXVsdENvbXB1dGVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBUYXJnZXQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRVJST1IgbG9va2luZyBmb3IgdmFyaWFudCB0YXJnZXRcIiwgZGVmLl92YXJpYW50LCB0KTtcbiAgICAgIHRocm93IFwiRVJST1IgbG9va2luZyBmb3IgdmFyaWFudCB0YXJnZXQgXCIgKyBkZWYuX3ZhcmlhbnQ7XG4gICAgfVxuICAgIHBQYXJlbnQuX25leHRWYXJpYW50ID0gX25leHRWYXJpYW50RnVuY3Rpb24uYmluZChwVGFyZ2V0LCBrbywgcFRhcmdldCwgX2dldFZhcmlhbnRzKGRlZikpO1xuICB9XG5cbiAgZm9yICh2YXIgcHJvcDIgaW4gZGVmKVxuICAgIGlmIChkZWYuaGFzT3duUHJvcGVydHkocHJvcDIpKSB7XG4gICAgICB2YXIgdmFsID0gZGVmW3Byb3AyXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsLl9jb250ZXh0ICE9ICd1bmRlZmluZWQnICYmIHZhbC5fY29udGV4dCA9PSAnYmxvY2snKSB7XG4gICAgICAgIHZhciBwcm9wVm0gPSBjb250ZW50TW9kZWxbcHJvcDJdKCk7XG4gICAgICAgIHZhciBuZXdWbSA9IF9tYWtlQ29tcHV0ZWRGdW5jdGlvbihkZWZzW3Byb3AyXSwgZGVmcywgdGhtcywga28sIGNvbnRlbnRNb2RlbCwgaXNDb250ZW50LCBwcm9wVm0pO1xuICAgICAgICB0W3Byb3AyXShuZXdWbSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIHZhbC50eXBlID09ICdibG9ja3MnKSB7XG4gICAgICAgIHZhciBtYWluVm0gPSBjb250ZW50TW9kZWxbcHJvcDJdKCk7XG4gICAgICAgIHZhciBibG9ja3NWbSA9IG1haW5WbS5ibG9ja3MoKTtcbiAgICAgICAgdmFyIG9sZEJsb2NrLCBibG9ja1R5cGUsIG5ld0Jsb2NrO1xuICAgICAgICBmb3IgKHZhciBpYiA9IDA7IGliIDwgYmxvY2tzVm0ubGVuZ3RoOyBpYisrKSB7XG4gICAgICAgICAgb2xkQmxvY2sgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGJsb2Nrc1ZtW2liXSk7XG4gICAgICAgICAgYmxvY2tUeXBlID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShvbGRCbG9jay50eXBlKTtcbiAgICAgICAgICBuZXdCbG9jayA9IF9tYWtlQ29tcHV0ZWRGdW5jdGlvbihkZWZzW2Jsb2NrVHlwZV0sIGRlZnMsIHRobXMsIGtvLCBjb250ZW50TW9kZWwsIGlzQ29udGVudCwgb2xkQmxvY2spO1xuICAgICAgICAgIGJsb2Nrc1ZtW2liXShuZXdCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmxvY2tzT2JzID0gbWFpblZtLmJsb2NrcztcblxuICAgICAgICBfYXVnbWVudEJsb2Nrc09ic2VydmFibGUoYmxvY2tzT2JzLCBfYmxvY2tJbnN0cnVtZW50RnVuY3Rpb24uYmluZChtYWluVm0sIHVuZGVmaW5lZCwgZGVmcywgdGhtcywga28sIHVuZGVmaW5lZCwgY29udGVudE1vZGVsLCBpc0NvbnRlbnQpKTtcblxuICAgICAgICBjb250ZW50TW9kZWxbcHJvcDJdLl93cmFwID0gX21ha2VCbG9ja3NXcmFwLmJpbmQoY29udGVudE1vZGVsW3Byb3AyXSwgYmxvY2tzT2JzLl9pbnN0cnVtZW50QmxvY2spO1xuICAgICAgICBjb250ZW50TW9kZWxbcHJvcDJdLl91bndyYXAgPSBfdW53cmFwLmJpbmQoY29udGVudE1vZGVsW3Byb3AyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gIHJldHVybiB0O1xufTtcblxudmFyIF9hdWdtZW50QmxvY2tzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uKGJsb2Nrc09icywgaW5zdHJ1bWVudCkge1xuICBibG9ja3NPYnMuX2luc3RydW1lbnRCbG9jayA9IGluc3RydW1lbnQ7XG4gIGlmICh0eXBlb2YgYmxvY2tzT2JzLm9yaWdQdXNoID09ICd1bmRlZmluZWQnKSB7XG4gICAgYmxvY2tzT2JzLm9yaWdQdXNoID0gYmxvY2tzT2JzLnB1c2g7XG4gICAgYmxvY2tzT2JzLnB1c2ggPSBfbWFrZVB1c2guYmluZChibG9ja3NPYnMpO1xuICAgIGJsb2Nrc09icy5vcmlnU3BsaWNlID0gYmxvY2tzT2JzLnNwbGljZTtcbiAgICBibG9ja3NPYnMuc3BsaWNlID0gX21ha2VTcGxpY2UuYmluZChibG9ja3NPYnMpO1xuICB9XG59O1xuXG52YXIgX21ha2VCbG9ja3NXcmFwID0gZnVuY3Rpb24oaW5zdHJ1bWVudCwgaW5wdXRNb2RlbCkge1xuICB2YXIgbW9kZWwgPSBrby50b0pTKGlucHV0TW9kZWwpO1xuICB2YXIgaW5wdXQgPSBtb2RlbC5ibG9ja3M7XG4gIG1vZGVsLmJsb2NrcyA9IFtdO1xuICB2YXIgcmVzID0ga293cmFwLmZyb21KUyhtb2RlbCwgdW5kZWZpbmVkLCB0cnVlKSgpO1xuICBfYXVnbWVudEJsb2Nrc09ic2VydmFibGUocmVzLmJsb2NrcywgaW5zdHJ1bWVudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb2JqID0ga28udG9KUyhpbnB1dFtpXSk7XG4gICAgLy8gY29uc29sZS5sb2coXCJfbWFrZUJsb2Nrc1dyYXAgc2V0IGJsb2NrSWRcIiwgb2JqLmlkLCAnYmxvY2tfJytpKTtcbiAgICBvYmouaWQgPSAnYmxvY2tfJyArIGk7XG4gICAgcmVzLmJsb2Nrcy5wdXNoKG9iaik7XG4gIH1cbiAgdGhpcyhyZXMpO1xufTtcblxudmFyIF9tYWtlUHVzaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHRocm93IFwiQXJyYXkgcHVzaCB3aXRoIG11bHRpcGxlIGFyZ3VtZW50cyBub3QgaW1wbGVtZW50ZWRcIjtcbiAgLy8gdW53cmFwIG9ic2VydmFibGUgYmxvY2tzLCBvdGhlcndpc2UgdmlzaWJpbGl0eSAoZGVwZW5kZW5jeSkgaGFuZGxpbmcgYnJlYWtzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBrby5pc09ic2VydmFibGUoYXJndW1lbnRzWzBdKSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdLl91bndyYXAgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdLl91bndyYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBwdXNoaW5nIG9ic2VydmFibGUgd2l0aCBubyBfdW53cmFwIGZ1bmN0aW9uIChUT0RPIHJlbW92ZSBtZSwgZXhwZWN0ZWQgY29uZGl0aW9uKVwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFrby5pc09ic2VydmFibGUoYXJndW1lbnRzWzBdKSkge1xuICAgIHZhciBpbnN0cnVtZW50ZWQgPSB0aGlzLl9pbnN0cnVtZW50QmxvY2soYXJndW1lbnRzWzBdKTtcbiAgICByZXR1cm4gdGhpcy5vcmlnUHVzaC5hcHBseSh0aGlzLCBbaW5zdHJ1bWVudGVkXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ1B1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufTtcblxudmFyIF9tYWtlU3BsaWNlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykgdGhyb3cgXCJBcnJheSBzcGxpY2Ugd2l0aCBtdWx0aXBsZSBvYmplY3RzIG5vdCBpbXBsZW1lbnRlZFwiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYga28uaXNPYnNlcnZhYmxlKGFyZ3VtZW50c1syXSkpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXS5fdW53cmFwID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFyZ3VtZW50c1syXSA9IGFyZ3VtZW50c1syXS5fdW53cmFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV0FSTjogc3BsaWNpbmcgb2JzZXJ2YWJsZSB3aXRoIG5vIF91bndyYXAgZnVuY3Rpb24gKFRPRE8gcmVtb3ZlIG1lLCBleHBlY3RlZCBjb25kaXRpb24pXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgIWtvLmlzT2JzZXJ2YWJsZShhcmd1bWVudHNbMl0pKSB7XG4gICAgdmFyIGluc3RydW1lbnRlZCA9IHRoaXMuX2luc3RydW1lbnRCbG9jayhhcmd1bWVudHNbMl0pO1xuICAgIHJldHVybiB0aGlzLm9yaWdTcGxpY2UuYXBwbHkodGhpcywgW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBpbnN0cnVtZW50ZWRdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnU3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cbi8vIGRlZiwgZGVmcyBhbmQgdGhlbWVzIGFyZSBib3VuZCBpbiBcIl9tb2RlbEluc3RydW1lbnRcIiB3aGlsZSB0aGUgbmV4dCBwYXJhbWV0ZXJzIGFyZSBleHBvc2VkIGJ5IHRoaXMgbW9kdWxlXG52YXIgX2Jsb2NrSW5zdHJ1bWVudEZ1bmN0aW9uID0gZnVuY3Rpb24oZGVmLCBkZWZzLCB0aGVtZXMsIGtub2Nrb3V0LCBzZWxmLCBtb2RlbENvbnRlbnQsIGlzQ29udGVudCwgc2VsZjIpIHtcbiAgLy8gdWdseTogc29tZXRpbWVzIHdlIGhhdmUgdG8gYmluZCBjb250ZW50IGJ1dCBub3Qgc2VsZiwgc28gd2UgcmVwZWF0IHNlbGYgYXQgdGhlIGVuZCBhcyBcInNlbGYyXCJcbiAgaWYgKHR5cGVvZiBzZWxmID09ICd1bmRlZmluZWQnKSBzZWxmID0gc2VsZjI7XG5cbiAgdmFyIGNvbXB1dGVkRnVuY3Rpb25zO1xuICBjb21wdXRlZEZ1bmN0aW9ucyA9IHtcbiAgICAnJzogX21ha2VDb21wdXRlZEZ1bmN0aW9uLmJpbmQoc2VsZiwgZGVmLCBkZWZzLCB0aGVtZXMsIGtub2Nrb3V0LCBtb2RlbENvbnRlbnQsIGlzQ29udGVudClcbiAgfTtcblxuICB2YXIgcmVzID0ga293cmFwLmZyb21KUyhzZWxmLCBjb21wdXRlZEZ1bmN0aW9ucywgdHJ1ZSk7XG4gIHJlcy5fdW53cmFwID0gX3Vud3JhcC5iaW5kKHJlcyk7XG4gIHJldHVybiByZXM7XG59O1xuXG52YXIgX3dyYXAgPSBmdW5jdGlvbihpbnN0cnVtZW50LCB1bndyYXBwZWQpIHtcbiAgdmFyIG5ld0NvbnRlbnQgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGluc3RydW1lbnQoa28sIHVud3JhcHBlZCwgdW5kZWZpbmVkLCB0cnVlKSk7XG4gIHRoaXMobmV3Q29udGVudCk7XG59O1xuXG52YXIgX3Vud3JhcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ga28udG9KUyh0aGlzKTtcbn07XG5cbnZhciBfbW9kZWxJbnN0cnVtZW50ID0gZnVuY3Rpb24obW9kZWwsIG1vZGVsRGVmLCBkZWZzKSB7XG4gIHZhciBfaW5zdHJ1bWVudCA9IF9ibG9ja0luc3RydW1lbnRGdW5jdGlvbi5iaW5kKHVuZGVmaW5lZCwgbW9kZWxEZWYsIGRlZnMsIGRlZnNbJ3RoZW1lcyddKTtcbiAgdmFyIHJlcyA9IF9pbnN0cnVtZW50KGtvLCBtb2RlbCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgLy8gcmVzLl9pbnN0cnVtZW50ID0gX2luc3RydW1lbnQ7XG4gIHJlcy5fd3JhcCA9IF93cmFwLmJpbmQocmVzLCBfaW5zdHJ1bWVudCk7XG4gIHJlcy5fdW53cmFwID0gX3Vud3JhcC5iaW5kKHJlcyk7XG4gIHJldHVybiByZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9tb2RlbEluc3RydW1lbnQ7IiwidmFyIHRpbnljb2xvciA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvdGlueWNvbG9yL3Rpbnljb2xvci5qc1wiKTtcblxuZnVuY3Rpb24gQ29sb3IodGlueWNvbG9yKSB7XG4gIHRoaXMuZ2V0QnJpZ2h0bmVzcyA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZ2V0QnJpZ2h0bmVzcygpO1xuICB9O1xuICB0aGlzLmlzTGlnaHQgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmlzTGlnaHQoKTtcbiAgfTtcbiAgdGhpcy5pc0RhcmsgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmlzRGFyaygpO1xuICB9O1xuICB0aGlzLmdldEx1bWluYW5jZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZ2V0THVtaW5hbmNlKCk7XG4gIH07XG5cblxuICB0aGlzLmxpZ2h0ZW4gPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikubGlnaHRlbihhbW91bnQpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIHRoaXMuYnJpZ2h0ZW4gPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuYnJpZ2h0ZW4oYW1vdW50KS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLmRhcmtlbiA9IGZ1bmN0aW9uKGNvbG9yLCBhbW91bnQpIHtcbiAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5kYXJrZW4oYW1vdW50KS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLmRlc2F0dXJhdGUgPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZGVzYXR1cmF0ZShhbW91bnQpLnRvSGV4U3RyaW5nKCk7XG4gIH07XG4gIHRoaXMuc2F0dXJhdGUgPSBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuc2F0dXJhdGUoYW1vdW50KS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLmdyZXlzY2FsZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcikuZ3JleXNjYWxlKCkudG9IZXhTdHJpbmcoKTtcbiAgfTtcbiAgdGhpcy5zcGluID0gZnVuY3Rpb24oY29sb3IsIGFtb3VudCkge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLnNwaW4oYW1vdW50KS50b0hleFN0cmluZygpO1xuICB9O1xuICB0aGlzLmNvbXBsZW1lbnQgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IpLmNvbXBsZW1lbnQoKS50b0hleFN0cmluZygpO1xuICB9O1xuXG4gIHRoaXMubWl4ID0gdGlueWNvbG9yLm1peDtcbiAgdGhpcy5yZWFkYWJpbGl0eSA9IHRpbnljb2xvci5yZWFkYWJpbGl0eTtcbiAgdGhpcy5pc1JlYWRhYmxlID0gdGlueWNvbG9yLmlzUmVhZGFibGU7XG4gIHRoaXMubW9zdFJlYWRhYmxlID0gdGlueWNvbG9yLm1vc3RSZWFkYWJsZTtcbn1cblxudmFyIGNvbG9yUGx1Z2luID0gZnVuY3Rpb24odm0pIHtcbiAgZ2xvYmFsLkNvbG9yID0gbmV3IENvbG9yKHRpbnljb2xvcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbG9yUGx1Z2luOyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIGdsb2JhbDogZmFsc2UgKi9cbnZhciBjb25zb2xlID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vYm93ZXJfY29tcG9uZW50cy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanNcIik7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcblxudmFyIGxzTG9hZGVyID0gZnVuY3Rpb24oaGFzaF9rZXksIGVtYWlsUHJvY2Vzc29yQmFja2VuZCkge1xuICB2YXIgbWRTdHIgPSBnbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtZXRhZGF0YS1cIiArIGhhc2hfa2V5KTtcbiAgaWYgKG1kU3RyICE9PSBudWxsKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHZhciB0ZCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRlbXBsYXRlLVwiICsgaGFzaF9rZXkpO1xuICAgIGlmICh0ZCAhPT0gbnVsbCkgbW9kZWwgPSBKU09OLnBhcnNlKHRkKTtcbiAgICB2YXIgbWQgPSBKU09OLnBhcnNlKG1kU3RyKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IG1kLFxuICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgZXh0ZW5zaW9uOiBsc0NvbW1hbmRQbHVnaW5GYWN0b3J5KG1kLCBlbWFpbFByb2Nlc3NvckJhY2tlbmQpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIkNhbm5vdCBmaW5kIHN0b3JlZCBkYXRhIGZvciBcIitoYXNoX2tleTtcbiAgfVxufTtcblxudmFyIGxzQ29tbWFuZFBsdWdpbkZhY3RvcnkgPSBmdW5jdGlvbihtZCwgZW1haWxQcm9jZXNzb3JCYWNrZW5kKSB7XG4gIHZhciBjb21tYW5kc1BsdWdpbiA9IGZ1bmN0aW9uKG1ka2V5LCBtZG5hbWUsIHZpZXdNb2RlbCkge1xuXG4gICAgLy8gY29uc29sZS5sb2coXCJsb2FkaW5nIGZyb20gbWV0YWRhdGFcIiwgbWQsIG1vZGVsKTtcbiAgICB2YXIgc2F2ZUNtZCA9IHtcbiAgICAgIG5hbWU6ICdTYXZlJywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgc2F2ZUNtZC5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBzYXZlQ21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmlld01vZGVsLm1ldGFkYXRhLmNoYW5nZWQgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKHR5cGVvZiB2aWV3TW9kZWwubWV0YWRhdGEua2V5ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBmaW5kIGtldCBpbiBtZXRhZGF0YSBvYmplY3QuLi5cIiwgdmlld01vZGVsLm1ldGFkYXRhKTtcbiAgICAgICAgdmlld01vZGVsLm1ldGFkYXRhLmtleSA9IG1ka2V5O1xuICAgICAgfVxuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWV0YWRhdGEtXCIgKyBtZGtleSwgdmlld01vZGVsLmV4cG9ydE1ldGFkYXRhKCkpO1xuICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidGVtcGxhdGUtXCIgKyBtZGtleSwgdmlld01vZGVsLmV4cG9ydEpTT04oKSk7XG4gICAgICBzYXZlQ21kLmVuYWJsZWQodHJ1ZSk7XG4gICAgfTtcbiAgICB2YXIgdGVzdENtZCA9IHtcbiAgICAgIG5hbWU6ICdUZXN0JywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgdmFyIGRvd25sb2FkQ21kID0ge1xuICAgICAgbmFtZTogJ0Rvd25sb2FkJywgLy8gbDEwbiBoYXBwZW5zIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgZW5hYmxlZDoga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgIH07XG4gICAgdGVzdENtZC5leGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0ZXN0Q21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmFyIGVtYWlsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidGVzdGVtYWlsXCIpO1xuICAgICAgaWYgKGVtYWlsID09PSBudWxsIHx8IGVtYWlsID09ICdudWxsJykgZW1haWwgPSB2aWV3TW9kZWwudCgnSW5zZXJ0IGhlcmUgdGhlIHJlY2lwaWVudCBlbWFpbCBhZGRyZXNzJyk7XG4gICAgICBlbWFpbCA9IGdsb2JhbC5wcm9tcHQodmlld01vZGVsLnQoXCJUZXN0IGVtYWlsIGFkZHJlc3NcIiksIGVtYWlsKTtcbiAgICAgIGlmIChlbWFpbC5tYXRjaCgvQC8pKSB7XG4gICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRlc3RlbWFpbFwiLCBlbWFpbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyB0ZXN0aW5nLi4uXCIsIGVtYWlsKTtcbiAgICAgICAgdmFyIHBvc3RVcmwgPSBlbWFpbFByb2Nlc3NvckJhY2tlbmQgPyBlbWFpbFByb2Nlc3NvckJhY2tlbmQgOiAnL2RsLyc7XG4gICAgICAgIHZhciBwb3N0ID0gJC5wb3N0KHBvc3RVcmwsIHtcbiAgICAgICAgICBhY3Rpb246ICdlbWFpbCcsXG4gICAgICAgICAgcmNwdDogZW1haWwsXG4gICAgICAgICAgc3ViamVjdDogXCJbdGVzdF0gXCIgKyBtZGtleSArIFwiIC0gXCIgKyBtZG5hbWUsXG4gICAgICAgICAgaHRtbDogdmlld01vZGVsLmV4cG9ydEhUTUwoKVxuICAgICAgICB9LCBudWxsLCAnaHRtbCcpO1xuICAgICAgICBwb3N0LmZhaWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKHZpZXdNb2RlbC50KCdVbmV4cGVjdGVkIGVycm9yIHRhbGtpbmcgdG8gc2VydmVyOiBjb250YWN0IHVzIScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvc3Quc3VjY2VzcyhmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInN1Y2Nlc3NcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgICB2aWV3TW9kZWwubm90aWZpZXIuc3VjY2Vzcyh2aWV3TW9kZWwudChcIlRlc3QgZW1haWwgc2VudC4uLlwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwb3N0LmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB0ZXN0Q21kLmVuYWJsZWQodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLmFsZXJ0KHZpZXdNb2RlbC50KCdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnKSk7XG4gICAgICAgIHRlc3RDbWQuZW5hYmxlZCh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGRvd25sb2FkQ21kLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRvd25sb2FkQ21kLmVuYWJsZWQoZmFsc2UpO1xuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmluZm8odmlld01vZGVsLnQoXCJEb3dubG9hZGluZy4uLlwiKSk7XG4gICAgICB2aWV3TW9kZWwuZXhwb3J0SFRNTHRvVGV4dGFyZWEoJyNkb3dubG9hZEh0bWxUZXh0YXJlYScpO1xuICAgICAgdmFyIHBvc3RVcmwgPSBlbWFpbFByb2Nlc3NvckJhY2tlbmQgPyBlbWFpbFByb2Nlc3NvckJhY2tlbmQgOiAnL2RsLyc7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkRm9ybScpLnNldEF0dHJpYnV0ZShcImFjdGlvblwiLCBwb3N0VXJsKTtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWRGb3JtJykuc3VibWl0KCk7XG4gICAgICBkb3dubG9hZENtZC5lbmFibGVkKHRydWUpO1xuICAgIH07XG5cbiAgICB2aWV3TW9kZWwuc2F2ZSA9IHNhdmVDbWQ7XG4gICAgdmlld01vZGVsLnRlc3QgPSB0ZXN0Q21kO1xuICAgIHZpZXdNb2RlbC5kb3dubG9hZCA9IGRvd25sb2FkQ21kO1xuICB9LmJpbmQodW5kZWZpbmVkLCBtZC5rZXksIG1kLm5hbWUpO1xuXG4gIHJldHVybiBjb21tYW5kc1BsdWdpbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbHNMb2FkZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCIuLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMva25vY2tvdXQtc29ydGFibGUvYnVpbGQva25vY2tvdXQtc29ydGFibGUubWluLmpzXCIpO1xuXG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9qcXVlcnl1aS1zcGlubmVyLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvanF1ZXJ5dWktdGFicy5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL2NvbG9ycGlja2VyLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvYmxvY2tzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvY3NzdGV4dC5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL2JpbmQtaWZyYW1lLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZHJvcHBhYmxlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZmlsZXVwbG9hZC5qc1wiKTtcbnJlcXVpcmUoXCIuL2JpbmRpbmdzL3ZpcnR1YWxzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3Mvd3lzaXd5Z3MuanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9zY3JvbGxmaXguanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9pZi1zdWJzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZXh0c29ydGFibGVzLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvZXZlbnRhYmxlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvdG9vbHRpcHMuanNcIik7XG5yZXF1aXJlKFwiLi9iaW5kaW5ncy9leHRlbmRlci1wYWdpbmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3MvdmFsaWRhdGVkLXZhbHVlLmpzXCIpO1xucmVxdWlyZShcIi4vYmluZGluZ3Mvc2Nyb2xsaW50b3ZpZXcuanNcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgZ2xvYmFsOiBmYWxzZSAqL1xuXG52YXIgJCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydqUXVlcnknXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2pRdWVyeSddIDogbnVsbCk7XG52YXIga28gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna28nXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2tvJ10gOiBudWxsKTtcbnZhciBrb2pxdWkgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sna29qcXVpJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrb2pxdWknXSA6IG51bGwpOyAvLyBqdXN0IGZvciB0aGUgd2lkZ2V0IHBsdWdpbnNcbnZhciB0ZW1wbGF0ZUNvbnZlcnRlciA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlci9tYWluLmpzXCIpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBpbml0aWFsaXplVmlld21vZGVsID0gcmVxdWlyZShcIi4vdmlld21vZGVsLmpzXCIpO1xudmFyIHRlbXBsYXRlU3lzdGVtID0gcmVxdWlyZSgnLi9iaW5kaW5ncy9jaG9vc2UtdGVtcGxhdGUuanMnKTtcblxuLy8gY2FsbCBhIGdpdmVuIG1ldGhvZCBvbiBldmVyeSBwbHVnaW4gaW1wbGVtZW50aW5nIGl0LlxuLy8gc3VwcG9ydHMgYSBcInJldmVyc2VcIiBwYXJhbWV0ZXIgdG8gY2FsbCB0aGUgbWV0aG9kcyBmcm9tIHRoZSBsYXN0IG9uZSB0byB0aGUgZmlyc3Qgb25lLlxudmFyIHBsdWdpbnNDYWxsID0gZnVuY3Rpb24ocGx1Z2lucywgbWV0aG9kTmFtZSwgYXJncywgcmV2ZXJzZSkge1xuICB2YXIgc3RhcnQsIGVuZCwgZGlmZiwgcmVzLCByZXN1bHRzO1xuICByZXN1bHRzID0gW107XG4gIGlmICh0eXBlb2YgcmV2ZXJzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV2ZXJzZSkge1xuICAgIHN0YXJ0ID0gcGx1Z2lucy5sZW5ndGggLSAxO1xuICAgIGVuZCA9IDA7XG4gICAgZGlmZiA9IC0xO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gMDtcbiAgICBlbmQgPSBwbHVnaW5zLmxlbmd0aCAtIDE7XG4gICAgZGlmZiA9IDE7XG4gIH1cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpICE9IGVuZCArIGRpZmY7IGkgKz0gZGlmZikge1xuICAgIGlmICh0eXBlb2YgcGx1Z2luc1tpXVttZXRob2ROYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlcyA9IHBsdWdpbnNbaV1bbWV0aG9kTmFtZV0uYXBwbHkocGx1Z2luc1tpXSwgYXJncyk7XG4gICAgICBpZiAodHlwZW9mIHJlcyAhPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdHMucHVzaChyZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIHdvcmthcm91bmQgZm9yIGtub2Nrb3V0LWpxdWVyeXVpJ3MgYnV0dG9uc2V0L2J1dHRvbiBkaXNwb3NhbDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ndmFzL2tub2Nrb3V0LWpxdWVyeXVpL2lzc3Vlcy8yNVxudmFyIG9yaWdEaXNwb3NlQ2FsbGJhY2sgPSBrby51dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrO1xua28udXRpbHMuZG9tTm9kZURpc3Bvc2FsLmFkZERpc3Bvc2VDYWxsYmFjayA9IGZ1bmN0aW9uKG5vZGUsIGNhbGxiYWNrKSB7XG4gIHZhciBuZXdDYWxsYmFjayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coXCJjb3VnaHQgZGlzcG9zZSBjYWxsYmFjayBleGNlcHRpb25cIiwgZSk7XG4gICAgfVxuICB9O1xuICBvcmlnRGlzcG9zZUNhbGxiYWNrKG5vZGUsIG5ld0NhbGxiYWNrKTtcbn07XG5cbnZhciBiaW5kaW5nUGx1Z2luTWFrZXIgPSBmdW5jdGlvbihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKSB7XG4gIHJldHVybiB7XG4gICAgdmlld01vZGVsOiBmdW5jdGlvbih2aWV3TW9kZWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ2FwcGx5QmluZGluZ3MnLCBrby5hcHBseUJpbmRpbmdzLmJpbmQodW5kZWZpbmVkLCB2aWV3TW9kZWwpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIsIGVyci5zdGFjayk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGVyZm9ybWFuY2VBd2FyZUNhbGxlcigndW5hcHBseUJpbmRpbmdzJywga28uY2xlYW5Ob2RlLmJpbmQodGhpcywgZ2xvYmFsLmRvY3VtZW50LmJvZHkpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIsIGVyci5zdGFjayk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG52YXIgdGVtcGxhdGVDcmVhdG9yID0gZnVuY3Rpb24odGVtcGxhdGVQbHVnaW4sIGh0bWxPckVsZW1lbnQsIG9wdGlvbmFsTmFtZSwgdGVtcGxhdGVNb2RlKSB7XG4gIHZhciB0bXBOYW1lID0gb3B0aW9uYWxOYW1lO1xuICBpZiAodHlwZW9mIG9wdGlvbmFsTmFtZSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGVtcGxhdGVNb2RlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBodG1sT3JFbGVtZW50ICE9ICdvYmplY3QnIHx8IGh0bWxPckVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdyZXBsYWNlZGh0bWwnKSB0bXBOYW1lICs9ICctJyArIHRlbXBsYXRlTW9kZTtcbiAgfVxuXG4gIHdoaWxlICh0eXBlb2YgdG1wTmFtZSA9PSAndW5kZWZpbmVkJyB8fCB0bXBOYW1lID09PSBudWxsIHx8IHRlbXBsYXRlUGx1Z2luLmV4aXN0cyh0bXBOYW1lKSkge1xuICAgIHRtcE5hbWUgPSAnYW5vbnltb3VzLScgKyBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogMTAwMDAwKSArIDEpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBodG1sT3JFbGVtZW50ID09ICdvYmplY3QnICYmIGh0bWxPckVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICdyZXBsYWNlZGh0bWwnKSB7XG4gICAgdmFyICRlbCA9ICQoaHRtbE9yRWxlbWVudCk7XG4gICAgdmFyICRoZWFkID0gJCgncmVwbGFjZWRoZWFkJywgJGVsKTtcbiAgICB2YXIgJGJvZHkgPSAkKCdyZXBsYWNlZGJvZHknLCAkZWwpO1xuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLWhlYWQnLCAkaGVhZC5odG1sKCkgfHwgJycpO1xuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLXNob3cnLCAkYm9keS5odG1sKCkgfHwgJycpO1xuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLXByZXZpZXcnLCAkZWwuaHRtbCgpKTtcbiAgICB0ZW1wbGF0ZVBsdWdpbi5hZGRlcih0bXBOYW1lICsgJy13eXNpd3lnJywgJGVsLmh0bWwoKSk7XG5cbiAgICAvLyAkaGVhZC5hdHRyKCdkYXRhLWJpbmQnLCAnYmxvY2s6IGNvbnRlbnQnKTtcbiAgICAkaGVhZC5jaGlsZHJlbigpLmRldGFjaCgpO1xuICAgICRoZWFkLmh0bWwoXCI8IS0tIGtvIGJsb2NrOiBjb250ZW50IC0tPjwhLS0gL2tvIC0tPlwiKTtcbiAgICAkaGVhZC5iZWZvcmUoJzwhLS0ga28gd2l0aFByb3BlcnRpZXM6IHsgdGVtcGxhdGVNb2RlOiBcXCdoZWFkXFwnIH0gLS0+Jyk7XG4gICAgJGhlYWQuYWZ0ZXIoJzwhLS0gL2tvIC0tPicpO1xuICAgICRib2R5Lmh0bWwoXCI8IS0tIGtvIGJsb2NrOiBjb250ZW50IC0tPjwhLS0gL2tvIC0tPlwiKTtcblxuICAgIHRlbXBsYXRlUGx1Z2luLmFkZGVyKHRtcE5hbWUgKyAnLWlmcmFtZScsICRlbFswXS5vdXRlckhUTUwpO1xuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGh0bWxPckVsZW1lbnQgPT0gJ29iamVjdCcpIHtcbiAgICB0ZW1wbGF0ZVBsdWdpbi5hZGRlcih0bXBOYW1lLCBodG1sT3JFbGVtZW50Lm91dGVySFRNTCk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGVQbHVnaW4uYWRkZXIodG1wTmFtZSwgaHRtbE9yRWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gdG1wTmFtZTtcbn07XG5cbi8vIEFkYXB0ZXIgdG8gdHJhbnNmb3JtIFwidmlld01vZGVsIHBsdWdpbnNcIiBpbnRvIG1vcmUgZ2VuZXJpYyBwbHVnaW5zLlxuZnVuY3Rpb24gX3ZpZXdNb2RlbFBsdWdpbkluc3RhbmNlKHBsdWdpbkZ1bmN0aW9uKSB7XG4gIHZhciBpbnN0YW5jZTtcbiAgcmV0dXJuIHtcbiAgICB2aWV3TW9kZWw6IGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuICAgICAgaW5zdGFuY2UgPSBwbHVnaW5GdW5jdGlvbih2aWV3TW9kZWwpO1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW5zdGFuY2UuaW5pdCAhPT0gJ3VuZGVmaW5lZCcpIGluc3RhbmNlLmluaXQoKTtcbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGluc3RhbmNlLmRpc3Bvc2UgIT09ICd1bmRlZmluZWQnKSBpbnN0YW5jZS5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgX3RlbXBsYXRlVXJsQ29udmVydGVyID0gZnVuY3Rpb24oYmFzZVBhdGgsIHVybCkge1xuICBpZiAoIXVybC5tYXRjaCgvXlteXFwvXSo6LykgJiYgIXVybC5tYXRjaCgvXlxcLy8pICYmICF1cmwubWF0Y2goL15cXFsvKSAmJiAhdXJsLm1hdGNoKC9eIz8kLykpIHtcbiAgICAvLyBUT0RPIHRoaXMgY291bGQgYmUgc21hcnRlciBqb2luaW5nIHRoZSB1cmxzLi4uXG4gICAgcmV0dXJuIGJhc2VQYXRoICsgdXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgdGVtcGxhdGVMb2FkZXIgPSBmdW5jdGlvbihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyLCB0ZW1wbGF0ZUZpbGVOYW1lLCB0ZW1wbGF0ZU1ldGFkYXRhLCBqc29yanNvbiwgZXh0ZW5zaW9ucywgZ2FsbGVyeVVybCkge1xuICB2YXIgdGVtcGxhdGVGaWxlID0gdHlwZW9mIHRlbXBsYXRlRmlsZU5hbWUgPT0gJ3N0cmluZycgPyB0ZW1wbGF0ZUZpbGVOYW1lIDogdGVtcGxhdGVNZXRhZGF0YS50ZW1wbGF0ZTtcbiAgdmFyIHRlbXBsYXRlUGF0aCA9IFwiLi9cIjtcbiAgdmFyIHAgPSB0ZW1wbGF0ZUZpbGUubGFzdEluZGV4T2YoJy8nKTtcbiAgaWYgKHAgIT0gLTEpIHtcbiAgICB0ZW1wbGF0ZVBhdGggPSB0ZW1wbGF0ZUZpbGUuc3Vic3RyKDAsIHAgKyAxKTtcbiAgfVxuXG4gIHZhciB0ZW1wbGF0ZVVybENvbnZlcnRlciA9IF90ZW1wbGF0ZVVybENvbnZlcnRlci5iaW5kKHVuZGVmaW5lZCwgdGVtcGxhdGVQYXRoKTtcblxuICB2YXIgbWV0YWRhdGE7XG4gIGlmICh0eXBlb2YgdGVtcGxhdGVGaWxlID09ICdzdHJpbmcnKSB7XG4gICAgbWV0YWRhdGEgPSB7XG4gICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVGaWxlLFxuICAgICAgLy8gVE9ETyBsMTBuP1xuICAgICAgbmFtZTogJ05vIG5hbWUnLFxuICAgICAgY3JlYXRlZDogRGF0ZS5ub3coKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbWV0YWRhdGEgPSB0ZW1wbGF0ZU1ldGFkYXRhO1xuICB9XG5cbiAgJC5nZXQodGVtcGxhdGVGaWxlLCBmdW5jdGlvbih0ZW1wbGF0ZWNvZGUpIHtcbiAgICB2YXIgcmVzID0gdGVtcGxhdGVDb21waWxlcihwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgXCJ0ZW1wbGF0ZVwiLCB0ZW1wbGF0ZWNvZGUsIGpzb3Jqc29uLCBtZXRhZGF0YSwgZXh0ZW5zaW9ucywgZ2FsbGVyeVVybCk7XG4gICAgcmVzLmluaXQoKTtcbiAgfSk7XG59O1xuXG52YXIgdGVtcGxhdGVDb21waWxlciA9IGZ1bmN0aW9uKHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIsIHRlbXBsYXRlVXJsQ29udmVydGVyLCB0ZW1wbGF0ZU5hbWUsIHRlbXBsYXRlY29kZSwganNvcmpzb24sIG1ldGFkYXRhLCBleHRlbnNpb25zLCBnYWxsZXJ5VXJsKSB7XG4gIC8vIHdlIHN0cmlwIGNvbnRlbnQgYmVmb3JlIDxodG1sPiB0YWcgYW5kIGFmdGVyIDwvaHRtbD4gYmVjYXVzZSBqcXVlcnkgZG9lc24ndCBwYXJzZSBpdC5cbiAgLy8gd2UnbGwga2VlcCBpdCBcInJhd1wiIGFuZCB1c2UgaXQgaW4gdGhlIHByZXZpZXcvb3V0cHV0IG1ldGhvZHMuXG4gIHZhciByZXMgPSB0ZW1wbGF0ZWNvZGUubWF0Y2goL14oW1xcU1xcc10qKShbPF1odG1sW14+XSo+W1xcU1xcc10qPFxcL2h0bWw+KShbXFxTXFxzXSopJC9pKTtcbiAgaWYgKHJlcyA9PT0gbnVsbCkgdGhyb3cgXCJVbmFibGUgdG8gZmluZCA8aHRtbD4gb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIGluIHRoZSB0ZW1wbGF0ZVwiO1xuICB2YXIgcHJlZml4ID0gcmVzWzFdO1xuICAvLyB3ZSBwYXJzZSB0aGUgaHRtbCBjb250ZW50IGFmdGVyIHJlcGxhY2luZyB0aGUgdGFnIG5hbWUgZm9yIGh0bWwvaGVhZC9ib2R5IHNvIHRvIGF2b2lkIGpxdWVyeSBpc3N1ZXMgaW4gcGFyc2luZy5cbiAgdmFyIGJhc2ljU3RydWN0dXJlID0geyAnPGh0bWwnOiAwLCAnPGhlYWQnOiAwLCAnPGJvZHknOiAwLCAnPC9odG1sJzogMCwgJzwvYm9keSc6IDAsICc8L2hlYWQnOiAwIH07XG4gIHZhciBodG1sID0gcmVzWzJdLnJlcGxhY2UoLyg8XFwvPykoaHRtbHxoZWFkfGJvZHkpKFtePl0qPikvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBwMSwgcDIsIHAzKSB7XG4gICAgYmFzaWNTdHJ1Y3R1cmVbKHAxK3AyKS50b0xvd2VyQ2FzZSgpXSArPSAxO1xuICAgIHJldHVybiBwMSArICdyZXBsYWNlZCcgKyBwMiArIHAzO1xuICB9KTtcbiAgZm9yICh2YXIgZWxlIGluIGJhc2ljU3RydWN0dXJlKSBpZiAoYmFzaWNTdHJ1Y3R1cmUuaGFzT3duUHJvcGVydHkoZWxlKSkgaWYgKGJhc2ljU3RydWN0dXJlW2VsZV0gIT0gMSkge1xuICAgIGlmIChiYXNpY1N0cnVjdHVyZVtlbGVdID09PSAwKSB0aHJvdyBcIkVSUk9SOiBtaXNzaW5nIG1hbmRhdG9yeSBlbGVtZW50IFwiK2VsZStcIj5cIjtcbiAgICBpZiAoYmFzaWNTdHJ1Y3R1cmVbZWxlXSA+IDEpIHRocm93IFwiRVJST1I6IG11bHRpcGxlIGVsZW1lbnQgXCIrZWxlK1wiPiBvY2NvdXJlbmNlcyBhcmUgbm90IHN1cHBvcnRlZCAoZm91bmQgXCIrYmFzaWNTdHJ1Y3R1cmVbZWxlXStcIiBvY2NvdXJlbmNlcylcIjtcbiAgfVxuICB2YXIgcG9zdGZpeCA9IHJlc1szXTtcbiAgdmFyIGJsb2NrRGVmcyA9IFtdO1xuICB2YXIgZW5hYmxlVW5kbyA9IHRydWU7XG4gIHZhciBlbmFibGVSZWNvcmRlciA9IHRydWU7XG4gIHZhciBiYXNlVGhyZXNob2xkID0gJyskcm9vdC5jb250ZW50TGlzdGVuZXJzKCknO1xuXG4gIHZhciBwbHVnaW5zID0gW107XG5cbiAgaWYgKHR5cGVvZiBleHRlbnNpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb25zW2ldID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2lucy5wdXNoKF92aWV3TW9kZWxQbHVnaW5JbnN0YW5jZShleHRlbnNpb25zW2ldKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbHVnaW5zLnB1c2goZXh0ZW5zaW9uc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNyZWF0ZWRUZW1wbGF0ZXMgPSBbXTtcbiAgdmFyIHRlbXBsYXRlc1BsdWdpbiA9IHtcbiAgICBhZGRlcjogZnVuY3Rpb24oaWQsIGh0bWwpIHtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3N0cmluZycpIHRocm93IFwiVGVtcGxhdGUgc3lzdGVtOiBjYW5ub3QgY3JlYXRlIG5ldyB0ZW1wbGF0ZSBcIiArIGlkO1xuICAgICAgdmFyIHRyYXNoID0gaHRtbC5tYXRjaCgvKGRhdGEpPy1rby1bXiA9Ol0qL2cpO1xuICAgICAgaWYgKHRyYXNoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFUlJPUjogZm91bmQgdW5leHBlY3RlZCAta28tIGF0dHJpYnV0ZSBpbiBjb21waWxlZCB0ZW1wbGF0ZVwiLCBpZCwgXCIsIHlvdSBwcm9iYWJseSBtaXNwZWxsZWQgaXQ6XCIsIHRyYXNoKTtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlU3lzdGVtLmFkZFRlbXBsYXRlKGlkLCBodG1sKTtcbiAgICAgIGNyZWF0ZWRUZW1wbGF0ZXMucHVzaChpZCk7XG4gICAgfSxcbiAgICBleGlzdHM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgZWwgPSB0ZW1wbGF0ZVN5c3RlbS5nZXRUZW1wbGF0ZUNvbnRlbnQoaWQpO1xuICAgICAgaWYgKHR5cGVvZiBlbCAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0cnVlO1xuICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSBjcmVhdGVkVGVtcGxhdGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRlbXBsYXRlU3lzdGVtLnJlbW92ZVRlbXBsYXRlKGNyZWF0ZWRUZW1wbGF0ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBrby5iaW5kaW5nSGFuZGxlcnNbJ2Jsb2NrJ10udGVtcGxhdGVFeGlzdHMgPSB0ZW1wbGF0ZXNQbHVnaW4uZXhpc3RzO1xuXG4gIC8vIHRlbXBsYXRlY3JlYXRvciB0cmFja3MgY3JlYXRlZCB0ZW1wbGF0ZSAodmlhIHRlbXBsYXRlQWRkZXIpIHNvIHRvIGJlIGFibGUgdG8gZGlzcG9zZSB0aGVtIGxhdGVyXG4gIHZhciBteVRlbXBsYXRlQ3JlYXRvciA9IHRlbXBsYXRlQ3JlYXRvci5iaW5kKHVuZGVmaW5lZCwgdGVtcGxhdGVzUGx1Z2luKTtcblxuICAvLyBmaXJzdCBwYXNzOiB3ZSBcImNvbXBpbGVcIiB0aGUgdGVtcGxhdGUgaW50byBhIHRlcm1wbGF0ZURlZiBvYmplY3RcbiAgdmFyIHRlbXBsYXRlRGVmID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlcigndHJhbnNsYXRlVGVtcGxhdGUnLCB0ZW1wbGF0ZUNvbnZlcnRlci50cmFuc2xhdGVUZW1wbGF0ZS5iaW5kKHVuZGVmaW5lZCwgdGVtcGxhdGVOYW1lLCBodG1sLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbXlUZW1wbGF0ZUNyZWF0b3IpKTtcblxuICAvLyBzZWNvbmQgcGFzczogZ2l2ZW4gdGhlIHRlbXBsYXRlRGVmIHdlIGNyZWF0ZSBhIGJhc2UgY29udGVudCBtb2RlbCBvYmplY3QgZm9yIHRoaXMgdGVtcGxhdGUuXG4gIHZhciBjb250ZW50ID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlcignZ2VuZXJhdGVNb2RlbCcsIHRlbXBsYXRlQ29udmVydGVyLndyYXBwZWRSZXN1bHRNb2RlbC5iaW5kKHVuZGVmaW5lZCwgdGVtcGxhdGVEZWYpKTtcblxuICAvLyB0aGlyZCBwYXNzOiB3ZSBjcmVhdGUgXCJzdHlsZS9jb250ZW50IGVkaXRvcnNcIiBmb3IgZXZlcnkgYmxvY2tcbiAgdmFyIHdpZGdldHMgPSB7fTtcbiAgdmFyIHdpZGdldFBsdWdpbnMgPSBwbHVnaW5zQ2FsbChwbHVnaW5zLCAnd2lkZ2V0JywgWyQsIGtvLCBrb2pxdWldKTtcbiAgZm9yICh2YXIgd2kgPSAwOyB3aSA8IHdpZGdldFBsdWdpbnMubGVuZ3RoOyB3aSsrKSB7XG4gICAgd2lkZ2V0c1t3aWRnZXRQbHVnaW5zW3dpXS53aWRnZXRdID0gd2lkZ2V0UGx1Z2luc1t3aV07XG4gIH1cbiAgYmxvY2tEZWZzLnB1c2guYXBwbHkoYmxvY2tEZWZzLCBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKCdnZW5lcmF0ZUVkaXRvcnMnLCB0ZW1wbGF0ZUNvbnZlcnRlci5nZW5lcmF0ZUVkaXRvcnMuYmluZCh1bmRlZmluZWQsIHRlbXBsYXRlRGVmLCB3aWRnZXRzLCB0ZW1wbGF0ZVVybENvbnZlcnRlciwgbXlUZW1wbGF0ZUNyZWF0b3IsIGJhc2VUaHJlc2hvbGQpKSk7XG5cbiAgdmFyIGluY29tcGF0aWJsZVRlbXBsYXRlID0gZmFsc2U7XG4gIGlmICh0eXBlb2YganNvcmpzb24gIT09ICd1bmRlZmluZWQnICYmIGpzb3Jqc29uICE9PSBudWxsKSB7XG4gICAgdmFyIHVud3JhcHBlZDtcbiAgICBpZiAodHlwZW9mIGpzb3Jqc29uID09ICdzdHJpbmcnKSB7XG4gICAgICB1bndyYXBwZWQgPSBrby51dGlscy5wYXJzZUpzb24oanNvcmpzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bndyYXBwZWQgPSBqc29yanNvbjtcbiAgICB9XG5cbiAgICAvLyB3ZSBydW4gYSBiYXNpYyBjb21wYXRpYmlsaXR5IGNoZWNrIGJldHdlZW4gdGhlIGNvbnRlbnQtbW9kZWwgd2UgZXhwZWN0IGFuZCB0aGUgaW5pdGlhbGl6YXRpb24gbW9kZWxcbiAgICB2YXIgY2hlY2tNb2RlbFJlcyA9IHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ2NoZWNrTW9kZWwnLCB0ZW1wbGF0ZUNvbnZlcnRlci5jaGVja01vZGVsLmJpbmQodW5kZWZpbmVkLCBjb250ZW50Ll91bndyYXAoKSwgYmxvY2tEZWZzLCB1bndyYXBwZWQpKTtcbiAgICAvLyBpZiBjaGVja01vZGVsUmVzIGlzIDEgdGhlbiB0aGUgbW9kZWwgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUgYnV0IHdlIGZpeGVkIGl0XG4gICAgaWYgKGNoZWNrTW9kZWxSZXMgPT0gMikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRyeWluZyB0byBjb21waWxlIGFuIGluY29tcGF0aWJsZSB0ZW1wbGF0ZSB2ZXJzaW9uIVwiLCBjb250ZW50Ll91bndyYXAoKSwgYmxvY2tEZWZzLCB1bndyYXBwZWQpO1xuICAgICAgaW5jb21wYXRpYmxlVGVtcGxhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb250ZW50Ll93cmFwKHVud3JhcHBlZCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gaW5qZWN0IG1vZGVsIGNvbnRlbnQhXCIsIGV4KTtcbiAgICAgIGluY29tcGF0aWJsZVRlbXBsYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIGJ1aWxkIHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHByZXZpZXcvb3V0cHV0LCBidXQgY29uY2F0ZW5hdGluZyBwcmVmaXgsIHRlbXBsYXRlIGFuZCBjb250ZW50IGFuZCBzdHJpcHBpbmcgdGhlIFwicmVwbGFjZWRcIiBwcmVmaXggYWRkZWQgdG8gXCJwcm9ibGVtYXRpY1wiIHRhZyAoaHRtbC9oZWFkL2JvZHkpXG4gIHZhciBpZnJhbWVUcGwgPSBwcmVmaXggKyB0ZW1wbGF0ZVN5c3RlbS5nZXRUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGVOYW1lICsgJy1pZnJhbWUnKS5yZXBsYWNlKC8oPFxcLz8pcmVwbGFjZWQoaHRtbHxoZWFkfGJvZHkpKFtePl0qPikvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIHAxICsgcDIgKyBwMztcbiAgfSkgKyBwb3N0Zml4O1xuXG4gIC8vIHN0b3JlIHRoaXMgc28gdG8gcmVzdG9yZSBpdCBvbiBkaXNwb3NhbGVcbiAgdmFyIG9yaWdpRnJhbWVUcGwgPSBrby5iaW5kaW5nSGFuZGxlcnMuYmluZElmcmFtZS50cGw7XG4gIGtvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lLnRwbCA9IGlmcmFtZVRwbDtcbiAgdmFyIGlGcmFtZVBsdWdpbiA9IHtcbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGtvLmJpbmRpbmdIYW5kbGVycy5iaW5kSWZyYW1lLnRwbCA9IG9yaWdpRnJhbWVUcGw7XG4gICAgfVxuICB9O1xuXG4gIHBsdWdpbnMucHVzaChpRnJhbWVQbHVnaW4pO1xuICBwbHVnaW5zLnB1c2godGVtcGxhdGVzUGx1Z2luKTtcblxuICAvLyBpbml0aWFsaXplIHRoZSB2aWV3TW9kZWwgb2JqZWN0IGJhc2VkIG9uIHRoZSBjb250ZW50IG1vZGVsLlxuICB2YXIgdmlld01vZGVsID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlcignaW5pdGlhbGl6ZVZpZXdtb2RlbCcsIGluaXRpYWxpemVWaWV3bW9kZWwuYmluZCh0aGlzLCBjb250ZW50LCBibG9ja0RlZnMsIHRlbXBsYXRlVXJsQ29udmVydGVyLCBnYWxsZXJ5VXJsKSk7XG5cbiAgdmlld01vZGVsLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gIC8vIGxldCdzIHJ1biBzb21lIHZlcnNpb24gY2hlY2sgb24gdGVtcGxhdGUgYW5kIGVkaXRvciB1c2VkIHRvIGJ1aWxkIHRoZSBtb2RlbCBiZWluZyBsb2FkZWQuXG4gIHZhciBlZGl0dmVyID0gJzAuMTMuMCc7XG4gIGlmICh0eXBlb2Ygdmlld01vZGVsLm1ldGFkYXRhLmVkaXRvcnZlcnNpb24gIT09ICd1bmRlZmluZWQnICYmIHZpZXdNb2RlbC5tZXRhZGF0YS5lZGl0b3J2ZXJzaW9uICE9PSBlZGl0dmVyKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIG1vZGVsIGJlaW5nIGxvYWRlZCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYW4gb2xkZXIgZWRpdG9yIHZlcnNpb25cIiwgdmlld01vZGVsLm1ldGFkYXRhLmVkaXRvcnZlcnNpb24sIFwidnNcIiwgZWRpdHZlcik7XG4gIH1cbiAgdmlld01vZGVsLm1ldGFkYXRhLmVkaXRvcnZlcnNpb24gPSBlZGl0dmVyO1xuXG4gIGlmICh0eXBlb2YgdGVtcGxhdGVEZWYudmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHZpZXdNb2RlbC5tZXRhZGF0YS50ZW1wbGF0ZXZlcnNpb24gIT09ICd1bmRlZmluZWQnICYmIHZpZXdNb2RlbC5tZXRhZGF0YS50ZW1wbGF0ZXZlcnNpb24gIT09IHRlbXBsYXRlRGVmLnZlcnNpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgbW9kZWwgYmVpbmcgbG9hZGVkIGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBhIGRpZmZlcmVudCB0ZW1wbGF0ZSB2ZXJzaW9uXCIsIHRlbXBsYXRlRGVmLnZlcnNpb24sIFwidnNcIiwgdmlld01vZGVsLm1ldGFkYXRhLnRlbXBsYXRldmVyc2lvbik7XG4gICAgfVxuICAgIHZpZXdNb2RlbC5tZXRhZGF0YS50ZW1wbGF0ZXZlcnNpb24gPSB0ZW1wbGF0ZURlZi52ZXJzaW9uO1xuICB9XG5cbiAgdGVtcGxhdGVTeXN0ZW0uaW5pdCgpO1xuXG4gIC8vIGV2ZXJ5dGhpbmcncyByZWFkeSwgc3RhcnQga25vY2tvdXQgYmluZGluZ3MuXG4gIHBsdWdpbnMucHVzaChiaW5kaW5nUGx1Z2luTWFrZXIocGVyZm9ybWFuY2VBd2FyZUNhbGxlcikpO1xuXG4gIHBsdWdpbnNDYWxsKHBsdWdpbnMsICd2aWV3TW9kZWwnLCBbdmlld01vZGVsXSk7XG5cbiAgaWYgKGluY29tcGF0aWJsZVRlbXBsYXRlKSB7XG4gICAgJCgnI2luY29tcGF0aWJsZS10ZW1wbGF0ZScpLmRpYWxvZyh7XG4gICAgICBtb2RhbDogdHJ1ZSxcbiAgICAgIGFwcGVuZFRvOiAnI21vLWJvZHknLFxuICAgICAgYnV0dG9uczoge1xuICAgICAgICBPazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJCh0aGlzKS5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtb2RlbDogdmlld01vZGVsLFxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcGx1Z2luc0NhbGwocGx1Z2lucywgJ2luaXQnLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH0sXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICBwbHVnaW5zQ2FsbChwbHVnaW5zLCAnZGlzcG9zZScsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG59O1xuXG5cbnZhciBjaGVja0ZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBmdW5jKSB7XG4gIGlmICghZnVuYygpKSB7XG4gICAgY29uc29sZS53YXJuKFwiTWlzc2luZyBmZWF0dXJlXCIsIGZlYXR1cmUpO1xuICAgIHRocm93IFwiTWlzc2luZyBmZWF0dXJlIFwiICsgZmVhdHVyZTtcbiAgfVxufTtcblxudmFyIGlzQ29tcGF0aWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIHdpbmRvdy5tc01hdGNoTWVkaWEgd291bGQgbWF0Y2ggYWxzbyBJRTlcbiAgICAvLyBJRTkgd291bGRuJ3QgYmUgc28gaGFyZCB0byBzdXBwb3J0LCBidXQgaXQgZG9lc24ndCB3b3J0aCBpdC4gKHByZXZpZXcgaWZyYW1lIGFuZCBhdXRvbWF0aWMgc2Nyb2xsIGFyZSAyIHRoaW5ncyBub3Qgd29ya2luZyBpbiBJRTkpXG4gICAgY2hlY2tGZWF0dXJlKCdtYXRjaE1lZGlhJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGdsb2JhbC5tYXRjaE1lZGlhICE9ICd1bmRlZmluZWQnO1xuICAgIH0pO1xuICAgIGNoZWNrRmVhdHVyZSgnWE1MSHR0cFJlcXVlc3QgMicsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdYTUxIdHRwUmVxdWVzdCcgaW4gZ2xvYmFsICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9KTtcbiAgICBjaGVja0ZlYXR1cmUoJ0VTNSBzdHJpY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgLyogXCJ1c2Ugc3RyaWN0XCI7Ki9cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICd1bmRlZmluZWQnO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICAgIGNoZWNrRmVhdHVyZSgnQ1NTIGJvcmRlclJhZGl1cycsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQuYm9keS5zdHlsZVsnYm9yZGVyUmFkaXVzJ10gIT0gJ3VuZGVmaW5lZCc7XG4gICAgfSk7XG4gICAgY2hlY2tGZWF0dXJlKCdDU1MgYm94U2hhZG93JywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGdsb2JhbC5kb2N1bWVudC5ib2R5LnN0eWxlWydib3hTaGFkb3cnXSAhPSAndW5kZWZpbmVkJztcbiAgICB9KTtcbiAgICBjaGVja0ZlYXR1cmUoJ0NTUyBib3hTaXppbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LmJvZHkuc3R5bGVbJ2JveFNpemluZyddICE9ICd1bmRlZmluZWQnO1xuICAgIH0pO1xuICAgIGNoZWNrRmVhdHVyZSgnQ1NTIGJhY2tncm91bmRTaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGdsb2JhbC5kb2N1bWVudC5ib2R5LnN0eWxlWydiYWNrZ3JvdW5kU2l6ZSddICE9ICd1bmRlZmluZWQnO1xuICAgIH0pO1xuICAgIGNoZWNrRmVhdHVyZSgnQ1NTIGJhY2tncm91bmRPcmlnaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LmJvZHkuc3R5bGVbJ2JhY2tncm91bmRPcmlnaW4nXSAhPSAndW5kZWZpbmVkJztcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbnZhciBmaXhQYWdlRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgaXMgZ2xvYmFsIGNvZGUgdG8gcHJldmVudCBkcmFnZ2luZy9kcm9wcGluZyBpbiB0aGUgcGFnZSB3aGVyZSB3ZSBkb24ndCBkZWFsIHdpdGggaXQuXG4gIC8vIElFOCBkb2Vzbid0IGhhdmUgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIsIGJ1dCBkb2Vzbid0IHN1cHBvcnQgZHJhZyZkcm9wIHRvby5cbiAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgLy8gcHJldmVudCBnZW5lcmljIGZpbGUgZHJvcHBwaW5nIGluIHRoZSBwYWdlXG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiYnJvd3NlciBpcyB1c2luZyBkcmFnIGxpc3RlbmVyIG9uIHdpbmRvd1wiKTtcbiAgICAgIGUgPSBlIHx8IGdsb2JhbC5ldmVudDtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJicm93c2VyIGlzIHVzaW5nIGRyYWdzdGFydCBsaXN0ZW5lciBvbiB3aW5kb3dcIik7XG4gICAgICBlID0gZSB8fCBnbG9iYWwuZXZlbnQ7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gdGhpcyBpcyBjYWxsZWQgb24gbW91c2UgbW92ZSBvbiBldmVyeSBzdXBwb3J0ZWQgYnJvd3Nlci5cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiYnJvd3NlciBpcyB1c2luZyBkcmFnb3ZlciBsaXN0ZW5lciBvbiB3aW5kb3dcIik7XG4gICAgICBlID0gZSB8fCBnbG9iYWwuZXZlbnQ7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImJyb3dzZXIgaXMgdXNpbmcgZHJvcCBsaXN0ZW5lciBvbiB3aW5kb3dcIik7XG4gICAgICBlID0gZSB8fCBnbG9iYWwuZXZlbnQ7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBJIGJyb3dzZXIgc3VwcG9ydGF0aSBlbnRyYXRvIHR1dHRpIHF1aSBxdWFuZG8gc2kgZHJvcHBhIHF1YWxjb3NhIHN1bCBib2R5XG4gICAgICAvLyBjb25zb2xlLmxvZyhcImJyb3dzZXIgaXMgdXNpbmcgZHJvcCBsaXN0ZW5lciBvbiBib2R5IHRhZ1wiKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbiAgaWYgKGdsb2JhbC5kb2N1bWVudC5vbmRyYWdzdGFydCkge1xuICAgIGdsb2JhbC5kb2N1bWVudC5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJicm93c2VyIGNhbGxlZCBvbmRyYWdzdGFydC4gcmV0dXJuIGZhbHNlIVwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGlsZTogdGVtcGxhdGVDb21waWxlcixcbiAgbG9hZDogdGVtcGxhdGVMb2FkZXIsXG4gIGlzQ29tcGF0aWJsZTogaXNDb21wYXRpYmxlLFxuICBmaXhQYWdlRXZlbnRzOiBmaXhQYWdlRXZlbnRzXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY29uc29sZSA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jvd2VyX2NvbXBvbmVudHMvY29uc29sZS1icm93c2VyaWZ5L2luZGV4LmpzXCIpO1xuXG52YXIgX2NhbGwgPSBmdW5jdGlvbih3aGF0VG9DYWxsKSB7XG4gIHJldHVybiB3aGF0VG9DYWxsKCk7XG59O1xuXG52YXIgbG9ncyA9IFtdO1xuXG52YXIgX3RpbWVkQ2FsbCA9IGZ1bmN0aW9uKG5hbWUsIHdoYXRUb0NhbGwpIHtcbiAgdmFyIHJlcztcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGlmICh0eXBlb2YgY29uc29sZSA9PSAnb2JqZWN0JyAmJiBjb25zb2xlLnRpbWUpIGNvbnNvbGUudGltZShuYW1lKTtcbiAgcmVzID0gX2NhbGwod2hhdFRvQ2FsbCk7XG4gIGlmICh0eXBlb2YgY29uc29sZSA9PSAnb2JqZWN0JyAmJiBjb25zb2xlLnRpbWUpIGNvbnNvbGUudGltZUVuZChuYW1lKTtcbiAgdmFyIGRpZmYgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0O1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gJ29iamVjdCcgJiYgIWNvbnNvbGUudGltZSkgY29uc29sZS5sb2cobmFtZSwgXCJ0b29rXCIsIGRpZmYsIFwibXNcIik7XG4gIGxvZ3MucHVzaCh7XG4gICAgbmFtZTogbmFtZSxcbiAgICB0aW1lOiBkaWZmXG4gIH0pO1xuICAvLyBtYXggbG9nc1xuICBpZiAobG9ncy5sZW5ndGggPiAxMDApIGxvZ3MudW5zaGlmdCgpO1xuICByZXR1cm4gcmVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRpbWVkQ2FsbDogX3RpbWVkQ2FsbCxcbiAgbG9nczogbG9nc1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGtvID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2tvJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydrbyddIDogbnVsbCk7XG52YXIgdW5kb01hbmFnZXIgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2tub2Nrb3V0LXVuZG9tYW5hZ2VyL2tub2Nrb3V0LXVuZG9tYW5hZ2VyLmpzXCIpO1xudmFyIHVuZG9zZXJpYWxpemVyID0gcmVxdWlyZShcIi4vdW5kb3NlcmlhbGl6ZXIuanNcIik7XG5cbnZhciBhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlciA9IGZ1bmN0aW9uKHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZpZXdNb2RlbCkge1xuXG4gICAgdmlld01vZGVsLmNvbnRlbnRMaXN0ZW5lcnModmlld01vZGVsLmNvbnRlbnRMaXN0ZW5lcnMoKSArIDIpO1xuXG4gICAgLy8gVE9ETyB0aGUgbGFiZWxzIHNob3VsZCBiZSBjb21wdXRlZCBvYnNlcnZhYmxlcyAobmVlZHMgY2hhbmdlcyBpbiB1bmRvbWFuYWdlciBwcm9qZWN0cylcbiAgICB2YXIgdW5kb1JlZG9TdGFjayA9IHVuZG9NYW5hZ2VyKHZpZXdNb2RlbC5jb250ZW50LCB7XG4gICAgICBsZXZlbHM6IDEwMCxcbiAgICAgIHVuZG9MYWJlbDoga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7IHJldHVybiB2aWV3TW9kZWwudChcIlVuZG8gKCNDT1VOVCMpXCIpOyB9KSxcbiAgICAgIHJlZG9MYWJlbDoga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7IHJldHVybiB2aWV3TW9kZWwudChcIlJlZG9cIik7IH0pXG4gICAgfSk7XG4gICAgdmlld01vZGVsLnVuZG8gPSB1bmRvUmVkb1N0YWNrLnVuZG9Db21tYW5kO1xuICAgIHZpZXdNb2RlbC51bmRvLmV4ZWN1dGUgPSBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyLmJpbmQodmlld01vZGVsLCAndW5kbycsIHZpZXdNb2RlbC51bmRvLmV4ZWN1dGUpO1xuICAgIHZpZXdNb2RlbC5yZWRvID0gdW5kb1JlZG9TdGFjay5yZWRvQ29tbWFuZDtcbiAgICB2aWV3TW9kZWwucmVkby5leGVjdXRlID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlci5iaW5kKHZpZXdNb2RlbCwgJ3JlZG8nLCB2aWV3TW9kZWwucmVkby5leGVjdXRlKTtcbiAgICB2aWV3TW9kZWwudW5kb1Jlc2V0ID0gcGVyZm9ybWFuY2VBd2FyZUNhbGxlci5iaW5kKHZpZXdNb2RlbCwgJ3VuZG9SZXNldCcsIHVuZG9SZWRvU3RhY2sucmVzZXQpO1xuICAgIHZpZXdNb2RlbC5zZXRVbmRvTW9kZU1lcmdlID0gdW5kb1JlZG9TdGFjay5zZXRNb2RlTWVyZ2U7XG4gICAgdmlld01vZGVsLnNldFVuZG9Nb2RlT25jZSA9IHVuZG9SZWRvU3RhY2suc2V0TW9kZU9uY2U7XG4gICAgdW5kb1JlZG9TdGFjay5zZXRNb2RlSWdub3JlKCk7XG4gICAgdW5kb1JlZG9TdGFjay5zZXRVbmRvQWN0aW9uTWFrZXIodW5kb3NlcmlhbGl6ZXIubWFrZVVuZG9BY3Rpb24uYmluZCh1bmRlZmluZWQsIHZpZXdNb2RlbC5jb250ZW50KSk7XG4gICAgdW5kb3NlcmlhbGl6ZXIud2F0Y2hFbmFibGVkKHRydWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdW5kb1JlZG9TdGFjay5zZXRNb2RlSWdub3JlKCk7XG4gICAgICB9LFxuICAgICAgcnVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdW5kb1JlZG9TdGFjay5zZXRNb2RlT25jZSgpO1xuICAgICAgfSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB1bmRvUmVkb1N0YWNrLnNldE1vZGVPbmNlKCk7XG4gICAgICB9LFxuICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZpZXdNb2RlbC5jb250ZW50TGlzdGVuZXJzKHZpZXdNb2RlbC5jb250ZW50TGlzdGVuZXJzKCkgLSAyKTtcbiAgICAgICAgdW5kb3NlcmlhbGl6ZXIud2F0Y2hFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgdW5kb1JlZG9TdGFjay5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRVbmRvU3RhY2tFeHRlbnNpb25NYWtlcjsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbi8vIFRoaXMgbW9kdWxlIGRlYWxzIHdpdGggc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRpb24gb2YgYSBcInRyZWUtcGF0aFwiIHJlcHJlc2VudGluZyB0aGUgcGF0aCB0byByZWFjaCB0aGUgZ2l2ZW4gbGVhZi5cbi8vIEluIG9yZGVyIHRvIGJlIGNvcnJlY3RseSBzZXJpYWxpemVkIHdlIGhhdmUgdG8gbW92ZSBmcm9tIFwicmVmZXJlbmNlXCIgdG8gXCJzdHJpbmdcIiBhbmQgdmljZXZlcnNhLlxuXG52YXIgX3JlZmVyZW5jZSA9IGZ1bmN0aW9uKG1vZGVsLCBwYXRoKSB7XG4gIHZhciBwID0gMDtcbiAgdmFyIHAxLCBwMjtcbiAgdmFyIG0gPSBtb2RlbDtcbiAgd2hpbGUgKHAgPCBwYXRoLmxlbmd0aCkge1xuICAgIHN3aXRjaCAocGF0aC5jaGFyQXQocCkpIHtcbiAgICAgIGNhc2UgJygnOlxuICAgICAgICBpZiAocGF0aC5jaGFyQXQocCArIDEpID09ICcpJykge1xuICAgICAgICAgIG0gPSBtKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHAgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgcDIgPSBwYXRoLmluZGV4T2YoJ10nLCBwKTtcbiAgICAgICAgbSA9IG1bcGF0aC5zdWJzdHJpbmcocCArIDEsIHAyKV07XG4gICAgICAgIHAgPSBwMiArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnLic6XG4gICAgICAgIHAxID0gcGF0aC5pbmRleE9mKCcoJywgcCk7XG4gICAgICAgIGlmIChwMSA9PSAtMSkgcDEgPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgcDIgPSBwYXRoLmluZGV4T2YoJ1snLCBwKTtcbiAgICAgICAgaWYgKHAyID09IC0xKSBwMiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICBwMiA9IE1hdGgubWluKHAxLCBwMik7XG4gICAgICAgIG0gPSBtW3BhdGguc3Vic3RyaW5nKHAgKyAxLCBwMildO1xuICAgICAgICBwID0gcDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVE9ETyBlcnJvclxuICAgIH1cbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbnZhciBfZ2V0UGF0aCA9IGZ1bmN0aW9uKHBhcmVudHMsIGNoaWxkKSB7XG4gIHZhciBwYXRoID0gXCJcIjtcbiAgdmFyIHA7XG4gIGZvciAodmFyIGsgPSAwOyBrIDw9IHBhcmVudHMubGVuZ3RoOyBrKyspIHtcbiAgICBwID0gayA8IHBhcmVudHMubGVuZ3RoID8gcGFyZW50c1trXSA6IGNoaWxkO1xuICAgIGlmIChrby5pc09ic2VydmFibGUocCkpIHBhdGggKz0gJygpJztcbiAgICBpZiAodHlwZW9mIHAuX2ZpZWxkTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhdGggKz0gXCIuXCIgKyBwLl9maWVsZE5hbWU7XG4gICAgfSBlbHNlIGlmIChrID4gMCAmJiB0eXBlb2YgcGFyZW50c1trIC0gMV0ucG9wID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRBcnJheSA9IGtvLmlzT2JzZXJ2YWJsZShwYXJlbnRzW2sgLSAxXSkgPyBrby51dGlscy5wZWVrT2JzZXJ2YWJsZShwYXJlbnRzW2sgLSAxXSkgOiBwYXJlbnRzW2sgLSAxXTtcbiAgICAgIHZhciBwb3MgPSBrby51dGlscy5hcnJheUluZGV4T2YocGFyZW50QXJyYXksIHApO1xuICAgICAgaWYgKHBvcyAhPSAtMSkge1xuICAgICAgICBwYXRoICs9IFwiW1wiICsgcG9zICsgXCJdXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOT1RFIHRoaXMgaGFwcGVuLCBzb21ldGltZXMgd2hlbiBUaW55TUNFIHNlbmRzIHVwZGF0ZXMgZm9yIG9iamVjdHMgYWxyZWFkeSByZW1vdmVkLlxuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBvYmplY3Qgbm90IGZvdW5kIGluIHBhcmVudCBhcnJheVwiLCBwYXJlbnRBcnJheSwgcCwgaywgcGFyZW50cy5sZW5ndGgsIGtvLnRvSlMocGFyZW50QXJyYXkpLCBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHApKTtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIG9iamVjdCBub3QgZm91bmQgaW4gcGFyZW50IGFycmF5XCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIHBhcmVudCB3aXRoIG5vIF9maWVsZE5hbWUgYW5kIG5vIHBhcmVudCBhcnJheVwiLCBrLCBwYXJlbnRzKTtcbiAgICAgIHRocm93IFwiVW5leHBlY3RlZCBwYXJlbnQgd2l0aCBubyBfZmllbGROYW1lIGFuZCBubyBwYXJlbnQgYXJyYXlcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG52YXIgbWFrZURlcmVmZXJlbmNlZFVuZG9BY3Rpb24gPSBmdW5jdGlvbih1bmRvRnVuYywgbW9kZWwsIHBhdGgsIHZhbHVlLCBpdGVtKSB7XG4gIHZhciBjaGlsZCA9IF9yZWZlcmVuY2UobW9kZWwsIHBhdGgpO1xuICB1bmRvRnVuYyhjaGlsZCwgdmFsdWUsIGl0ZW0pO1xufTtcblxudmFyIGxpc3RlbmVyO1xuXG52YXIgX3NldExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZnVuYykge1xuICBsaXN0ZW5lciA9IGxpc3RlbmZ1bmM7XG59O1xuXG4vKiBkZXJlZmVyZW5jaW5nIHBhdGggYW5kIGNoYW5naW5nIHZhbHVlIHdpdGggXCJ0b0pTXCIgKi9cbnZhciBtYWtlVW5kb0FjdGlvbkRlcmVmZXJlbmNlZCA9IGZ1bmN0aW9uKG1vZGVsLCB1bmRvRnVuYywgcGFyZW50cywgY2hpbGQsIG9sZFZhbCwgaXRlbSkge1xuICB0cnkge1xuICAgIHZhciBwYXRoID0gX2dldFBhdGgocGFyZW50cywgY2hpbGQpO1xuXG4gICAgLy8gVHJhbnNmb3JtIGFjdGlvbnMgaW4gc2ltcGxlIEpTIG9iamVjdHMuXG4gICAgaWYgKHR5cGVvZiBvbGRWYWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvbGRWYWwgPT09ICdmdW5jdGlvbicpIG9sZFZhbCA9IGtvLnRvSlMob2xkVmFsKTtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGl0ZW0udmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB2YXIgbmV3SXRlbSA9IGtvLnRvSlMoaXRlbSk7XG4gICAgICBpdGVtID0gbmV3SXRlbTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIocGF0aCwgY2hpbGQsIG9sZFZhbCwgaXRlbSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5kb3NlcmlhbGl6ZXIgaWdub3JpbmcgZXhjZXB0aW9uIGluIGxpc3RlbmVyIGNhbGxiYWNrXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlRGVyZWZlcmVuY2VkVW5kb0FjdGlvbi5iaW5kKHVuZGVmaW5lZCwgdW5kb0Z1bmMsIG1vZGVsLCBwYXRoLCBvbGRWYWwsIGl0ZW0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTk9URSB0aGlzIGhhcHBlbnMsIGZyb20gdGltZSB0byB0aW1lLCB3aGVuIFRpbnlNQ0Ugc2VuZHMgdXBkYXRlcyBmb3IgZGVsZXRlZCBjb250ZW50LlxuICAgIGNvbnNvbGUuZXJyb3IoXCJFeGNlcHRpb24gcHJvY2Vzc2luZyB1bmRvXCIsIGUsIHBhcmVudHMsIGNoaWxkLCBpdGVtKTtcbiAgfVxufTtcblxudmFyIHdhdGNoRW5hYmxlZDtcbnZhciBfd2F0Y2hFbmFibGVkID0gZnVuY3Rpb24obmV3VmFsKSB7XG4gIGlmICh0eXBlb2YgbmV3VmFsICE9PSAndW5kZWZpbmVkJylcbiAgICB3YXRjaEVuYWJsZWQgPSBuZXdWYWw7XG4gIGVsc2VcbiAgICByZXR1cm4gd2F0Y2hFbmFibGVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlcmVmZXJlbmNlOiBfZ2V0UGF0aCxcbiAgcmVmZXJlbmNlOiBfcmVmZXJlbmNlLFxuICBtYWtlVW5kb0FjdGlvbjogbWFrZVVuZG9BY3Rpb25EZXJlZmVyZW5jZWQsXG4gIHNldExpc3RlbmVyOiBfc2V0TGlzdGVuZXIsXG4gIHdhdGNoRW5hYmxlZDogX3dhdGNoRW5hYmxlZFxufTsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBnbG9iYWw6IGZhbHNlICovXG5cbnZhciAkID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2pRdWVyeSddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnalF1ZXJ5J10gOiBudWxsKTtcbnZhciBrbyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydrbyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsna28nXSA6IG51bGwpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKFwiLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL2NvbnNvbGUtYnJvd3NlcmlmeS9pbmRleC5qc1wiKTtcbnZhciBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyID0gcmVxdWlyZShcIi4vdGltZWQtY2FsbC5qc1wiKS50aW1lZENhbGw7XG5cbnZhciB0b2FzdHIgPSByZXF1aXJlKFwiLi8uLi8uLi9ib3dlcl9jb21wb25lbnRzL3RvYXN0ci90b2FzdHIuanNcIik7XG50b2FzdHIub3B0aW9ucyA9IHtcbiAgXCJjbG9zZUJ1dHRvblwiOiBmYWxzZSxcbiAgXCJkZWJ1Z1wiOiBmYWxzZSxcbiAgXCJwb3NpdGlvbkNsYXNzXCI6IFwidG9hc3QtYm90dG9tLWZ1bGwtd2lkdGhcIixcbiAgXCJ0YXJnZXRcIjogXCIjbW8tYm9keVwiLFxuICBcIm9uY2xpY2tcIjogbnVsbCxcbiAgXCJzaG93RHVyYXRpb25cIjogXCIzMDBcIixcbiAgXCJoaWRlRHVyYXRpb25cIjogXCIxMDAwXCIsXG4gIFwidGltZU91dFwiOiBcIjUwMDBcIixcbiAgXCJleHRlbmRlZFRpbWVPdXRcIjogXCIxMDAwXCIsXG4gIFwic2hvd0Vhc2luZ1wiOiBcInN3aW5nXCIsXG4gIFwiaGlkZUVhc2luZ1wiOiBcImxpbmVhclwiLFxuICBcInNob3dNZXRob2RcIjogXCJmYWRlSW5cIixcbiAgXCJoaWRlTWV0aG9kXCI6IFwiZmFkZU91dFwiXG59O1xuXG4vKiBOT1RFOiB0cmFuc2xhdGlvbnMgbW92ZWQgdG8gXCJwbHVnaW5cIlxudmFyIHN0cmluZ3MgPSB7XG4gICdzaG93IHByZXZpZXcgYW5kIHNlbmQgdGVzdCc6ICdWaXN1YWxpenphIHVuYSBhbnRlcHJpbWEgZSBmYWkgdW4gaW52aW8gZGkgdGVzdCcsXG4gIC8vIFN0cmluZ3MgZm9yIGFwcC5qc1xuICAnRG93bmxvYWQnOiAnRG93bmxvYWQnLFxuICAnVGVzdCc6ICdUZXN0JyxcbiAgJ1NhdmUnOiAnU2FsdmEnLFxuICAnRG93bmxvYWRpbmcuLi4nOiBcIkRvd25sb2FkIGluIGNvcnNvLi4uXCIsXG4gICdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnOiBcIkluZGlyaXp6byBlbWFpbCBpbnZhbGlkb1wiLFxuICBcIlRlc3QgZW1haWwgc2VudC4uLlwiOiBcIkVtYWlsIGRpIHRlc3QgaW52aWF0YS4uLlwiLFxuICAnVW5leHBlY3RlZCBlcnJvciB0YWxraW5nIHRvIHNlcnZlcjogY29udGFjdCB1cyEnOiAnRXJyb3JlIGRpIGNvbXVuaWNhemlvbmUgY29uIGlsIHNlcnZlcjogY29udGF0dGFjaSEnLFxuICAnSW5zZXJ0IGhlcmUgdGhlIHJlY2lwaWVudCBlbWFpbCBhZGRyZXNzJzogJ0luc2VyaXNjaSBxdWkgbFxcJ2luZGlyaXp6byBlbWFpbCBhIGN1aSBzcGVkaXJlJyxcbiAgXCJUZXN0IGVtYWlsIGFkZHJlc3NcIjogXCJJbmRpcml6em8gZW1haWwgZGkgdGVzdFwiLFxuICAvLyB2aWV3TW9kZWxcbiAgJ0Jsb2NrIHJlbW92ZWQ6IHVzZSB1bmRvIGJ1dHRvbiB0byByZXN0b3JlIGl0Li4uJzogJ0Jsb2NjbyBlbGltaW5hdG86IHVzYSBpbCBwdWxzYW50ZSBhbm51bGxhIHBlciByZWN1cGVyYXJsby4uLicsXG4gICdOZXcgYmxvY2sgYWRkZWQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG9uZSAoX19wb3NfXyknOiAnTnVvdm8gYmxvY2NvIGFnZ2l1bnRvIHNvdHRvIGEgcXVlbGxvIHNlbGV6aW9uYXRvIChfX3Bvc19fKScsXG4gICdOZXcgYmxvY2sgYWRkZWQgYXQgdGhlIG1vZGVsIGJvdHRvbSAoX19wb3NfXyknOiAnTnVvdm8gYmxvY2NvIGFnZ2l1bnRvIGluIGZvbmRvIGFsIG1vZGVsbG8gKF9fcG9zX18pJyxcbiAgLy8gdW5kb21haW4uanNcbiAgJ1VuZG8gKCNDT1VOVCMpJzogJ0FubnVsbGEgKCNDT1VOVCMpJyxcbiAgJ1JlZG8nOiAnUmlwcmlzdGluYScsXG4gIC8vIGVkaXRvci5qc1xuICAnU2VsZWN0ZWQgZWxlbWVudCBoYXMgbm8gZWRpdGFibGUgcHJvcGVydGllcyc6ICdMXFwnZWxlbWVudG8gc2VsZXppb25hdG8gbm9uIGZvcm5pc2NlIHByb3ByaWV0w6AgZWRpdGFiaWxpJyxcbiAgJ1RoaXMgc3R5bGUgaXMgc3BlY2lmaWMgZm9yIHRoaXMgYmxvY2s6IGNsaWNrIGhlcmUgdG8gcmVtb3ZlIHRoZSBjdXN0b20gc3R5bGUgYW5kIHJldmVydCB0byB0aGUgdGhlbWUgdmFsdWUnOiAnUXVlc3RvIHN0aWxlIMOoIHNwZWNpZmljbyBkaSBxdWVzdG8gYmxvY2NvOiBjbGljY2EgcXVpIHBlciBhbm51bGxhcmUgbG8gc3RpbGUgcGVyc29uYWxpenphdG8nLFxuICAnU3dpdGNoIGJldHdlZW4gZ2xvYmFsIGFuZCBibG9jayBsZXZlbCBzdHlsZXMgZWRpdGluZyc6ICdQZXJtZXR0ZSBkaSBzcGVjaWZpY2FyZSBzZSBzaSB2dW9sZSBtb2RpZmljYXJlIGxvIHN0aWxlIGdlbmVyYWxlIG8gc29sYW1lbnRlIHF1ZWxsbyBzcGVjaWZpY28gZGVsIGJsb2NjbyBzZWxlemlvbmF0bycsXG4gIC8vIG1haW4udHBsLmh0bWxcbiAgJ1VuZG8gbGFzdCBvcGVyYXRpb24nOiAnQW5udWxsYSB1bHRpbWEgb3BlcmF6aW9uZScsXG4gICdSZWRvIGxhc3Qgb3BlcmF0aW9uJzogJ1JpcGV0aSBvcGVyYXppb25lIGFubnVsbGF0YScsXG4gICdTaG93IGltYWdlIGdhbGxlcnknOiAnVmlzdWFsaXp6YSBnYWxsZXJpYSBpbW1hZ2luaScsXG4gICdHYWxsZXJ5JzogJ0dhbGxlcmlhJyxcbiAgJ1ByZXZpZXcnOiAnQW50ZXByaW1hJyxcbiAgJ1Nob3cgbGl2ZSBwcmV2aWV3JzogJ01vc3RyYSBhbnRlcHJpbWEgbGl2ZScsXG4gICdMYXJnZSBzY3JlZW4nOiAnU2NoZXJtbyBncmFuZGUnLFxuICAnVGFibGV0JzogJ1RhYmxldCcsXG4gICdTbWFydHBob25lJzogJ1NtYXJ0cGhvbmUnLFxuICAnU2hvdyBwcmV2aWV3IGFuZCBzZW5kIHRlc3QnOiAnVmlzdWFsaXp6YSB1bmEgYW50ZXByaW1hIGUgZmFpIHVuIGludmlvIGRpIHRlc3QnLFxuICAnRG93bmxvYWQgdGVtcGxhdGUnOiAnU2NhcmljYSBpbCB0ZW1wbGF0ZScsXG4gICdTYXZlIHRlbXBsYXRlJzogJ1NhbHZhIGlsIHRlbXBsYXRlJyxcbiAgJ1NhdmVkIG1vZGVsIGlzIG9ic29sZXRlJzogJ01vZGVsbG8gc2FsdmF0byBvYnNvbGV0bycsXG4gICc8cD5UaGUgc2F2ZWQgbW9kZWwgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIGEgcHJldmlvdXMsIG5vbiBjb21wbGV0ZWx5IGNvbXBhdGlibGUgdmVyc2lvbiwgb2YgdGhlIHRlbXBsYXRlPC9wPjxwPlNvbWUgY29udGVudCBvciBzdHlsZSBpbiB0aGUgbW9kZWwgPGI+Q09VTEQgQkUgTE9TVDwvYj4gaWYgeW91IHdpbGwgPGI+c2F2ZTwvYj48L3A+PHA+Q29udGFjdCB1cyBmb3IgbW9yZSBpbmZvcm1hdGlvbnMhPC9wPic6ICc8cD5JbCBtb2RlbGxvIHNhbHZhdG8gw6ggc3RhdG8gY3JlYXRvIGNvbiB1bmEgdmVyc2lvbmUgcHJlY2VkZW50ZSBkZWwgdGVtcGxhdGUgbm9uIGRlbCB0dXR0byBjb21wYXRpYmlsZTwvcD48cD5BbGN1bmkgY29udGVudXRpIG8gc3RpbGkgZGVsIG1vZGVsbG8gPGI+UE9UUkVCQkVSTyBFU1NFUkUgUEVSU0k8L2I+IHNlIHByb2NlZGVyYWkgZSBkZWNpZGVyYWkgZGkgPGI+c2FsdmFyZTwvYj48L3A+PHA+Q29udGF0dGFjaSBzZSBoYWkgZGVpIGR1YmJpITwvcD4nLFxuXG4gIC8vIFRPRE8gdGhpcyBjYW5ub3QgYmUgZG9uZSBpbiBrbm9ja291dCBhcyB3aXRoIHVuY29tcGF0aWJsZSBicm93c2VycyB3ZSBkb24ndCBpbml0aWFsaXplXG4gIC8vICdVc3VwcG9ydGVkIGJyb3dzZXInOiAnQnJvd3NlciBub24gY29tcGF0aWJpbGUnLFxuICAvLyAnPHA+WW91ciBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuPC9wPjxwPlVzZSBhIGRpZmZlcmVudCBicm93c2VyIG9yIHRyeSB1cGRhcmluZyB5b3VyIGJyb3dzZXIuPC9wPjxwPlN1cHBvcnRlZCBicm93c2VyczogPHVsPjxsaT5JbnRlcm5ldCBFeHBsb3JlciAmZ3Q7PSAxMDwvbGk+PGxpPkdvb2dsZSBDaHJvbWUgJmd0Oz0gMzA8L2xpPjxsaT5BcHBsZSBTYWZhcmkgJmd0Oz0gNTwvbGk+PGxpPk1vemlsbGEgRmlyZWZpeCAmZ3Q7PSAyMDwvbGk+PC91bD48L3A+JzogJzxwPklsIHR1byBicm93c2VyIG5vbiDDqCBzdXBwb3J0YXRvLjwvcD48cD5BY2NlZGkgY29uIHVuIGJyb3dzZXIgZGlmZmVyZW50ZSBvIHByb3ZhIGFkIGFnZ2lvcm5hcmUgaWwgdHVvIGJyb3dzZXIuPC9wPjxwPkJyb3dzZXIgc3VwcG9ydGF0aTogPHVsPjxsaT5JbnRlcm5ldCBFeHBsb3JlciAmZ3Q7PSAxMDwvbGk+PGxpPkdvb2dsZSBDaHJvbWUgJmd0Oz0gMzA8L2xpPjxsaT5BcHBsZSBTYWZhcmkgJmd0Oz0gNTwvbGk+PGxpPk1vemlsbGEgRmlyZWZpeCAmZ3Q7PSAyMDwvbGk+PC91bD48L3A+JyxcblxuICAvLyB0b29sYm94XG4gICdCbG9ja3MnOiAnQmxvY2NoaScsXG4gICdCbG9ja3MgcmVhZHkgdG8gYmUgYWRkZWQgdG8gdGhlIHRlbXBsYXRlJzogJ0VsZW5jbyBjb250ZW51dGkgYWdnaXVuZ2liaWxpIGFsIG1lc3NhZ2dpbycsXG4gICdDb250ZW50JzogJ0NvbnRlbnV0bycsXG4gICdFZGl0IGNvbnRlbnQgb3B0aW9ucyc6ICdNb2RpZmljYSBvcHppb25pIGNvbnRlbnV0aScsXG4gICdTdHlsZSc6ICdTdGlsZScsXG4gICdFZGl0IHN0eWxlIG9wdGlvbnMnOiAnTW9kaWZpY2Egb3B6aW9uaSBncmFmaWNoZScsXG4gICdCbG9jayBfX25hbWVfXyc6ICdCbG9jY28gX19uYW1lX18nLFxuICAnQ2xpY2sgb3IgZHJhZyB0byBhZGQgdGhpcyBibG9jayB0byB0aGUgdGVtcGxhdGUnOiAnQ2xpY2NhIG8gdHJhc2NpbmEgcGVyIGFnZ2l1bmdlcmUgYWwgbWVzc2FnZ2lvJyxcbiAgJ0FkZCc6ICdBZ2dpdW5naScsXG4gICdCeSBjbGlja2luZyBvbiBtZXNzYWdlIHBhcnRzIHlvdSB3aWxsIHNlbGVjdCBhIGJsb2NrIGFuZCBjb250ZW50IG9wdGlvbnMsIGlmIGFueSwgd2lsbCBzaG93IGhlcmUnOiAnQ2xpY2NhbmRvIHN1IGFsY3VuZSBwYXJ0aSBkZWwgbWVzc2FnZ2lvIHNlbGV6aW9uZXJhaSB1biBibG9jY28gZSBsZSBvcHppb25pIGNvbnRlbnV0aXN0aWNoZSwgc2UgZGlzcG9uaWJpbGksIGNvbXBhcmlyYW5ubyBxdWknLFxuICAnQnkgY2xpY2tpbmcgb24gbWVzc2FnZSBwYXJ0cyB5b3Ugd2lsbCBzZWxlY3QgYSBibG9jayBhbmQgc3R5bGUgb3B0aW9ucywgaWYgYXZhaWxhYmxlLCB3aWxsIHNob3cgaGVyZSc6ICdDbGljY2FuZG8gc3UgYWxjdW5lIHBhcnRpIGRlbCBtZXNzYWdnaW8gc2VsZXppb25lcmFpIHVuIGJsb2NjbyBlIGxlIG9wemlvbmkgZGkgc3RpbGUsIHNlIGRpc3BvbmliaWxpLCBjb21wYXJpcmFubm8gcXVpJyxcbiAgJ0NsaWNrIG9yIGRyYWcgZmlsZXMgaGVyZSc6ICdDbGljY2EgbyB0cmFzY2luYSBpIGZpbGUgcXVpIScsXG4gICdObyBpbWFnZXMgdXBsb2FkZWQsIHlldCc6ICdOb24gaGFpIGFuY29yYSBjYXJpY2F0byBpbW1hZ2luaScsXG4gICdTaG93IGltYWdlcyBmcm9tIHRoZSBnYWxsZXJ5JzogJ1Zpc3VhbGl6emEgbGUgaW1tYWdpbmkgY2FyaWNhdGUgbmVsbGEgdHVhIGFyZWEnLFxuICAnTG9hZGluZy4uLic6ICdDYXJpY2FtZW50by4uLicsXG4gICdMb2FkIGdhbGxlcnknOiAnQ2FyaWNhIGdhbGxlcmlhJyxcbiAgJ0xvYWRpbmcgZ2FsbGVyeS4uLic6ICdDYXJpY2FtZW50byBpbiBjb3Jzby4uLicsXG4gICdUaGUgZ2FsbGVyeSBpcyBlbXB0eSc6ICdOZXNzdW5hIGltbWFnaW5lIG5lbGxhIGdhbGxlcmlhJyxcbiAgLy8gaW1nLXd5c2l3eWcudG1scFxuICAnUmVtb3ZlIGltYWdlJzogJ1JpbXVvdmkgaW1tYWdpbmUnLFxuICAnT3BlbiB0aGUgaW1hZ2UgZWRpdGluZyB0b29sJzogJ0F2dmlhIHN0cnVtZW50byBtb2RpZmljYSBpbW1hZ2luZScsXG4gICdVcGxvYWQgYSBuZXcgaW1hZ2UnOiAnQ2FyaWNhIHVuYSBudW92YSBpbW1hZ2luZScsXG4gICdEcm9wIGFuIGltYWdlIGhlcmUnOiAnVHJhc2NpbmEgdW5hIGltbWFnaW5lIHF1aScsXG4gICdEcm9wIGFuIGltYWdlIGhlcmUgb3IgY2xpY2sgdGhlIHVwbG9hZCBidXR0b24nOiAnVHJhc2NpbmEgdW5hIGltbWFnaW5lIHF1aSBvIGNsaWNjYSBzdWwgcHVsc2FudGUgZGkgY2FyaWNhbWVudG8nLFxuICAvLyBnYWxsZXJ5XG4gICdEcmFnIHRoaXMgaW1hZ2UgYW5kIGRyb3AgaXQgb24gYW55IHRlbXBsYXRlIGltYWdlIHBsYWNlaG9sZGVyJzogJ1RyYXNjaW5hIHF1ZXN0YSBpbW1hZ2luZSBzdWxsYSBwb3NpemlvbmUgaW4gY3VpIHZ1b2kgaW5zZXJpcmxhJyxcbiAgJ0dhbGxlcnk6JzogJ0dhbGxlcmlhOicsXG4gICdTZXNzaW9uIGltYWdlcyc6ICdJbW1hZ2luaSBkaSBzZXNzaW9uZScsXG4gICdSZWNlbnRzJzogJ1JlY2VudGknLFxuICAnUmVtb3RlIGdhbGxlcnknOiAnR2FsbGVyaWEgcmVtb3RhJyxcblxuICAvLyBjdXN0b21zdHlsZVxuICAnQ3VzdG9taXplZCBibG9jay48dWw+PGxpPkluIHRoaXMgc3RhdHVzIGNoYW5nZXMgdG8gcHJvcGVydGllcyB3aWxsIGJlIHNwZWNpZmljIHRvIHRoZSBjdXJyZW50IGJsb2NrIChpbnN0ZWFkIG9mIGJlaW5nIGdsb2JhbCB0byBhbGwgYmxvY2tzIGluIHRoZSBzYW1lIHNlY3Rpb24pPC9saT48bGk+QSA8c3BhbiBjbGFzcz1cImN1c3RvbVN0eWxlZFwiPjxzcGFuPlwic21hbGwgY3ViZVwiIDwvc3Bhbj48L3NwYW4+IGljb24gYmVzaWRlIHRoZSBwcm9wZXJ0eSB3aWxsIG1hcmsgdGhlIGN1c3RvbWl6YXRpb24uIEJ5IGNsaWNraW5nIHRoaXMgaWNvbiB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSByZXZlcnRlZCB0byB0aGUgdmFsdWUgZGVmaW5lZCBmb3IgdGhlIHNlY3Rpb24uPC9saT48L3VsPic6ICdCbG9jY28gcGVyc29uYWxpenphdG8uPHVsPjxsaT5JbiBxdWVzdGEgbW9kYWxpdMOgIHNlIGNhbWJpIHVuYSBwcm9wcmlldMOgIHZlcnLDoCBtb2RpZmljYXRhIHNvbGFtZW50ZSBwZXIgcXVlc3RvIHNwZWNpZmljbyBibG9jY28gKGludmVjZSBjaGUgcGVyIHR1dHRpIGkgYmxvY2NoaSBkZWxsYSBzdGVzc2Egc2V6aW9uZSkuPC9saT48bGk+UGVyIHNlZ25hbGFyZSBsYSBwZXJzb25hbGl6emF6aW9uZSBhcHBhcmlyw6AgbFxcJ2ljb25hIDxzcGFuIGNsYXNzPVwiY3VzdG9tU3R5bGVkXCI+PHNwYW4+IGRlbCBcImN1YmV0dG9cIjwvc3Bhbj48L3NwYW4+IGEgZmlhbmNvIGRlbGxlIHByb3ByaWV0w6AuIENsaWNjYW5kbyBxdWVzdGEgaWNvbmEgdG9ybmVyYWkgYWwgdmFsb3JlIGNvbXVuZS48L2xpPjwvdWw+JyxcbiAgLy8gYmxvY2tzLXd5c2l3eWdcbiAgJ0Ryb3AgaGVyZSBibG9ja3MgZnJvbSB0aGUgXCJCbG9ja3NcIiB0YWInOiAnVHJhc2NpbmEgcXVpIGkgYmxvY2NoaSBkYWxsYSBzY2hlZGEgXFwnQmxvY2NoaVxcJycsXG4gIC8vIGJsb2NrLXd5c2l3eWdcbiAgJ0RyYWcgdGhpcyBoYW5kbGUgdG8gbW92ZSB0aGUgYmxvY2snOiAnVHJhc2NpbmEgcGVyIHNwb3N0YXJlIGlsIGJsb2NjbyBhbHRyb3ZlJyxcbiAgJ01vdmUgdGhpcyBibG9jayB1cHNpZGUnOiAnU3Bvc3RhIGlsIGJsb2NjbyBpbiBzdScsXG4gICdNb3ZlIHRoaXMgYmxvY2sgZG93bnNpZGUnOiAnU3Bvc3RhIGlsIGJsb2NjbyBpbiBnaXUnLFxuICAnRGVsZXRlIGJsb2NrJzogJ0VsaW1pbmEgYmxvY2NvJyxcbiAgJ0R1cGxpY2F0ZSBibG9jayc6ICdEdXBsaWNhIGJsb2NjbycsXG4gICdTd2l0Y2ggYmxvY2sgdmFyaWFudCc6ICdDYW1iaWEgdmFyaWFudGUgYmxvY2NvJyxcbiAgLy8gY29sb3JwaWNrZXJcbiAgJ1RoZW1lIENvbG9ycyxTdGFuZGFyZCBDb2xvcnMsV2ViIENvbG9ycyxUaGVtZSBDb2xvcnMsQmFjayB0byBQYWxldHRlLEhpc3RvcnksTm8gaGlzdG9yeSB5ZXQuJzogJ0NvbG9yaSBUZW1hLENvbG9yaSBTdGFuZGFyZCxDb2xvcmkgV2ViLENvbG9yaSBUZW1hLFRvcm5hIGFsbGEgdGF2b2xvenphLFN0b3JpY28sc3RvcmljbyBjb2xvcmkgdnVvdG8nLFxuXG4gICdEcm9wIGhlcmUnOiAnUmlsYXNjaWEgcXVpJyxcblxufTtcbiovXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVFZGl0b3IoY29udGVudCwgYmxvY2tEZWZzLCB0aHVtYlBhdGhDb252ZXJ0ZXIsIGdhbGxlcnlVcmwpIHtcblxuICB2YXIgdmlld01vZGVsID0ge1xuICAgIGdhbGxlcnlSZWNlbnQ6IGtvLm9ic2VydmFibGVBcnJheShbXSkuZXh0ZW5kKHtcbiAgICAgIHBhZ2luZzogMTZcbiAgICB9KSxcbiAgICBnYWxsZXJ5UmVtb3RlOiBrby5vYnNlcnZhYmxlQXJyYXkoW10pLmV4dGVuZCh7XG4gICAgICBwYWdpbmc6IDE2XG4gICAgfSksXG4gICAgc2VsZWN0ZWRCbG9jazoga28ub2JzZXJ2YWJsZShudWxsKSxcbiAgICBzZWxlY3RlZEl0ZW06IGtvLm9ic2VydmFibGUobnVsbCksXG4gICAgc2VsZWN0ZWRUb29sOiBrby5vYnNlcnZhYmxlKDApLFxuICAgIHNlbGVjdGVkSW1hZ2VUYWI6IGtvLm9ic2VydmFibGUoMCksXG4gICAgZHJhZ2dpbmc6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIGRyYWdnaW5nSW1hZ2U6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIGdhbGxlcnlMb2FkZWQ6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHNob3dQcmV2aWV3RnJhbWU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHByZXZpZXdNb2RlOiBrby5vYnNlcnZhYmxlKCdtb2JpbGUnKSxcbiAgICBzaG93VG9vbGJveDoga28ub2JzZXJ2YWJsZSh0cnVlKSxcbiAgICBzaG93VGhlbWU6IGtvLm9ic2VydmFibGUoZmFsc2UpLFxuICAgIHNob3dHYWxsZXJ5OiBrby5vYnNlcnZhYmxlKGZhbHNlKSxcbiAgICBkZWJ1Zzoga28ub2JzZXJ2YWJsZShmYWxzZSksXG4gICAgY29udGVudExpc3RlbmVyczoga28ub2JzZXJ2YWJsZSgwKSxcblxuICAgIGxvZ29QYXRoOiAnbWVkaWEvZWRpdG9yLWljb24ucG5nJyxcbiAgICBsb2dvVXJsOiAnLicsXG4gICAgbG9nb0FsdDogJ2JhZHNlbmRlcidcbiAgfTtcblxuICAvLyB2aWV3TW9kZWwuY29udGVudCA9IGNvbnRlbnQuX2luc3RydW1lbnQoa28sIGNvbnRlbnQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIHZpZXdNb2RlbC5jb250ZW50ID0gY29udGVudDtcbiAgdmlld01vZGVsLmJsb2NrRGVmcyA9IGJsb2NrRGVmcztcblxuICB2aWV3TW9kZWwubm90aWZpZXIgPSB0b2FzdHI7XG5cbiAgLy8gRG9lcyB0b2tlbiBzdWJzdGl0dXRpb24gaW4gaTE4bmV4dCBzdHlsZVxuICB2aWV3TW9kZWwudHQgPSBmdW5jdGlvbihrZXksIHBhcmFtT2JqKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbU9iaiAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHBhcmFtT2JqKVxuICAgICAgICBpZiAocGFyYW1PYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBrZXkgPSBrZXkucmVwbGFjZShuZXcgUmVnRXhwKCdfXycgKyBwcm9wICsgJ19fJywgJ2cnKSwgcGFyYW1PYmpbcHJvcF0pO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfTtcblxuICAvLyBTaW1wbHkgbWFwcyB0byB0dDogbGFuZ3VhZ2UgcGx1Z2lucyBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZGVmaW5lIHRoZWlyIG93biBsYW5ndWFnZVxuICAvLyBoYW5kbGluZy5cbiAgLy8gSWYgdGhpcyBtZXRob2QgaW52b2tlcyBhbiBvYnNlcnZhYmxlIChlLmc6IHZpZXdNb2RlbC5sYW5nKCkpIHRoZW4gdGhlIFVJIGxhbmd1YWdlIHdpbGwgYXV0b21hdGljYWxseVxuICAvLyB1cGRhdGUgd2hlbiB0aGUgXCJsYW5nXCIgb2JzZXJ2YWJsZSBjaGFuZ2VzLlxuICB2aWV3TW9kZWwudCA9IHZpZXdNb2RlbC50dDtcblxuICAvLyBjdXJyZW50bHkgY2FsbGVkIGJ5IGVkaXRvci5odG1sIHRvIHRyYW5zbGF0ZSB0ZW1wbGF0ZS1kZWZpbmVkIGtleXMgKGxhYmVsLCBoZWxwLCBkZXNjcmlwdGlvbnMpXG4gIC8vIHRoZSBlZGl0b3IgYWx3YXlzIHVzZXMgdGhlIFwidGVtcGxhdGVcIiBjYXRlZ29yeSBmb3IgdGhhdCBzdHJpbmdzLlxuICAvLyB5b3UgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGFzIHlvdSBsaWtlIGluIG9yZGVyIHRvIHByb3ZpZGUgdHJhbnNsYXRpb24gb3IgY2hhbmdlIHRoZSBzdHJpbmdzIGluIGFueSB3YXkuXG4gIHZpZXdNb2RlbC51dCA9IGZ1bmN0aW9uKGNhdGVnb3J5LCBrZXkpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9O1xuXG4gIHZpZXdNb2RlbC50ZW1wbGF0ZVBhdGggPSB0aHVtYlBhdGhDb252ZXJ0ZXI7XG5cbiAgdmlld01vZGVsLnJlbW90ZVVybFByb2Nlc3NvciA9IGZ1bmN0aW9uKHVybCkge1xuICAgIHJldHVybiB1cmw7XG4gIH07XG5cbiAgdmlld01vZGVsLnJlbW90ZUZpbGVQcm9jZXNzb3IgPSBmdW5jdGlvbihmaWxlT2JqKSB7XG4gICAgaWYgKHR5cGVvZiBmaWxlT2JqLnVybCAhPT0gJ3VuZGVmaW5lZCcpIGZpbGVPYmoudXJsID0gdmlld01vZGVsLnJlbW90ZVVybFByb2Nlc3NvcihmaWxlT2JqLnVybCk7XG4gICAgaWYgKHR5cGVvZiBmaWxlT2JqLnRodW1ibmFpbFVybCAhPT0gJ3VuZGVmaW5lZCcpIGZpbGVPYmoudGh1bWJuYWlsVXJsID0gdmlld01vZGVsLnJlbW90ZVVybFByb2Nlc3NvcihmaWxlT2JqLnRodW1ibmFpbFVybCk7XG4gICAgLy8gZGVsZXRlVXJsP1xuICAgIHJldHVybiBmaWxlT2JqO1xuICB9O1xuXG4gIC8vIHRvb2xib3gudG1wbC5odG1sXG4gIHZpZXdNb2RlbC5sb2FkR2FsbGVyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZpZXdNb2RlbC5nYWxsZXJ5TG9hZGVkKCdsb2FkaW5nJyk7XG4gICAgdmFyIHVybCA9IGdhbGxlcnlVcmwgPyBnYWxsZXJ5VXJsIDogJy91cGxvYWQvJztcbiAgICAvLyByZXRyaWV2ZSB0aGUgZnVsbCBsaXN0IG9mIHJlbW90ZSBmaWxlc1xuICAgICQuZ2V0SlNPTih1cmwsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5maWxlcy5sZW5ndGg7IGkrKykgZGF0YS5maWxlc1tpXSA9IHZpZXdNb2RlbC5yZW1vdGVGaWxlUHJvY2Vzc29yKGRhdGEuZmlsZXNbaV0pO1xuICAgICAgdmlld01vZGVsLmdhbGxlcnlMb2FkZWQoZGF0YS5maWxlcy5sZW5ndGgpO1xuICAgICAgLy8gVE9ETyBkbyBJIHdhbnQgdGhpcyBjYWxsIHRvIHJldHVybiByZWxhdGl2ZSBwYXRocz8gT3IganVzdCBhYnNvbHV0ZSBwYXRocz9cbiAgICAgIHZpZXdNb2RlbC5nYWxsZXJ5UmVtb3RlKGRhdGEuZmlsZXMucmV2ZXJzZSgpKTtcbiAgICB9KS5mYWlsKGZ1bmN0aW9uKCkge1xuICAgICAgdmlld01vZGVsLmdhbGxlcnlMb2FkZWQoZmFsc2UpO1xuICAgICAgdmlld01vZGVsLm5vdGlmaWVyLmVycm9yKHZpZXdNb2RlbC50KCdVbmV4cGVjdGVkIGVycm9yIGxpc3RpbmcgZmlsZXMnKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gaW1nLXd5c2l3eWcudG1wbC5odG1sXG4gIHZpZXdNb2RlbC5maWxlVG9JbWFnZSA9IGZ1bmN0aW9uKG9iaiwgZXZlbnQsIHVpKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJmaWxlVG9JbWFnZVwiLCBvYmopO1xuICAgIHJldHVybiBvYmoudXJsO1xuICB9O1xuXG4gIC8vIGJsb2NrLXd5c2l3eWcudG1wbC5odG1sXG4gIHZpZXdNb2RlbC5yZW1vdmVCbG9jayA9IGZ1bmN0aW9uKGRhdGEsIHBhcmVudCkge1xuICAgIC8vIGxldCdzIHVuc2VsZWN0IHRoZSBibG9ja1xuICAgIGlmIChrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHZpZXdNb2RlbC5zZWxlY3RlZEJsb2NrKSA9PSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKGRhdGEpKSB7XG4gICAgICB2aWV3TW9kZWwuc2VsZWN0QmxvY2sobnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHZhciByZXMgPSBwYXJlbnQuYmxvY2tzLnJlbW92ZShkYXRhKTtcbiAgICAvLyBUT0RPIFRoaXMgbWVzc2FnZSBzaG91bGQgYmUgZGlmZmVyZW50IGRlcGVuZGluZyBvbiB1bmRvIHBsdWdpbiBwcmVzZW5jZS5cbiAgICB2aWV3TW9kZWwubm90aWZpZXIuaW5mbyh2aWV3TW9kZWwudCgnQmxvY2sgcmVtb3ZlZDogdXNlIHVuZG8gYnV0dG9uIHRvIHJlc3RvcmUgaXQuLi4nKSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBibG9jay13eXNpd3lnLnRtcGwuaHRtbFxuICB2aWV3TW9kZWwuZHVwbGljYXRlQmxvY2sgPSBmdW5jdGlvbihpbmRleCwgcGFyZW50KSB7XG4gICAgdmFyIGlkeCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoaW5kZXgpO1xuICAgIC8vIERlaW5zdHJ1bWVudC9kZW9ic2VydmUgdGhlIG9iamVjdFxuICAgIHZhciB1bndyYXBwZWQgPSBrby50b0pTKGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUocGFyZW50LmJsb2NrcylbaWR4XSk7XG4gICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGlkIHNvIHRoYXQgYSBuZXcgb25lIHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGNsb25lXG4gICAgaWYgKHR5cGVvZiB1bndyYXBwZWQuaWQgIT09ICd1bmRlZmluZWQnKSB1bndyYXBwZWQuaWQgPSAnJztcbiAgICAvLyBpbnNlcnQgdGhlIGNsb25lZCBibG9ja1xuICAgIHBhcmVudC5ibG9ja3Muc3BsaWNlKGlkeCArIDEsIDAsIHVud3JhcHBlZCk7XG4gIH07XG5cbiAgLy8gYmxvY2std3lzaXd5Zy50bXBsLmh0bWxcbiAgdmlld01vZGVsLm1vdmVCbG9jayA9IGZ1bmN0aW9uKGluZGV4LCBwYXJlbnQsIHVwKSB7XG4gICAgdmFyIGlkeCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoaW5kZXgpO1xuICAgIHZhciBwYXJlbnRCbG9ja3MgPSBrby51dGlscy51bndyYXBPYnNlcnZhYmxlKHBhcmVudC5ibG9ja3MpO1xuICAgIGlmICgodXAgJiYgaWR4ID4gMCkgfHwgKCF1cCAmJiBpZHggPCBwYXJlbnRCbG9ja3MubGVuZ3RoIC0gMSkpIHtcbiAgICAgIHZhciBkZXN0SW5kZXggPSBpZHggKyAodXAgPyAtMSA6IDEpO1xuICAgICAgdmFyIGRlc3RCbG9jayA9IHBhcmVudEJsb2Nrc1tkZXN0SW5kZXhdO1xuICAgICAgdmlld01vZGVsLnN0YXJ0TXVsdGlwbGUoKTtcbiAgICAgIHBhcmVudC5ibG9ja3Muc3BsaWNlKGRlc3RJbmRleCwgMSk7XG4gICAgICBwYXJlbnQuYmxvY2tzLnNwbGljZShpZHgsIDAsIGRlc3RCbG9jayk7XG4gICAgICB2aWV3TW9kZWwuc3RvcE11bHRpcGxlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIHRlc3QgbWV0aG9kLCBjb21tYW5kIGxpbmUgdXNlIG9ubHlcbiAgdmlld01vZGVsLmxvYWREZWZhdWx0QmxvY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gY2xvbmluZyB0aGUgd2hvbGUgXCJtYWluQmxvY2tzXCIgb2JqZWN0IHNvIHRoYXQgdW5kb21hbmFnZXIgd2lsbFxuICAgIC8vIHNlZSBpdCBhcyBhIHNpbmdsZSBvcGVyYXRpb24gKG1heWJlIEkgY291bGQgdXNlIFwic3RhcnRNdWx0aXBsZVwiL1wic3RvcE11bHRpcGxlXCIuXG4gICAgdmFyIHJlcyA9IGtvLnRvSlModmlld01vZGVsLmNvbnRlbnQoKS5tYWluQmxvY2tzKTtcbiAgICByZXMuYmxvY2tzID0gW107XG4gICAgdmFyIGlucHV0ID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2aWV3TW9kZWwuYmxvY2tEZWZzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb2JqID0ga28udG9KUyhpbnB1dFtpXSk7XG4gICAgICAvLyBnZW5lcmF0aW5nIGlkcyBmb3IgYmxvY2tzLCBtYXliZSB0aGlzIHdvdWxkIHdvcmsgYWxzbyBsZWF2aW5nIGl0IGVtcHR5LlxuICAgICAgb2JqLmlkID0gJ2Jsb2NrXycgKyBpO1xuICAgICAgcmVzLmJsb2Nrcy5wdXNoKG9iaik7XG4gICAgfVxuICAgIHBlcmZvcm1hbmNlQXdhcmVDYWxsZXIoJ3NldE1haW5CbG9ja3MnLCB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MuX3dyYXAuYmluZCh2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MsIHJlcykpO1xuICB9O1xuXG4gIC8vIGdhbGxlcnktaW1hZ2VzLnRtcGwuaHRtbFxuICB2aWV3TW9kZWwuYWRkSW1hZ2UgPSBmdW5jdGlvbihpbWcpIHtcbiAgICB2YXIgc2VsZWN0ZWRJbWcgPSAkKCcjbWFpbi13eXNpd3lnLWFyZWEgLnNlbGVjdGFibGUtaW1nLnNlbGVjdGVkaXRlbScpO1xuICAgIGlmIChzZWxlY3RlZEltZy5sZW5ndGggPT0gMSAmJiB0eXBlb2YgaW1nID09ICdvYmplY3QnICYmIHR5cGVvZiBpbWcudXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAga28uY29udGV4dEZvcihzZWxlY3RlZEltZ1swXSkuX3NyYyhpbWcudXJsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIHRvb2xib3gudG1wbC5odG1sXG4gIHZpZXdNb2RlbC5hZGRCbG9jayA9IGZ1bmN0aW9uKG9iaiwgZXZlbnQpIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBhIHNlbGVjdGVkIGJsb2NrIHdlIHRyeSB0byBhZGQgdGhlIGJsb2NrIGp1c3QgYWZ0ZXIgdGhlIHNlbGVjdGVkIG9uZS5cbiAgICB2YXIgc2VsZWN0ZWQgPSB2aWV3TW9kZWwuc2VsZWN0ZWRCbG9jaygpO1xuICAgIC8vIHNlYXJjaCB0aGUgc2VsZWN0ZWQgYmxvY2sgcG9zaXRpb24uXG4gICAgdmFyIGZvdW5kO1xuICAgIGlmIChzZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETyBcIm1haW5CbG9ja3NcIiBpcyBhbiBoYXJkY29kZWQgdGhpbmcuXG4gICAgICBmb3IgKHZhciBpID0gdmlld01vZGVsLmNvbnRlbnQoKS5tYWluQmxvY2tzKCkuYmxvY2tzKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXdNb2RlbC5jb250ZW50KCkubWFpbkJsb2NrcygpLmJsb2NrcygpW2ldKCkgPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBvcztcbiAgICBpZiAodHlwZW9mIGZvdW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcG9zID0gZm91bmQgKyAxO1xuICAgICAgdmlld01vZGVsLmNvbnRlbnQoKS5tYWluQmxvY2tzKCkuYmxvY2tzLnNwbGljZShwb3MsIDAsIG9iaik7XG4gICAgICB2aWV3TW9kZWwubm90aWZpZXIuaW5mbyh2aWV3TW9kZWwudCgnTmV3IGJsb2NrIGFkZGVkIGFmdGVyIHRoZSBzZWxlY3RlZCBvbmUgKF9fcG9zX18pJywge1xuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3TW9kZWwuY29udGVudCgpLm1haW5CbG9ja3MoKS5ibG9ja3MucHVzaChvYmopO1xuICAgICAgcG9zID0gdmlld01vZGVsLmNvbnRlbnQoKS5tYWluQmxvY2tzKCkuYmxvY2tzKCkubGVuZ3RoIC0gMTtcbiAgICAgIHZpZXdNb2RlbC5ub3RpZmllci5pbmZvKHZpZXdNb2RlbC50KCdOZXcgYmxvY2sgYWRkZWQgYXQgdGhlIG1vZGVsIGJvdHRvbSAoX19wb3NfXyknLCB7XG4gICAgICAgIHBvczogcG9zXG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8vIGZpbmQgdGhlIG5ld2x5IGFkZGVkIGJsb2NrIGFuZCBzZWxlY3QgaXQhXG4gICAgdmFyIGFkZGVkID0gdmlld01vZGVsLmNvbnRlbnQoKS5tYWluQmxvY2tzKCkuYmxvY2tzKClbcG9zXSgpO1xuICAgIHZpZXdNb2RlbC5zZWxlY3RCbG9jayhhZGRlZCwgdHJ1ZSk7XG4gICAgLy8gcHJldmVudCBjbGljayBwcm9wYWdhdGlvbiAobG9zaW5nIHVybCBoYXNoIC0gc2VlICM0MylcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gVXNlZCBieSBzdHlsZXNoZWV0LmpzIHRvIGNyZWF0ZSBtdWx0aXBsZSBzdHlsZXNcbiAgdmlld01vZGVsLmZpbmRPYmplY3RzT2ZUeXBlID0gZnVuY3Rpb24oZGF0YSwgdHlwZSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgb2JqID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShkYXRhKTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iailcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgdmFyIHZhbCA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUob2JqW3Byb3BdKTtcbiAgICAgICAgLy8gVE9ETyB0aGlzIGlzIG5vdCB0aGUgcmlnaHQgd2F5IHRvIGRlYWwgd2l0aCBcImJsb2NrIGxpc3RcIiBvYmplY3RzLlxuICAgICAgICBpZiAocHJvcC5tYXRjaCgvQmxvY2tzJC8pKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZSh2YWwuYmxvY2tzKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUoY29udGVudHNbaV0pO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwgfHwga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShjLnR5cGUpID09IHR5cGUpIHJlcy5wdXNoKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPIGludmVzdGlnYXRlIHdoaWNoIGNvbmRpdGlvbiBwcm92aWRlIGEgbnVsbCB2YWx1ZS5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlID09PSBudWxsIHx8IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUodmFsLnR5cGUpID09IHR5cGUpIHJlcy5wdXNoKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8qXG4gIHZpZXdNb2RlbC5wbGFjZWhvbGRlckhlbHBlciA9ICdzb3J0YWJsZS1wbGFjZWhvbGRlcic7XG4gIGlmIChmYWxzZSkge1xuICAgIHZpZXdNb2RlbC5wbGFjZWhvbGRlckhlbHBlciA9IHtcbiAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uKGN1cnJlbnRJdGVtKSB7XG4gICAgICAgIHJldHVybiAkKCc8ZGl2IC8+JykucmVtb3ZlQ2xhc3MoJ3VpLWRyYWdnYWJsZScpLmFkZENsYXNzKCdzb3J0YWJsZS1wbGFjZWhvbGRlcicpLmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKS5jc3MoJ3dpZHRoJywgJzEwMCUnKS5jc3MoJ2hlaWdodCcsIGN1cnJlbnRJdGVtLmNzcygnaGVpZ2h0JykpLmNzcygnb3BhY2l0eScsICcuOCcpWzBdO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24oY29udGFpbmVyLCBwKSB7XG4gICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgKi9cblxuICAvLyBBdHRlbXB0IHRvIGluc2VydCB0aGUgYmxvY2sgaW4gdGhlIGRlc3RpbmF0aW9uIGxheW91dCBkdXJpbmcgZHJhZ2dpbmdcbiAgdmlld01vZGVsLnBsYWNlaG9sZGVySGVscGVyID0ge1xuICAgIGVsZW1lbnQ6IGZ1bmN0aW9uKGN1cnJlbnRJdGVtKSB7XG4gICAgICByZXR1cm4gJChjdXJyZW50SXRlbVswXS5vdXRlckhUTUwpLnJlbW92ZUNsYXNzKCd1aS1kcmFnZ2FibGUnKS5hZGRDbGFzcygnc29ydGFibGUtcGxhY2Vob2xkZXInKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKS5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJykuY3NzKCd3aWR0aCcsICcxMDAlJykuY3NzKCdoZWlnaHQnLCAnYXV0bycpLmNzcygnb3BhY2l0eScsICcuOCcpWzBdO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbihjb250YWluZXIsIHApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgLy8gVE9ETyB0aGUgdW5kdW1hbmFnZXIgc2hvdWxkIGJlIHBsdWdnYWJsZS5cbiAgLy8gVXNlZCBieSBcIm1vdmVCbG9ja1wiIGFuZCBibG9ja3Mtd3lzaXd5Zy50bXBsLmh0bWwgdG8gXCJtZXJnZVwiIGRyYWcvZHJvcCBvcGVyYXRpb25zIGludG8gYSBzaW5nbGUgdW5kby9yZWRvIG9wLlxuICB2aWV3TW9kZWwuc3RhcnRNdWx0aXBsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygdmlld01vZGVsLnNldFVuZG9Nb2RlTWVyZ2UgIT09ICd1bmRlZmluZWQnKSB2aWV3TW9kZWwuc2V0VW5kb01vZGVNZXJnZSgpO1xuICB9O1xuICB2aWV3TW9kZWwuc3RvcE11bHRpcGxlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3TW9kZWwuc2V0VW5kb01vZGVPbmNlICE9PSAndW5kZWZpbmVkJykgdmlld01vZGVsLnNldFVuZG9Nb2RlT25jZSgpO1xuICB9O1xuXG4gIC8vIFVzZWQgYnkgY29kZSBnZW5lcmF0ZWQgYnkgZWRpdG9yLmpzXG4gIHZpZXdNb2RlbC5sb2NhbEdsb2JhbFN3aXRjaCA9IGZ1bmN0aW9uKHByb3AsIGdsb2JhbFByb3ApIHtcbiAgICB2YXIgY3VycmVudCA9IHByb3AoKTtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkgcHJvcChnbG9iYWxQcm9wKCkpO1xuICAgIGVsc2UgcHJvcChudWxsKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gVXNlZCBieSBlZGl0b3IgYW5kIG1haW4gXCJjb252ZXJ0ZXJcIiB0byBzdXBwb3J0IGl0ZW0gc2VsZWN0aW9uXG4gIHZpZXdNb2RlbC5zZWxlY3RJdGVtID0gZnVuY3Rpb24odmFsdWVBY2Nlc3NvciwgaXRlbSwgYmxvY2spIHtcbiAgICB2YXIgdmFsID0ga28udXRpbHMucGVla09ic2VydmFibGUodmFsdWVBY2Nlc3Nvcik7XG4gICAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ3VuZGVmaW5lZCcpIHZpZXdNb2RlbC5zZWxlY3RCbG9jayhibG9jaywgZmFsc2UsIHRydWUpO1xuICAgIGlmICh2YWwgIT0gaXRlbSkge1xuICAgICAgdmFsdWVBY2Nlc3NvcihpdGVtKTtcbiAgICAgIC8vIE9uIHNlbGVjdEl0ZW0gaWYgd2Ugd2VyZSBvbiBcIkJsb2Nrc1wiIHRvb2xib3ggdGFiIHdlIG1vdmUgdG8gXCJDb250ZW50XCIgdG9vbGJveCB0YWIuXG4gICAgICBpZiAoaXRlbSAhPT0gbnVsbCAmJiB2aWV3TW9kZWwuc2VsZWN0ZWRUb29sKCkgPT09IDApIHZpZXdNb2RlbC5zZWxlY3RlZFRvb2woMSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfS5iaW5kKHZpZXdNb2RlbCwgdmlld01vZGVsLnNlbGVjdGVkSXRlbSk7XG5cbiAgdmlld01vZGVsLmlzU2VsZWN0ZWRJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiB2aWV3TW9kZWwuc2VsZWN0ZWRJdGVtKCkgPT0gaXRlbTtcbiAgfTtcblxuICB2aWV3TW9kZWwuc2VsZWN0QmxvY2sgPSBmdW5jdGlvbih2YWx1ZUFjY2Vzc29yLCBpdGVtLCBkb05vdFNlbGVjdCwgZG9Ob3RVbnNlbGVjdEl0ZW0pIHtcbiAgICB2YXIgdmFsID0ga28udXRpbHMucGVla09ic2VydmFibGUodmFsdWVBY2Nlc3Nvcik7XG4gICAgaWYgKCFkb05vdFVuc2VsZWN0SXRlbSkgdmlld01vZGVsLnNlbGVjdEl0ZW0obnVsbCk7XG4gICAgaWYgKHZhbCAhPSBpdGVtKSB7XG4gICAgICB2YWx1ZUFjY2Vzc29yKGl0ZW0pO1xuICAgICAgLy8gaGlkZSBnYWxsZXJ5IG9uIGJsb2NrIHNlbGVjdGlvblxuICAgICAgdmlld01vZGVsLnNob3dHYWxsZXJ5KGZhbHNlKTtcbiAgICAgIGlmIChpdGVtICE9PSBudWxsICYmICFkb05vdFNlbGVjdCAmJiB2aWV3TW9kZWwuc2VsZWN0ZWRUb29sKCkgPT09IDApIHZpZXdNb2RlbC5zZWxlY3RlZFRvb2woMSk7XG4gICAgfVxuICB9LmJpbmQodmlld01vZGVsLCB2aWV3TW9kZWwuc2VsZWN0ZWRCbG9jayk7XG5cbiAgLy8gREVCVUdcbiAgdmlld01vZGVsLmNvdW50U3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uKG1vZGVsLCBkZWJ1Zykge1xuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIHByb3AgaW4gbW9kZWwpXG4gICAgICBpZiAobW9kZWwuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgdmFyIHAgPSBtb2RlbFtwcm9wXTtcbiAgICAgICAgaWYgKGtvLmlzT2JzZXJ2YWJsZShwKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcC5fZGVmYXVsdENvbXB1dGVkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlYnVnICE9ICd1bmRlZmluZWQnKSBjb25zb2xlLmxvZyhkZWJ1ZyArIFwiL1wiICsgcHJvcCArIFwiL19cIiwgcC5fZGVmYXVsdENvbXB1dGVkLmdldFN1YnNjcmlwdGlvbnNDb3VudCgpKTtcbiAgICAgICAgICAgIHJlcyArPSBwLl9kZWZhdWx0Q29tcHV0ZWQuZ2V0U3Vic2NyaXB0aW9uc0NvdW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgZGVidWcgIT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUubG9nKGRlYnVnICsgXCIvXCIgKyBwcm9wICsgXCIvLVwiLCBwLmdldFN1YnNjcmlwdGlvbnNDb3VudCgpKTtcbiAgICAgICAgICByZXMgKz0gcC5nZXRTdWJzY3JpcHRpb25zQ291bnQoKTtcbiAgICAgICAgICBwID0ga28udXRpbHMudW53cmFwT2JzZXJ2YWJsZShwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHAgPT0gJ29iamVjdCcgJiYgcCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0b3QgPSB2aWV3TW9kZWwuY291bnRTdWJzY3JpcHRpb25zKHAsIHR5cGVvZiBkZWJ1ZyAhPSAndW5kZWZpbmVkJyA/IGRlYnVnICsgJy8nICsgcHJvcCArIFwiQFwiIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGRlYnVnICE9ICd1bmRlZmluZWQnKSBjb25zb2xlLmxvZyhkZWJ1ZyArIFwiL1wiICsgcHJvcCArIFwiQFwiLCB0b3QpO1xuICAgICAgICAgIHJlcyArPSB0b3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIERFQlVHXG4gIHZpZXdNb2RlbC5sb29wU3Vic2NyaXB0aW9uc0NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ID0gdmlld01vZGVsLmNvdW50U3Vic2NyaXB0aW9ucyh2aWV3TW9kZWwuY29udGVudCgpKTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N1YnNjcmlwdGlvbnNDb3VudCcpLmlubmVySFRNTCA9IGNvdW50O1xuICAgIGdsb2JhbC5zZXRUaW1lb3V0KHZpZXdNb2RlbC5sb29wU3Vic2NyaXB0aW9uc0NvdW50LCAxMDAwKTtcbiAgfTtcblxuICB2aWV3TW9kZWwuZXhwb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBwZXJmb3JtYW5jZUF3YXJlQ2FsbGVyKFwiZXhwb3J0SFRNTFwiLCB2aWV3TW9kZWwuZXhwb3J0SFRNTCk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gY29uZGl0aW9uYWxfcmVzdG9yZShodG1sKSB7XG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSgvPHJlcGxhY2VkY2NbXj5dKiBjb25kaXRpb249XCIoW15cIl0qKVwiW14+XSo+KFtcXHNcXFNdKj8pPFxcL3JlcGxhY2VkY2M+L2csIGZ1bmN0aW9uKG1hdGNoLCBjb25kaXRpb24sIGJvZHkpIHtcbiAgICAgIHZhciBkZCA9ICc8IS0tW2lmICcrY29uZGl0aW9uKyddPic7XG4gICAgICBkZCArPSBib2R5LnJlcGxhY2UoLzwhLS0gY2M6YmVmb3JlOihbXiBdKikgLS0+PCEtLSBjYzphZnRlcjpcXDEgLS0+L2csICc8LyQxPicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXi4qPCEtLSBjYzpzdGFydCAtLT4vLCcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0gY2M6ZW5kIC0tPi4qJC8sJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPChcXC8/KWNjKFtBLVphLXpdKikvZywgJzwkMSQyJyk7XG4gICAgICBkZCArPSAnPCFbZW5kaWZdLS0+JztcbiAgICAgIHJldHVybiBkZDtcbiAgICB9KTtcbiAgfVxuXG4gIHZpZXdNb2RlbC5leHBvcnRIVE1MID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkID0gJ2V4cG9ydGZyYW1lJztcbiAgICAkKCdib2R5JykuYXBwZW5kKCc8aWZyYW1lIGlkPVwiJyArIGlkICsgJ1wiIGRhdGEtYmluZD1cImJpbmRJZnJhbWU6ICRkYXRhXCI+PC9pZnJhbWU+Jyk7XG4gICAgdmFyIGZyYW1lRWwgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIGtvLmFwcGx5QmluZGluZ3Modmlld01vZGVsLCBmcmFtZUVsKTtcbiAgICAvLyBPYnNvbGV0ZSBtZXRob2QgZGlkbid0IHdvcmsgb24gSUUxMSB3aGVuIHVzaW5nIFwiSFRNTDUgZG9jdHlwZVwiOlxuICAgIC8vIHZhciBkb2NUeXBlID0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhnbG9iYWwuZG9jdW1lbnQuZG9jdHlwZSk7XG4gICAgdmFyIG5vZGUgPSBmcmFtZUVsLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdHlwZTtcbiAgICB2YXIgZG9jVHlwZSA9IFwiPCFET0NUWVBFIFwiICsgbm9kZS5uYW1lICtcbiAgICAgIChub2RlLnB1YmxpY0lkID8gJyBQVUJMSUMgXCInICsgbm9kZS5wdWJsaWNJZCArICdcIicgOiAnJykgK1xuICAgICAgKCFub2RlLnB1YmxpY0lkICYmIG5vZGUuc3lzdGVtSWQgPyAnIFNZU1RFTScgOiAnJykgK1xuICAgICAgKG5vZGUuc3lzdGVtSWQgPyAnIFwiJyArIG5vZGUuc3lzdGVtSWQgKyAnXCInIDogJycpICsgJz4nO1xuICAgIHZhciBjb250ZW50ID0gZG9jVHlwZSArIFwiXFxuXCIgKyBmcmFtZUVsLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICBrby5jbGVhbk5vZGUoZnJhbWVFbCk7XG4gICAga28ucmVtb3ZlTm9kZShmcmFtZUVsKTtcblxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzxzY3JpcHQgKFtePl0qICk/dHlwZT1cInRleHRcXC9odG1sXCJbXj5dKj5bXFxzXFxTXSo/PFxcL3NjcmlwdD4vZ20sICcnKTtcbiAgICAvLyBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC88IS0tIGtvIC4qPyAtLT4vZywgJycpOyAvLyBzb21ldGltZXMgd2UgaGF2ZSBleHByZXNzaW9ucyBsaWtlICg8IS0tIGtvIHZhciA+IDIgLS0+KVxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzwhLS0ga28gKCg/IS0tKS4pKj8gLS0+L2csICcnKTsgLy8gdGhpcyByZXBsYWNlcyB0aGUgYWJvdmUgd2l0aCBhIG1vcmUgZm9ybWFsIChidXQgc2xvd2VyKSBzb2x1dGlvblxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLzwhLS0gXFwva28gLS0+L2csICcnKTtcbiAgICAvLyBSZW1vdmUgZGF0YS1iaW5kL2RhdGEtYmxvY2sgYXR0cmlidXRlc1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyBkYXRhLWJpbmQ9XCJbXlwiXSpcIi9nbSwgJycpO1xuICAgIC8vIFJlbW92ZSB0cmFzaCBsZWZ0b3ZlciBieSBUaW55TUNFXG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvIGRhdGEtbWNlLShocmVmfHNyYyk9XCJbXlwiXSpcIi9nbSwgJycpO1xuXG4gICAgLy8gUmVwbGFjZSBcInJlcGxhY2Vkc3R5bGVcIiB0byBcInN0eWxlXCIgYXR0cmlidXRlcyAoY2hyb21lIHB1dHMgcmVwbGFjZWRzdHlsZSBhZnRlciBzdHlsZSlcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gc3R5bGU9XCJbXlwiXSpcIihbXj5dKikgcmVwbGFjZWQoc3R5bGU9XCJbXlwiXSpcIikvZ20sICckMSAkMicpO1xuICAgIC8vIFJlcGxhY2UgXCJyZXBsYWNlZHN0eWxlXCIgdG8gXCJzdHlsZVwiIGF0dHJpYnV0ZXMgKGllL2ZmIGhhdmUgcmV2ZXJzZSBvcmRlcilcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gcmVwbGFjZWQoc3R5bGU9XCJbXlwiXSpcIikoW14+XSopIHN0eWxlPVwiW15cIl0qXCIvZ20sICcgJDEkMicpO1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyByZXBsYWNlZChzdHlsZT1cIlteXCJdKlwiKS9nbSwgJyAkMScpO1xuXG4gICAgLy8gc2FtZSBhcyBzdHlsZSwgYnV0IGZvciBodHRwLWVxdWl2IChzb21lIGJyb3dzZXIgYnJlYWsgaXQgaWYgd2UgZG9uJ3QgcmVwbGFjZSwgYnV0IHRoZW4gd2UgZmluZCBpdCBkdXBsaWNhdGVkKVxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyBodHRwLWVxdWl2PVwiW15cIl0qXCIoW14+XSopIHJlcGxhY2VkKGh0dHAtZXF1aXY9XCJbXlwiXSpcIikvZ20sICckMSAkMicpO1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyByZXBsYWNlZChodHRwLWVxdWl2PVwiW15cIl0qXCIpKFtePl0qKSBodHRwLWVxdWl2PVwiW15cIl0qXCIvZ20sICcgJDEkMicpO1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyByZXBsYWNlZChodHRwLWVxdWl2PVwiW15cIl0qXCIpL2dtLCAnICQxJyk7XG5cbiAgICAvLyBXZSBhbHJlYWR5IHJlcGxhY2Ugc3R5bGUgYW5kIGh0dHAtZXF1aXYgYW5kIHdlIGRvbid0IG5lZWQgdGhpcy5cbiAgICAvLyBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8gcmVwbGFjZWQoW149IF0qPSkvZ20sICcgJDEnKTtcbiAgICAvLyBSZXN0b3JlIGNvbmRpdGlvbmFsIGNvbW1lbnRzXG4gICAgY29udGVudCA9IGNvbmRpdGlvbmFsX3Jlc3RvcmUoY29udGVudCk7XG4gICAgdmFyIHRyYXNoID0gY29udGVudC5tYXRjaCgvIGRhdGEtW14gPV0rKD1cIlteXCJdK1wiKT8gLykgfHwgY29udGVudC5tYXRjaCgvIHJlcGxhY2VkKFtePSBdKj0pLyk7XG4gICAgaWYgKHRyYXNoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJPdXRwdXQgSFRNTCBjb250YWlucyB1bmV4cGVjdGVkIGRhdGEtIGF0dHJpYnV0ZXMgb3IgcmVwbGFjZWQgYXR0cmlidXRlc1wiLCB0cmFzaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH07XG5cbiAgdmlld01vZGVsLmV4cG9ydEhUTUx0b1RleHRhcmVhID0gZnVuY3Rpb24odGV4dGFyZWFpZCkge1xuICAgICQodGV4dGFyZWFpZCkudmFsKHZpZXdNb2RlbC5leHBvcnRIVE1MKCkpO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnRKU09OdG9UZXh0YXJlYSA9IGZ1bmN0aW9uKHRleHRhcmVhaWQpIHtcbiAgICAkKHRleHRhcmVhaWQpLnZhbCh2aWV3TW9kZWwuZXhwb3J0SlNPTigpKTtcbiAgfTtcblxuICB2aWV3TW9kZWwuaW1wb3J0SlNPTmZyb21UZXh0YXJlYSA9IGZ1bmN0aW9uKHRleHRhcmVhaWQpIHtcbiAgICB2aWV3TW9kZWwuaW1wb3J0SlNPTigkKHRleHRhcmVhaWQpLnZhbCgpKTtcbiAgfTtcblxuICB2aWV3TW9kZWwuZXhwb3J0TWV0YWRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIganNvbiA9IGtvLnRvSlNPTih2aWV3TW9kZWwubWV0YWRhdGEpO1xuICAgIHJldHVybiBqc29uO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnRKU09OID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGpzb24gPSBrby50b0pTT04odmlld01vZGVsLmNvbnRlbnQpO1xuICAgIHJldHVybiBqc29uO1xuICB9O1xuXG4gIHZpZXdNb2RlbC5leHBvcnRKUyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBrby50b0pTKHZpZXdNb2RlbC5jb250ZW50KTtcbiAgfTtcblxuICB2aWV3TW9kZWwuaW1wb3J0SlNPTiA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgICB2YXIgdW53cmFwcGVkID0ga28udXRpbHMucGFyc2VKc29uKGpzb24pO1xuICAgIHZpZXdNb2RlbC5jb250ZW50Ll93cmFwKHVud3JhcHBlZCk7XG4gIH07XG5cbiAgdmlld01vZGVsLmV4cG9ydFRoZW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZsYXQgPSB7fTtcbiAgICB2YXIgbW9kID0gdmlld01vZGVsLmNvbnRlbnQoKS50aGVtZSgpO1xuXG4gICAgdmFyIF9leHBvcnQgPSBmdW5jdGlvbihwcmVmaXgsIGZsYXQsIG1vZCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBtb2QpXG4gICAgICAgIGlmIChtb2QuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICB2YXIgYSA9IGtvLnV0aWxzLnVud3JhcE9ic2VydmFibGUobW9kW3Byb3BdKTtcbiAgICAgICAgICBpZiAoYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgX2V4cG9ydChwcm9wICsgJy4nLCBmbGF0LCBhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhdFtwcmVmaXggKyBwcm9wXSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9leHBvcnQoJycsIGZsYXQsIG1vZCk7XG5cbiAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBmbGF0KVxuICAgICAgaWYgKGZsYXQuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgcHJvcCAhPSAndHlwZScpIHtcbiAgICAgICAgb3V0cHV0ICs9IHByb3AgKyBcIjogXCIgKyBmbGF0W3Byb3BdICsgXCI7XCIgKyBcIlxcblwiO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBtb3hpZW1hbmFnZXIgKG9yIGZpbGUgYnJvd3Nlci9pbWFnZWVkaXRvcikgZXh0ZW5zaW9uIHBvaW50cy5cbiAgLy8gSnVzdCBpbXBsZW1lbnQgZWRpdEltYWdlIG9yIGxpbmtEaWFsb2cgbWV0aG9kc1xuICAvLyB2aWV3TW9kZWwuZWRpdEltYWdlID0gZnVuY3Rpb24oc3JjLCBkb25lKSB7fSA6IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBlbmFibGUgaW1hZ2UgZWRpdGluZyAoc3JjIGlzIGEgd2lydGFibGVPYnNlcnZhYmxlKS5cbiAgLy8gdmlld01vZGVsLmxpbmtEaWFsb2cgPSBmdW5jdGlvbigpIHt9OiBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdXNpbmcgXCJ0aGlzXCIgdG8gZmluZCB0aGUgaW5wdXQgZWxlbWVudCAkKHRoaXMpLnZhbCBpcyBhIHdyaXRhYmxlT2JzZXJ2YWJsZS5cblxuICB2aWV3TW9kZWwubG9hZEltYWdlID0gZnVuY3Rpb24oaW1nKSB7XG4gICAgLy8gcHVzaCBpbWFnZSBhdCB0b3Agb2YgXCJyZWNlbnRcIiBnYWxsZXJ5XG4gICAgdmlld01vZGVsLmdhbGxlcnlSZWNlbnQudW5zaGlmdChpbWcpO1xuICAgIC8vIHNlbGVjdCByZWNlbnQgZ2FsbGVyeSB0YWJcbiAgICB2aWV3TW9kZWwuc2VsZWN0ZWRJbWFnZVRhYigwKTtcbiAgfTtcblxuICB2aWV3TW9kZWwuZGlhbG9nID0gZnVuY3Rpb24oc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAkKHNlbGVjdG9yKS5kaWFsb2cob3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gRHVtbXkgbG9nIG1ldGhvZCBvdmVycmlkZGVuIGJ5IGV4dGVuc2lvbnNcbiAgdmlld01vZGVsLmxvZyA9IGZ1bmN0aW9uKGNhdGVnb3J5LCBtc2cpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcInZpZXdNb2RlbC5sb2dcIiwgY2F0ZWdvcnksIG1zZyk7XG4gIH07XG5cbiAgLy8gYXV0b21hdGljYWxseSBsb2FkIHRoZSBnYWxsZXJ5IHdoZW4gdGhlIGdhbGxlcnkgdGFiIGlzIHNlbGVjdGVkXG4gIHZpZXdNb2RlbC5zZWxlY3RlZEltYWdlVGFiLnN1YnNjcmliZShmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIGlmIChuZXdWYWx1ZSA9PSAxICYmIHZpZXdNb2RlbC5nYWxsZXJ5TG9hZGVkKCkgPT09IGZhbHNlKSB7XG4gICAgICB2aWV3TW9kZWwubG9hZEdhbGxlcnkoKTtcbiAgICB9XG4gIH0sIHZpZXdNb2RlbCwgJ2NoYW5nZScpO1xuXG4gIHJldHVybiB2aWV3TW9kZWw7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0aWFsaXplRWRpdG9yO1xuIl19
